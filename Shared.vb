


'1006-1007      '1012       '1014-1017      '1019-1026      '1028       '1031-1041      '1043-1050      '1053-1059
'1061           '1063       '1074-1075      '1077-1078      '1080-1082  '1084           '1086           '1088
'1090-1095      '1098-1099

'1165-1166  '1171   '1175-1176  '1178-1182  '1186-1187  '1189-1191  '1193-1195  '1197-1199
'1202   '1204-1205  '1207   '1210   '1217   '1221-1228  '1230   '1234   '1236   '1242   '1247-1256  '1260-1263  '1268   '1273-1276  '1279-1288  '1291-1302
'1304   '1310   '1319-1325  '1327-1331  '1333-1334  '1336-1374  '1376   '1378-1384  '1386   '1388-1395  '1399-1401
'1403-1404  '1406-1408  '1417   '1419   '1428-1433  '1435-1436  '1438-1442  '1445   '1450-1451  '1454   '1457-1459  '1461-1462  '1465   '1467   '1469-1502
'1506-1508  '1513-1546  '1549-1550  '1552   '1552-1555  '1557   '1559-1560  '1563   '1565-1573  '1575-1589  '1591-1600
'1604   '1608-1610  '1612-1614  '1616-1655  '1657-1659  '1664   '1666-1670  '1672-1673  '1675-1676  '1681-1683  '1692   '1692   '1694-1695  '1697-1700
'1702-1703  '1708-1716  '1718-1721  '1725   '1727-1729  '1732-1743  '1746-1747  '1749-1754  '1756   '1764-1765  '1769   '1771   '1777   '1779   
'1784   '1786-1787  '1799-1800
'1810-1812  '1815-1817  '1819-1829  '1838-1845  '1849-1855  '1857-1859  '1865   '1870   '1873   '1875-1880  '1882  '1884   '1886   '1889   '1894   '1897   '1897
'1900-1901  '1903-1904  '1906   '1913-1914  '1918   '1922-1943  '1949   '1952   '1961   '1974   '1983   '1987   '1987-1992  '1994-1996
'2001-2002  '2004-2008  '2011-2026  '2029-2044  '2047   '2055   '2061   '2065-2066  '2070-2073  '2083-2084  '2087-2096
'2101-2110  '2112-2116  '2121-2181  '2183-2198  
'2200-2299  
'2301   '2319   '2320   '2327   '2331   '2332   '2347   '2347   '2351   '2353   '2359   '2371   '2372   '2374   '2377
'2379-2407  '2410   '2413   '2416-2418  '2425-2429  '2431-2432  '2435-2436  '2438   '2440-2447  '2449-2459  '2463   '2471-2472  '2486   '2496-2499
'2505-2511  '2515   '2515-2518  '2525   '2529   '2531   '2547-2553  '2556-2558  '2560-2567  '2591
'2599-2601  '2603-2605  '2610   '2611   '2625-2626  '2632-2634  '2636-2640  '2651   '2653-2654  '2657-2661  '2663-2681  '2691-2693  '2695
'2698-2710  '2717   '2721-2722  '2732   '2737-2739  '2743   '2745-2748  '2750   '2752-2755  '2760-2762  '2765-2766  '2768-2770  '2772-2774  '2784   '2786-2792
'2815   '2823   '2823   '2826-2831  '2833   '2846-2847  '2849-2854  '2856   '2858   '2860   '2860   '2866-2867  '2870-2881  '2885   '2888-2890  '2896-2899
'2902   '2904   '2906-2914  '2916   '2923   '2927   '2929   '2931   '2933   '2935   '2940   '2942   '2944   '2947       '2950-2951  '2953   '2972
'3002   '3014   '3015-3020  '3036-3037  '3040-3041  '3081   '3082   '3082   '3083   '3084   '3085   '3086   '3087   '3088   '3089   '3090
'3133-3134  '3139-3144  '3195   
'3213   '3250   '3257   '3259   '3291-3299  
'3302   '3320   '3341-3348  '3350   '3353   '3359-3360  '3395
'3419   '3424   '3429-3435  '3437-3440  '3442-3450  '3458-3459  '3463   '3477   '3484   '3493
'3500   '3508   '3517-3616
'3618-9999




'DebugLevel /Debug=[1-10]       sets the level of debugging Ignores 11
'1 is errors only
'2 adds warnings
'...
'10 outputs at least something for almost every subroutine

'todo fix bugs:
'todo in Symbol window update Symbol, does not update the data in the table!  big bug (Feature, students cant change it. :)
'todo new Symbol needs to have a name, and have something, and either REPLACE (delete, and add) the Symbol, or ADD it
'#Const MINEDEBUG = True


Option Strict On
Option Infer Off
Option Compare Text
Option Explicit On
Imports System.Drawing.Drawing2D
Imports System.IO
Imports System.Net.WebRequestMethods
Imports System.Reflection
Imports System.Windows.Forms.Form
Imports System.Windows.Forms.LinkLabel
Imports System.Windows.Forms.VisualStyles
Imports System.Windows.Forms.VisualStyles.VisualStyleElement
Imports System.Windows.Forms.VisualStyles.VisualStyleElement.ProgressBar
Imports System.Xml
Imports System.Xml.XPath


'Imports System Text

Namespace MyFlowChartNameSpace

    ''' <summary>
    ''' This is the shared Function and subroutines for the Flow Chart Program
    ''' </summary>
    Public Class F_C
        Const DefaultDebugLevel As Int32 = 4                    'Is used when starting up the program (1-3 is for running program normally, 4-11 is when in a debug mode



        Shared ReadOnly MyTraceCount(2500) As Int32             ' Here only for debugging and how many times the BugNumber is called
        Shared ReadOnly MyTraceRoutine(2500) As String          ' Only here for debugging, holds the first 16 letters of the message passed

        Const ShowWindow As Int32 = 1                           '1 means to show this form (in show All Forms()
        Const HideWindow As Int32 = 0                           '0 means to hide this form 
        Const LeaveWindow As Int32 = -1                         '0 do nothing with this for (but make it background, cause another form is visible)

        'not used 'Const SPECIALMARKER As Int32 = 127           ' this is used as a marker for replacements inside the program

        Const SecurityRun As Int32 = 1                          'byte 1 means they do something (disallow this program from running (just in case), disable all buttons.
        Const SecurityFileIO As Int32 = 2                       'Byte 2 means not demo, they can input or output
        Const SecuritySave As Int32 = 3                         'byte 3 means read only, they can not make changes to anything.(Or save anything?)
        Const SecurityChangeSymbol As Int32 = 4                 'byte 4 means student they can make changes to the Symbol.)Or save Symbols?
        Const Security5 As Int32 = 5                            'byte 5 is the level they are allowed (A-Z)
        Const Security6 As Int32 = 6                            'byte 6 is the level they are at.(A-Z)
        Const Security7 As Int32 = 7
        Const SecurityFlowChart As Int32 = 8
        Const SecurityOptions As Int32 = 9
        Const SecuritySymbol As Int32 = 10
        Const SecurityIOFile As Int32 = 11
        Const Security12 As Int32 = 12                          '4 digits 15 and 12 can not be zero, because they tell the professional level of the user
        Const Security13 As Int32 = 13
        Const Security14 As Int32 = 14
        Const Security15 As Int32 = 15                          '4 digits 15 and 12 can not be zero, because they tell the professional level of the user

        '                                           These are the four (future) levels of the program
        Private ReadOnly Security() As String = {"Student", "Teacher", "Programmer", "Expert"}
        'Student limits
        '           should not be able to have made Symbols. they must be already in the startup file for that language
        '           Should not be able to have a debug over (startup debug level ? )
        'teacher
        'proGrammar
        'expert


        Shared TimerIndexFlowChartCounter As Int32 ' This is only for the timers routines to know to go to the next Symbol/path
        ''' <summary>
        '''  list of error messages that are put into the FlowChart to be displayed.
        ''' </summary>
        ''' 
        Shared ReadOnly MyErrorList() As String = {
"1001 Symbol does not have a /point SyntaxCameFromLine",
"1002 Symbol does not have a /point Go_ToNextLine",
"1003 Symbol goes to two or more places (A Symbol can come from many places, but can only Go_To one place)",
"1004 Points of a Symbol is not connected to any path",
"1005 Paths are not connected to any Symbol or Constant - they must all connect to both ends to Symbol or another path, or a Constant",
"1006 Not all of the point names are in the Syntax",
"1007 That the Syntax matches the program text.",
"1008 Make sure that the point names are in the point list",
"1009 All paths must have at least one output or Constant",
"1010 All Points have a valid DataType",
"1011 All DataType have a valid Color",
"1012 All Colors are valid (in MicroSoft, they can only be the assigned colors, and are 'switched if wrong)",
"1013 All /point names are in either the MicroCodeText or the Syntax",
"1014 No Duplicate /point names",
"1015 No Syntax and No Program Code to make it from",
"1016 Two paths meet here with different path names",
"1017 Two points with different names",
"1018 ?",
"1019 ?",
"1020 ?",
"1021 ?",
"1022 ?",
"1023 ?",
"1024 ?",
"1025 ?",
"1026 ?",
"1027 ?",
"1028 ?",
"1029 ?",
"1030 ?",
"1031 ?",
"1032 ?",
"1033 ?",
"1034 ?"}


        Friend Const ConstantALLFILES As Int32 = 32
        Friend Const ConstantALLTables As Int32 = 32
        Friend Const ConstantCharterLength As Int32 = 16000
        Friend Const ConstantMaxFlowChartScale As Single = 32 'bigger scale makes the picture smaller and smaller 
        Friend Const ConstantMinFlowChartScale As Single = 0.0009765625    '0.0625
        Friend Const ConstantFlowChartScaleChange As Single = 1.5
        Friend Const NUMBEROPTIONS As Int32 = 64

        Friend Const MyConstantIgnoreFunctionOperatorKeyWord As String = "z" & "z" & "z" & "z" & "z" & "z" & "z" & "z" '"z z z z z z z z"

        Friend Const FD As String = ","
        Friend Const COMMA As String = ", "
        '|~!@%^&*()_-+={[}]\:;'<,>.?/   ' Available special characters for make syntax between two  RMStart & MyUniverse.SysGen.Constants.RMEnd

        ' So That I can remember which is which Constants
        Friend Const ConstantCOME_FROM As Int32 = 1
        Friend Const ConstantGo_ToS As Int32 = 0
        Friend Const ConstantBufferSizeBeforeChangingSizeOfArray As Int32 = 64
        Friend Const ConstantMyErrorCode As Int32 = -1




        Friend Shared Language_KeyWord(1) As String ' 2020/6/22 Changing to require from input file
        Friend Shared Language_Function(1) As String ' 2020/6/22 Changing to require from input file
        Friend Shared Language_Operator(1) As String ' 2020/6/22 Changing to require from input file
        Friend Shared Language_Grammar(1) As String ' 2023/4/14 added to make syntax from (simple) BNF definition of
        Friend Shared Language_Blocks(1) As String ' 2023/4/14 added to make syntax from (simple) BNF definition of language 


        Friend Shared My_keyWord(32) As String
        Friend Const My_KeyConstUnknown As Int32 = 0
        Friend Const My_KeyConstUnKnownError As Int32 = 1
        Friend Const My_KeyConstName As Int32 = 2
        Friend Const My_KeyConstPoint As Int32 = 3
        Friend Const My_KeyConstLine As Int32 = 4
        Friend Const My_KeyConstUse As Int32 = 5
        Friend Const My_KeyConstPath As Int32 = 6
        Friend Const My_KeyConstDataType As Int32 = 7
        Friend Const My_KeyConstFileName As Int32 = 8
        Friend Const My_KeyConstVersion As Int32 = 9
        Friend Const My_KeyConstAuthor As Int32 = 10
        Friend Const My_KeyConstLanguage As Int32 = 11
        Friend Const My_KeyConstStroke As Int32 = 12
        Friend Const My_KeyConstError As Int32 = 13
        Friend Const My_KeyConstDelete As Int32 = 14
        Friend Const My_KeyConstConstant As Int32 = 15
        Friend Const My_KeyConstX1 As Int32 = 16
        Friend Const My_KeyConstY1 As Int32 = 17
        Friend Const My_KeyConstX2 As Int32 = 18
        Friend Const My_KeyConstY2 As Int32 = 19
        Friend Const My_KeyConstColor As Int32 = 20
        Friend Const My_KeyConstMicroCodeText As Int32 = 21
        Friend Const My_KeyConstNotes As Int32 = 22
        Friend Const My_KeyConstOpcode As Int32 = 23
        Friend Const My_KeyConstSyntax As Int32 = 24
        Friend Const My_KeyConstOption As Int32 = 25
        'Friend Const ? As Int32 = 26
        Friend Const My_KeyConstLanguageKeyWord As Int32 = 27
        'friend const My_KeyConstUnused28 as int32 = 28
        'friend const My_KeyConstUnused29 as int32 = 29
        'friend const My_KeyConstUnused30 as int32 = 30
        'friend const My_KeyConstUnused31 as int32 = 31
        'friend const My_KeyConstUnused32 as int32 = 32





        ' See Init () for the assignment because what is allowed is sometimes defined by what is in a ComboBox list
        'and it is a variable and not a Constant so that (in the future) it can be changed to allow different input and output
        Friend Shared formatLanguage As String
        Friend Shared formatColor As String ' " /Color=Color Name" & comma & " Alpha" & comma & " Red" & comma & " Green" & comma & " Blue" & comma & " Style" & comma & " StartCap" & comma & " EndCap"
        Friend Shared formatDataType As String ' " /DataType=DataTypeName" & comma & " Number Of Bytes" & comma & " Color Name" & comma & " Color Width" & comma & " Description"
        Friend Shared formatSymbolName As String ' " /Name=Symbol Name" & comma & " options"
        Friend Shared formatPoint As String ' " /Point = X" & comma & " Y" & comma & " {Input/Output...}" & comma & " Data Type" & comma & " Name"
        Friend Shared formatLine As String ' " /Line=x1" & comma & " y1" & comma & " x2" & comma & " y2" & comma & " Color"
        Friend Shared formatNameOfFile As String ' " /FileName=Device:/Path/FileName.Extension"
        Friend Shared formatStroke As String ' " /Stroke={}"
        Friend Shared formatNotes As String ' " /Notes={}"
        Friend Shared formatVersion As String ' " /Version={}"
        Friend Shared formatAuthor As String ' " /Author={}"
        Friend Shared formatOpcode As String ' " /OpCode={}"
        Friend Shared formatPath As String ' " /Path=Name" & comma & " x1" & comma & " y1" & comma & " x2" & comma & " y2" & comma & " Data type"
        Friend Shared formatUse As String ' " /Use=Name" & comma & " X" & comma & " Y" & comma & " rotation" & comma & " future dynamic options"
        Friend Shared formatConstant As String ' " /Constant=name " & comma & " X" & comma & " Y" & comma & " Value"
        Friend Shared FormatMacroText As String ' " /MicroCodeText=Order section name, Text [replacements] text ..."
        Friend Shared FormatKeyWord As String ' " /keyword=keyword"
        Friend Shared FormatSyntax As String ' " /Syntax={keyword" & comma & "special characters" & comma & RMS & "variable" ) & FCCL_WhiteSpace & comma & RMS & "quote" ) & comma & RMS & "number" ) & comma & "Alphabetics" & comma & " and so on}"
        Friend Shared FormatOption As String ' " /Option=number" & comma & "{on or off}  or /Option as string 'ComputerLanguage"
        Friend Shared FormatError As String '" /error  as string ' Code" & comma & " name" & comma & " x1" & comma & " y1" & comma & " Name " & comma & " {other things maybe}"
        Friend Shared FormatDelete As String '" /Delete ..."
        'Friend Shared FormatThisCode As String ' " /ThisCode added to /path or /Constant "
        Friend Shared FormatLanguage_KeyWord As String ' " /Keyword=ReservedWord"
        Friend Shared FormatLanguage_Function As String ' " /function=FunctionWord"
        Friend Shared FormatLanguage_Operator As String ' " /Operator=operator"
        Friend Shared FormatLanguage_Grammar As String = " /Grammar = GrammarName '::=' Simple BNF "
        ' " /Grammar = GrammarName ::= Simple BNF definition"
        Friend Shared FormatSet_ As String
        Friend Shared FormatOrder As String ' /Order=section1,(Sections2,(Sections3,Sections4,Sections5))

        '1-8 is unusable
        '9- (  MyUniverse.SysGen.Constants.ConstantFirstLanguage-1) is options
        '( ConstantFirstLanguage to ConstantLastLanguage)is for computer languages that is build into for special rules (as yet unknown)
        '  (  MyUniverse.SysGen.Constants.ConstantLastLanguage+1 to 99 99 is for messages (MsgBox, and just sending to the text status text box)
        ' The first 64 bits are for the option list on the options window
        Friend Shared MyMessageBits(1250) As Byte ' 1250 gives exactly 10,000 bit settings for yes or no
        Friend Shared MyTraceBits(1024) As Byte ' 1024 gives exactly 8,192 bit settings for yes or no

        ' not used?  Public Shared FastFlipFlop(4, 14) As Short

        '
        '    'Flipping instruction X=XX+XY, Y=YX+YY   to flip X=-1+0, Y=0+1 (see The first 0 of each for the default non Flip example)
        '0=default, 1=flip, 2=flop, 3=Rotate90, 4=Rotate180, 5=Rotate270
        ' Flip=sideways, Flop=top2bottom, 
        'Matrix
        '0  1  2  3  4  5 6    7    8    9   10   11
        '1  -1 1  0  1  0
        '0  0  0  1  0  -1
        '0  0  0  -1 -1 1
        '1  1  -1 0  0  0


        Structure MyRecordNames
            Dim PointName As String
            Dim SymbolName As String
            Dim PathName As String
        End Structure


        Structure MyPointStructure
            Dim x As Int32
            Dim y As Int32
            Dim Named As MyRecordNames
        End Structure


        Structure MyLineStructure
            Dim a As MyPointStructure
            Dim b As MyPointStructure
        End Structure

        Structure MyRECTStructure
            Public MyWorldXY As MyLineStructure    'Used for real world XY
            Public MyInputWindowXY As MyLineStructure   'Used for the Window XY
        End Structure


        Structure MyWindowInfoStructure
            Dim MouseStatus As String
            Dim MouseStroke As String
            Dim MyWindow As MyLineStructure                     ' this should hold the size of the total flow chart
            Dim MyScrenZeroZero As MyPointStructure
            Dim PaintThisOrEraseThis As Boolean
            Dim FlowChartclosing As Boolean
        End Structure

        Structure MyDisplayStructure
            Dim x As Int32
            Dim y As Int32
            Dim ColorName As String
            'Dim ColorBrush As Brush
            Dim ColorPen As Pen
            'todo need to add nere to be able to resize the rectangle that holds the display text size 
            Dim Textwidth As Int32 'current default is 500
            Dim Textheight As Int32 ' current default is 500
        End Structure

        Structure ChangesMadeStructure
            Dim SymbolNameSelected As Boolean 'False if no changed, true if change the selected Symbol 
            Dim SymbolWindowSymbolEdited As Boolean 'True when any changes made to catch before you change/delete,not saved.
        End Structure

        Structure DumpFileNameStructure
            Public OutputFileName1 As String 'dumps only on request, named Symbols, Symbol graphics, FlowChart graphic data
            Public OutputFileName2 As String ' creates new file of normal export then all variables that are changeable at this point
            Public OutputFileName3 As String 'dumps a log with debug 1 to 10
        End Structure



        'This is simply an option for each Symbol, it is up to the microtextcode to use it.
        Structure SymbolOptionsStructure
            Dim OptionNames As String
            Dim OptionNumber As Int32
        End Structure


        Structure MySystemStructure
            Dim FCProcessID As Int32
            Dim Dumps As DumpFileNameStructure
            ' Dim MyPreProcessorDirectory As String
            Dim MyNOTaClipBoard As String
            Dim FlowChartOptions() As SymbolOptionsStructure
            Dim SelectionOption As Int32
            Dim WindowsStatus() As String
        End Structure

        Structure SnapStructure
            Dim MySnap As Int32 ' min snap (assume 1) (used in Symbol Window only)
            Dim MyPointSnap As Int32 ' the grid for points and paths
            Dim MySymbolSnap As Int32 ' The grid for placing Symbols on the flow chart (used in the Flow Chart Window only)
            '            Dim MaxSymbolInYSpacing As Int32 ' The maximun height of the automatic placement (before it rolls back to the top .
            '            Dim SymbolGridPlacement As Int32
        End Structure


        Structure MyFlowChartStructure
            Dim Constants As ConstantsStructure
            Dim FindingMyBugsFlag As Boolean
            Dim Order As String 'Order of the sections of the code
            Dim NumberOfButtonsActive As Int32
            Dim HighestSymbolNumber As Int32
            Dim Snaps As SnapStructure
            Dim MinBox As Int32  'Min Size of box to select all
            Dim MyFlowChartScale As Single
            Dim MySymbolScale As Single
            Dim Size As MyPointStructure
            Dim ReSize As Int16 ' Used as a flag to not let resize call it's self recursively ( 987 vs anything else)
            Dim DoNotAskToAdd As Boolean
            Dim Placement As MyPointStructure
            Dim ChangesMade As ChangesMadeStructure
        End Structure

        Structure ConstantsStructure
            Dim RMStart As String
            Dim RMEnd As String
            Dim ConstantQuote As String
            Dim SyntaxQuotes As String
            Dim SyntaxVariables As String
            Dim SyntaxNumbers As String
            Dim SyntaxAlphas As String
            Dim SyntaxAlphaNumeric As String
            Dim SyntaxSpecialCharacters As String
            Dim ConstantSpecialCharacters As String
            Dim SyntaxComments As String
            Dim SyntaxKeyWords As String
            Dim SyntaxOperators As String
            Dim SyntaxFunctions As String
            Dim SyntaxGrammar As String
            Dim Grammar As String
            Dim SyntaxFieldDelimiters As String
            Dim SyntaxUnknowns As String
            Dim SyntaxCameFromLine As String
            Dim SyntaxGo_ToNextLine As String
            '    Dim SyntaxMultiLines As String ' not currently allowed
            Dim SyntaxVariable As String
            Dim ConstantVariable As String
            Dim SyntaxWhiteSpaces As String
            Dim ConstantWhiteSpaces As String
            Dim ConstantDelimiters As String

            Dim ConstantSymbolCenter As Int32
            Dim ConstantSpacingFactor As Int32
            Dim ConstantMinPenSize As Int32
            Dim ConstantMaxPenSize As Int32
            Dim ConstantMinBoxSize As Int32
            Dim ConstantFirstLineTextOffset As Int32 'todo not sure that this is used anymore
            Dim ConstantSecondLineTextOffset As Int32 'todo not sure that this is used anymore
            Dim ConstantDistanceBetweenControls As Int32
            Dim ConstantRecordsBeforeSaveIsAllowed As Int32
            Dim ConstantDistanceToMovePaths As Int32

            Dim DrillDown_FileName As String  'ONLY CUrrent File name Device:/Paths/Filename.Extension
            '(direction, First/Second line, X/Y
            Dim MyCmdModeString As String
        End Structure



        Structure MyParseStructure
            Dim LastCodeLine As String
            Dim LastParsedVariableNames As String   'MyUniverse.MyStaticData.PathNames
            Dim LastParseArray() As String
        End Structure

        Structure Flow_Chart_File_Path_Name_Structure
            Dim LastIndexFlowChart As Int32
            Dim LastFlowChart_FilePathName As String
        End Structure

        Structure MyEnumStructure
            Dim LastResults() As String
            Dim LastWhatString As String
            Dim LastComboBox As String
            Dim Last_Enum As Int32
            Dim LastUnEnum As String
        End Structure


        Structure FindIndex_In_TableNetLinksStructure
            Dim LastIndex As Int32
            Dim LastFound As Int32
            Dim LastPathName As String
        End Structure



        Structure StaticStructure
            Dim Tagged As Int32
            Dim tag As Int32
            Dim LookforX, LookForY As Int32
            Dim FoundX, FoundY As Int32
            Dim MinXY As MyPointStructure     ' Location of total picture
            Dim MaxXY As MyPointStructure
            Dim Hints() As String ' Not static, but a list of the last 10 new hints.
            Dim FindIndex_In_TableNetLinks As FindIndex_In_TableNetLinksStructure
            Dim MyEnum As MyEnumStructure
            Dim MyUnEnum As MyEnumStructure
            Dim FlowChart_FilePathName As Flow_Chart_File_Path_Name_Structure
            Dim LastParsed As MyParseStructure

            'This is data file stuff (That should be in a data file)
            Dim Named_TableCount As Int32    'This is one for each Symbol 
            Dim Symbol_TableCount As Int32     ' Number in the MyArray (Points to last)
            Dim FlowChart_TableCount As Int32     ' Number in the MyArray (Points to last)
            Dim DataType_TableCount As Int32 ' The number of DataType_Tables in the table
            Dim Color_TableCount As Int32   ' A list of the colors available to use
            Dim SymbolNumber_Counter As Int32

            Dim ZeroZero As MyPointStructure
            Dim ZeroZeroZeroZero As MyLineStructure
            Dim My_Syntax_Line_Parsed() As String
            Dim My_Code_Line_Parsed() As String
            Dim Path_Names As String ' global that is the current list of the variable names only of the parsed code line
            Dim Path_NamesCounted As Int32

        End Structure

        Structure MyCheatingStructure
            Dim LastDataTypeFound As String 'shorten findDataTypeorcolor()
            Dim LastColorFound As String 'shorten findDataTypeorcolor()
            Dim LastTable As String
            Dim LastString As String
            Dim LastIndex As Int32
            Dim LastSearchString As String
            Dim LastSearchFind As String
            Dim LastISAMStringTable As String
            Dim LastISAMStringString As String
            Dim LastISAMStringIndex As Int32
            Dim LastISAMNumberTable As String
            Dim LastISAMNumberNumber As Int32
            Dim LastISAMNumberIndex As Int32
            Dim ColorsSorted As Int32
            Dim DataTypeSorted As Int32
            Dim NamedSorted As Int32
            Dim FlowChartSorted As Int32
            Dim BugsCounted As Int32
            Dim LastSortedStringTable As String
            Dim LastSortedStringString As String
            Dim LastSortedStringIndex As Int32
            Dim Last_UnSortedStringTable As String
            Dim Last_UnSortedStringString As String
            Dim Last_UnSortedStringIndex As Int32
            Dim LastLanguageTable As String
            Dim LastLanguageString As String
            Dim LastLanguageIndex As Int32
        End Structure

        Structure CStructure
            Dim StillComment As Boolean ' This is for the /* to the */ comments
        End Structure

        Structure LanguageStructure
            Dim C As CStructure
        End Structure

        Structure IOTypeStructure
            Dim Input As Int32
            Dim Output As Int32
            Dim Both As Int32
            Dim Other As Int32
            Dim Total As Int32
        End Structure

        Structure PointTypeStructure
            Dim MyName As String
            Dim Logic As IOTypeStructure
            Dim Data As IOTypeStructure
            Dim Total As Int32
        End Structure

        Structure UseTypeStructure
            Dim MyName As String
            Dim Total As Int32
        End Structure

        Structure MyPointCountsStructure
            Dim SymbolName As String
            Dim NumberOfPoints As PointTypeStructure
            Dim NumberOfLines As PointTypeStructure
            Dim NumberOfOther As PointTypeStructure
            Dim Total As Int32
        End Structure

        Structure MyPathCounts
            Dim PathName As String
            Dim NumberOfConnectionsToOtherPaths As PointTypeStructure
            Dim NumberOfConnectionsToSymbols As PointTypeStructure
            Dim NumberOfErrors As Int32
            Dim Total As Int32
        End Structure

        Structure MyUseStructure
            Dim IndexUseSymbol As Int32
            Dim NumberOfConnections As MyPointCountsStructure
            Dim Total As Int32
        End Structure
        Structure MySymbolCountsStructure
            Dim Name As String
            Dim Symbol As MyPointCountsStructure
            Dim Path As MyPathCounts
            Dim Uses As MyUseStructure
            Dim Total As Int32
        End Structure

        Structure MySymbolPointPreference
            Dim x As Int32
            Dim y As Int32
        End Structure



        Structure ProgramOptionsStructure
            Dim FCCL_Directory As String
            Dim FCCL_Case As String
            Dim FCCL_Comment As String
            Dim FCCL_Extension As String ' contains the extension(s) available
            Dim FCCL_Extensions As String 'used as marker
            Dim FCCL_MultiLine As String
            Dim FCCL_LanguageClassName As String
            Dim FCCL_DialectName As String     ' 
            Dim FCCL_VarChars As String
            Dim FCCL_Process As String
            Dim FCCL_Order As String
            Dim FCCL_WhiteSpace As String
            Dim FCCL_Variable As String
            Dim FlowChartTextBox As String
            Dim SelectedSymbolName As String
            Dim SelectedDataType As String
            Dim SelectedColor As String
            Dim SelectedInputOutput As String
            Dim SelectedRotation As String
            Dim SelectedPathStart As String
            Dim SelectedPathEnd As String
            Dim SelectedPathLineStyle As String
            Dim SelectedNumberOfBytes As String

            Dim SelectedObject As Int32
            Dim Helpurl As String
            Dim SymbolChanged As Boolean 'This is a flag if something changes on the Symbol Window to allow it to be updated (added)
        End Structure

        Structure FlowChartRegisterStructure
            Dim FCRName As String   'name of the program,
            Dim FCRVersion As String    'Version of the program
            Dim FCRCPUid As String      'This should be the computer ID, so that it can be licened to a single computer
            Dim FCRKey As String    'This is the key that lets it do more stuff (
            Dim FCRUserLevel As String  'This is the level that the user is allowed up to
            '        So that the program can be made to be used by students by levels (The FlowChartKey should set this level
            Dim FCRUserProfession As String ' This is the level of expertise
            '       This level should be made available via a drop down of the allowed levels of expertise.
            Dim ID As String    ' this will be the cpu id stuff later when i get a square from it.
        End Structure


        Structure MyUniverseStructure
            Dim DebugCount() As Int32
            Dim MyProgramStatus As String
            Dim FCCLDebugLevel As Int32 'from zero (none) to 10 (all) controls 'level' of debugging messages
            Dim Grammar As Boolean
            Dim Security As String  'This string holds what the user can and can not do (See Security())
            Dim PaidFor As FlowChartRegisterStructure
            Dim MySystem As MySystemStructure
            Dim SysGen As MyFlowChartStructure
            Dim MySS As ImportLineStruct
            Dim MyMouseAndDrawing As MyWindowInfoStructure
            Dim Area As MyRECTStructure
            Dim MyCheatSheet As MyCheatingStructure
            Dim MyStaticData As StaticStructure
            Dim ProgramOptions As ProgramOptionsStructure
            Dim Languages As LanguageStructure
            Dim SymbolAndPath As MySymbolCountsStructure
            Dim MySymbolPoints() As MySymbolPointPreference
            Dim OptionDisplay() As MyDisplayStructure
        End Structure

        Structure MyNumberOrString
            Dim MyNumber As Int32
            Dim MyString As String
        End Structure

        Structure MyRecordStruct
            Dim Coded As Byte
            Dim X1, Y1 As Int32
            Dim X2, Y2 As MyNumberOrString
            Dim NameOfPoint As String
            Dim a As MyPointStructure
            Dim b As MyPointStructure
        End Structure

        Structure TempsStructure
            Dim TempFormat As String
            Dim TempRecord As Int32
            Dim TempInteger1 As Int32 ' no longer temp(s)
            Dim TempString2 As String 'on/off or true/false ...
            Dim TempInt32 As Int32
        End Structure



        Structure TextsStructure
            Dim AllText As String 'This is the entire file, or one line inputs on the window
            Dim KWord As String ' This is the /key
            Dim KPar As String ' This is everything aver the =  in /key=parameters
            Dim LineNumberIn As Int32
        End Structure

        Structure ImportLineStruct
            Dim Inputs As TextsStructure
            Dim Temps As TempsStructure
            Dim LastName As String
            Dim IndexName, IndexSymbol As Int32
            Dim TopMost As Int32
            Dim MyRecord As MyRecordStruct
        End Structure

        Structure ThisArrow
            Dim TempPenWidthSize, ArrowFactor, DirectionIs As Int32
            Dim IndexDataType As Int32 '  Used Only For Trying to improve the speed by not sorting
            Dim MinePen As Pen
            Dim MyXY1 As MyPointStructure    ' center point to show direction
            Dim MyXY2 As MyPointStructure    ' shows direction of path into the Symbol
            Dim XY1 As MyPointStructure     ' Used only to display points (as lines)
            Dim XY2 As MyPointStructure     ' Other end of the line
            'Dim index As Int32   ' Index of this data type
            Dim ColorName, Temp As String
            Dim Input_Output_Both_Direction As Int32
            Dim IO_SizeModifier() As Integer
        End Structure
        Friend Shared MyUniverse As MyUniverseStructure
        '- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
        'none of the following _file arrays should be changed.  
        'Because the ISAM() is sorted to point to the next in line.
        'that is the 'record number' in the array has an ISAM array for X and Y ...
        'and going through those array(s) in order gives the the next in line
        '(but note that you can start at a location and still have the same values before and after
        'so you must always check if the one(s) before is is also what you are looking for. (and after)
        'So start somewhere with a value you are looking for and go down till you hit less,
        'then start going up till you hit a value that is higher
        'ie: 
        'record #   X   Y   Name    XISAM   YISAM   NameISAM
        '1          10  2   Cost        4   1       1
        '2          8   13  Price       2   3       4
        '3          12  9   Profit      1   4       2
        '4          1   11  overhead    3   2       3
        '
        ' (if I could have used redim on a structure I would have used that. )
        'When converted to C# it does it more correctly

        '- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
        Friend Shared Color_Name_ISAM(16) As Int32     'Sorted Pointers to MyArray
        Friend Shared Color_FileName(16) As String
        Friend Shared Color_FileAlpha(16) As Byte
        Friend Shared Color_FileRed(16) As Byte
        Friend Shared Color_FileGreen(16) As Byte
        Friend Shared Color_FileBlue(16) As Byte
        Friend Shared Color_FileEndCap(16) As Byte
        Friend Shared Color_FileStartCap(16) As Byte
        Friend Shared Color_FileStyle(16) As Byte
        Friend Shared Named_FileSymbolName_ISAM(ConstantALLFILES) As Int32    'sorted Indexes to MyArrays
        Friend Shared Named_FileSyntax_ISAM(ConstantALLFILES) As Int32      ' Only used during Decompile and reset to length of one afterwards

        Friend Shared Named_FileSymbolName(ConstantALLFILES) As String   'Name of the Symbol
        Friend Shared Named_FileSyntax(ConstantALLFILES) As String ' The Syntax for the deCompiler made from the program test 2020/6/22
        Friend Shared Named_FileSymbolIndexes(ConstantALLFILES) As Int32  ' A Indexes to this Symbol in the Symbol Graphics Table     'Find the Symbol name and this Indexes should point to the first record of the file_Symbol list of graphics
        Friend Shared Named_FileMicroCodeText(ConstantALLFILES) As String   'The actual program MicroCodeText to be 'fixed'
        Friend Shared Named_FileOpCode(ConstantALLFILES) As String 'The Machine code of this assemble Symbol
        Friend Shared Named_FileNotes(ConstantALLFILES) As String  'Notes for this Symbol
        Friend Shared Named_FileNameOfFile(ConstantALLFILES) As String   'The device:/path/Filename where this came from 
        Friend Shared Named_FileAuthor(ConstantALLFILES) As String 'Who wrote or responsible for this Symbol
        Friend Shared Named_FileVersion(ConstantALLFILES) As String ' the date of the latest update
        Friend Shared Named_FileStroke(ConstantALLFILES) As String 'The movement of the mouse that id's this Symbol
        '2020 08 12 removed because each Symbol is NOT language related, only the whole FlowChart    'friend shared  Named_FileLanguage(ConstantALLFILES) As String   'The computer language this applies to

        Friend Shared Symbol_FileSymbolName(ConstantALLTables) As String 'The name of this Symbol for /Name code
        Friend Shared Symbol_File_NameOfPoint(ConstantALLTables) As String 'name of points and color of lines
        Friend Shared Symbol_FileCoded(ConstantALLTables) As Byte  'The code /line /point etc 
        Friend Shared Symbol_FileX1(ConstantALLTables) As Int32
        Friend Shared Symbol_FileY1(ConstantALLTables) As Int32
        Friend Shared Symbol_FileX2_io(ConstantALLTables) As MyNumberOrString  'Used also as Enum Input/output/bot/optional IO ....
        Friend Shared Symbol_FileY2_dt(ConstantALLTables) As MyNumberOrString  ' Also used as the index to the data type

        Friend Shared Net_FileNames(0) As String ' This hold the name of the paths
        Friend Shared Net_FileLinks(0) As String ' This holds all of the link numbers that are connected together.

        Friend Shared FlowChart_FilePathSymbolName(ConstantALLTables) As String  ' The name of the /use, the variable name of /Path & /Constant
        Friend Shared FlowChart_FileCoded(ConstantALLTables) As Byte ' The codes /Use, /Path, /Constant
        Friend Shared FlowChart_FileX1(ConstantALLTables) As Int32
        Friend Shared FlowChart_FileY1(ConstantALLTables) As Int32
        Friend Shared FlowChart_File_X2_Rotation(ConstantALLTables) As Int32   'X2 for /path, Rotation for /use
        Friend Shared FlowChart_File_Y2_Option(ConstantALLTables) As Int32   'Y2 for path , future options for /use
        Friend Shared FlowChart_File_DataType(ConstantALLTables) As String  'The DataType for /Path /Constant

        Friend Shared FlowChart_ISAM_X1(ConstantALLTables) As Int32 'Holds Indexes to the FlowChart, sorted (Indexd Sequencial Access Method
        Friend Shared FlowChart_ISAM_Y1(ConstantALLTables) As Int32
        Friend Shared FlowChart_ISAM_X2(ConstantALLTables) As Int32
        Friend Shared FlowChart_ISAM_Y2(ConstantALLTables) As Int32
        Friend Shared FlowChart_ISAM_Name(ConstantALLTables) As Int32

        Friend Shared DataType_Name_ISAM(ConstantALLTables) As Int32    'Sorted MyArray to Names of the DataTypes
        Friend Shared DataType_FileName(ConstantALLTables) As String    'Name of the DataType
        Friend Shared DataType_FileDescription(ConstantALLTables) As String
        Friend Shared DataType_FileNumberOfBytes(ConstantALLTables) As Int32  ' size in bytes of the data
        Friend Shared DataType_FileColorIndex(ConstantALLTables) As Int32   'number of the color in color_file...to use
        Friend Shared DataType_FileWidth(ConstantALLTables) As Byte 'Width of the /Path and diameter of the /Points



        Friend Shared MyBits() As Int32 = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8198, 16384, 32768, 65536, 131072, 262144, 524288, 1048576}
        'the size of mydirection determins the size of the arrows at points 
        Friend Shared MyDirections(16, 2, 2) As SByte  ' This is the matrix to determine the two end points from the center
        Friend Shared MyRotation(4, 12) As Int32 'holds how to rotate


        '- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' Programing routines to follow
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


        Friend Shared Function MakePathName(A As String) As String
#If MINEDEBUG Then
            If MyDebug(10) Then follow(2925, "MakePathName")
            if mydebug(10) then  follow(2789, "Path=" & A)
            If MyDebug(10) Then follow(2915,  "ListBoxLanguageDialect")
#End If
            Return AddRM(NameOfPointOnly(A) & ".PathName")
        End Function


        Public Shared Function MyLeft(MyString As String, Number As Int32) As String
            Return Mid(MyString, 1, Number) 'Return MyLeft(MyString, Number)
        End Function
        Public Shared Function MyRight(MyString As String, Number As Int32) As String
            If Len(MyString) = 0 Then Return ""
            If Number > Len(MyString) Then Return ""
            Return Mid(MyString, Len(MyString) - Number + 1)
        End Function



        Public Shared Sub ShowSorts(MyTable As String, Total As Int32) 'Displays the number of sorts made
            Dim Count As Int32
#If MINEDEBUG Then
            If Total > 0 Then
                        If MyDebug(7) Then follow(2408, 7, "ShowSorts, " & MyTable & " " & Total.ToString)
            End If
#End If
            Count = MyUniverse.MyCheatSheet.BugsCounted
            MyUniverse.MyCheatSheet.BugsCounted = 0
            If Total > 0 And Count > 0 Then
                DisplayMyStatus(7, MyTable & " Still working ... sorted " & Total & " Total issues's detected " & Count)
            ElseIf Count > 0 Then
                DisplayMyStatus(7, MyTable & " Still working ... issues's detected " & Count)
            ElseIf Total > 0 Then
                DisplayMyStatus(7, MyTable & " Still working ... sorted " & Total)
                DoThisEvent(2750)
            Else
                'DisplayMyStatus(3,". . .")
            End If
            ' removed 20232506MyDoEvents(230)
        End Sub



        '   mine()
        Public Shared Function MyMsgCtr(MessageNumber As Integer, SubName As String, String1 As String, String2 As String, String3 As String, String4 As String, String5 As String, String6 As String, String7 As String, String8 As String, String9 As String) As MsgBoxResult
            Dim X, J As String
            Dim Temp As Integer
            Dim RtnMsgBox As MsgBoxResult
#If MINEDEBUG Then
                    If MyDebug(6 ) then follow(2409, 6, "msgctr, " & SubName)
#End If

            'If MessageNumber = 1249 Then Return MsgBoxResult.Abort

            'todo is this required?  MyMsgCtr = MsgBoxResult.Ignore
            If IsBitSet(MessageNumber) Then
                'X = " No Warning Message!"
                'Temp = OptionsWindow.ComboBoxDebug.Items.Count
                Temp = FindMessageNumber(MessageNumber)
                If Temp < 1 Or Temp > OptionsWindow.ComboBoxDebug.Items.Count Then
                    'aI N F O 2 (1)
                    Return MsgBoxResult.Cancel
                End If

                X = OptionsWindow.ComboBoxDebug.Items.Item(Temp).ToString
                If PopValue(X) = MessageNumber Then
                    J = Pop(X, MyUniverse.SysGen.Constants.ConstantDelimiters)
                    X = MyReplace(X, AddRM("routine"), SubName)
                    X = MyReplace(X, AddRM("tracer"), MessageNumber.ToString)
                    X = MyReplace(X, AddRM("string1"), PrintAbleNull(String1))
                    X = MyReplace(X, AddRM("string2"), PrintAbleNull(String2))
                    X = MyReplace(X, AddRM("string3"), PrintAbleNull(String3))
                    X = MyReplace(X, AddRM("string4"), PrintAbleNull(String4))
                    X = MyReplace(X, AddRM("string5"), PrintAbleNull(String5))
                    X = MyReplace(X, AddRM("string6"), PrintAbleNull(String6))
                    X = MyReplace(X, AddRM("string7"), PrintAbleNull(String7))
                    X = MyReplace(X, AddRM("string8"), PrintAbleNull(String8))
                    X = MyReplace(X, AddRM("string9"), PrintAbleNull(String9))
                    X = MessageNumber & FD & J & FD & SubName & "() " & vbCrLf & X ' Put it back
#If MINEDEBUG Then
                    if MyDebug(10 ) then follow(2409, 2, "msgctr: " & SubName & vbCrLf & X)
#End If
                    Select Case LCase(Trim(J))
                        Case "error"
                            MSG_AInfo1(1003, "Msg No = " & SHL(MessageNumber.ToString), " / Msg = " & SHL(X), " Severity Level =" & SHL(J))
                            MyBeep()
                            RtnMsgBox = MsgBox(X, MsgBoxStyle.YesNo, "Continue displaying this message ?")
                            FindingMyBugs(1) 'hack Least amount of checking here 'hack
                        Case "warning"
                            MSG_AInfo1(1004, "Msg No = " & SHL(MessageNumber.ToString), "/Msg = " & SHL(X), " Severity Level =" & SHL(J))
                            MyBeep()
                            RtnMsgBox = MsgBox(X, MsgBoxStyle.YesNo, "Continue displaying this message ?")
                        Case "information"
                            MyBeep()
                            RtnMsgBox = MsgBox(X, MsgBoxStyle.YesNo, "Continue displaying this message ?")
                        Case "status"
                            DisplayMyStatus(4, MessageNumber & " Unknown Error Message TypeOf " & X)
                        Case "display" ' DoNot Use For right now
                            MyBeep()
                            RtnMsgBox = MsgBox(X, MsgBoxStyle.YesNo, "Continue displaying this message ?")
                        Case Else
                            MyBeep()
                            RtnMsgBox = MsgBox(X, MsgBoxStyle.OkCancel, "Unknown Type=" & J & vbCrLf & "unknown message number " & MessageNumber & vbCrLf & " Cancel will Stop this message")
                    End Select
                    Select Case RtnMsgBox
                        Case MsgBoxResult.Abort
                        Case MsgBoxResult.Cancel
                            BitSet(MessageNumber, "off")
                        Case MsgBoxResult.Ignore
                        Case MsgBoxResult.No
                            BitSet(MessageNumber, "off")
                        Case MsgBoxResult.Ok
                        Case MsgBoxResult.Retry
                        Case MsgBoxResult.Yes
                    End Select
                    'aI N F O 2 (-2)
                    Return RtnMsgBox
                End If
                ' We should never get here
                'A I N F O 2 (28)
                MyBeep()
                Return MsgBox("MessageNumber  =" & MessageNumber &
      vbCrLf & " A = " & String1 &
      vbCrLf & " B = " & String2 &
      vbCrLf & " C = " & String3 &
      vbCrLf & " D = " & String4 &
      vbCrLf & " E = " & String5 &
      vbCrLf & " F = " & String6 &
      vbCrLf & " G = " & String7 &
      vbCrLf & " H = " & String8 &
      vbCrLf & " I = " & String9,
      MsgBoxStyle.AbortRetryIgnore,
"No Error Message For " & MessageNumber & vbCrLf & X)
            Else
                'Done dump raw data if message turned of (and option turned on)
                Dump3(MessageNumber, Now().ToString & HighLight(String1) & HighLight(String2) & HighLight(String4) & HighLight(String5) & HighLight(String6) & HighLight(String7) & HighLight(String8) & HighLight(String9) & vbCrLf & "--------------------->msg " & vbCrLf & HighLight(MessageNumber.ToString) & HighLight(SubName))
                'A I N F O 2 (29)n
                Return MsgBoxResult.Ignore
            End If
            MSG_ABug(1005, "Should never get to the end of msgctr()", "", "")
            If MyOptionTest(25) = True Then
                Return MsgBoxResult.Cancel
            Else
                Return MsgBoxResult.Abort
            End If
        End Function


        Public Shared Function GetBrush(ColorName As String) As Brush
            If ColorName = "AliceBlue" Then Return Brushes.AliceBlue
            If ColorName = "AntiqueWhite" Then Return Brushes.AntiqueWhite
            If ColorName = "Aqua" Then Return Brushes.Aqua
            If ColorName = "Aquamarine" Then Return Brushes.Aquamarine
            If ColorName = "Azure" Then Return Brushes.Azure
            If ColorName = "Beige" Then Return Brushes.Beige
            If ColorName = "Bisque" Then Return Brushes.Bisque
            If ColorName = "Black" Then Return Brushes.Black
            If ColorName = "BlanchedAlmond" Then Return Brushes.BlanchedAlmond
            If ColorName = "Blue" Then Return Brushes.Blue
            If ColorName = "BlueViolet" Then Return Brushes.BlueViolet
            If ColorName = "Brown" Then Return Brushes.Brown
            If ColorName = "BurlyWood" Then Return Brushes.BurlyWood
            If ColorName = "CadetBlue" Then Return Brushes.CadetBlue
            If ColorName = "Chartreuse" Then Return Brushes.Chartreuse
            If ColorName = "Chocolate" Then Return Brushes.Chocolate
            If ColorName = "Coral" Then Return Brushes.Coral
            If ColorName = "CornflowerBlue" Then Return Brushes.CornflowerBlue
            If ColorName = "Cornsilk" Then Return Brushes.Cornsilk
            If ColorName = "Crimson" Then Return Brushes.Crimson
            If ColorName = "Cyan" Then Return Brushes.Cyan
            If ColorName = "DarkBlue" Then Return Brushes.DarkBlue
            If ColorName = "DarkCyan" Then Return Brushes.DarkCyan
            If ColorName = "DarkGoldenrod" Then Return Brushes.DarkGoldenrod
            If ColorName = "DarkGray" Then Return Brushes.DarkGray
            If ColorName = "DarkGreen" Then Return Brushes.DarkGreen
            If ColorName = "DarkKhaki" Then Return Brushes.DarkKhaki
            If ColorName = "DarkMagenta" Then Return Brushes.DarkMagenta
            If ColorName = "DarkOliveGreen" Then Return Brushes.DarkOliveGreen
            If ColorName = "DarkOrange" Then Return Brushes.DarkOrange
            If ColorName = "DarkOrchid" Then Return Brushes.DarkOrchid
            If ColorName = "DarkRed" Then Return Brushes.DarkRed
            If ColorName = "DarkSalmon" Then Return Brushes.DarkSalmon
            If ColorName = "DarkSeaGreen" Then Return Brushes.DarkSeaGreen
            If ColorName = "DarkSlateBlue" Then Return Brushes.DarkSlateBlue
            If ColorName = "DarkSlateGray" Then Return Brushes.DarkSlateGray
            If ColorName = "DarkTurquoise" Then Return Brushes.DarkTurquoise
            If ColorName = "DarkViolet" Then Return Brushes.DarkViolet
            If ColorName = "DeepPink" Then Return Brushes.DeepPink
            If ColorName = "DeepSkyBlue" Then Return Brushes.DeepSkyBlue
            If ColorName = "DimGray" Then Return Brushes.DimGray
            If ColorName = "DodgerBlue" Then Return Brushes.DodgerBlue
            If ColorName = "Firebrick" Then Return Brushes.Firebrick
            If ColorName = "FloralWhite" Then Return Brushes.FloralWhite
            If ColorName = "ForestGreen" Then Return Brushes.ForestGreen
            If ColorName = "Fuchsia" Then Return Brushes.Fuchsia
            If ColorName = "Gainsboro" Then Return Brushes.Gainsboro
            If ColorName = "GhostWhite" Then Return Brushes.GhostWhite
            If ColorName = "Gold" Then Return Brushes.Gold
            If ColorName = "Goldenrod" Then Return Brushes.Goldenrod
            If ColorName = "Gray" Then Return Brushes.Gray
            If ColorName = "Green" Then Return Brushes.Green
            If ColorName = "GreenYellow" Then Return Brushes.GreenYellow
            If ColorName = "Honeydew" Then Return Brushes.Honeydew
            If ColorName = "HotPink" Then Return Brushes.HotPink
            If ColorName = "IndianRed" Then Return Brushes.IndianRed
            If ColorName = "Indigo" Then Return Brushes.Indigo
            If ColorName = "Ivory" Then Return Brushes.Ivory
            If ColorName = "Khaki" Then Return Brushes.Khaki
            If ColorName = "Lavender" Then Return Brushes.Lavender
            If ColorName = "LavenderBlush" Then Return Brushes.LavenderBlush
            If ColorName = "LawnGreen" Then Return Brushes.LawnGreen
            If ColorName = "LemonChiffon" Then Return Brushes.LemonChiffon
            If ColorName = "LightBlue" Then Return Brushes.LightBlue
            If ColorName = "LightCoral" Then Return Brushes.LightCoral
            If ColorName = "LightCyan" Then Return Brushes.LightCyan
            If ColorName = "LightGoldenrodYellow" Then Return Brushes.LightGoldenrodYellow
            If ColorName = "LightGray" Then Return Brushes.LightGray
            If ColorName = "LightGreen" Then Return Brushes.LightGreen
            If ColorName = "LightPink" Then Return Brushes.LightPink
            If ColorName = "LightSalmon" Then Return Brushes.LightSalmon
            If ColorName = "LightSeaGreen" Then Return Brushes.LightSeaGreen
            If ColorName = "LightSkyBlue" Then Return Brushes.LightSkyBlue
            If ColorName = "LightSlateGray" Then Return Brushes.LightSlateGray
            If ColorName = "LightSteelBlue" Then Return Brushes.LightSteelBlue
            If ColorName = "LightYellow" Then Return Brushes.LightYellow
            If ColorName = "Lime" Then Return Brushes.Lime
            If ColorName = "LimeGreen" Then Return Brushes.LimeGreen
            If ColorName = "Linen" Then Return Brushes.Linen
            If ColorName = "Magenta" Then Return Brushes.Magenta
            If ColorName = "Maroon" Then Return Brushes.Maroon
            If ColorName = "MediumAquamarine" Then Return Brushes.MediumAquamarine
            If ColorName = "MediumBlue" Then Return Brushes.MediumBlue
            If ColorName = "MediumOrchid" Then Return Brushes.MediumOrchid
            If ColorName = "MediumPurple" Then Return Brushes.MediumPurple
            If ColorName = "MediumSeaGreen" Then Return Brushes.MediumSeaGreen
            If ColorName = "MediumSlateBlue" Then Return Brushes.MediumSlateBlue
            If ColorName = "MediumSpringGreen" Then Return Brushes.MediumSpringGreen
            If ColorName = "MediumTurquoise" Then Return Brushes.MediumTurquoise
            If ColorName = "MediumVioletRed" Then Return Brushes.MediumVioletRed
            If ColorName = "MidnightBlue" Then Return Brushes.MidnightBlue
            If ColorName = "MintCream" Then Return Brushes.MintCream
            If ColorName = "MistyRose" Then Return Brushes.MistyRose
            If ColorName = "Moccasin" Then Return Brushes.Moccasin
            If ColorName = "NavajoWhite" Then Return Brushes.NavajoWhite
            If ColorName = "Navy" Then Return Brushes.Navy
            If ColorName = "OldLace" Then Return Brushes.OldLace
            If ColorName = "Olive" Then Return Brushes.Olive
            If ColorName = "OliveDrab" Then Return Brushes.OliveDrab
            If ColorName = "Orange" Then Return Brushes.Orange
            If ColorName = "OrangeRed" Then Return Brushes.OrangeRed
            If ColorName = "Orchid" Then Return Brushes.Orchid
            If ColorName = "PaleGoldenrod" Then Return Brushes.PaleGoldenrod
            If ColorName = "PaleGreen" Then Return Brushes.PaleGreen
            If ColorName = "PaleTurquoise" Then Return Brushes.PaleTurquoise
            If ColorName = "PaleVioletRed" Then Return Brushes.PaleVioletRed
            If ColorName = "PapayaWhip" Then Return Brushes.PapayaWhip
            If ColorName = "PeachPuff" Then Return Brushes.PeachPuff
            If ColorName = "Peru" Then Return Brushes.Peru
            If ColorName = "Pink" Then Return Brushes.Pink
            If ColorName = "Plum" Then Return Brushes.Plum
            If ColorName = "PowderBlue" Then Return Brushes.PowderBlue
            If ColorName = "Purple" Then Return Brushes.Purple
            If ColorName = "Red" Then Return Brushes.Red
            If ColorName = "RosyBrown" Then Return Brushes.RosyBrown
            If ColorName = "RoyalBlue" Then Return Brushes.RoyalBlue
            If ColorName = "SaddleBrown" Then Return Brushes.SaddleBrown
            If ColorName = "Salmon" Then Return Brushes.Salmon
            If ColorName = "SandyBrown" Then Return Brushes.SandyBrown
            If ColorName = "SeaGreen" Then Return Brushes.SeaGreen
            If ColorName = "SeaShell" Then Return Brushes.SeaShell
            If ColorName = "Sienna" Then Return Brushes.Sienna
            If ColorName = "Silver" Then Return Brushes.Silver
            If ColorName = "SkyBlue" Then Return Brushes.SkyBlue
            If ColorName = "SlateBlue" Then Return Brushes.SlateBlue
            If ColorName = "SlateGray" Then Return Brushes.SlateGray
            If ColorName = "Snow" Then Return Brushes.Snow
            If ColorName = "SpringGreen" Then Return Brushes.SpringGreen
            If ColorName = "SteelBlue" Then Return Brushes.SteelBlue
            If ColorName = "Tan" Then Return Brushes.Tan
            If ColorName = "Teal" Then Return Brushes.Teal
            If ColorName = "Thistle" Then Return Brushes.Thistle
            If ColorName = "Tomato" Then Return Brushes.Tomato
            If ColorName = "Transparent" Then Return Brushes.Transparent
            If ColorName = "Turquoise" Then Return Brushes.Turquoise
            If ColorName = "Violet" Then Return Brushes.Violet
            If ColorName = "Wheat" Then Return Brushes.Wheat
            If ColorName = "White" Then Return Brushes.White
            If ColorName = "WhiteSmoke" Then Return Brushes.WhiteSmoke
            If ColorName = "Yellow" Then Return Brushes.Yellow
            If ColorName = "YellowGreen" Then Return Brushes.YellowGreen
            Return Brushes.Black
        End Function





        'Routine  This returns a pen color by name (cause I can't make my own from RGB() to work, cause I lazy right now)
        Public Shared Function MyGetPen(PassedColor As String, PassedDataType As String) As Pen     'Converts from Red/Green/Blue/Alpha to Color structure into globalMyGetPen_Static
            'GetMyPen is a global that is changed and passed back.
            'todo this (and get brushes) needs to be changed to use the color table instead of MicroSoft named colors
            Dim ColorORDataTypeName As String
            Dim IndexColor As Int32
            Dim A, R, G, B As Int32
#If MINEDEBUG Then
                    If MyDebug(9 ) then follow(2410, 9, "GetPen, " & PassedColor & ", " & PassedDataType)
#End If
            If Len(PassedColor) = 0 And Len(PassedDataType) = 0 Then
                MSG_ABug(1008, "No color or DataType Name", "", "")
                If MyOptionTest(25) = True Then
                    Return Pens.Black
                Else
                    Return Pens.Red
                End If
            End If

            ColorORDataTypeName = FindColorFromDataType(Trim(PassedDataType))
            If Len(ColorORDataTypeName) = 0 Then    ' This is if it was a color name
                ColorORDataTypeName = Trim(PassedColor)
            Else
                'This is if it was a data type name passed
                ColorORDataTypeName = Trim(ColorORDataTypeName)
            End If
            If Len(ColorORDataTypeName) = 0 Then ' an error , neighter on is valid
                MSG_ABug(1009, "Invalid data/color ", PassedColor, PassedDataType)
                If MyOptionTest(25) = True Then
                    ColorORDataTypeName = "Errored"
                Else
                    ColorORDataTypeName = "Errored"
                End If
            End If



            If MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis = False Then
                Return Pens.White 'todo this should be the background color of the image, what ever it is set to 
            End If



            IndexColor = FindColor(PassedColor)
            If IndexColor = ConstantMyErrorCode Then Return Pens.Red
            A = Color_TableAlpha(IndexColor)
            R = Color_TableRed(IndexColor)
            G = Color_TableGreen(IndexColor)
            B = Color_TableBlue(IndexColor)

            MyGetPen = New Pen(Color.FromArgb(A, B, G, B))
            Return MyGetPen


            Select Case UCase(MyLeft(ColorORDataTypeName, 1))
                Case "A"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("AliceBlue")
                            Return Pens.AliceBlue
                        Case UCase("AntiqueWhite")
                            Return Pens.AntiqueWhite
                        Case UCase("Aqua")
                            Return Pens.Aqua
                        Case UCase("Aquamarine")
                            Return Pens.Aquamarine
                        Case UCase("Azure")
                            Return Pens.Azure
                        Case Else
                            Return Pens.Black
                    End Select
                Case "B"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("Beige")
                            Return Pens.Beige
                        Case UCase("Bisque")
                            Return Pens.Bisque
                        Case UCase("Black")
                            Return Pens.Black
                        Case UCase("BlanchedAlmond")
                            Return Pens.BlanchedAlmond
                        Case UCase("Blue")
                            Return Pens.Blue
                        Case UCase("BlueViolet")
                            Return Pens.BlueViolet
                        Case UCase("Brown")
                            Return Pens.Brown
                        Case UCase("BurlyWood")
                            Return Pens.BurlyWood
                        Case Else
                            Return Pens.Black
                    End Select
                Case "C"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("CadetBlue")
                            Return Pens.CadetBlue
                        Case UCase("Chartreuse")
                            Return Pens.Chartreuse
                        Case UCase("Chocolate")
                            Return Pens.Chocolate
                        Case UCase("Coral")
                            Return Pens.Coral
                        Case UCase("CornflowerBlue")
                            Return Pens.CornflowerBlue
                        Case UCase("Cornsilk")
                            Return Pens.Cornsilk
                        Case UCase("Crimson")
                            Return Pens.Crimson
                        Case UCase("Cyan")
                            Return Pens.Cyan
                        Case Else
                            Return Pens.Black
                    End Select
                Case "D"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("DarkBlue")
                            Return Pens.DarkBlue
                        Case UCase("DarkCyan")
                            Return Pens.DarkCyan
                        Case UCase("DarkGoldenrod")
                            Return Pens.DarkGoldenrod
                        Case UCase("DarkGray")
                            Return Pens.DarkGray
                        Case UCase("DarkGreen")
                            Return Pens.DarkGreen
                        Case UCase("DarkKhaki")
                            Return Pens.DarkKhaki
                        Case UCase("DarkMagenta")
                            Return Pens.DarkMagenta
                        Case UCase("DarkOliveGreen")
                            Return Pens.DarkOliveGreen
                        Case UCase("DarkOrange")
                            Return Pens.DarkOrange
                        Case UCase("DarkOrchid")
                            Return Pens.DarkOrchid
                        Case UCase("DarkRed")
                            Return Pens.DarkRed
                        Case UCase("DarkSalmon")
                            Return Pens.DarkSalmon
                        Case UCase("DarkSeaGreen")
                            Return Pens.DarkSeaGreen
                        Case UCase("DarkSlateBlue")
                            Return Pens.DarkSlateBlue
                        Case UCase("DarkSlateGray")
                            Return Pens.DarkSlateGray
                        Case UCase("DarkTurquoise")
                            Return Pens.DarkTurquoise
                        Case UCase("DarkViolet")
                            Return Pens.DarkViolet
                        Case UCase("DeepPink")
                            Return Pens.DeepPink
                        Case UCase("DeepSkyBlue")
                            Return Pens.DeepSkyBlue
                        Case UCase("DimGray")
                            Return Pens.DimGray
                        Case UCase("DodgerBlue")
                            Return Pens.DodgerBlue
                        Case Else
                            Return Pens.Black
                    End Select
                Case "F"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("Firebrick")
                            Return Pens.Firebrick
                        Case UCase("FloralWhite")
                            Return Pens.FloralWhite
                        Case UCase("ForestGreen")
                            Return Pens.ForestGreen
                        Case UCase("Fuchsia")
                            Return Pens.Fuchsia
                        Case Else
                            Return Pens.Black
                    End Select
                Case "G"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("Gainsboro")
                            Return Pens.Gainsboro
                        Case UCase("GhostWhite")
                            Return Pens.GhostWhite
                        Case UCase("Gold")
                            Return Pens.Gold
                        Case UCase("Goldenrod")
                            Return Pens.Goldenrod
                        Case UCase("Gray")
                            Return Pens.Gray
                        Case UCase("Green")
                            Return Pens.Green
                        Case UCase("GreenYellow")
                            Return Pens.GreenYellow
                        Case Else
                            Return Pens.Black
                    End Select
                Case "H"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("Honeydew")
                            Return Pens.Honeydew
                        Case UCase("HotPink")
                            Return Pens.HotPink
                    End Select
                Case "I"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("IndianRed")
                            Return Pens.IndianRed
                        Case UCase("Indigo")
                            Return Pens.Indigo
                        Case UCase("Ivory")
                            Return Pens.Ivory
                        Case Else
                            Return Pens.Black
                    End Select
                Case "K"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("Khaki")
                            Return Pens.Khaki
                        Case Else
                            Return Pens.Black
                    End Select
                Case "L"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("Lavender")
                            Return Pens.Lavender
                        Case UCase("LavenderBlush")
                            Return Pens.LavenderBlush
                        Case UCase("LawnGreen")
                            Return Pens.LawnGreen
                        Case UCase("LemonChiffon")
                            Return Pens.LemonChiffon
                        Case UCase("LightBlue")
                            Return Pens.LightBlue
                        Case UCase("LightCoral")
                            Return Pens.LightCoral
                        Case UCase("LightCyan")
                            Return Pens.LightCyan
                        Case UCase("LightGoldenrodYellow")
                            Return Pens.LightGoldenrodYellow
                        Case UCase("LightGray")
                            Return Pens.LightGray
                        Case UCase("LightGreen")
                            Return Pens.LightGreen
                        Case UCase("LightPink")
                            Return Pens.LightPink
                        Case UCase("LightSalmon")
                            Return Pens.LightSalmon
                        Case UCase("LightSeaGreen")
                            Return Pens.LightSeaGreen
                        Case UCase("LightSkyBlue")
                            Return Pens.LightSkyBlue
                        Case UCase("LightSlateGray")
                            Return Pens.LightSlateGray
                        Case UCase("LightSteelBlue")
                            Return Pens.LightSteelBlue
                        Case UCase("LightYellow")
                            Return Pens.LightYellow
                        Case UCase("Lime")
                            Return Pens.Lime
                        Case UCase("LimeGreen")
                            Return Pens.LimeGreen
                        Case UCase("Linen")
                            Return Pens.Linen
                        Case Else
                            Return Pens.Black
                    End Select
                Case "M"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("Magenta")
                            Return Pens.Magenta
                        Case UCase("Maroon")
                            Return Pens.Maroon
                        Case UCase("MediumAquamarine")
                            Return Pens.MediumAquamarine
                        Case UCase("MediumBlue")
                            Return Pens.MediumBlue
                        Case UCase("MediumOrchid")
                            Return Pens.MediumOrchid
                        Case UCase("MediumPurple")
                            Return Pens.MediumPurple
                        Case UCase("MediumSeaGreen")
                            Return Pens.MediumSeaGreen
                        Case UCase("MediumSlateBlue")
                            Return Pens.MediumSlateBlue
                        Case UCase("MediumSpringGreen")
                            Return Pens.MediumSpringGreen
                        Case UCase("MediumTurquoise")
                            Return Pens.MediumTurquoise
                        Case UCase("MediumVioletRed")
                            Return Pens.MediumVioletRed
                        Case UCase("MidnightBlue")
                            Return Pens.MidnightBlue
                        Case UCase("MintCream")
                            Return Pens.MintCream
                        Case UCase("MistyRose")
                            Return Pens.MistyRose
                        Case UCase("Moccasin")
                            Return Pens.Moccasin
                        Case Else
                            Return Pens.Black
                    End Select
                Case "N"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("NavajoWhite")
                            Return Pens.NavajoWhite
                        Case UCase("Navy")
                            Return Pens.Navy
                        Case Else
                            Return Pens.Black
                    End Select
                Case "O"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("OldLace")
                            Return Pens.OldLace
                        Case UCase("Olive")
                            Return Pens.Olive
                        Case UCase("OliveDrab")
                            Return Pens.OliveDrab
                        Case UCase("Orange")
                            Return Pens.Orange
                        Case UCase("OrangeRed")
                            Return Pens.OrangeRed
                        Case UCase("Orchid")
                            Return Pens.Orchid
                        Case Else
                            Return Pens.Black
                    End Select
                Case "P"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("PaleGoldenrod")
                            Return Pens.PaleGoldenrod
                        Case UCase("PaleGreen")
                            Return Pens.PaleGreen
                        Case UCase("PaleTurquoise")
                            Return Pens.PaleTurquoise
                        Case UCase("PaleVioletRed")
                            Return Pens.PaleVioletRed
                        Case UCase("PapayaWhip")
                            Return Pens.PapayaWhip
                        Case UCase("PeachPuff")
                            Return Pens.PeachPuff
                        Case UCase("Peru")
                            Return Pens.Peru
                        Case UCase("Pink")
                            Return Pens.Pink
                        Case UCase("Plum")
                            Return Pens.Plum
                        Case UCase("PowderBlue")
                            Return Pens.PowderBlue
                        Case UCase("Purple")
                            Return Pens.Purple
                        Case Else
                            Return Pens.Black
                    End Select
                Case "R"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("Red")
                            Return Pens.Red
                        Case UCase("RosyBrown")
                            Return Pens.RosyBrown
                        Case UCase("RoyalBlue")
                            Return Pens.RoyalBlue
                        Case Else
                            Return Pens.Black
                    End Select
                Case "S"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("SaddleBrown")
                            Return Pens.SaddleBrown
                        Case UCase("Salmon")
                            Return Pens.Salmon
                        Case UCase("SandyBrown")
                            Return Pens.SandyBrown
                        Case UCase("SeaGreen")
                            Return Pens.SeaGreen
                        Case UCase("SeaShell")
                            Return Pens.SeaShell
                        Case UCase("Sienna")
                            Return Pens.Sienna
                        Case UCase("Silver")
                            Return Pens.Silver
                        Case UCase("SkyBlue")
                            Return Pens.SkyBlue
                        Case UCase("SlateBlue")
                            Return Pens.SlateBlue
                        Case UCase("SlateGray")
                            Return Pens.SlateGray
                        Case UCase("Snow")
                            Return Pens.Snow
                        Case UCase("SpringGreen")
                            Return Pens.SpringGreen
                        Case UCase("SteelBlue")
                            Return Pens.SteelBlue
                        Case Else
                            Return Pens.Black
                    End Select
                Case "T"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("Tan")
                            Return Pens.Tan
                        Case UCase("Teal")
                            Return Pens.Teal
                        Case UCase("Thistle")
                            Return Pens.Thistle
                        Case UCase("Tomato")
                            Return Pens.Tomato
                        Case UCase("Transparent")
                            Return Pens.Transparent
                        Case UCase("Turquoise")
                            Return Pens.Turquoise
                        Case Else
                            Return Pens.Black
                    End Select
                Case "V"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("Violet")
                            Return Pens.Violet
                        Case Else
                            Return Pens.Black
                    End Select
                Case "W"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("Wheat")
                            Return Pens.Wheat
                        Case UCase("White")
                            Return Pens.White
                        Case UCase("WhiteSmoke")
                            Return Pens.WhiteSmoke
                        Case Else
                            Return Pens.Black
                    End Select
                Case "Y"
                    Select Case UCase(ColorORDataTypeName)
                        Case UCase("Yellow")
                            Return Pens.Yellow
                        Case UCase("YellowGreen")
                            Return Pens.YellowGreen
                        Case Else
                            Return Pens.Black
                    End Select

                Case Else
                    '?? Why am I looking it up in the color table? and then making it black
                    ' ohh because the RGB pen creation was to hard to do, cause Im lazy
                    Return Pens.Black
                    'To bad I cant make it into red green blue pen yet
            End Select
            MSG_ABug(2650, "Unable to handle color ", ColorORDataTypeName, "")
            If MyOptionTest(25) = True Then
                Return Pens.Black
            Else
                Return Nothing
            End If
        End Function



        Public Shared Function MySign(A As Int32) As Int32   'Returns the sign value
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2411, 10, "sign")
#End If
            If A > 0 Then Return 1
            If A < 0 Then Return -1
            Return 0
        End Function


        'Routine  This returns an absolute value (ie: never negitive)
        Public Shared Function MyABS(A As Int32) As Int32   'Returns the absolute value
            If A > 0 Then Return A
            Return -A
        End Function




        Public Shared Function MyABS64(A As Int64) As Int64   'Returns the absolute value
            If A > 0 Then Return A
            Return -A
        End Function

        'routine to get the max value (dumb, should be a default function ! )
        Public Shared Function MyMax(a As Int32, b As Int32) As Int32
            If a > b Then Return a
            Return b
        End Function


        'Routine This returns the minium of the two (long) values
        Public Shared Function MyMin(a As Int32, b As Int32) As Int32
            If a < b Then Return a
            Return b
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Routine This returns the number forced to be between 
        'This routine returns  Min <= A <= Max
        Public Shared Function MyMinMax(A As Int32, MinimunValue As Int32, MaximunValue As Int32) As Int32
            If A < MinimunValue Then Return MinimunValue
            If A > MaximunValue Then Return MaximunValue
            Return A
        End Function



        'Routine This makes sure ALL MyArray bounds will never become to small.
        'Routine (continued) It also displays on OptionsWindow.the size, and amount used.
        Public Shared Sub MyMakeArraySizesBigger() ' Checks that all of the arrays have room to add to
            Dim MyNumber As Integer
            Dim Named_Counter, FlowChart_Counter, Symbol_Counter, Color_Counter, DataType_Counter As Int32
            If MyUniverse.MyStaticData.Named_TableCount > UBound(Named_FileSymbolName) Then Named_Counter = UBound(Named_FileSymbolName) Else Named_Counter = MyUniverse.MyStaticData.Named_TableCount
            If Named_Counter + ConstantBufferSizeBeforeChangingSizeOfArray / 2 > UBound(Named_FileSymbolName) Then
                MyNumber = CInt(MyMax(Named_Counter + ConstantBufferSizeBeforeChangingSizeOfArray, 16))
#If MINEDEBUG Then
                        If MyDebug(9 ) then follow(2412, 9, "MyMakeArraySizesBigger ?: Named " & MyNumber.ToString)
#End If
                ReDim Preserve Named_FileSymbolName_ISAM(MyNumber)
                ReDim Preserve Named_FileSyntax_ISAM(MyNumber)
                ReDim Preserve Named_FileSymbolName(MyNumber)
                ReDim Preserve Named_FileMicroCodeText(MyNumber)
                ReDim Preserve Named_FileSyntax(MyNumber)
                ReDim Preserve Named_FileOpCode(MyNumber)
                ReDim Preserve Named_FileNotes(MyNumber)
                ReDim Preserve Named_FileNameOfFile(MyNumber)
                ReDim Preserve Named_FileStroke(MyNumber)
                ReDim Preserve Named_FileSymbolIndexes(MyNumber)
                ReDim Preserve Named_FileVersion(MyNumber)
                ReDim Preserve Named_FileAuthor(MyNumber)
                FileInputOutputWindow.PB_Size1.Width = CInt((MyNumber ^ 0.5))
                FileInputOutputWindow.PB_Size1.Value = CInt(100.0 * Named_Counter / UBound(Named_FileSymbolName))
                FileInputOutputWindow.PB_LabelSizeNamed.Text = "Named" & MyUniverse.ProgramOptions.FCCL_WhiteSpace & Named_Counter & "/" & UBound(Named_FileSymbolName)
                DoEvents(126001)
            End If

            'Symbol_Counter = MyMinMax(Symbol_TableCount, 1, UBound(Symbol_FileCoded))
            If MyUniverse.MyStaticData.Symbol_TableCount > UBound(Symbol_FileCoded) Then Symbol_Counter = UBound(Symbol_FileCoded) Else Symbol_Counter = MyUniverse.MyStaticData.Symbol_TableCount
            If Symbol_Counter + ConstantBufferSizeBeforeChangingSizeOfArray / 2 > UBound(Symbol_FileSymbolName) Then
                MyNumber = CInt(MyMax(Symbol_Counter + ConstantBufferSizeBeforeChangingSizeOfArray, 16))
                ' sorted by SymbolName
#If MINEDEBUG Then
                        If MyDebug(9 ) then follow(2412, 9, "MyMakeArraySizesBigger, ?: Symbols " & MyNumber.ToString)
#End If
                ReDim Preserve Symbol_FileSymbolName(MyNumber)
                ReDim Preserve Symbol_FileCoded(MyNumber)
                ReDim Preserve Symbol_FileX1(MyNumber)
                ReDim Preserve Symbol_FileY1(MyNumber)
                ReDim Preserve Symbol_FileX2_io(MyNumber)
                ReDim Preserve Symbol_FileY2_dt(MyNumber)
                ReDim Preserve Symbol_File_NameOfPoint(MyNumber)
                FileInputOutputWindow.PB_Size2.Width = CInt(MyNumber ^ 0.5)
                FileInputOutputWindow.PB_Size2.Value = CInt(100.0 * Symbol_Counter / UBound(Symbol_FileSymbolName))
                FileInputOutputWindow.PB_LabelSizeSymbol.Text = "Symbols" & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.MyStaticData.SymbolNumber_Counter & "/" & UBound(Symbol_FileSymbolName)
                'DoEvents(127001)
            End If

            'FlowChart_Counter = MyMinMax(FlowChart_TableCount, 1, UBound(FlowChart_FileCoded))
            'TopOfFile("FlowChart")
            If MyUniverse.MyStaticData.FlowChart_TableCount > UBound(FlowChart_FileCoded) Then FlowChart_Counter = UBound(FlowChart_FileCoded) Else FlowChart_Counter = MyUniverse.MyStaticData.FlowChart_TableCount
            If FlowChart_Counter + ConstantBufferSizeBeforeChangingSizeOfArray / 2 > UBound(FlowChart_FileCoded) Then
                MyNumber = CInt(MyMax(FlowChart_Counter + ConstantBufferSizeBeforeChangingSizeOfArray, 16))
                If MyDebug(11) = True Then If mydebug(9) Then follow(2412, 11, "MyMakeArraySizesBigger, ?: Flow Chart " & MyNumber.ToString)
                ReDim Preserve FlowChart_FileCoded(MyNumber)
                ReDim Preserve FlowChart_FilePathSymbolName(MyNumber)
                ReDim Preserve FlowChart_FileX1(MyNumber)
                ReDim Preserve FlowChart_FileY1(MyNumber)
                ReDim Preserve FlowChart_File_X2_Rotation(MyNumber)
                ReDim Preserve FlowChart_File_Y2_Option(MyNumber)
                ReDim Preserve FlowChart_File_DataType(MyNumber)
                ' removed    ReDim Preserve FlowChart_FileCompiledMacroCodeText(MyNumber)
                ReDim Preserve FlowChart_ISAM_X1(MyNumber)
                ReDim Preserve FlowChart_ISAM_Y1(MyNumber)
                ReDim Preserve FlowChart_ISAM_X2(MyNumber)
                ReDim Preserve FlowChart_ISAM_Y2(MyNumber)
                ReDim Preserve FlowChart_ISAM_Name(MyNumber)

                FileInputOutputWindow.PB_Size3.Width = CInt(MyNumber ^ 0.5)
                FileInputOutputWindow.PB_Size3.Value = CInt(100.0 * FlowChart_Counter / UBound(FlowChart_FileCoded))
                FileInputOutputWindow.PB_LabelSizeFlowChart.Text = "FlowChart" & MyUniverse.ProgramOptions.FCCL_WhiteSpace & FlowChart_Counter & "/" & UBound(FlowChart_FilePathSymbolName)
                DoEvents(128001)
            End If


            'TopOfFile("Color")
            'Color_Counter = MyMinMax(Color_TableCount, 1, UBound(Color_FileBlue))
            If MyUniverse.MyStaticData.Color_TableCount > UBound(Color_FileName) Then Color_Counter = UBound(Color_FileName) Else Color_Counter = MyUniverse.MyStaticData.Color_TableCount
            If Color_Counter + ConstantBufferSizeBeforeChangingSizeOfArray / 2 > UBound(Color_FileName) Then
                MyNumber = CInt(MyMax(Color_Counter + ConstantBufferSizeBeforeChangingSizeOfArray, 16))
                If MyDebug(11) = True Then If mydebug(9) Then follow(2412, 11, "MyMakeArraySizesBigger, ?: Color " & MyNumber.ToString)
                ReDim Preserve Color_FileName(MyNumber)
                ReDim Preserve Color_FileAlpha(MyNumber)
                ReDim Preserve Color_FileRed(MyNumber)
                ReDim Preserve Color_FileGreen(MyNumber)
                ReDim Preserve Color_FileBlue(MyNumber)
                ReDim Preserve Color_FileStyle(MyNumber) '1, dash , 2, dot, 3, DashDot, 4, DashDotDot
                ReDim Preserve Color_FileStartCap(MyNumber)
                ReDim Preserve Color_FileEndCap(MyNumber)
                ReDim Preserve Color_Name_ISAM(MyNumber)
                FileInputOutputWindow.PB_Size4.Width = CInt(MyNumber ^ 0.5)
                FileInputOutputWindow.PB_Size4.Value = CInt(100.0 * Color_Counter / UBound(Color_FileName))
                FileInputOutputWindow.PB_LabelSizeColor.Text = "Colors" & MyUniverse.ProgramOptions.FCCL_WhiteSpace & Color_Counter & "/" & UBound(Color_FileName)
                'todo to speed up MyDoEvents
            End If


            'TopOfFile("DataType")
            'DataType_Counter = MyMinMax(DataType_TableCount, 1, UBound(FlowChart_FileCoded))
            If MyUniverse.MyStaticData.DataType_TableCount > UBound(DataType_FileName) Then DataType_Counter = UBound(DataType_FileName) Else DataType_Counter = MyUniverse.MyStaticData.DataType_TableCount
            If DataType_Counter + ConstantBufferSizeBeforeChangingSizeOfArray / 2 > UBound(DataType_FileName) Then
                MyNumber = CInt(MyMax(DataType_Counter + ConstantBufferSizeBeforeChangingSizeOfArray, 16))
                If MyDebug(11) = True Then If mydebug(9) Then follow(2412, 11, "MyMakeArraySizesBigger, ?: Data Types " & MyNumber.ToString)
                ReDim Preserve DataType_Name_ISAM(MyNumber)
                ReDim Preserve DataType_FileName(MyNumber)
                ReDim Preserve DataType_FileColorIndex(MyNumber)
                ReDim Preserve DataType_FileDescription(MyNumber)
                ReDim Preserve DataType_FileNumberOfBytes(MyNumber)
                ReDim Preserve DataType_FileWidth(MyNumber)
                FileInputOutputWindow.PB_Size5.Width = CInt(MyNumber ^ 0.5)
                FileInputOutputWindow.PB_Size5.Value = CInt(100.0 * DataType_Counter / UBound(DataType_FileName))
                FileInputOutputWindow.PB_LabelSizeDataType.Text = "DataType" & MyUniverse.ProgramOptions.FCCL_WhiteSpace & DataType_Counter & "/" & UBound(DataType_FileName)

                ' removed 20232506MyDoEvents(129)
            End If



        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This makes sure that the file counters of where you are is inside the bounds of the arrays
        Public Shared Function FileCounter(MyTable As String) As Int32
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2917, 10, "FileCounter")
#End If
            MyMakeArraySizesBigger()
            Select Case LCase(ReplaceRM("", MyTable, ""))
                Case "color"
                    FileCounter = MyMinMax(MyUniverse.MyStaticData.Color_TableCount, 0, UBound(Color_FileName))
                    While FileCounter > 0 And Len(Color_FileName(FileCounter)) = 0
                        FileCounter -= 1
                    End While
                Case "FlowChart"
                    FileCounter = MyMinMax(MyUniverse.MyStaticData.FlowChart_TableCount, 0, UBound(FlowChart_FileCoded))
                    While FileCounter > 0 And Len(FlowChart_FilePathSymbolName(FileCounter)) = 0
                        FileCounter -= 1
                    End While
                Case "named"
                    FileCounter = MyMinMax(MyUniverse.MyStaticData.Named_TableCount, 0, UBound(Named_FileSymbolName))
                    While FileCounter > 0 And Len(Named_FileSymbolName(FileCounter)) = 0
                        FileCounter -= 1
                    End While
                Case "Symbol"
                    FileCounter = MyMinMax(MyUniverse.MyStaticData.Symbol_TableCount, 0, UBound(Symbol_FileSymbolName))
                    While FileCounter > 0 And Symbol_FileCoded(FileCounter) = 0
                        FileCounter -= 1
                    End While
                Case "DataType"
                    FileCounter = MyMinMax(MyUniverse.MyStaticData.DataType_TableCount, 0, UBound(DataType_FileName))
                    While FileCounter > 0 And Len(DataType_FileName(FileCounter)) = 0
                        FileCounter -= 1
                    End While
                Case "Keyword"
                    FileCounter = UBound(Language_KeyWord)
                    While FileCounter > 1 And Language_KeyWord(FileCounter) = ""
                        FileCounter -= 1
                    End While
                Case "operator"
                    FileCounter = UBound(Language_Operator)
                    While FileCounter > 1 And Language_Operator(FileCounter) = ""
                        FileCounter -= 1
                    End While
                Case "function"
                    FileCounter = UBound(Language_Function)
                    While FileCounter > 1 And Language_Function(FileCounter) = ""
                        FileCounter -= 1
                    End While
                Case "Grammar"
                    FileCounter = UBound(Language_Grammar)
                    While FileCounter > 1 And Language_Grammar(FileCounter) = ""
                        FileCounter -= 1
                    End While
                Case Else
                    FileCounter = 0 'CInt((Color_TableCount + FlowChart_TableCount + Named_TableCount + Symbol_TableCount + DataType_TableCount) / 5)
                    MSG_ABug(1018, "Program error this is a Wrong table name", MyTable, FileCounter.ToString)
            End Select
        End Function


        Public Shared Sub FileCounter2(MyTable As String, NewValue As Int32) ' Keeps track of the highest pointer of the MyTable Arrays
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2918, 10, "FileCounter2")
#End If
            If MyDebug(11) = True Then If mydebug(9) Then follow(2413, 11, "FileCounter2, " & MyTable & " " & NewValue.ToString)
            Select Case LCase(MyTable)
                Case "color"
                    MyUniverse.MyStaticData.Color_TableCount = NewValue
                Case "FlowChart"
                    MyUniverse.MyStaticData.FlowChart_TableCount = NewValue
                Case "named"
                    MyUniverse.MyStaticData.Named_TableCount = NewValue
                Case "Symbol"
                    MyUniverse.MyStaticData.Symbol_TableCount = NewValue
                Case "DataType"
                    MyUniverse.MyStaticData.DataType_TableCount = NewValue
                    'MSG_ABug(1020, "FileCounter: ", MyTable, 0) 'hack
                Case Else
                    MSG_ABug(2711, "End of table not updated ", MyTable, NewValue.ToString)
                    If MyOptionTest(25) = True Then
                        Return
                    Else
                        Return
                    End If
            End Select
            MyMakeArraySizesBigger()
            '
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'One of many routines that returns the top of the data in the array
        Public Shared Function NewTopOfFile(MyTable As String) As Int32
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2919, 10, "NewTopOfFile")
#End If
            If MyDebug(11) = True Then If mydebug(9) Then follow(2414, 11, "NewTopOfFile " & MyTable)
            NewTopOfFile = FileCounter(MyTable) + 1
            FileCounter2(MyTable, NewTopOfFile)
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This is to keep track of the top of the USED arrays (as opposed to the size of the array)

        Public Shared Function TopOfFile(MyTable As String) As Integer
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2920, 10, "TopOfFile")
#End If
            TopOfFile = FileCounter(MyTable) ' get the max size that it should be
        End Function

        Public Shared Sub ShowThisWindow(F As Form, status As Integer)
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2921, 10, "ShowThisWindow")
            FindingMyBugsChangeOfWindows()
#End If
            Select Case status
                Case HideWindow
                    If MyDebug(6) = True Then If mydebug(9) Then follow(2415, 6, "A)Window=" & F.Name & " as HIDE")
                    F.Visible = False
                    F.SendToBack()
                    F.WindowState = System.Windows.Forms.FormWindowState.Normal
                    F.SendToBack()
                Case ShowWindow
                    If MyDebug(6) = True Then If mydebug(9) Then follow(2415, 6, "B)Window=" & F.Name & " as SHOW")
                    'F.WindowState = System.Windows.Forms.FormWindowState.Maximized
                    F.BringToFront()
                    F.Visible = True
                    F.Activate()
                    If F.WindowState = System.Windows.Forms.FormWindowState.Minimized Then
                        F.WindowState = System.Windows.Forms.FormWindowState.Normal
                    End If
                    MyButtonsEnableRules() ' enable and disable the buttons on all forms
                Case LeaveWindow
                    If MyDebug(6) Then follow(2415, 6, "C)Window=" & F.Name & " as Do NOTHING")
                    'F.WindowState = System.Windows.Forms.FormWindowState.Normal
                    'F.SendToBack()
                Case Else
                    If MyDebug(6) Then follow(2415, 6, "D)Window=" & F.Name & " as ERROR and UNKNOWN")
                    F.WindowState = System.Windows.Forms.FormWindowState.Normal
                    F.Activate()
                    F.Visible = True
                    F.BringToFront()
                    MyButtonsEnableRules() ' enable and disable the buttons on all forms
            End Select

        End Sub


        Public Shared Sub ShowSelectionOptions(BugNumber As Int32, Title As String, List1() As String)
            Dim I As Int32
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2922, 10, "ShowSelectedionOptions")
#End If

            For I = 1 To List1.Length
                SelectionOption.SelectionListBox.Items.Add(List1(I))
            Next I
            'SelectionOption.Show()
            SelectionOption.Activate()
            MyUniverse.MySystem.SelectionOption = 0 'flag this it has not been selected
#If MINEDEBUG Then
            FindingMyBugsChangeOfWindows()
#End If
            SelectionOption.Visible = True
            While SelectionOption.Visible = True And MyUniverse.MySystem.SelectionOption < 1
                DoEvents(123456)
            End While
            If MyUniverse.MySystem.SelectionOption = 0 Then Return
            If MyUniverse.MySystem.SelectionOption < List1.Length Then
                Return
            End If
            Return 'ERROR ?????
        End Sub

        Public Shared Sub ShowAllForms(FormFlowChart As Integer, FormSymbol As Integer, FormOption As Integer, FormFileIO As Integer)
            Dim Temp As String
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2416, 10, "ShowAllForms")
                    If MyDebug(6 ) then follow(2416, 6, "ShowAllForms " & FormFlowChart.ToString & FormSymbol.ToString & FormOption.ToString & FormFileIO.ToString)
#End If
            '-1 is no change (sent to the back)
            '0 is make it invisible (not being used right now)
            '1 is make it the front and visible
            Temp = MyUniverse.ProgramOptions.SelectedSymbolName

            If Temp = "" Then
                Temp = "Start"
                'Need to select it in the drop down list  (OK, I forgot what I called that subroutine
                FlowChartWindow.ToolStripDropDownSelectSymbol.Text = "Start"
                SymbolWindow.ToolStripDropDownSelectSymbol.Text = "Start"
                MyUniverse.ProgramOptions.SelectedSymbolName = "Start"
            End If
            'No because it overrides the select Symbol with "start" GetAllSymbolNames("Start") 'todo check that this is require HERE?
            FillAllDropdowns(Temp)


            'This is to make sure that some window is always on
            If FormFlowChart <> ShowWindow And FormSymbol <> ShowWindow And FormFileIO <> ShowWindow And FormOption <> ShowWindow Then Return

            If FormFlowChart = 1 Then FlowChartWindow.BringToFront()
            If FormSymbol = 1 Then SymbolWindow.BringToFront()
            If FormFileIO = 1 Then FileInputOutputWindow.BringToFront()
            If FormOption = 1 Then OptionsWindow.BringToFront()

            ShowThisWindow(FlowChartWindow, FormFlowChart)
            ShowThisWindow(SymbolWindow, FormSymbol)
            ShowThisWindow(FileInputOutputWindow, FormFileIO)
            ShowThisWindow(OptionsWindow, FormOption)


            MyUniverse.MySystem.WindowsStatus(1) = "Hide"
            MyUniverse.MySystem.WindowsStatus(2) = "Hide"
            MyUniverse.MySystem.WindowsStatus(3) = "Hide"
            MyUniverse.MySystem.WindowsStatus(4) = "Hide"

            If FormFlowChart = ShowWindow Then MyUniverse.MySystem.WindowsStatus(1) = "Show"
            If FormSymbol = ShowWindow Then MyUniverse.MySystem.WindowsStatus(2) = "Show"
            If FormFileIO = ShowWindow Then MyUniverse.MySystem.WindowsStatus(3) = "Show"
            If FormOption = ShowWindow Then MyUniverse.MySystem.WindowsStatus(4) = "Show"

            DoEvents(118001)
        End Sub 'ShowAllForms


        Public Shared Function MyRotated(IndexSymbol As Int32, IndexFlowChart As Int32) As MyPointStructure
            Dim RotationName As String
            Dim InputXY As MyPointStructure
            Dim OffsetXY As MyPointStructure
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2923, 10, "MyRotated")
#End If
            InputXY = MyUniverse.MyStaticData.ZeroZero
            OffsetXY = MyUniverse.MyStaticData.ZeroZero
            RotationName = FlowChart_Table_Rotation(IndexFlowChart)
            FindingMyBugsTOF_Indexes(IndexFlowChart, IndexSymbol, 0, 0, 0)
            If IndexSymbol = 0 Then
                InputXY.x = 0
                InputXY.y = 0
                SetNameOfPoint(InputXY, "", "", "")
            Else
                InputXY.x = Symbol_TableX1(IndexSymbol)
                InputXY.y = Symbol_TableY1(IndexSymbol)
                SetNameOfPoint(InputXY, Symbol_Table_NameOfPoint(IndexSymbol), "", "")
            End If
            OffsetXY.x = FlowChart_TableX1(IndexFlowChart)
            OffsetXY.y = FlowChart_TableY1(IndexFlowChart)
            Select Case LCase(FlowChart_TableCode(IndexFlowChart))
                Case My_keyWord(My_KeyConstUse)
                    SetNameOfPoint(OffsetXY, "", FlowChart_TableSymbol_Name(IndexFlowChart), "")
                Case "/path"
                    'todo this needs to return the name of the path
                    SetNameOfPoint(OffsetXY, "", "", FlowChart_TablePathName(IndexFlowChart))
                Case Else
                    SetNameOfPoint(OffsetXY, "?" & FlowChart_TableCode(IndexFlowChart), "??" & FlowChart_TableCode(IndexFlowChart), "???" & FlowChart_TableCode(IndexFlowChart))
            End Select
            MyRotated = MyRotated_x(InputXY, OffsetXY, RotationName)
            If MyDebug(10) = True Then If mydebug(9) Then follow(2712, 10, RotationName & FD & MyShowPoint(InputXY) & " + " & MyShowPoint(OffsetXY) & " ---> " & MyShowPoint(MyRotated))
        End Function

        Public Shared Function MyRotated_1(IndexSymbol As Int32, OffsetXY As MyPointStructure, RotationName As String) As MyPointStructure
            Dim InputXY As MyPointStructure
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2926, 10, "MyRotated_1")
                    If MyDebug(5 ) then follow(2417, 5, "rotated1 " & RotationName & ", " & MyShowPoint(OffsetXY))
#End If
            InputXY = MyUniverse.MyStaticData.ZeroZero
            FindingMyBugsTOF_Indexes(0, IndexSymbol, 0, 0, 0)
            InputXY.x = Symbol_TableX1(IndexSymbol)
            InputXY.y = Symbol_TableY1(IndexSymbol)
            SetNameOfPoint(InputXY, Symbol_Table_NameOfPoint(IndexSymbol), "", "")
            MyRotated_1 = MyRotated_x(InputXY, OffsetXY, RotationName)
            If MyDebug(11) = True Then If mydebug(9) Then follow(2713, 11, RotationName & FD & MyShowPoint(InputXY) & " + " & MyShowPoint(OffsetXY) & " ---> " & MyShowPoint(MyRotated_1))
        End Function


        Public Shared Function MyRotated_1a(IndexSymbol As Int32, RotationName As String) As MyPointStructure
            Dim InputXY As MyPointStructure
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2927, 10, "MyRotated_1a")
#End If
            InputXY = MyUniverse.MyStaticData.ZeroZero
            InputXY.x = Symbol_TableX1(IndexSymbol)
            InputXY.y = Symbol_TableY1(IndexSymbol)
            SetNameOfPoint(InputXY, Symbol_Table_NameOfPoint(IndexSymbol), "", "")
            MyRotated_1a = MyRotated_x(InputXY, MyUniverse.MyStaticData.ZeroZero, RotationName)
            If MyDebug(11) = True Then If mydebug(9) Then follow(2714, 11, RotationName & FD & MyShowPoint(InputXY) & " ---> " & MyShowPoint(MyRotated_1a))
        End Function




        Public Shared Function MyRotated_2(IndexSymbol As Int32, IndexFlowChart As Int32, RotationName As String) As MyPointStructure
            Dim InputXY As MyPointStructure
            Dim OffsetXY As MyPointStructure
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2928, 10, "MyRotated_2")
                    If MyDebug(5 ) then follow(2419, 5, "rotated")
#End If
            InputXY = MyUniverse.MyStaticData.ZeroZero
            OffsetXY = MyUniverse.MyStaticData.ZeroZero

            FindingMyBugsTOF_Indexes(IndexFlowChart, IndexSymbol, 0, 0, 0)
            FindingMyBugs(2) 'hack Least amount of checking here 'hack
            InputXY.x = Symbol_Table_X2(IndexSymbol)
            InputXY.y = Symbol_Table_Y2(IndexSymbol)
            SetNameOfPoint(InputXY, Symbol_Table_NameOfPoint(IndexSymbol), "", "")
            OffsetXY.x = FlowChart_TableX1(IndexFlowChart)
            OffsetXY.y = FlowChart_TableY1(IndexFlowChart)
            SetNameOfPoint(OffsetXY, "", FlowChart_TablePathName(IndexFlowChart), FlowChart_TablePathName(IndexFlowChart).ToString)
            MyRotated_2 = MyRotated_x(InputXY, OffsetXY, RotationName)
            If MyDebug(1) Then follow(2715, RotationName & FD & MyShowPoint(InputXY) & " + " & MyShowPoint(OffsetXY) & " ---> " & MyShowPoint(MyRotated_2))

        End Function

        Public Shared Function MyRotated_2(IndexSymbol As Int32, OffsetXY As MyPointStructure, RotationName As String) As MyPointStructure
            Dim InputXY As MyPointStructure
#If MINEDEBUG Then
            If MyDebug(10) = True Then          If MyDebug(10 ) then follow(2929, 10, "")
                    If MyDebug(5 ) then follow(2420, 5, "rotated " & RotationName & ", " & MyShowPoint(OffsetXY))
#End If
            InputXY = MyUniverse.MyStaticData.ZeroZero
            InputXY.x = Symbol_Table_X2(IndexSymbol)
            InputXY.y = Symbol_Table_Y2(IndexSymbol)
            SetNameOfPoint(InputXY, Symbol_Table_NameOfPoint(IndexSymbol), "", "")
            MyRotated_2 = MyRotated_x(InputXY, OffsetXY, RotationName)
            If MyDebug(11) = True Then If mydebug(9) Then follow(2716, 11, RotationName & FD & MyShowPoint(InputXY) & " + " & MyShowPoint(OffsetXY) & " ---> " & MyShowPoint(MyRotated_2))
        End Function


        Public Shared Function FlipFlop(WhichOne As Int32, Index As Int32) As Int32
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2930, 10, "FlipFlop")
#End If
            If WhichOne = MyMinMax(WhichOne, 1, 4) Then
                If Index = MyMinMax(Index, 0, 16) Then
                    Return MyRotation(WhichOne, Index)
                End If
            End If
            Return MyRotation(WhichOne, 1)
        End Function
        Public Shared Sub SaveRotation(Index As Int32, InputString As String)
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2931, 10, "SaveRotation")
            If MyDebug(10) = True Then if mydebug(9) then follow(2421, 10, "SaveRotation " & FD & InputString)
#End If
            MyRotation(1, Index) = PopValue(InputString)
            MyRotation(2, Index) = PopValue(InputString)
            MyRotation(3, Index) = PopValue(InputString)
            MyRotation(4, Index) = PopValue(InputString)
        End Sub


        Public Shared Function MyRotated_x(InputXY As MyPointStructure, OffsetXY As MyPointStructure, RotationName As String) As MyPointStructure
            Dim R As Int32
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2932, 10, "MyRotated_x")
#End If
            MyRotated_x = MyUniverse.MyStaticData.ZeroZero
            R = MyEnumValue(RotationName, SymbolWindow.ToolStripDropDownRotation)
            If R < 0 Or R > 16 Then
                MyMsgCtr(1273, "MyRotated_x", R.ToString, RotationName, "", "", "", "", "", "", "")
                R = 1
            End If
            MyRotated_x.x = InputXY.x * FlipFlop(1, R) + InputXY.y * FlipFlop(2, R)
            MyRotated_x.y = InputXY.x * FlipFlop(3, R) + InputXY.y * FlipFlop(4, R)
            MyRotated_x.x += OffsetXY.x
            MyRotated_x.y += OffsetXY.y
            SetNameOfPoint(MyRotated_x, InputXY.Named.PathName, InputXY.Named.SymbolName, InputXY.Named.PathName)
        End Function

        Public Shared Function AddNewSymbol(SymbolName As String) As Int32
            Dim IndexNamed, IndexSymbol As Int32
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2933, 10, "AddNewSymbol")
  if mydebug(9) then follow(2422, 1, "Add New Symbol graphics " & SymbolName)
#End If
            'First make sure that we are not changing the name to something already there
            IndexNamed = FindISAM_IN_Table("Named", "Do Not add", Named_FileSymbolName, Named_FileSymbolName_ISAM, SymbolName)

            'todo need to add a message that you cant rename to something that already exist.
            If IndexNamed = ConstantMyErrorCode Then 'Name already there so DoNot add it again
                IndexNamed = AddNewNamedRecord(SymbolName, "", "", "", "", "", "", "", "")
            End If

            IndexSymbol = CInt(FindInSymbolList(SymbolName))
            If IndexSymbol <= 0 Then
                ' add in the name record for this Symbol
                'NewTopOfFile("Symbol")
                MyInsertSymbolLineRecord(NewTopOfFile("Symbol"), SymbolName, "/name", MyLine1(0, 0, 0, 0), "")
            Else
                MSG_AInfo(1027, "new Symbol name warning? ", HighLight(SymbolName), MyShowNamedRecords(True, IndexSymbol))
            End If
            MyMakeArraySizesBigger()
            '2020 07 17 removed because only the named needs to be sorted, and is done on insert 'SortALLISAM()
            'reget all Symbol names (could replace this with only adding the Symbol name added
            'GetAllSymbolNames(SymbolName)
            AddSymbolToDropDown(SymbolName)
            Return IndexSymbol
        End Function




        Public Shared Sub AddSortedList(ThisTable As String, WhatStringToAdd As String, ByRef MyArray() As String)
            Dim I As Int32
            Dim PerCentageFull As Int32 ' percentage as integer
            Dim Key As String
            Dim MyTable As String
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2934, 10, "AddSortedList")
                    If MyDebug(5 ) then follow(2423, 5, "AddKeyWord " & ThisTable & ", " & MyTrim(WhatStringToAdd))
#End If
            If MyDebug(8) Then FMB1(8063)
            If MyDebug(8) Then FMB(1113, WhatStringToAdd)

            MyTable = ReplaceRM("", ThisTable, "")
            Key = MyTrim(WhatStringToAdd)
            If Key = "," & vbCr Then Key = ","
            MyMakeArraySizesBigger()
            If MyIsNothing(Key) Or Key = "" Or Len(Trim(Key)) = 0 Then ' Never add a blank keyword
                MSG_AInfo(1029, "Keyword blank", Key, "")
                Return
            End If
            ShowSorts(MyTable, ReSortLanguagekeyWord(MyTable, MyArray, TopOfFile(MyTable)))
            I = FindInSortedLanguageList(MyTable, LCase(Trim(Key)), MyArray)
            If I > ConstantMyErrorCode Then
                If LCase(Trim(Key)) <> LCase(MyArray(I)) Then
                    If Len(MyArray(I)) = 0 Then
                        'MyArray(I) = Key
                        GoTo FoundEndAtI
                    Else
                        For I = 0 To UBound(MyArray)
                            If MyArray(I) = Key Then
                                MSG_ABug(1030, MyTable & " is not added twice", Key, MyArray(I))
                                If MyOptionTest(25) = True Then
                                    Return 'found where the binary search failed
                                Else
                                    Key &= "_Duplicate_" & MyRnd()
                                End If
                            End If
                        Next I
                        I = UBound(MyArray)
                        If MyDebug(8) Then FMB1(8064)
                        GoTo FoundEndAtI ' Never add a duplicate key
                    End If
                Else
                End If
            End If


            I = MyMinMax(UBound(MyArray), 1, UBound(MyArray)) ' Find the top MAKE sure it's not less than one.
            While MyArray(I) = Nothing ' Find the top of the data
                I -= 1
                If I < 2 Then
                    I = 1 'in case it comes back as zero
                    Exit While
                End If
            End While

            If MyIsNothing(MyArray(I)) Then ' Incase we are the first one
                If I = 1 Then
                    I = 1
                Else
                    I += 1
                End If
            Else
                While (I < UBound(MyArray)) And (Not MyIsNothing(MyArray(I)))
                    If I = UBound(MyArray) Then
                        ReDim Preserve MyArray(I + 1)
                    End If
                    I += 1
                End While
            End If

FoundEndAtI:
            If MyDebug(8) Then FMB(1114, Key)
            If MyDebug(8) Then FMB1(8065)
            FMB(MyArray, Key) 'should not already be here
            MyArray(I) = Key ' We should be at an empty one
            ReSortLanguagekeyWord(MyTable, MyArray, I)
            ShowSorts(MyTable, ReSortLanguagekeyWord(MyTable, MyArray, I))
            FindingMyBugsSorted()
            If I = UBound(MyArray) Then
                ReDim Preserve MyArray(UBound(MyArray) + 1)
                'SortAllList()
            End If
            'todo removed 2023/06/24 MyDoEvents(130)

            Select Case LCase(ThisTable)
                Case MyUniverse.SysGen.Constants.SyntaxFunctions
                    ReSortLanguagekeyWord("LanguageFunction", Language_Function, I)

                    FileInputOutputWindow.ProgressBarFunctions.Width = UBound(Language_Function)
                    'ReSetPB(FileInputOutputWindow.ProgressBarFunctions, UBound(Language_Function))
                    PerCentageFull = CInt(100.0 * I / (100 + UBound(Language_Function)))
                    FileInputOutputWindow.ProgressBarFunctions.Value = PerCentageFull
                    FileInputOutputWindow.LabelFunctions.Text = "Function:" & I & " / " & UBound(Language_Function)
                Case MyUniverse.SysGen.Constants.SyntaxOperators
                    ReSortLanguagekeyWord("LanguageOperator", Language_Operator, I)
                    FileInputOutputWindow.ProgressBarOperators.Width = UBound(Language_Operator)
                    PerCentageFull = CInt(100.0 * I / (100 + UBound(Language_Operator)))
                    FileInputOutputWindow.ProgressBarOperators.Value = PerCentageFull
                    FileInputOutputWindow.LabelOperators.Text = "Operator:" & I & " / " & UBound(Language_Operator)
                Case MyUniverse.SysGen.Constants.SyntaxKeyWords
                    If MyDebug(8) Then FMB1(8066)
                    ReSortLanguagekeyWord("LanguagekeyWord", Language_KeyWord, I)
                    FindingMyBugsSorted()
                    FileInputOutputWindow.ProgressBarKeyWords.Width = UBound(Language_KeyWord)
                    PerCentageFull = CInt(100.0 * I / (100 + UBound(Language_KeyWord)))
                    FileInputOutputWindow.ProgressBarKeyWords.Value = PerCentageFull
                    FileInputOutputWindow.LabelKeyWords.Text = "KeyWord:" & I & " / " & UBound(Language_KeyWord)
                Case MyUniverse.SysGen.Constants.SyntaxGrammar, "Grammar"
                    ReSortLanguagekeyWord("LanguageGrammar", Language_Grammar, I)
                    FileInputOutputWindow.ProgressBarGrammar.Width = UBound(Language_Grammar)
                    PerCentageFull = CInt(100.0 * I / (100 + UBound(Language_Grammar)))
                    FileInputOutputWindow.ProgressBarGrammar.Value = PerCentageFull
                    FileInputOutputWindow.LabelGrammar.Text = "Grammar:" & I & " / " & UBound(Language_Grammar)
                    FileInputOutputWindow.ProgressBarGrammar.Width = UBound(Language_Grammar)
                Case Else
                    MSG_ABug(2331, "Program bug - Unknown table ", MyTable, "")
            End Select
        End Sub


        Public Shared Function MyRnd() As String
            MyRnd = (Int(Rnd() * 100000) + 100000).ToString
        End Function


        Public Shared Sub MakeListOfLanguagesClassesFromFiles(RootLanguageFile As String) ' removed , MyRootDir As String)
            Dim AllLanguagesClass(), X As String
            Dim MyMenuItemToAdd() As String
            Dim Kounter As Int32

            ReDim AllLanguagesClass(0)
            ReDim MyMenuItemToAdd(0)
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2935, 10, "MakeListOfLanguageClassesFromFiles")
#End If
            AllLanguagesClass(0) = Nothing
            Kounter = 0
            X = Dir(RootLanguageFile & "\*.", vbDirectory)
            While X <> ""
                Kounter += 1
                ReDim Preserve AllLanguagesClass(Kounter) ' save all of the directory
                AllLanguagesClass(Kounter) = RootLanguageFile & "\" & X
                X = Dir()
            End While
            MyMenuItemToAdd(0) = FileNameOnly(RootLanguageFile)
            MakeLanguageClassDropDown(AllLanguagesClass)
        End Sub





        Public Shared Sub MakeDialectListFromFile(DialectFileName As String)

            Dim X As String
            Dim MyMenuItemToAdd(0) As String
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2936, 10, "")
#End If
            MyMenuItemToAdd(0) = Nothing
            X = Dir(Application.StartupPath.ToString() & "\" & DialectFileName & "\*Definition.Symbol")
            While X <> ""
                If InStr(LCase(X), "Definition.Symbol") <> 0 Then
                    X = Trim(Replace(X, "Definition.Symbol", ""))
                    If X <> ".." And X <> "." Then
                        'MSG_AInfo(1034, "Computer Language file", RootLanguageFile, X)
                        ReDim Preserve MyMenuItemToAdd(UBound(MyMenuItemToAdd) + 1)
                        MyMenuItemToAdd(UBound(MyMenuItemToAdd)) = Trim(X)
                    End If
                End If
                X = Dir()
            End While
            MakeDialectDropDown(MyMenuItemToAdd)
        End Sub

        Public Shared Sub MakeLanguageClassDropDown(MyMenuItemStringArray() As String)
            Dim I As Int32
            Dim X As String
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2937, 10, "MakeLanguageClassDropDown")
#End If
            X = MyMenuItemStringArray(0)
            If UBound(MyMenuItemStringArray) < 1 Then
                Return ' must be in a sub directory
            End If
            ' First add the class if not already there.
            For I = 0 To OptionsWindow.ListBoxLanguage.Items.Count - 1
                If OptionsWindow.ListBoxLanguage.Items.Item(I).ToString = MyMenuItemStringArray(0) Then
                    X = Nothing
                End If
            Next
            If X <> Nothing Then
                OptionsWindow.ListBoxLanguage.Items.Add(X)
            End If
            For I = 1 To UBound(MyMenuItemStringArray)
                If Len(FileNameOnly(MyMenuItemStringArray(I))) > 0 Then
                    OptionsWindow.ListBoxLanguage.Items.Add(FileNameOnly(MyMenuItemStringArray(I)))
                End If
            Next I
        End Sub


        Public Shared Function FileNameOnly(P As String) As String
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2938, 10, "FileNameOnly")
#End If
            FileNameOnly = P
            While InStr(FileNameOnly, "\") <> 0
                FileNameOnly = Mid(FileNameOnly, InStr(FileNameOnly, "\") + 1, Len(FileNameOnly))
            End While
        End Function



        Public Shared Sub MakeDialectDropDown(MyMenuItemStringArray() As String)
            Dim I As Int32
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2939, 10, "MakeDialectDropDown")
#End If
            OptionsWindow.ListBoxDialect.Items.Clear()
            For I = 1 To UBound(MyMenuItemStringArray)
                OptionsWindow.ListBoxDialect.Items.Add(Trim(MyMenuItemStringArray(I)))
            Next I
            DoEvents(120)
        End Sub

        Public Shared Sub SetDisplayOptions(I As Int32, Message As String, X As CheckState)
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2943, 10, "SetDisplayOptions")
#End If
            OptionsWindow.CheckedListBoxOptionSelection.Items(I) = Message
            OptionsWindow.CheckedListBoxOptionSelection.SetItemCheckState(I, X)
        End Sub


        Public Shared Function ProgramBuzzy(A As String) As Boolean
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2944, 10, "ProgramBuzzy")
#End If
            If MyUniverse.MyProgramStatus = A Then Return True
            If A = "" And MyUniverse.MyProgramStatus = "" Then Return True
            If MyUniverse.MyProgramStatus = "" Then Return True
            If A = "Painting" And MyUniverse.MyProgramStatus = "Begin" Then Return True
            If A = "Begin" And MyUniverse.MyProgramStatus = "Alive" Then Return False
            If A = "Alive" And MyUniverse.MyProgramStatus = "Painting" Then Return True
            If A = "Alive" And MyUniverse.MyProgramStatus = "Begin" Then Return False
            If A = "Painting" And MyUniverse.MyProgramStatus = "Alive" Then Return False
            Return False
        End Function



        'Routine  Sets up (and resets) the original values for all parameters (for new, open, and next level file)
        Public Shared Sub Init() ' Load all Starting list, ComboBox(s) and other Information(s)
            Dim D As SByte
            Dim I As Int32
            Dim II, LocalIndex As Int32
            Dim TempCode As String
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2945, 10, "Init()")
#End If
            ReDim MyUniverse.MySystem.WindowsStatus(4)
            MyUniverse.MySystem.WindowsStatus(1) = "?"
            MyUniverse.MySystem.WindowsStatus(2) = "?"
            MyUniverse.MySystem.WindowsStatus(3) = "?"
            MyUniverse.MySystem.WindowsStatus(4) = "?"
            MyUniverse.SysGen.FindingMyBugsFlag = False
            MyUniverse.FCCLDebugLevel = DefaultDebugLevel
            ReDim MyUniverse.DebugCount(100)
            MyUniverse.MySystem.Dumps.OutputFileName1 = FileIO.FileSystem.CurrentDirectory & "\Dump1.txt"
            MyUniverse.MySystem.Dumps.OutputFileName2 = FileIO.FileSystem.CurrentDirectory & "\Dump2.txt"
            MyUniverse.MySystem.Dumps.OutputFileName3 = FileIO.FileSystem.CurrentDirectory & "\Dump3.txt"

            MyDeCompileLine(CommandLineIs())
            FlowChartWindow.ToolStripTextBoxMyInputText.Text = "Start"

            ReDim MyUniverse.MyStaticData.MyEnum.LastResults(20)
            ReDim MyUniverse.MyStaticData.MyUnEnum.LastResults(20)


            TempCode = MyUniverse.MySystem.Dumps.OutputFileName1
            If Dir(TempCode) <> "" Then Kill(TempCode)
            TempCode = MyUniverse.MySystem.Dumps.OutputFileName2
            If Dir(TempCode) <> "" Then Kill(TempCode)
            TempCode = MyUniverse.MySystem.Dumps.OutputFileName3
            If Dir(TempCode) <> "" Then Kill(TempCode)



            MyUniverse.Security = SetSecurityOption()
            If Security_Option(SecurityFlowChart) = 0 Then
                MyBeep()
                MsgBox("Invalid key " & MyUniverse.Security & " " & MyUniverse.MySS.Temps.TempInt32)
                Application.ExitThread()
            End If

            TempCode = CPUID1.CPU_ID()
            SplashWindow.Show()


            'todo SplashWindow.LabelExpireDate.Text = "test expires in " & DateDiff(MicroSoft.VisualBasic.DateInterval.Day, Today(), CDate("12/31/2023")) & " days..."
            SplashWindow.Text = "test expires in " & DateDiff(Microsoft.VisualBasic.DateInterval.Day, Today(), CDate("12/31/2023")) & " days..."
            'todo DisplayMyStatus(3,SplashWindow.LabelExpireDate.Text)
            DisplayMyStatus(10, SplashWindow.Text)
            DoThisEvent(2899)
            MyUniverse.MySS.Inputs.LineNumberIn = 1 ' The number of lines input (starts at one, and goes up every time another line is entered (from files, or textbox)
            ReDim MyUniverse.MySystem.FlowChartOptions(10)



            SetDefaults()


            MyUniverse.SysGen.Constants.ConstantSymbolCenter = 250  'this defines the max distance from 0,0 of the Symbol (-250 to 250) byt the Symbol is actually 0-500
            MyUniverse.SysGen.Constants.ConstantSpacingFactor = 240 '20 ' number of Symbols down before going over another row

            MyUniverse.SysGen.Constants.ConstantMinPenSize = 9
            MyUniverse.SysGen.Constants.ConstantMaxPenSize = 25

            MyUniverse.SysGen.Constants.ConstantMinBoxSize = 100
            MyUniverse.SysGen.Constants.ConstantFirstLineTextOffset = 50
            MyUniverse.SysGen.Constants.ConstantSecondLineTextOffset = 100
            MyUniverse.SysGen.Constants.ConstantDistanceBetweenControls = 5
            MyUniverse.SysGen.Constants.ConstantRecordsBeforeSaveIsAllowed = 0
            MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths = 101
            MyUniverse.SysGen.Constants.ConstantSpecialCharacters = "`~!@#$%^&*()_-+={[}]|\:;, '<,>.?/" & Chr(34)
            MyUniverse.SysGen.Constants.ConstantWhiteSpaces = MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCr & vbLf & Strings.Chr(9) & vbVerticalTab & vbFormFeed & vbCrLf
            MyUniverse.SysGen.Constants.ConstantDelimiters = MyUniverse.SysGen.Constants.ConstantWhiteSpaces & "=" & COMMA ' White Space



            'Load the options here
            For I = 1 To NUMBEROPTIONS
                OptionsWindow.CheckedListBoxOptionSelection.Items.Add(Str(I), CheckState.Unchecked)
            Next

            I = 0 : SetDisplayOptions(I, "  Check List", CheckState.Unchecked)
            I = 1 : SetDisplayOptions(I, I.ToString & "  Display Path Name", CheckState.Checked)
            I = 2 : SetDisplayOptions(I, I.ToString & "  Display Symbol Name", CheckState.Checked)
            I = 3 : SetDisplayOptions(I, I.ToString & "  Display ID Stroke", CheckState.Unchecked)
            I = 4 : SetDisplayOptions(I, I.ToString & "  Display File Name", CheckState.Unchecked)
            I = 5 : SetDisplayOptions(I, I.ToString & "  Display Notes", CheckState.Unchecked)
            I = 6 : SetDisplayOptions(I, I.ToString & "  Display OpCode", CheckState.Unchecked)
            I = 7 : SetDisplayOptions(I, I.ToString & "  Display Code", CheckState.Unchecked)
            I = 8 : SetDisplayOptions(I, I.ToString & "  Display Index Short Cut Pointer", CheckState.Unchecked)
            I = 9 : SetDisplayOptions(I, I.ToString & "  Display ErrorText", CheckState.Unchecked)
            I = 10 : SetDisplayOptions(I, I.ToString & " Display InputOutPut", CheckState.Unchecked)
            I = 11 : SetDisplayOptions(I, I.ToString & " Display Errors", CheckState.Unchecked)
            I = 12 : SetDisplayOptions(I, I.ToString & " Display PathNames", CheckState.Unchecked)
            I = 13 : SetDisplayOptions(I, I.ToString & " Display Constants", CheckState.Unchecked)
            I = 14 : SetDisplayOptions(I, I.ToString & " Make Paths Orthogonal", CheckState.Checked)
            I = 15 : SetDisplayOptions(I, I.ToString & " Move Symbols from on top of each other", CheckState.Checked)
            I = 16 : SetDisplayOptions(I, I.ToString & " Output Line Numbers", CheckState.Unchecked)
            I = 17 : SetDisplayOptions(I, I.ToString & " Display Data Value on Paths", CheckState.Unchecked)
            I = 18 : SetDisplayOptions(I, I.ToString & " Disable ClipBoard Processor", CheckState.Checked)
            I = 19 : SetDisplayOptions(I, I.ToString & " Auto Route", CheckState.Checked)
            I = 20 : SetDisplayOptions(I, I.ToString & " Display Point data type", CheckState.Unchecked)
            I = 21 : SetDisplayOptions(I, I.ToString & " Display Symbol Name", CheckState.Unchecked)
            I = 22 : SetDisplayOptions(I, I.ToString & " Expanded Export", CheckState.Checked)
            I = 23 : SetDisplayOptions(I, I.ToString & " Use hand to scroll", CheckState.Checked)
            I = 24 : SetDisplayOptions(I, I.ToString & " Number Points", CheckState.Unchecked)
            I = 25 : SetDisplayOptions(I, I.ToString & " Auto Correct Problems", CheckState.Checked)
            'todo need to turn these off before release version (For debugging only
            I = 26 : SetDisplayOptions(I, I.ToString & " Stop Display debug ", CheckState.Unchecked)
            I = 27 : SetDisplayOptions(I, I.ToString & " Dump Status", CheckState.Checked)
            I = 28 : SetDisplayOptions(I, I.ToString & " Dump Messages", CheckState.Checked)
            I = 29 : SetDisplayOptions(I, I.ToString & " Dump errors", CheckState.Checked)
            I = 30 : SetDisplayOptions(I, I.ToString & " Dump Bugs", CheckState.Checked)
            I = 31 : SetDisplayOptions(I, I.ToString & " internal Testing", CheckState.Unchecked)

            I = 32 : SetDisplayOptions(I, I.ToString & " Display Order Index ", CheckState.Checked)
            I = 33 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 34 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 35 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 36 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 37 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 38 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 39 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 40 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 41 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 42 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 43 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 44 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 45 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 46 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 47 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 48 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 49 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 50 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 51 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 52 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 53 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 54 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 55 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 56 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 57 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 58 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 59 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 60 : SetDisplayOptions(I, I.ToString & " ", CheckState.Checked)
            I = 61 : SetDisplayOptions(I, I.ToString & "Ignore Grammar Checking ", CheckState.Checked)
            I = 62 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)
            I = 63 : SetDisplayOptions(I, I.ToString & " ", CheckState.Unchecked)

            MyUniverse.SysGen.NumberOfButtonsActive = 1 'Init causes it to reset
            'todo check if this can be removed            MyUniverse.SysGen.Constants.getmypen = Pens.Black
            'Make sure all of te forms are loaded.
            'flow10' Can I not do this yet?    ShowAllForms(ShowWindow, ShowWindow, ShowWindow, ShowWindow, ShowWindow, ShowWindow)
            'flow10' can I not do this yet?    ShowAllForms(HideWindow, HideWindow, HideWindow, ShowWindow, HideWindow, HideWindow)
            ' Need to remove the second parameter and replace it with the actual location when it is found(Looked for)
            OptionsWindow.ListBoxLanguage.Items.Clear()
            OptionsWindow.ListBoxDialect.Items.Clear()
            MakeListOfLanguagesClassesFromFiles(My.Application.Info.DirectoryPath & "\Languages")
            ', My.Application.Info.DirectoryPath & "\Languages")

            FindingMyBugs(4)

            DoEvents(121001)
            MyUniverse.SysGen.Constants.DrillDown_FileName = "*"
            '
            My_keyWord(My_KeyConstUnknown) = "/unknown"
            My_keyWord(My_KeyConstName) = "/name"   'Symbol
            My_keyWord(My_KeyConstPoint) = "/point"  'Symbol
            My_keyWord(My_KeyConstLine) = "/line"   'Symbol
            My_keyWord(My_KeyConstUse) = "/use"    'FlowChart
            My_keyWord(My_KeyConstPath) = "/path"   'FlowChart
            My_keyWord(My_KeyConstDataType) = "/DataType"   '
            My_keyWord(My_KeyConstFileName) = "/filename"   'Symbol
            My_keyWord(My_KeyConstVersion) = "/version"    'Symbol
            My_keyWord(My_KeyConstAuthor) = "/author" 'Symbol
            My_keyWord(My_KeyConstLanguage) = "/language"   '
            My_keyWord(My_KeyConstStroke) = "/stroke"    'Symbol
            My_keyWord(My_KeyConstError) = "/error"  'FlowChart
            My_keyWord(My_KeyConstDelete) = "/delete" 'FlowChart
            My_keyWord(My_KeyConstConstant) = "/Constant" 'FlowChart
            My_keyWord(My_KeyConstX1) = "/x1" 'not required
            My_keyWord(My_KeyConstY1) = "/y1" 'not required
            My_keyWord(My_KeyConstX2) = "/x2" 'not required
            My_keyWord(My_KeyConstY2) = "/y2" 'not required
            My_keyWord(My_KeyConstColor) = "/color" '
            My_keyWord(My_KeyConstNotes) = "/notes" 'Symbol
            My_keyWord(My_KeyConstOpcode) = "/opcode" 'Symbol
            My_keyWord(My_KeyConstSyntax) = "/syntax"
            My_keyWord(My_KeyConstOption) = "/option"
            My_keyWord(My_KeyConstLanguageKeyWord) = "/keyword"
            My_keyWord(My_KeyConstMicroCodeText) = "/MicroCodeText" 'Symbol
            'My_keyWord(My_KeyConstUnused29) = "/unknown_29" 'Future
            'My_keyWord(My_KeyConstUnused30) = "/unknown_30" 'Future
            'My_keyWord(My_KeyConstUnused31) = "/unknown_31" 'Future
            'My_keyWord(My_KeyConstUnused32) = "/unknown_32" 'Future

            FindingMyBugs(5)

            DoOption(51, "on", "")

            MyUniverse.MyCheatSheet.ColorsSorted = 0 ' Flagged as nothing to sort.
            MyUniverse.MyCheatSheet.DataTypeSorted = 0
            MyUniverse.MyCheatSheet.NamedSorted = 0
            MyUniverse.MyCheatSheet.FlowChartSorted = 0

            MyAddErrorMessages()

            'MyTrace1("Starting to fill the dropdowns " )
            SymbolWindow.ToolStripDropDownInputOutput.DropDownItems.Add("IO, 255")      'everything
            SymbolWindow.ToolStripDropDownInputOutput.DropDownItems.Add("Both, 3")      'bit one, two
            SymbolWindow.ToolStripDropDownInputOutput.DropDownItems.Add("Input, 1")     'bit one
            SymbolWindow.ToolStripDropDownInputOutput.DropDownItems.Add("All, 0")
            SymbolWindow.ToolStripDropDownInputOutput.DropDownItems.Add("OptionalBoth, 7")  'bit 1,2,3
            SymbolWindow.ToolStripDropDownInputOutput.DropDownItems.Add("OptionalInput, 5") 'bit 1,3
            SymbolWindow.ToolStripDropDownInputOutput.DropDownItems.Add("OptionalOutput, 6")    'bit 1,2
            SymbolWindow.ToolStripDropDownInputOutput.DropDownItems.Add("Output, 2")    'bit 2

            'SupportTables (Unchangeable)
            SymbolWindow.ToolStripDropDownPathLineStyle.DropDownItems.Clear()
            SymbolWindow.ToolStripDropDownPathLineStyle.DropDownItems.Add("Dash, 1")
            SymbolWindow.ToolStripDropDownPathLineStyle.DropDownItems.Add("DashDot, 3")
            SymbolWindow.ToolStripDropDownPathLineStyle.DropDownItems.Add("DashDotDot, 4")
            SymbolWindow.ToolStripDropDownPathLineStyle.DropDownItems.Add("Dot, 2")
            SymbolWindow.ToolStripDropDownPathLineStyle.DropDownItems.Add("Solid, 0")

            SymbolWindow.ToolStripDropDownPathStart.DropDownItems.Clear()
            SymbolWindow.ToolStripDropDownPathStart.DropDownItems.Add("AnchorMask, 240")
            SymbolWindow.ToolStripDropDownPathStart.DropDownItems.Add("ArrowAnchor, 20")
            SymbolWindow.ToolStripDropDownPathStart.DropDownItems.Add("DiamondAnchor, 19")
            SymbolWindow.ToolStripDropDownPathStart.DropDownItems.Add("Flat, 0")
            SymbolWindow.ToolStripDropDownPathStart.DropDownItems.Add("NoAnchor, 16")
            SymbolWindow.ToolStripDropDownPathStart.DropDownItems.Add("Round, 2")
            SymbolWindow.ToolStripDropDownPathStart.DropDownItems.Add("RoundAnchor, 18")
            SymbolWindow.ToolStripDropDownPathStart.DropDownItems.Add("Square, 1")
            SymbolWindow.ToolStripDropDownPathStart.DropDownItems.Add("SquareAnchor, 17")
            SymbolWindow.ToolStripDropDownPathStart.DropDownItems.Add("Triangle, 3")

            SymbolWindow.ToolStripDropDownPathEnd.DropDownItems.Clear()
            SymbolWindow.ToolStripDropDownPathEnd.DropDownItems.Add("AnchorMask, 240")
            SymbolWindow.ToolStripDropDownPathEnd.DropDownItems.Add("ArrowAnchor, 20")
            SymbolWindow.ToolStripDropDownPathEnd.DropDownItems.Add("DiamondAnchor, 19")
            SymbolWindow.ToolStripDropDownPathEnd.DropDownItems.Add("Flat, 0")
            SymbolWindow.ToolStripDropDownPathEnd.DropDownItems.Add("NoAnchor, 16")
            SymbolWindow.ToolStripDropDownPathEnd.DropDownItems.Add("Round, 2")
            SymbolWindow.ToolStripDropDownPathEnd.DropDownItems.Add("RoundAnchor, 18")
            SymbolWindow.ToolStripDropDownPathEnd.DropDownItems.Add("Square, 1")
            SymbolWindow.ToolStripDropDownPathEnd.DropDownItems.Add("SquareAnchor, 17")
            SymbolWindow.ToolStripDropDownPathEnd.DropDownItems.Add("Triangle, 3")


            'todo make this into an internal list, and then only select and display the rotation names
            SymbolWindow.ToolStripDropDownRotation.DropDownItems.Clear()
            SymbolWindow.ToolStripDropDownRotation.DropDownItems.Add("Default") : SaveRotation(0, "1 , 0 , 0 , 1, ^.Flips to  ^.Stays the same ")
            SymbolWindow.ToolStripDropDownRotation.DropDownItems.Add("Flip") : SaveRotation(1, "-1, 0, 0, 1, ^ .Flips To  v.sideways flip ")
            SymbolWindow.ToolStripDropDownRotation.DropDownItems.Add("Flop") : SaveRotation(2, "1, 0, 0, -1, ^ .Flips To  v.top side flips down ")
            SymbolWindow.ToolStripDropDownRotation.DropDownItems.Add("Rotate90") : SaveRotation(3, "0, 1, -1, 0, ^ .Flips To  > rotate 90 degrees period On bottom")
            SymbolWindow.ToolStripDropDownRotation.DropDownItems.Add("Rotate180") : SaveRotation(4, "-1, 0, 0, -1, ^ .Flips To  .v rotate 180")
            SymbolWindow.ToolStripDropDownRotation.DropDownItems.Add("Rotate270") : SaveRotation(5, "0, -1, 1, 0, ^ .Flips To  <rotate 270 ")
            SymbolWindow.ToolStripDropDownRotation.DropDownItems.Add(" FlipRotate90") : SaveRotation(6, "0, -1, 1, 0, ^ .Flips To  > period On top flip Then rotate 90 ")
            SymbolWindow.ToolStripDropDownRotation.DropDownItems.Add("FlipRotate180") : SaveRotation(7, "1, 0, 0, -1, ^ .Flips To  v.flip Then rotate 180 (mirror image Of) ")
            SymbolWindow.ToolStripDropDownRotation.DropDownItems.Add("FlipRotate270") : SaveRotation(8, "0 , -1 , -1 , 0, ^.Flips To  <Period On bottom ")
            SymbolWindow.ToolStripDropDownRotation.DropDownItems.Add("FlopRotate90") : SaveRotation(9, "0 , -1 , -1 , 0, ^.Flips To  > period On bottom Same As ")
            SymbolWindow.ToolStripDropDownRotation.DropDownItems.Add("FlopRotate180") : SaveRotation(10, "-1 , 0 , 0 , 1, ^.Flips To  .^ same As flip rotate180 ")
            SymbolWindow.ToolStripDropDownRotation.DropDownItems.Add("FlopRotate270") : SaveRotation(11, "0 , 1 , 1 , 0, ^.Flips To  ^.period On top")
            SymbolWindow.ToolStripDropDownRotation.DropDownItems.Add("FlipFlop") : SaveRotation(12, "0 , -1 , -1 , 0, ^.Flips To  ^.same As rotate180 ")

            FindingMyBugs(6)


            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Clear()
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("0")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("1")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("2")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("4")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("8")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("16")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("32")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("64")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("128")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("256")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("512")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("1024")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("2048")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("4096")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("8192")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("16384")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("32768")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("65536")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("131072")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("262144")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("524288")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("1048576")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("2097152")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("4194304")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("8388608")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("16777216")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("33554432")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("67108864")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("134217728")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("268435456")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("536870912")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("1073741824")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("2147483648")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("4294967296")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("8589934592")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("17179869184")
            SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Add("34359738378")




            SymbolWindow.ToolStripDropDownLineWidth.DropDownItems.Clear()
            For II = 0 To 50
                SymbolWindow.ToolStripDropDownLineWidth.DropDownItems.Add(Str(II))
            Next II

            FindingMyBugs(7)

            ' original changed for testing.
            D = 0 : MyDirections(D, 1, 1) = -10 : MyDirections(D, 1, 2) = -10 : MyDirections(D, 2, 1) = 10 : MyDirections(D, 2, 2) = 10 'No Direction
            D = 1 : MyDirections(D, 1, 1) = 10 : MyDirections(D, 1, 2) = -10 : MyDirections(D, 2, 1) = -10 : MyDirections(D, 2, 2) = -10 '-10  '
            D = 2 : MyDirections(D, 1, 1) = 10 : MyDirections(D, 1, 2) = -10 : MyDirections(D, 2, 1) = -10 : MyDirections(D, 2, 2) = -10  'NorthEast

            D = 3 : MyDirections(D, 1, 1) = 10 : MyDirections(D, 1, 2) = 10 : MyDirections(D, 2, 1) = 10 : MyDirections(D, 2, 2) = -10 '
            D = 4 : MyDirections(D, 1, 1) = 10 : MyDirections(D, 1, 2) = 10 : MyDirections(D, 2, 1) = 10 : MyDirections(D, 2, 2) = -10 'Right
            D = 5 : MyDirections(D, 1, 1) = 10 : MyDirections(D, 1, 2) = 10 : MyDirections(D, 2, 1) = 10 : MyDirections(D, 2, 2) = -10 '

            D = 6 : MyDirections(D, 1, 1) = 10 : MyDirections(D, 1, 2) = 10 : MyDirections(D, 2, 1) = -10 : MyDirections(D, 2, 2) = 10  '
            D = 7 : MyDirections(D, 1, 1) = 10 : MyDirections(D, 1, 2) = 10 : MyDirections(D, 2, 1) = -10 : MyDirections(D, 2, 2) = 10  '
            D = 8 : MyDirections(D, 1, 1) = 10 : MyDirections(D, 1, 2) = 10 : MyDirections(D, 2, 1) = -10 : MyDirections(D, 2, 2) = 10  'Bottom
            D = 9 : MyDirections(D, 1, 1) = 10 : MyDirections(D, 1, 2) = 10 : MyDirections(D, 2, 1) = -10 : MyDirections(D, 2, 2) = 10  '
            D = 10 : MyDirections(D, 1, 1) = 10 : MyDirections(D, 1, 2) = 10 : MyDirections(D, 2, 1) = -10 : MyDirections(D, 2, 2) = 10  '

            D = 11 : MyDirections(D, 1, 1) = -10 : MyDirections(D, 1, 2) = 10 : MyDirections(D, 2, 1) = -10 : MyDirections(D, 2, 2) = -10  '
            D = 12 : MyDirections(D, 1, 1) = -10 : MyDirections(D, 1, 2) = 10 : MyDirections(D, 2, 1) = -10 : MyDirections(D, 2, 2) = -10  'Left
            D = 13 : MyDirections(D, 1, 1) = -10 : MyDirections(D, 1, 2) = 10 : MyDirections(D, 2, 1) = -10 : MyDirections(D, 2, 2) = -10  '

            D = 14 : MyDirections(D, 1, 1) = 10 : MyDirections(D, 1, 2) = -10 : MyDirections(D, 2, 1) = -10 : MyDirections(D, 2, 2) = -10  '
            D = 15 : MyDirections(D, 1, 1) = 10 : MyDirections(D, 1, 2) = -10 : MyDirections(D, 2, 1) = -10 : MyDirections(D, 2, 2) = -10  '
            D = 16 : MyDirections(D, 1, 1) = 10 : MyDirections(D, 1, 2) = -10 : MyDirections(D, 2, 1) = -10 : MyDirections(D, 2, 2) = -10  'Top


            'MyUniverse.SysGen.MySnap = 50 'It's fixed for now, but should be an option
            MyUniverse.SysGen.Snaps.MySnap = 1 ' lines on the Symbol
            MyUniverse.SysGen.Snaps.MyPointSnap = 50 'paths And points
            MyUniverse.SysGen.Snaps.MySymbolSnap = 2000 'Symbol placement On the FlowChart
            'MyUniverse.SysGen.Snaps.SymbolGridPlacementPlacement = 4 'should be between 2 and 16 ?? (not checked)
            MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis = True

            FindingMyBugs(8)

            ' almost a Constant
            MyUniverse.MyStaticData.ZeroZero.x = 0
            MyUniverse.MyStaticData.ZeroZero.y = 0
            SetNameOfPoint(MyUniverse.MyStaticData.ZeroZero, "", "", "")
            MyUniverse.MyStaticData.ZeroZeroZeroZero = MyLine1(MyUniverse.MyStaticData.ZeroZero, MyUniverse.MyStaticData.ZeroZero)

            MyUniverse.SysGen.HighestSymbolNumber = 100
            'Popvalue(Mid(TimeString, 7, 2) & Mid(TimeString, 4, 2) & Mid(TimeString, 1, 2))

            MyUniverse.SysGen.MinBox = MyUniverse.SysGen.Constants.ConstantMinBoxSize
            MyUniverse.SysGen.MyFlowChartScale = 0.125 '(ConstantMaxFlowChartScale) '1=1,1/2=.5,1/4=.25,1/8=.125,1/16=.0625    1/32=.03125,1/64=.015625,1/126=.0078125
            '0.1186523
            'todo make this so that it will also be able to scroll on the Symbol Window, other wise it has to stay at one.
            '  Or limited to a scale that is smaller than the size of the Window (height when maximized)
            MyUniverse.SysGen.MySymbolScale = 1.0 'fixed and never changes?
            LimitScale()
            MyUniverse.SysGen.Size.x = 1000
            MyUniverse.SysGen.Size.y = 1000
            SetNameOfPoint(MyUniverse.SysGen.Size, "", "", "")

            SymbolWindow.ToolStripDropDownButtonColor.DropDownItems.Clear()
            ' Known Colors right now.(Can/Should be added to with Alpha/Red/Green/Blue (Later))
            ImportColors(“AliceBlue" & COMMA & "255" & COMMA & "240" & COMMA & "248" & COMMA & "255" & COMMA & "DashDotDot" & COMMA & "Triangle" & COMMA & "RoundAnchor“)
            ImportColors(“AntiqueWhite" & COMMA & "255" & COMMA & "250" & COMMA & "235" & COMMA & "215" & COMMA & "DashDot" & COMMA & "RoundAnchor" & COMMA & "ArrowAnchor“)
            ImportColors(“aqua" & COMMA & "255" & COMMA & "1" & COMMA & "255" & COMMA & "255" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“aquamarine" & COMMA & "255" & COMMA & "127" & COMMA & "255" & COMMA & "212" & COMMA & "DashDotDot" & COMMA & "Round" & COMMA & "NoAnchor“)
            ImportColors(“Azure" & COMMA & "255" & COMMA & "240" & COMMA & "255" & COMMA & "255" & COMMA & "DashDot" & COMMA & "flat" & COMMA & "NoAnchor“)
            ImportColors(“beige" & COMMA & "255" & COMMA & "245" & COMMA & "245" & COMMA & "220" & COMMA & "Dot" & COMMA & "flat" & COMMA & "Square“)
            ImportColors(“bisque" & COMMA & "255" & COMMA & "255" & COMMA & "228" & COMMA & "196" & COMMA & "DashDotDot" & COMMA & "DiamondAnchor" & COMMA & "SquareAnchor“)
            ImportColors(“Black" & COMMA & "255" & COMMA & "1" & COMMA & "1" & COMMA & "1" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“BlanchedAlmond" & COMMA & "255" & COMMA & "255" & COMMA & "235" & COMMA & "205" & COMMA & "Dash" & COMMA & "DiamondAnchor" & COMMA & "Triangle“)
            ImportColors(“Blue" & COMMA & "255" & COMMA & "1" & COMMA & "1" & COMMA & "255" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“BlueViolet" & COMMA & "255" & COMMA & "138" & COMMA & "43" & COMMA & "226" & COMMA & "DashDotDot" & COMMA & "Triangle" & COMMA & "SquareAnchor“)
            ImportColors(“Brown" & COMMA & "255" & COMMA & "165" & COMMA & "42" & COMMA & "42" & COMMA & "Dash" & COMMA & "NoAnchor" & COMMA & "flat“)
            ImportColors(“BurlyWood" & COMMA & "255" & COMMA & "222" & COMMA & "184" & COMMA & "135" & COMMA & "DashDotDot" & COMMA & "NoAnchor" & COMMA & "NoAnchor“)
            ImportColors(“CadetBlue" & COMMA & "255" & COMMA & "95" & COMMA & "158" & COMMA & "160" & COMMA & "DashDot" & COMMA & "NoAnchor" & COMMA & "flat“)
            ImportColors(“Chartreuse" & COMMA & "255" & COMMA & "127" & COMMA & "255" & COMMA & "1" & COMMA & "Dash" & COMMA & "DiamondAnchor" & COMMA & "Round“)
            ImportColors(“Chocolate" & COMMA & "255" & COMMA & "210" & COMMA & "105" & COMMA & "30" & COMMA & "DashDotDot" & COMMA & "NoAnchor" & COMMA & "Square“)
            ImportColors(“Coral" & COMMA & "255" & COMMA & "255" & COMMA & "127" & COMMA & "80" & COMMA & "DashDot" & COMMA & "NoAnchor" & COMMA & "flat“)
            ImportColors(“CornflowerBlue" & COMMA & "255" & COMMA & "100" & COMMA & "149" & COMMA & "237" & COMMA & "Dot" & COMMA & "RoundAnchor" & COMMA & "SquareAnchor“)
            ImportColors(“Cornsilk" & COMMA & "255" & COMMA & "255" & COMMA & "248" & COMMA & "220" & COMMA & "DashDotDot" & COMMA & "RoundAnchor" & COMMA & "NoAnchor“)
            ImportColors(“Crimson" & COMMA & "255" & COMMA & "220" & COMMA & "20" & COMMA & "60" & COMMA & "DashDot" & COMMA & "Round" & COMMA & "NoAnchor“)
            ImportColors(“Cyan" & COMMA & "255" & COMMA & "1" & COMMA & "255" & COMMA & "255" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“DarkBlue" & COMMA & "255" & COMMA & "1" & COMMA & "1" & COMMA & "139" & COMMA & "Dot" & COMMA & "flat" & COMMA & "SquareAnchor“)
            ImportColors(“DarkCyan" & COMMA & "255" & COMMA & "1" & COMMA & "139" & COMMA & "139" & COMMA & "DashDotDot" & COMMA & "Round" & COMMA & "flat“)
            ImportColors(“DarkGoldenrod" & COMMA & "255" & COMMA & "184" & COMMA & "134" & COMMA & "11" & COMMA & "DashDot" & COMMA & "Square" & COMMA & "NoAnchor“)
            ImportColors(“DarkGray" & COMMA & "255" & COMMA & "169" & COMMA & "169" & COMMA & "169" & COMMA & "Dash" & COMMA & "Square" & COMMA & "flat“)
            ImportColors(“DarkGreen" & COMMA & "255" & COMMA & "1" & COMMA & "100" & COMMA & "1" & COMMA & "Dot" & COMMA & "Triangle" & COMMA & "NoAnchor“)
            ImportColors(“DarkKhaki" & COMMA & "255" & COMMA & "189" & COMMA & "183" & COMMA & "107" & COMMA & "DashDotDot" & COMMA & "NoAnchor" & COMMA & "SquareAnchor“)
            ImportColors(“DarkMagenta" & COMMA & "255" & COMMA & "139" & COMMA & "1" & COMMA & "139" & COMMA & "DashDot" & COMMA & "RoundAnchor" & COMMA & "DiamondAnchor“)
            ImportColors(“DarkOliveGreen" & COMMA & "255" & COMMA & "85" & COMMA & "107" & COMMA & "47" & COMMA & "Dash" & COMMA & "DiamondAnchor" & COMMA & "RoundAnchor“)
            ImportColors(“DarkOrange" & COMMA & "255" & COMMA & "255" & COMMA & "140" & COMMA & "1" & COMMA & "Dot" & COMMA & "Triangle" & COMMA & "RoundAnchor“)
            ImportColors(“DarkOrchid" & COMMA & "255" & COMMA & "153" & COMMA & "50" & COMMA & "204" & COMMA & "DashDotDot" & COMMA & "NoAnchor" & COMMA & "Round“)
            ImportColors(“DarkRed" & COMMA & "255" & COMMA & "139" & COMMA & "1" & COMMA & "1" & COMMA & "DashDot" & COMMA & "DiamondAnchor" & COMMA & "Round“)
            ImportColors(“DarkSalmon" & COMMA & "255" & COMMA & "233" & COMMA & "150" & COMMA & "122" & COMMA & "Dot" & COMMA & "Square" & COMMA & "Square“)
            ImportColors(“DarkSeaGreen" & COMMA & "255" & COMMA & "143" & COMMA & "188" & COMMA & "139" & COMMA & "DashDotDot" & COMMA & "flat" & COMMA & "SquareAnchor“)
            ImportColors(“DarkSlateBlue" & COMMA & "255" & COMMA & "72" & COMMA & "61" & COMMA & "139" & COMMA & "DashDot" & COMMA & "NoAnchor" & COMMA & "DiamondAnchor“)
            ImportColors(“DarkSlateGray" & COMMA & "255" & COMMA & "47" & COMMA & "79" & COMMA & "79" & COMMA & "Dash" & COMMA & "Square" & COMMA & "Triangle“)
            ImportColors(“DarkTurquoise" & COMMA & "255" & COMMA & "1" & COMMA & "206" & COMMA & "209" & COMMA & "Dot" & COMMA & "Square" & COMMA & "Square“)
            ImportColors(“DarkViolet" & COMMA & "255" & COMMA & "148" & COMMA & "1" & COMMA & "211" & COMMA & "DashDotDot" & COMMA & "Triangle" & COMMA & "DiamondAnchor“)
            '    ImportColors(“DataTypeError" & comma & "255" & comma & "255" & comma & "1" & comma & "1" & comma & "DashDotDot" & comma & "Triangle" & comma & "DiamondAnchor“)
            ImportColors(“DeepPink" & COMMA & "255" & COMMA & "255" & COMMA & "20" & COMMA & "147" & COMMA & "DashDot" & COMMA & "Square" & COMMA & "flat“)
            ImportColors(“DeepSkyBlue" & COMMA & "255" & COMMA & "1" & COMMA & "191" & COMMA & "255" & COMMA & "Dash" & COMMA & "NoAnchor" & COMMA & "flat“)
            ImportColors(“DimGray" & COMMA & "255" & COMMA & "105" & COMMA & "105" & COMMA & "105" & COMMA & "Dot" & COMMA & "NoAnchor" & COMMA & "Square“)
            ImportColors(“DodgerBlue" & COMMA & "255" & COMMA & "30" & COMMA & "144" & COMMA & "255" & COMMA & "DashDotDot" & COMMA & "Triangle" & COMMA & "ArrowAnchor“)
            ImportColors(“Errored" & COMMA & "100" & COMMA & "255" & COMMA & "1" & COMMA & "1" & COMMA & "Dash" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“Firebrick" & COMMA & "255" & COMMA & "178" & COMMA & "34" & COMMA & "34" & COMMA & "DashDot" & COMMA & "Round" & COMMA & "Triangle“)
            ImportColors(“FloralWhite" & COMMA & "255" & COMMA & "255" & COMMA & "250" & COMMA & "240" & COMMA & "Dash" & COMMA & "Triangle" & COMMA & "flat“)
            ImportColors(“ForestGreen" & COMMA & "255" & COMMA & "34" & COMMA & "139" & COMMA & "34" & COMMA & "Dot" & COMMA & "NoAnchor" & COMMA & "Triangle“)
            ImportColors(“Fuchsia" & COMMA & "255" & COMMA & "255" & COMMA & "1" & COMMA & "255" & COMMA & "DashDotDot" & COMMA & "SquareAnchor" & COMMA & "Round“)
            ImportColors(“Gainsboro" & COMMA & "255" & COMMA & "220" & COMMA & "220" & COMMA & "220" & COMMA & "Dash" & COMMA & "Round" & COMMA & "ArrowAnchor“)
            ImportColors(“GhostWhite" & COMMA & "255" & COMMA & "248" & COMMA & "248" & COMMA & "255" & COMMA & "Dot" & COMMA & "NoAnchor" & COMMA & "SquareAnchor“)
            ImportColors(“Gold" & COMMA & "255" & COMMA & "255" & COMMA & "215" & COMMA & "1" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“Goldenrod" & COMMA & "255" & COMMA & "218" & COMMA & "165" & COMMA & "32" & COMMA & "DashDot" & COMMA & "NoAnchor" & COMMA & "SquareAnchor“)
            ImportColors(“Gray" & COMMA & "255" & COMMA & "128" & COMMA & "128" & COMMA & "128" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“Green" & COMMA & "255" & COMMA & "1" & COMMA & "128" & COMMA & "1" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“GreenYellow" & COMMA & "255" & COMMA & "173" & COMMA & "255" & COMMA & "47" & COMMA & "DashDot" & COMMA & "NoAnchor" & COMMA & "NoAnchor“)
            ImportColors(“Honeydew" & COMMA & "255" & COMMA & "240" & COMMA & "255" & COMMA & "240" & COMMA & "Dash" & COMMA & "ArrowAnchor" & COMMA & "NoAnchor“)
            ImportColors(“HotPink" & COMMA & "255" & COMMA & "255" & COMMA & "105" & COMMA & "180" & COMMA & "Dot" & COMMA & "SquareAnchor" & COMMA & "NoAnchor“)
            ImportColors(“IndianRed" & COMMA & "255" & COMMA & "205" & COMMA & "92" & COMMA & "92" & COMMA & "DashDot" & COMMA & "Triangle" & COMMA & "NoAnchor“)
            ImportColors(“Indigo" & COMMA & "255" & COMMA & "75" & COMMA & "1" & COMMA & "130" & COMMA & "Dash" & COMMA & "ArrowAnchor" & COMMA & "NoAnchor“)
            ImportColors(“Ivory" & COMMA & "255" & COMMA & "255" & COMMA & "255" & COMMA & "240" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“Khaki" & COMMA & "255" & COMMA & "240" & COMMA & "230" & COMMA & "140" & COMMA & "DashDotDot" & COMMA & "flat" & COMMA & "Round“)
            ImportColors(“Lavender" & COMMA & "255" & COMMA & "230" & COMMA & "230" & COMMA & "250" & COMMA & "DashDot" & COMMA & "RoundAnchor" & COMMA & "SquareAnchor“)
            ImportColors(“LavenderBlush" & COMMA & "255" & COMMA & "255" & COMMA & "240" & COMMA & "245" & COMMA & "Dash" & COMMA & "RoundAnchor" & COMMA & "ArrowAnchor“)
            ImportColors(“LawnGreen" & COMMA & "255" & COMMA & "124" & COMMA & "252" & COMMA & "1" & COMMA & "Dot" & COMMA & "SquareAnchor" & COMMA & "ArrowAnchor“)
            ImportColors(“LemonChiffon" & COMMA & "255" & COMMA & "255" & COMMA & "250" & COMMA & "205" & COMMA & "DashDot" & COMMA & "Triangle" & COMMA & "RoundAnchor“)
            ImportColors(“LightBlue" & COMMA & "255" & COMMA & "173" & COMMA & "216" & COMMA & "230" & COMMA & "DashDotDot" & COMMA & "NoAnchor" & COMMA & "flat“)
            ImportColors(“LightCoral" & COMMA & "255" & COMMA & "240" & COMMA & "128" & COMMA & "128" & COMMA & "DashDot" & COMMA & "flat" & COMMA & "NoAnchor“)
            ImportColors(“LightCyan" & COMMA & "255" & COMMA & "224" & COMMA & "255" & COMMA & "255" & COMMA & "Dash" & COMMA & "flat" & COMMA & "Round“)
            ImportColors(“LightGoldenrodYellow" & COMMA & "255" & COMMA & "250" & COMMA & "250" & COMMA & "210" & COMMA & "Dot" & COMMA & "Triangle" & COMMA & "Square“)
            ImportColors(“LightGray" & COMMA & "255" & COMMA & "211" & COMMA & "211" & COMMA & "211" & COMMA & "DashDotDot" & COMMA & "RoundAnchor" & COMMA & "Square“)
            ImportColors(“LightGreen" & COMMA & "255" & COMMA & "144" & COMMA & "238" & COMMA & "144" & COMMA & "DashDot" & COMMA & "Triangle" & COMMA & "Round“)
            ImportColors(“LightPink" & COMMA & "255" & COMMA & "255" & COMMA & "182" & COMMA & "193" & COMMA & "Dash" & COMMA & "SquareAnchor" & COMMA & "NoAnchor“)
            ImportColors(“LightSalmon" & COMMA & "255" & COMMA & "255" & COMMA & "160" & COMMA & "122" & COMMA & "Dot" & COMMA & "Triangle" & COMMA & "SquareAnchor“)
            ImportColors(“LightSeaGreen" & COMMA & "255" & COMMA & "32" & COMMA & "178" & COMMA & "170" & COMMA & "DashDotDot" & COMMA & "ArrowAnchor" & COMMA & "flat“)
            ImportColors(“LightSkyBlue" & COMMA & "255" & COMMA & "135" & COMMA & "206" & COMMA & "250" & COMMA & "DashDot" & COMMA & "Triangle" & COMMA & "NoAnchor“)
            ImportColors(“LightSlateGray" & COMMA & "255" & COMMA & "119" & COMMA & "136" & COMMA & "153" & COMMA & "Dot" & COMMA & "DiamondAnchor" & COMMA & "RoundAnchor“)
            ImportColors(“LightSteelBlue" & COMMA & "255" & COMMA & "176" & COMMA & "196" & COMMA & "222" & COMMA & "DashDotDot" & COMMA & "RoundAnchor" & COMMA & "SquareAnchor“)
            ImportColors(“LightYellow" & COMMA & "255" & COMMA & "255" & COMMA & "255" & COMMA & "224" & COMMA & "DashDot" & COMMA & "ArrowAnchor" & COMMA & "NoAnchor“)
            ImportColors(“Lime" & COMMA & "255" & COMMA & "1" & COMMA & "255" & COMMA & "1" & COMMA & "Dash" & COMMA & "ArrowAnchor" & COMMA & "Round“)
            ImportColors(“LimeGreen" & COMMA & "255" & COMMA & "50" & COMMA & "205" & COMMA & "50" & COMMA & "Dot" & COMMA & "flat" & COMMA & "Round“)
            ImportColors(“Linen" & COMMA & "255" & COMMA & "250" & COMMA & "240" & COMMA & "230" & COMMA & "DashDotDot" & COMMA & "Round" & COMMA & "Triangle“)
            'ImportColors(“Logic"& comma & "255"& comma & "255"& comma & "255"& comma & "255"& comma & "Solid"& comma & "square"& comma & "square“)
            ImportColors(“Magenta" & COMMA & "255" & COMMA & "255" & COMMA & "1" & COMMA & "255" & COMMA & "DashDot" & COMMA & "NoAnchor" & COMMA & "Triangle“)
            ImportColors(“Maroon" & COMMA & "255" & COMMA & "128" & COMMA & "1" & COMMA & "1" & COMMA & "Dot" & COMMA & "Triangle" & COMMA & "ArrowAnchor“)
            ImportColors(“MediumAquamarine" & COMMA & "255" & COMMA & "102" & COMMA & "205" & COMMA & "170" & COMMA & "Dash" & COMMA & "SquareAnchor" & COMMA & "Square“)
            ImportColors(“MediumBlue" & COMMA & "255" & COMMA & "1" & COMMA & "1" & COMMA & "205" & COMMA & "Dot" & COMMA & "NoAnchor" & COMMA & "Round“)
            ImportColors(“MediumOrchid" & COMMA & "255" & COMMA & "186" & COMMA & "85" & COMMA & "211" & COMMA & "DashDotDot" & COMMA & "ArrowAnchor" & COMMA & "Round“)
            ImportColors(“MediumPurple" & COMMA & "255" & COMMA & "147" & COMMA & "112" & COMMA & "219" & COMMA & "DashDot" & COMMA & "Square" & COMMA & "RoundAnchor“)
            ImportColors(“MediumSeaGreen" & COMMA & "255" & COMMA & "60" & COMMA & "179" & COMMA & "113" & COMMA & "Dash" & COMMA & "Triangle" & COMMA & "NoAnchor“)
            ImportColors(“MediumSlateBlue" & COMMA & "255" & COMMA & "123" & COMMA & "104" & COMMA & "238" & COMMA & "Dot" & COMMA & "SquareAnchor" & COMMA & "flat“)
            ImportColors(“MediumSpringGreen" & COMMA & "255" & COMMA & "1" & COMMA & "250" & COMMA & "154" & COMMA & "DashDot" & COMMA & "Triangle" & COMMA & "Triangle“)
            ImportColors(“MediumTurquoise" & COMMA & "255" & COMMA & "72" & COMMA & "209" & COMMA & "204" & COMMA & "Dash" & COMMA & "flat" & COMMA & "Triangle“)
            ImportColors(“MediumVioletRed" & COMMA & "255" & COMMA & "199" & COMMA & "21" & COMMA & "133" & COMMA & "Dot" & COMMA & "NoAnchor" & COMMA & "Round“)
            ImportColors(“MidnightBlue" & COMMA & "255" & COMMA & "25" & COMMA & "25" & COMMA & "112" & COMMA & "DashDotDot" & COMMA & "RoundAnchor" & COMMA & "Square“)
            ImportColors(“MintCream" & COMMA & "255" & COMMA & "245" & COMMA & "255" & COMMA & "250" & COMMA & "DashDot" & COMMA & "RoundAnchor" & COMMA & "DiamondAnchor“)
            ImportColors(“MistyRose" & COMMA & "255" & COMMA & "255" & COMMA & "228" & COMMA & "225" & COMMA & "Dash" & COMMA & "ArrowAnchor" & COMMA & "NoAnchor“)
            ImportColors(“Moccasin" & COMMA & "255" & COMMA & "255" & COMMA & "228" & COMMA & "181" & COMMA & "Dot" & COMMA & "Square" & COMMA & "DiamondAnchor“)
            ImportColors(“NavajoWhite" & COMMA & "255" & COMMA & "255" & COMMA & "222" & COMMA & "173" & COMMA & "DashDotDot" & COMMA & "SquareAnchor" & COMMA & "NoAnchor“)
            ImportColors(“Navy" & COMMA & "255" & COMMA & "1" & COMMA & "1" & COMMA & "128" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“OldLace" & COMMA & "255" & COMMA & "253" & COMMA & "245" & COMMA & "230" & COMMA & "Dash" & COMMA & "NoAnchor" & COMMA & "SquareAnchor“)
            ImportColors(“Olive" & COMMA & "255" & COMMA & "128" & COMMA & "128" & COMMA & "1" & COMMA & "Dot" & COMMA & "Round" & COMMA & "DiamondAnchor“)
            ImportColors(“OliveDrab" & COMMA & "255" & COMMA & "107" & COMMA & "142" & COMMA & "35" & COMMA & "DashDot" & COMMA & "NoAnchor" & COMMA & "Square“)
            ImportColors(“Orange" & COMMA & "255" & COMMA & "255" & COMMA & "165" & COMMA & "1" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“OrangeRed" & COMMA & "255" & COMMA & "255" & COMMA & "69" & COMMA & "1" & COMMA & "Dot" & COMMA & "SquareAnchor" & COMMA & "NoAnchor“)
            ImportColors(“Orchid" & COMMA & "255" & COMMA & "218" & COMMA & "112" & COMMA & "214" & COMMA & "DashDotDot" & COMMA & "Round" & COMMA & "RoundAnchor“)
            ImportColors(“PaleGoldenrod" & COMMA & "255" & COMMA & "238" & COMMA & "232" & COMMA & "170" & COMMA & "Dash" & COMMA & "SquareAnchor" & COMMA & "SquareAnchor“)
            ImportColors(“PaleGreen" & COMMA & "255" & COMMA & "152" & COMMA & "251" & COMMA & "152" & COMMA & "Dot" & COMMA & "RoundAnchor" & COMMA & "DiamondAnchor“)
            ImportColors(“PaleTurquoise" & COMMA & "255" & COMMA & "175" & COMMA & "238" & COMMA & "238" & COMMA & "DashDotDot" & COMMA & "SquareAnchor" & COMMA & "Triangle“)
            ImportColors(“PaleVioletRed" & COMMA & "255" & COMMA & "219" & COMMA & "112" & COMMA & "147" & COMMA & "DashDot" & COMMA & "ArrowAnchor" & COMMA & "Square“)
            ImportColors(“PapayaWhip" & COMMA & "255" & COMMA & "255" & COMMA & "239" & COMMA & "213" & COMMA & "Dash" & COMMA & "ArrowAnchor" & COMMA & "flat“)
            ImportColors(“PeachPuff" & COMMA & "255" & COMMA & "255" & COMMA & "218" & COMMA & "185" & COMMA & "Dot" & COMMA & "Triangle" & COMMA & "Round“)
            ImportColors(“Peru" & COMMA & "255" & COMMA & "205" & COMMA & "133" & COMMA & "63" & COMMA & "DashDotDot" & COMMA & "Triangle" & COMMA & "Round“)
            ImportColors(“Pink" & COMMA & "255" & COMMA & "255" & COMMA & "192" & COMMA & "203" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“Plum" & COMMA & "255" & COMMA & "221" & COMMA & "160" & COMMA & "221" & COMMA & "Dash" & COMMA & "DiamondAnchor" & COMMA & "Round“)
            ImportColors(“PowderBlue" & COMMA & "255" & COMMA & "176" & COMMA & "224" & COMMA & "230" & COMMA & "DashDotDot" & COMMA & "Round" & COMMA & "Square“)
            ImportColors(“Purple" & COMMA & "255" & COMMA & "128" & COMMA & "1" & COMMA & "128" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“Red" & COMMA & "255" & COMMA & "255" & COMMA & "1" & COMMA & "1" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“RosyBrown" & COMMA & "255" & COMMA & "188" & COMMA & "143" & COMMA & "143" & COMMA & "DashDot" & COMMA & "SquareAnchor" & COMMA & "NoAnchor“)
            ImportColors(“RoyalBlue" & COMMA & "255" & COMMA & "65" & COMMA & "105" & COMMA & "225" & COMMA & "Dash" & COMMA & "SquareAnchor" & COMMA & "DiamondAnchor“)
            ImportColors(“SaddleBrown" & COMMA & "255" & COMMA & "139" & COMMA & "69" & COMMA & "19" & COMMA & "DashDotDot" & COMMA & "RoundAnchor" & COMMA & "Triangle“)
            ImportColors(“Salmon" & COMMA & "255" & COMMA & "250" & COMMA & "128" & COMMA & "114" & COMMA & "DashDot" & COMMA & "RoundAnchor" & COMMA & "ArrowAnchor“)
            ImportColors(“SandyBrown" & COMMA & "255" & COMMA & "244" & COMMA & "164" & COMMA & "96" & COMMA & "Dash" & COMMA & "RoundAnchor" & COMMA & "Round“)
            ImportColors(“SeaGreen" & COMMA & "255" & COMMA & "46" & COMMA & "139" & COMMA & "87" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“SeaShell" & COMMA & "255" & COMMA & "255" & COMMA & "245" & COMMA & "238" & COMMA & "DashDotDot" & COMMA & "Round" & COMMA & "SquareAnchor“)
            ImportColors(“Sienna" & COMMA & "255" & COMMA & "160" & COMMA & "82" & COMMA & "45" & COMMA & "DashDot" & COMMA & "DiamondAnchor" & COMMA & "SquareAnchor“)
            ImportColors(“Silver" & COMMA & "255" & COMMA & "192" & COMMA & "192" & COMMA & "192" & COMMA & "Dash" & COMMA & "DiamondAnchor" & COMMA & "NoAnchor“)
            ImportColors(“SkyBlue" & COMMA & "255" & COMMA & "135" & COMMA & "206" & COMMA & "235" & COMMA & "Dot" & COMMA & "Square" & COMMA & "NoAnchor“)
            ImportColors(“SlateBlue" & COMMA & "255" & COMMA & "106" & COMMA & "90" & COMMA & "205" & COMMA & "DashDot" & COMMA & "ArrowAnchor" & COMMA & "RoundAnchor“)
            ImportColors(“SlateGray" & COMMA & "255" & COMMA & "112" & COMMA & "128" & COMMA & "144" & COMMA & "Dash" & COMMA & "Triangle" & COMMA & "Square“)
            ImportColors(“Snow" & COMMA & "255" & COMMA & "255" & COMMA & "250" & COMMA & "250" & COMMA & "Dot" & COMMA & "flat" & COMMA & "ArrowAnchor“)
            ImportColors(“SpringGreen" & COMMA & "255" & COMMA & "1" & COMMA & "255" & COMMA & "127" & COMMA & "DashDotDot" & COMMA & "NoAnchor" & COMMA & "Triangle“)
            ImportColors(“SteelBlue" & COMMA & "255" & COMMA & "70" & COMMA & "130" & COMMA & "180" & COMMA & "DashDot" & COMMA & "NoAnchor" & COMMA & "Triangle“)
            ImportColors(“Tan" & COMMA & "255" & COMMA & "210" & COMMA & "180" & COMMA & "140" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“Teal" & COMMA & "255" & COMMA & "1" & COMMA & "128" & COMMA & "128" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“Thistle" & COMMA & "255" & COMMA & "216" & COMMA & "191" & COMMA & "216" & COMMA & "DashDotDot" & COMMA & "NoAnchor" & COMMA & "RoundAnchor“)
            ImportColors(“Tomato" & COMMA & "255" & COMMA & "255" & COMMA & "99" & COMMA & "71" & COMMA & "DashDot" & COMMA & "Round" & COMMA & "DiamondAnchor“)
            ImportColors(“Transparent" & COMMA & "1" & COMMA & "1" & COMMA & "1" & COMMA & "1" & COMMA & "Solid" & COMMA & "NoAnchor" & COMMA & "NoAnchor“)
            ImportColors(“Turquoise" & COMMA & "255" & COMMA & "64" & COMMA & "224" & COMMA & "208" & COMMA & "Dash" & COMMA & "ArrowAnchor" & COMMA & "SquareAnchor“)
            ImportColors(“Violet" & COMMA & "255" & COMMA & "238" & COMMA & "130" & COMMA & "238" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“Wheat" & COMMA & "255" & COMMA & "245" & COMMA & "222" & COMMA & "179" & COMMA & "DashDotDot" & COMMA & "SquareAnchor" & COMMA & "DiamondAnchor“)
            ImportColors(“White" & COMMA & "255" & COMMA & "255" & COMMA & "255" & COMMA & "255" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“WhiteSmoke" & COMMA & "255" & COMMA & "245" & COMMA & "245" & COMMA & "245" & COMMA & "Dash" & COMMA & "NoAnchor" & COMMA & "SquareAnchor“)
            ImportColors(“Yellow" & COMMA & "255" & COMMA & "255" & COMMA & "255" & COMMA & "1" & COMMA & "Solid" & COMMA & "Round" & COMMA & "Round“)
            ImportColors(“YellowGreen" & COMMA & "255" & COMMA & "154" & COMMA & "205" & COMMA & "50" & COMMA & "DashDotDot" & COMMA & "ArrowAnchor" & COMMA & "flat“)


            MyUniverse.ProgramOptions.SelectedColor = "Black"

            SymbolWindow.ToolStripDropDownDataType.DropDownItems.Clear()

            ' "/DataType=DataTypename" & comma & " Number Of Bytes" & comma & " Color Name" & comma & " Color Width" & comma & " Description"
            ImportDataTypes("Bit" & COMMA & "1" & COMMA & "Blue" & COMMA & "3" & COMMA & "A Single On/off")
            'ImportDataTypes("Boolean" & comma & "1" & comma & "Green" & comma & "3" & comma & "A Boolean variable")
            ImportDataTypes("Byte" & COMMA & "8" & COMMA & "MistyRose" & COMMA & "4" & COMMA & "A Byte (8 bits)")
            ImportDataTypes("Erase" & COMMA & "1" & COMMA & "Orange" & COMMA & "1" & COMMA & "Logic Path For Errors") 'cHANGE THIS BACK TO wHITE
            ImportDataTypes("Errored" & COMMA & "1" & COMMA & "Red" & COMMA & "1" & COMMA & "Logic or data Paths For Errors")
            ImportDataTypes("Floating" & COMMA & "8" & COMMA & "DodgerBlue" & COMMA & "8" & COMMA & "A floating-point variable WinDef")
            ImportDataTypes("Int128" & COMMA & "16" & COMMA & "MediumOrchid" & COMMA & "12" & COMMA & "A 128 bit register ")
            ImportDataTypes("Int16" & COMMA & "2" & COMMA & "Aquamarine" & COMMA & "2" & COMMA & "A 16-bit Or 2 bytes signed Integer BaseTsd")
            ImportDataTypes("Int256" & COMMA & "32" & COMMA & "MediumBlue" & COMMA & "16" & COMMA & "A 256 bit register")
            ImportDataTypes("Int32" & COMMA & "4" & COMMA & "Aqua" & COMMA & "4" & COMMA & "A 32-bit Or 4 bytes signed Integer -2147483648 through 2147483647 BaseTsd")
            ImportDataTypes("Int512" & COMMA & "64" & COMMA & "MediumPurple" & COMMA & "19" & COMMA & "A 512 bit register (XMM or YMM register)")
            ImportDataTypes("Int64" & COMMA & "8" & COMMA & "Red" & COMMA & "8" & COMMA & "A 64-bit Or 8 bytes signed Integer ?+/- 9223372036854775807")
            ImportDataTypes("INT8" & COMMA & "1" & COMMA & "Orange" & COMMA & "2" & COMMA & "An 8-bit Or 1 Byte signed Integer Based (use byte)")
            ImportDataTypes("logic" & COMMA & "1" & COMMA & "Black" & COMMA & "3" & COMMA & "Logic Path")
            ImportDataTypes("String" & COMMA & "512" & COMMA & "Orange" & COMMA & "8" & COMMA & "pointer to string")
            ImportDataTypes("StringArray" & COMMA & "512" & COMMA & "Orange" & COMMA & "8" & COMMA & "pointer to  an array of strings")

            ReDim MyUniverse.MySymbolPoints(122) ' Maxium number of points in a 500x500 on grid of 50
            ImportSymbolPointPreference()

            ReDim MyUniverse.OptionDisplay(64) ' Fixed number of the options displayable
            ' I lost what the default of this use to be.

            'hack the color of the text is fixed for now, but needs to be be able to change it from the imports (later)

            SetColorOptions(0, "AliceBlue", 300, 0, 500, 500) ' Check list (No Used)
            SetColorOptions(1, "IndianRed", 0, -25, 500, 500) '  Display Point Names
            SetColorOptions(2, "DarkBlue", 0, -250, 500, 500) '  Display Symbol Name
            SetColorOptions(3, "OrangeRed", -250, -225, 500, 500) '  Display ID Stroke
            SetColorOptions(4, "ForestGreen", -250, -175, 500, 500) '  Display File Name
            SetColorOptions(5, "Gray", 25, 15, 500, 500) '  Display Notes
            SetColorOptions(6, "DarkOrchid", -250, -125, 500, 500) '  Display OpCode
            SetColorOptions(7, "Blue", 25, 25, 500, 500) '  Display Program Code Text
            SetColorOptions(8, "YellowGreen", -250, -225, 500, 500) '  Display Short Cut Pointer (Should never use)
            SetColorOptions(9, "Red", -250, 75, 500, 500) '  Display Error Text
            SetColorOptions(10, "SaddleBrown", -25, -25, 500, 500) ' Display Input Output name type
            SetColorOptions(11, "GreenYellow", +25, -25, 500, 500) ' Display Errors
            SetColorOptions(12, "Maroon", 0, -25, 500, 500) ' Display Path Names
            SetColorOptions(13, "Black", 0, -25, 500, 500) ' Display Constants
            SetColorOptions(14, "Red", 50, 250, 500, 500) ' Make Paths Orthogonal(No Used)
            SetColorOptions(15, "Wheat", 50, 200, 500, 500) ' Move Symbols from on top of each other (The amount moved each time Times 2)
            SetColorOptions(16, "Red", 50, 150, 500, 500) ' Output Line Number (Not used)
            SetColorOptions(17, "RosyBrown", 100, -25, 500, 500) ' Display Data VValue on Paths (Only after I finish my interrupter)
            SetColorOptions(18, "Red", 50, 50, 500, 500) ' 
            SetColorOptions(19, "Red", 50, -50, 500, 500) ' 
            SetColorOptions(20, "Red", 50, -100, 500, 500) ' 
            SetColorOptions(21, "LawnGreen", 50, -150, 500, 500) ' 
            SetColorOptions(22, "Red", 50, -200, 500, 500) ' 
            SetColorOptions(23, "Red", 50, -250, 500, 500) ' 
            SetColorOptions(24, "Red", 50, 225, 500, 500) ' 
            SetColorOptions(25, "Red", 50, 175, 500, 500) ' 
            SetColorOptions(26, "Red", 50, 125, 500, 500) ' 
            SetColorOptions(27, "Red", 50, 75, 500, 500) ' 
            SetColorOptions(28, "Red", 50, 25, 500, 500) ' 
            SetColorOptions(29, "Red", 50, -25, 500, 500) ' 
            SetColorOptions(30, "Red", 50, -75, 500, 500) ' 
            SetColorOptions(31, "Red", 50, -125, 500, 500) ' Write warning and errors (not used)
            SetColorOptions(32, "Red", 50, -225, 500, 500) ' Debug (mydebug() checking)
            SetColorOptions(32, "Red", 50, -225, 500, 500)

            SetColorOptions(33, "Red", 50, -225, 500, 500)
            SetColorOptions(34, "Red", 50, -225, 500, 500)
            SetColorOptions(35, "Red", 50, -225, 500, 500)
            SetColorOptions(36, "Red", 50, -225, 500, 500)
            SetColorOptions(37, "Red", 50, -225, 500, 500)
            SetColorOptions(38, "Red", 50, -225, 500, 500)
            SetColorOptions(39, "Red", 50, -225, 500, 500)
            SetColorOptions(40, "Red", 50, -225, 500, 500)
            SetColorOptions(41, "Red", 50, -225, 500, 500)
            SetColorOptions(42, "Red", 50, -225, 500, 500)
            SetColorOptions(43, "Red", 50, -225, 500, 500)
            SetColorOptions(44, "Red", 50, -225, 500, 500)
            SetColorOptions(45, "Red", 50, -225, 500, 500)
            SetColorOptions(46, "Red", 50, -225, 500, 500)
            SetColorOptions(47, "Red", 50, -225, 500, 500)
            SetColorOptions(48, "Red", 50, -225, 500, 500)
            SetColorOptions(49, "Red", 50, -225, 500, 500)
            SetColorOptions(50, "Red", 50, -225, 500, 500)
            SetColorOptions(51, "Red", 50, -225, 500, 500)
            SetColorOptions(52, "Red", 50, -225, 500, 500)
            SetColorOptions(53, "Red", 50, -225, 500, 500)
            SetColorOptions(54, "Red", 50, -225, 500, 500)
            SetColorOptions(55, "Red", 50, -225, 500, 500)
            SetColorOptions(56, "Red", 50, -225, 500, 500)
            SetColorOptions(57, "Red", 50, -225, 500, 500)
            SetColorOptions(58, "Red", 50, -225, 500, 500)
            SetColorOptions(59, "Red", 50, -225, 500, 500)
            SetColorOptions(60, "Green", 0, 0, 1000, 500)
            SetColorOptions(61, "Red", 50, -225, 500, 500)
            SetColorOptions(62, "Red", 50, -225, 500, 500)
            SetColorOptions(63, "Red", 50, -225, 500, 500)

            AddSortedList(MyUniverse.SysGen.Constants.SyntaxFunctions, MyConstantIgnoreFunctionOperatorKeyWord & "Function", Language_Function)
            AddSortedList(MyUniverse.SysGen.Constants.SyntaxOperators, MyConstantIgnoreFunctionOperatorKeyWord & "Operator", Language_Operator)
            AddSortedList(MyUniverse.SysGen.Constants.SyntaxKeyWords, MyConstantIgnoreFunctionOperatorKeyWord & "keyWord", Language_KeyWord)
            AddSortedList(MyUniverse.SysGen.Constants.SyntaxGrammar, MyConstantIgnoreFunctionOperatorKeyWord & "Grammar ::= ' '", Language_Grammar)
            'AddSortedList(MyUniverse.SysGen.Constants.SyntaxGrammar, "Single_Quote ::= '", Language_Grammar)


            AddSortedList(MyUniverse.SysGen.Constants.SyntaxKeyWords, "main", Language_KeyWord)


            SymbolWindow.PictureBox1.Width = MyUniverse.SysGen.Constants.ConstantSymbolCenter * 2 * CInt(MyUniverse.SysGen.MySymbolScale)
            SymbolWindow.PictureBox1.Height = MyUniverse.SysGen.Constants.ConstantSymbolCenter * 2 * CInt(MyUniverse.SysGen.MySymbolScale)

            MyUniverse.MyStaticData.MinXY.x = FlowChartWindow.PictureBox1.Top
            MyUniverse.MyStaticData.MaxXY.x = FlowChartWindow.PictureBox1.Width

            MyUniverse.MyStaticData.MinXY.y = FlowChartWindow.PictureBox1.Left
            MyUniverse.MyStaticData.MaxXY.y = FlowChartWindow.PictureBox1.Height

            'Makeing sure that there is at least a start Symbol defined for everything

            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownButtonColor, MyUniverse.ProgramOptions.SelectedColor)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownDataType, MyUniverse.ProgramOptions.SelectedDataType)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownInputOutput, MyUniverse.ProgramOptions.SelectedInputOutput)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownRotation, MyUniverse.ProgramOptions.SelectedRotation)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownPathStart, MyUniverse.ProgramOptions.SelectedPathStart)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownPathEnd, MyUniverse.ProgramOptions.SelectedPathEnd)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownPathLineStyle, MyUniverse.ProgramOptions.SelectedPathLineStyle)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownNumberOfBytes, MyUniverse.ProgramOptions.SelectedNumberOfBytes)



            TempCode = ": main ( " & MakePathName("CommandLine") & " ) "
            TempCode = AddCameFromLine(AddGo_ToNextLine(TempCode))
            'todo makeSymbolfrom syntax
#If MINEDEBUG Then
            FMB(5001)
#End If
            LocalIndex = AddNewNamedRecord("Start", TempCode, " No OpCode", "Start Of the Program", "Internal", "FlowChart Program", "0.1", "ABCDEFGHIJKLMNOP", MicroCodeText2Syntax(MyUniverse.MyStaticData.My_Code_Line_Parsed, TempCode)) '"No Language",
            AddNEWSymbolLineRecord("Start", "/name", 0, 0, 0, 0, "Starting")
            AddNEWSymbolpointRecord("Start", "/point", 200, 200, "output", "stringarray", "CommandLine")
            AddNEWSymbolpointRecord("Start", "/point", 0, 250, "output", "logic", "Address_1")
            AddNEWSymbolpointRecord("Start", "/point", 0, -250, "Input", "logic", "Address_0")
            GetSelfCorrectingIndexes("Start")
            AddNEWSymbolLineRecord("Start", "/line", -200, 100, 200, 100, "Blue")
            AddNEWSymbolLineRecord("Start", "/line", 200, 100, 250, 0, "Orange")
            AddNEWSymbolLineRecord("Start", "/line", 250, 0, 200, -100, "Red")
            AddNEWSymbolLineRecord("Start", "/line", 200, -100, -200, -100, "Green")
            AddNEWSymbolLineRecord("Start", "/line", -200, -100, -250, 0, "purple")
            AddNEWSymbolLineRecord("Start", "/line", -250, 0, -200, 100, "lightblue")
            GetSelfCorrectingIndexes("Start")
            FMB(5002)
            ReSortSymbolList()
            FMB(5003)
            ShowSorts("Named", ReSortStringArray("Named", Named_FileSyntax, Named_FileSyntax_ISAM))
            ShowSorts("Named", ReSortStringArray("Named", Named_FileSymbolName, Named_FileSymbolName_ISAM))
            CheckForAnySortNeeded(103)



            LocalIndex = AddANewFlowChartRecord()
            'Placed the start at the beginning just to put something into the table/file
            FlowChart_FileCoded(LocalIndex) = CByte(MyKeyword_2_Byte(My_keyWord(My_KeyConstUse)))
            FlowChart_FilePathSymbolName(LocalIndex) = "Start"
            ' removed     FlowChart_TableCompiledMacroCodeText(LocalIndex, "Start")

            FlowChart_FileX1(LocalIndex) = 500 'have to start somewhere, miught as well be here.
            FlowChart_FileY1(LocalIndex) = 500 ' 
            FlowChart_File_X2_Rotation(LocalIndex) = 0
            FlowChart_File_Y2_Option(LocalIndex) = 0
            FlowChart_File_DataType(LocalIndex) = "" 'todo find out what I should put in here and below as the default
            ' removedFlowChart_FileCompiledMacroCodeText(LocalIndex) = ""
            FlowChart_ISAM_Name(ConstantALLTables) = LocalIndex
            FlowChart_ISAM_Name(LocalIndex) = LocalIndex
            FlowChart_ISAM_X1(LocalIndex) = LocalIndex
            FlowChart_ISAM_Y1(LocalIndex) = LocalIndex
            FlowChart_ISAM_X2(LocalIndex) = LocalIndex
            FlowChart_ISAM_Y2(LocalIndex) = LocalIndex



            AddNEWFlowChartRecordPath("Command_Line", "/path", 700, 700, 1450, 950, "string")
            AddNEWFlowChartRecordPath("Path_Name_In", "/path", 500, 250, 500, -250, "logic")
            AddNEWFlowChartRecordPath("Path_Name_Out", "/path", 500, 750, 500, 1000, "logic")
            CheckForAnySortNeeded(104) 'hack
            DoThisEvent(2898)
            ShowSorts("FlowChart", ReSortFlowChart(LocalIndex))

            MyPlacement(False) 'sets the min's


            'load all 4 of the forms
            ShowAllForms(ShowWindow, ShowWindow, ShowWindow, ShowWindow)
            ShowAllForms(HideWindow, HideWindow, ShowWindow, HideWindow)




            FindingMyBugs(9)

            formatLanguage = " /language= Language Name"
            formatColor = " /Color=ColorName" & COMMA & " Alpha" & COMMA & " Red" & COMMA & " Green" & COMMA & " Blue" & COMMA & " Style" & COMMA & " StartCap" & COMMA & " EndCap"
            formatDataType = " /DataType=DataTypename" & COMMA & " Number Of Bytes" & COMMA & " Color Name" & COMMA & " Color Width" & COMMA & " Description"
            formatSymbolName = " /Name=Symbol Name" & COMMA & " options"
            'Need to get the {/...} options from the ComboBox 
            formatPoint = " /Point = X" & COMMA & " Y" & COMMA & " {Input/Output...}" & COMMA & " Data Type" & COMMA & " Name"
            formatLine = " /Line=x1" & COMMA & " y1" & COMMA & " x2" & COMMA & " y2" & COMMA & " Color"
            formatNameOfFile = " /FileName=Device:/Path/FileName.Extension"
            formatStroke = " /Stroke={}"
            formatNotes = " /Notes={}"
            FormatOrder = " /Order=name1,(name2,name3,(name4,name5),name6)..."
            formatVersion = " /Version={}"
            formatAuthor = " /Author={}"
            formatOpcode = " /OpCode={}"
            formatPath = " /Path=Name" & COMMA & " x1" & COMMA & " y1" & COMMA & " x2" & COMMA & " y2" & COMMA & " Data type"
            formatUse = " /Use=Name" & COMMA & " X" & COMMA & " Y" & COMMA & " rotation" & COMMA & " future dynamic options"
            formatConstant = " /Constant=name " & COMMA & " X" & COMMA & " Y" & COMMA & " Value"
            FormatMacroText = " /MicroCodeText=OrderName, Text " & AddRM(" replacements") & " text ..."
            FormatOption = " /Option=number" & COMMA & "{on or off}"
            FormatError = " /error = Code" & COMMA & " name" & COMMA & " x1" & COMMA & " y1" & COMMA & " Name " & COMMA & " {other things maybe}"
            FormatDelete = " /Delete ..."
            'FormatThisCode = " /ThisCode added to /path or /Constant "
            FormatLanguage_KeyWord = " /Keyword=ReservedWord  {" & COMMA & "only one word" & COMMA & " no spaces allowed currently}"
            FormatLanguage_Function = " /Function=FunctionWord  " & COMMA & "only one function name no (), {}, [] etc " & FD
            FormatLanguage_Operator = " /Operator=Operator  {" & COMMA & "only one operator ie: +" & COMMA & " no space allowed currently}"
            FormatLanguage_Grammar = " /Grammar = GrammarName '::=' Simple BNF "
            FormatSyntax = " /Syntax={keyword" & COMMA & "special characters" & COMMA & AddRM(" variables ")
            FormatSet_ = "/set=delimiters," & AddRM(FD) & "" & vbCrLf & "/Set=Options,1-32 Turns on this option" & vbCrLf & "/Set=Scale,625-10000" & vbCrLf & "/Set=Grids,lines(1-10),PathsPoints(lines,250),Symbols pathspoints,10000), " & vbCrLf & "/Set=Dump,Dump1.txt,Dump2.txt,Dump3.txt" & vbCrLf & "/Set=points,Index,X,Y" & vbCrLf & "/Set=text,Index,X,Y"
            FindingMyBugs(3)

            FileInputOutputWindow.ToolStripButtonFlowChartToSourceCode.ToolTipText = "FlowChart To Source Code"
            FileInputOutputWindow.ToolStripButtonOpenFile.ToolTipText = "Open FlowChart File"
            FileInputOutputWindow.ToolStripButtonSaveFileAs.ToolTipText = "Save File As"
            FileInputOutputWindow.ToolStripButtonShowFlowChart.ToolTipText = "Show FlowChart Window"
            FileInputOutputWindow.ToolStripButtonSourceCodeToFlowChartCode.ToolTipText = "Decompile Source Code To FlowChart"

            FlowChartWindow.ToolStripButtonAddConstant.ToolTipText = "Add Constant"
            FlowChartWindow.ToolStripButtonAddPath.ToolTipText = "Add Path"
            FlowChartWindow.ToolStripButtonDeleteobject.ToolTipText = "Delete "
            FlowChartWindow.ToolStripButtonMoveObject.ToolTipText = "Move"
            FlowChartWindow.ToolStripButtonOpenForm.ToolTipText = "File I/O"
            FlowChartWindow.ToolStripButtonOptionForm.ToolTipText = "Show Options Window"
            FlowChartWindow.ToolStripButtonRedraw.ToolTipText = "Redraw"
            FlowChartWindow.ToolStripButtonSymbolForm.ToolTipText = "Show Symbol Window"
            FlowChartWindow.ToolStripButtonZoomIn.ToolTipText = "Zoom In"
            FlowChartWindow.ToolStripButtonZoomOut.ToolTipText = "Zoom Out"
            FlowChartWindow.ToolStripDropDownSelectSymbol.ToolTipText = "Select Symbol To Place"


            FindingMyBugs(11)
            FMB(5004)

            SetUpHelpForm(SymbolWindow)
            'todo need to put the help back in
            'SetUpHelpComboBox(SymbolWindow, SymbolWindow.ComboBoxPointNameList, "Input Point name here")
            'SetUpHelpTextBox(SymbolWindow, SymbolWindow.TextBoxNamedSymbolName, "Enter a new Symbol name here (or change the current Symbol to a new name)")
            'SetUpHelpTextBox(SymbolWindow, SymbolWindow.TextBoxNamedDescription, "Enter the Description")
            'SetUpHelpTextBox(SymbolWindow, SymbolWindow.TextBoxNamedNameOfFile, "Enter the path and file name and .Symbol for this Symbols location")
            'SetUpHelpTextBox(SymbolWindow, SymbolWindow.TextBoxNamedNotes, "Enter any notes about the use of this Symbol")
            'SetUpHelpTextBox(SymbolWindow, SymbolWindow.TextBoxNamedOpCode, "Enter the machine code (Optional)")
            'SetUpHelpTextBox(SymbolWindow, SymbolWindow.TextBoxNamedProgramText, "Enter an example of the text for this Symbol.Which will create the syntax when used.")
            'SetUpHelpTextBox(SymbolWindow, SymbolWindow.TextBoxNamedStroke, "This is for the mouse movement to select this Symbol")
            'SetUpHelpTextBox(SymbolWindow, SymbolWindow.TextBoxNamedSyntax, "This syntax is made when you make any changes to the program example text")
            'SetUpHelpTextBox(SymbolWindow, SymbolWindow.TextBoxSymbolVersionAuthor, "Enter this version and author as 0.0.0 proGrammars or company name (copyright, phone number and so on)")


            FindingMyBugs(12)


            SymbolWindow.ToolStripButtonAddLine.ToolTipText = "Add a colored Line"
            SymbolWindow.ToolStripButtonAddPoint.ToolTipText = "Add a named point"
            SymbolWindow.ToolStripButtonDelete.ToolTipText = "Delete A Point/Line"
            SymbolWindow.ToolStripButtonFlowChartForm_FromSymbolWindow.ToolTipText = "Show FlowChart Window"
            SymbolWindow.ToolStripButtonMove.ToolTipText = "Move Point/Line"
            SymbolWindow.ToolStripButtonNewSymbol.ToolTipText = "Make A New Symbol"
            SymbolWindow.ToolStripButtonOptionForm_FromSymbolWindow.ToolTipText = "Show Options"
            SymbolWindow.ToolStripButtonUpdateSymbol.ToolTipText = "Update the Symbol"
            SymbolWindow.ToolStripDropDownButtonColor.ToolTipText = "Select the Color Of Lines (And DataTypes)"
            SymbolWindow.ToolStripDropDownDataType.ToolTipText = "Select the Data type"
            SymbolWindow.ToolStripDropDownSelectSymbol.ToolTipText = "Select the Symbol"

            SymbolWindow.HelpProviderPictureBox1.SetHelpString(SymbolWindow.PictureBox1, "PictureBox1")
            SymbolWindow.HelpProviderSymbolWindow.SetHelpString(SymbolWindow, "SymbolWindow")

            OptionsWindow.ToolStripButtonCheckAllData.ToolTipText = "Check All FlowChart Data"
            OptionsWindow.ToolStripButtonDeleteUnusedSymbols.ToolTipText = "Delete all Unused Symbols"
            OptionsWindow.ToolStripButtonDump.ToolTipText = "Dump into File ..."
            OptionsWindow.ToolStripButtonDeleteUnusedSymbols.ToolTipText = "Remove all unused Symbols"
            OptionsWindow.ToolStripButtonDeleteErrorMsgs.ToolTipText = "Delete FlowChart rrror messages"
            OptionsWindow.ToolStripButtonFlowChartForm_FromOptionsWindow.ToolTipText = "Show FlowChart"
            OptionsWindow.ToolStripButtonSymbolForm_FromOptionsWindow.ToolTipText = "Show Symbol"
            'FindingMyBugs(13)


            '
            ' OptionsSetDefaults(SymbolWindow.ToolStripDropDownLineWidth, "1") '


            MyUniverse.ProgramOptions.SelectedColor = "Black"
            MyUniverse.ProgramOptions.SelectedDataType = "logic"
            MyUniverse.ProgramOptions.SelectedInputOutput = "Both"
            MyUniverse.ProgramOptions.SelectedRotation = "Default"
            MyUniverse.ProgramOptions.SelectedSymbolName = "Start"

            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownButtonColor, MyUniverse.ProgramOptions.SelectedColor)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownDataType, MyUniverse.ProgramOptions.SelectedDataType)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownInputOutput, MyUniverse.ProgramOptions.SelectedInputOutput)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownRotation, MyUniverse.ProgramOptions.SelectedRotation)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName)
            SelectInToolStripDropDownButton(FlowChartWindow.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName)


            MyUniverse.ProgramOptions.SelectedPathStart = "Flat"
            MyUniverse.ProgramOptions.SelectedPathEnd = "Flat"
            MyUniverse.ProgramOptions.SelectedPathLineStyle = "Solid"
            MyUniverse.ProgramOptions.SelectedNumberOfBytes = "4"

            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownPathStart, MyUniverse.ProgramOptions.SelectedPathStart)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownPathEnd, MyUniverse.ProgramOptions.SelectedPathEnd)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownPathLineStyle, MyUniverse.ProgramOptions.SelectedPathLineStyle)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownNumberOfBytes, MyUniverse.ProgramOptions.SelectedNumberOfBytes)

            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName)
            SelectInToolStripDropDownButton(FlowChartWindow.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName)

            FindingMyBugs(14)
            ShowAllForms(HideWindow, HideWindow, LeaveWindow, HideWindow)

            SplashWindow.Visible = False
#If MINEDEBUG Then
            FindingMyBugsChangeOfWindows()
#End If
            'ShowAllForms(HideWindow, HideWindow, ShowWindow, HideWindow)

            'FindingMyBugsGrammar(MyUniverse.SysGen.Constants.SyntaxGrammar, Language_Grammar)
            MyUniverse.MyProgramStatus = "Alive"
            MyUniverse.FCCLDebugLevel = DefaultDebugLevel

            'ShowAllForms(HideWindow, HideWindow, ShowWindow, HideWindow)

            SymbolWindow.ToolStripDropDownButtonColor.Text = "Black"


            SortAllList()
            FMB(5005)
            I = FindingMyBugsSorted()
            DisplayMyStatus(7, "Select the computer language class and then the computer language dialect")
            MyUniverse.FCCLDebugLevel = DefaultDebugLevel
            ShowAllForms(LeaveWindow, LeaveWindow, LeaveWindow, LeaveWindow)
            MyUniverse.MySystem.Dumps.OutputFileName3 = FileIO.FileSystem.CurrentDirectory & "\Dump3.txt"
        End Sub ' End of INIT()

        Public Shared Sub SetColorOptions(LocalIndex As Int32, ColorName As String, X As Int32, Y As Int32, SetWidth As Int32, SetHeight As Int32)
            Dim A, R, G, B As Int16
            Dim IndexColor As Int32
            Dim Temp As String
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2946, 10, "SetColorOptions")
#End If
            IndexColor = FindColor(ColorName)
            If IndexColor = ConstantMyErrorCode Then
                Temp = RandomColor()
                IndexColor = FindColorIndexFromName(Temp)
            End If
            A = Color_TableAlpha(IndexColor)
            R = Color_TableRed(IndexColor)
            G = Color_TableGreen(IndexColor)
            B = Color_TableBlue(IndexColor)

            MyGetPen(ColorName, "") '            MyGetBrush_static(ColorName)

            MyUniverse.OptionDisplay(LocalIndex).ColorPen = New Pen(Color.FromArgb(100, 100, 100, 100))
            MyUniverse.OptionDisplay(LocalIndex).x = X
            MyUniverse.OptionDisplay(LocalIndex).y = Y
            MyUniverse.OptionDisplay(LocalIndex).ColorName = ColorName ' Check list (No Used)
            MyUniverse.OptionDisplay(LocalIndex).Textheight = SetHeight
            MyUniverse.OptionDisplay(LocalIndex).Textwidth = SetWidth
        End Sub



        Public Shared Function CheckThisPathName(PathName As String, IndexFlowChart As Int32) As String
            Dim MyPathName As String
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2947, 10, "CheckThisPathName")
#End If
            MyPathName = NameOfPointOnly(FlowChart_TablePath_Name(IndexFlowChart))
            PathName = NameOfPointOnly(PathName)
            If Len(PathName) = 0 Then
                If FlowChart_TableCode(IndexFlowChart) = "/path" Then
                    PathName = MyPathName
                Else
                    ' removed not needed ?PathName = FlowChart_Table_DataType(IndexFlowChart)
                    Return MakePathName("vNOT_PATH_" & MyRnd()) 'todo ??? 7))
                End If
                If Len(PathName) = 0 Then
                    PathName = MyPathName
                End If
            End If
            If PathName <> MyPathName Then
                MSG_ABug(1042, " Path names do not match", HighLight(PathName) & HighLight(MyPathName), FindIndex_In_TableNetLinks(IndexFlowChart) & ":" & MyShowNetLnks(FindIndex_In_TableNetLinks(IndexFlowChart)))
                If MyOptionTest(25) = True Then
                    'todo needs to fix this problem
                Else
                    'do nothing
                End If
            End If
            Return PathName
        End Function

        Public Shared Sub SetDefaults()
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2948, 10, "SetDefaults")
#End If

            MyUniverse.ProgramOptions.SelectedColor = "Black"
            MyUniverse.ProgramOptions.SelectedDataType = "Logic"
            MyUniverse.ProgramOptions.SelectedInputOutput = "Both"
            MyUniverse.ProgramOptions.SelectedRotation = "Default"
            MyUniverse.ProgramOptions.SelectedSymbolName = "Start"

            MyUniverse.ProgramOptions.SelectedPathStart = "Flat"
            MyUniverse.ProgramOptions.SelectedPathEnd = "Flat"
            MyUniverse.ProgramOptions.SelectedPathLineStyle = "Solid"
            MyUniverse.ProgramOptions.SelectedNumberOfBytes = "4"

            MyUniverse.MySystem.FlowChartOptions(0).OptionNames = "Symbol option 0"
            MyUniverse.MySystem.FlowChartOptions(1).OptionNames = "Symbol option 1"
            MyUniverse.MySystem.FlowChartOptions(2).OptionNames = "Symbol option 2"
            MyUniverse.MySystem.FlowChartOptions(3).OptionNames = "Symbol option 3"
            MyUniverse.MySystem.FlowChartOptions(4).OptionNames = "Symbol option 4"
            MyUniverse.MySystem.FlowChartOptions(5).OptionNames = "Symbol option 5"
            MyUniverse.MySystem.FlowChartOptions(6).OptionNames = "Symbol option 6"
            MyUniverse.MySystem.FlowChartOptions(7).OptionNames = "Symbol option 7"
            MyUniverse.MySystem.FlowChartOptions(8).OptionNames = "Symbol option 8"
            MyUniverse.MySystem.FlowChartOptions(9).OptionNames = "Symbol option 9"
            MyUniverse.MySystem.FlowChartOptions(10).OptionNames = "Symbol option 10"

            MyUniverse.ProgramOptions.SymbolChanged = False
            MyUniverse.ProgramOptions.Helpurl = "FILE:\\" & FileIO.FileSystem.CurrentDirectory & "\FlowChartHelpFiles/FlowChartHelp011.html"

            MyUniverse.SysGen.Constants.RMStart = ChrW(11010) '' was {[(
            MyUniverse.SysGen.Constants.RMEnd = ChrW(11011) ' was ")]}"


            If MyIsNothing(MyUniverse.ProgramOptions.FCCL_Case) Then
                MyUniverse.ProgramOptions.FCCL_Case = "no"
            End If
            If MyIsNothing(MyUniverse.ProgramOptions.FCCL_MultiLine) Then 'default
                MyUniverse.ProgramOptions.FCCL_MultiLine = ":" 'default
            End If
            If MyIsNothing(MyUniverse.ProgramOptions.FCCL_Comment) Then
                MyUniverse.ProgramOptions.FCCL_Comment = "'"       'Chr(34).ToString
            End If
            If MyIsNothing(ThisExtension(MyUniverse.ProgramOptions.FCCL_Extensions, 1)) Then
                MyUniverse.ProgramOptions.FCCL_Extensions = "*"
            End If
            If MyIsNothing(MyUniverse.ProgramOptions.FCCL_VarChars) Then
                MyUniverse.ProgramOptions.FCCL_VarChars = "_."
            End If
            If MyIsNothing(MyUniverse.ProgramOptions.FCCL_DialectName) Then
                MyUniverse.ProgramOptions.FCCL_DialectName = "Generic"
            End If
            If MyIsNothing(MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine) Then
                MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine = AddRM("Go_To")
            End If
            If MyIsNothing(MyUniverse.SysGen.Constants.SyntaxCameFromLine) Then
                MyUniverse.SysGen.Constants.SyntaxCameFromLine = AddRM("Came_From")
            End If
            If MyIsNothing(MyUniverse.ProgramOptions.FCCL_Process) Then
                MyUniverse.ProgramOptions.FCCL_Process = "FCGeneric"
            End If

            If MyIsNothing(MyUniverse.ProgramOptions.FCCL_WhiteSpace) Then
                MyUniverse.ProgramOptions.FCCL_WhiteSpace = " "
            End If

            If MyIsNothing(MyUniverse.ProgramOptions.FCCL_Variable) Then
                MyUniverse.ProgramOptions.FCCL_Variable = "Variable"
            End If

            MyUniverse.ProgramOptions.Helpurl = "FILE:\\" & FileIO.FileSystem.CurrentDirectory & "\" & "FlowChartHelpFiles/FlowChartHelp011.html"

            MyUniverse.SysGen.Constants.ConstantQuote = " " & Chr(34) & " " ' Put white space around quotes 2020 08 20
            MyUniverse.SysGen.Constants.SyntaxQuotes = AddRM("quote") '<"">
            'MyUniverse.SysGen.Constants.SyntaxVariables = AddRM("Variable")
            MyUniverse.SysGen.Constants.SyntaxNumbers = AddRM("Numbers")
            MyUniverse.SysGen.Constants.SyntaxAlphas = AddRM("Alpha")
            MyUniverse.SysGen.Constants.SyntaxAlphaNumeric = AddRM("AlphaNumeric")
            MyUniverse.SysGen.Constants.SyntaxSpecialCharacters = AddRM("Special")
            MyUniverse.SysGen.Constants.SyntaxComments = AddRM("Comment")
            MyUniverse.SysGen.Constants.SyntaxKeyWords = AddRM("KeyWord")
            MyUniverse.SysGen.Constants.SyntaxGrammar = AddRM("Grammar")
            MyUniverse.SysGen.Constants.SyntaxFunctions = AddRM("Function")
            MyUniverse.SysGen.Constants.SyntaxOperators = AddRM("Operator")
            MyUniverse.SysGen.Constants.SyntaxWhiteSpaces = AddRM("WhiteSpace")
            MyUniverse.SysGen.Constants.SyntaxVariable = AddRM("Variable")

            MyUniverse.SysGen.Constants.SyntaxFieldDelimiters = AddRM("FieldDelimiter")
            MyUniverse.SysGen.Constants.SyntaxUnknowns = AddRM("unknown")

        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function MyKeyword2String(Keyword As Int32) As String
            If Keyword < 0 Or Keyword > UBound(My_keyWord) Then Return ""
#If MINEDEBUG Then
  if mydebug(9) then follow(2949, 5, "MyKeyword2String " & Keyword.ToString & My_keyWord(Keyword))
#End If
            Return My_keyWord(Keyword)
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Returns the number of the character string
        Public Shared Function MyKeyword_2_Byte(Keyword As String) As Byte     'My_keyWord are now always in order, so I need to change this to a binary search (Cause the list can be in the thounsands)
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(3455, 10, "MyKeyword_2_Byte")
#End If
            For MyKeyword_2_Byte = CByte(LBound(My_keyWord)) To CByte(UBound(My_keyWord))
                If My_keyWord(MyKeyword_2_Byte) = Trim(Keyword) Then
                    Return MyKeyword_2_Byte
                End If
            Next
            MyKeyword_2_Byte = CByte(LBound(My_keyWord)) ' all ways points to unknown?
            'A I N F O 2 (35)
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Routine Just to let the user know whats going on, more or less
        Public Shared Sub DisplayMyStatus(DebugLevel As Int32, MyMessage As String) ' puts a status string into the textbox on all forms
            Dim S1 As String
            Dim S2 As String = ""
#If MINEDEBUG Then
            If MyDebug(11) = True Then if mydebug(9) then follow(DebugLevel, 11, "DisplayMyStatus")
#End If
            If FMBRecurse("DisplayMyStatus") > 5 Then Return
            S1 = MyMessage
            '    S1 = PopLine(S1)
            'Save updating the Window if it is the same status
            'todo If S1 = SplashWindow.LabelExpireDate.Text & " " & FlowChartWindow.LabelProgramStatus.Text Then return
            If S1 = SplashWindow.Text Then 'todo check this & " " & FlowChartWindow.LabelProgramStatus.Text Then
                Return
            End If
            'todo S1 = SplashWindow.LabelExpireDate.Text & S1
            S1 = SplashWindow.Text & S1
#If MINEDEBUG Then
            FindingMyBugsChangeOfWindows()
#End If
            If FlowChartWindow.Visible = True Then S2 &= "(FlowChart)"
            If SymbolWindow.Visible = True Then S2 &= "(Symbol)"
            If OptionsWindow.Visible = True Then S2 &= "(Option)"
            If FileInputOutputWindow.Visible = True Then S2 &= "(File IO)"
            If SplashWindow.Visible = True Then S2 &= "(Splash)"
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(3441, 10, "Windows : " & FD & FlowChartWindow.Visible & FD & SymbolWindow.Visible & FD & FileInputOutputWindow.Visible & FD & OptionsWindow.Visible & FD & SplashWindow.Visible)
#End If


            If FlowChartWindow.Visible = True Then
                If FlowChartWindow.LabelProgramStatus.Text <> S1 Then
                    FlowChartWindow.LabelProgramStatus.Text = S1
                    If MyDebug(5) Then follow(3420, 5, vbTab & S2 & vbTab & "Display Status:---> " & S1)
                    DoThisEvent(122)
                End If
            End If
            If SymbolWindow.Visible = True Then
                If SymbolWindow.LabelProgramStatus.Text <> S1 Then
                    SymbolWindow.LabelProgramStatus.Text = S1
                    If MyDebug(5) Then follow(3421, 5, vbTab & S2 & vbTab & "Display Status:---> " & S1)
                    DoThisEvent(123)
                End If
            End If
            If OptionsWindow.Visible = True Then
                If OptionsWindow.LabelProgramStatus.Text <> S1 Then
                    OptionsWindow.LabelProgramStatus.Text = S1
                    If MyDebug(5) Then follow(3422, 5, vbTab & S2 & vbTab & "Display Status:---> " & S1)
                    DoThisEvent(147000)
                End If
            End If
            If FileInputOutputWindow.Visible = True Then
                If FileInputOutputWindow.LabelProgramStatus.Text <> S1 Then
                    FileInputOutputWindow.LabelProgramStatus.Text = S1
                    If MyDebug(6) Then follow(3423, 6, vbTab & S2 & vbTab & "Display Status:---> " & S1)
                    DoThisEvent(124)
                End If
            End If
            If SplashWindow.Visible = True Then
                If SplashWindow.LabelProgramStatus.Text <> S1 Then
                    If SplashWindow.LabelProgramStatus.Text <> S1 Then
                        SplashWindow.LabelProgramStatus.Text = S1
                        If MyDebug(5) Then follow(3425, 5, vbTab & S2 & vbTab & "Display Status:---> " & S1)
                        DoThisEvent(1300) 'put back ' removed 20232506               
                    End If
                End If
            End If
            'todo removed to cut down _paint MyDoEvents ' To make sure that a message gets updated on the screed.
            ' removed 20232506 MyDoEvents(150)
        End Sub


        Public Shared Sub MyOpen(DoingWhat As String)    'Routine This is actual to open a new file to edit.
            Dim MyFileName As String
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2952, 10, "MyOpen")
#End If
            ShowAllForms(HideWindow, HideWindow, HideWindow, ShowWindow)

            CheckForAnySortNeeded(300)
            Select Case LCase(Trim(DoingWhat))
                Case "write"
                    MyFileName = XOpenFile("write", "Saving the file for this Symbol " & MyUniverse.SysGen.Constants.DrillDown_FileName & "." & ThisExtension(MyUniverse.ProgramOptions.FCCL_Extension, 1))
                    If MyFileName = Nothing Then Return
                    Export(False, MyFileName)
                Case "read"
                    MyFileName = XOpenFile("read", "Open the file for this FlowChart " & MyUniverse.SysGen.Constants.DrillDown_FileName) ' & ".", DrillDownFileName)
                    If MyFileName = Nothing Then Return
                    Import(MyFileName)
                Case Else
                    MyMsgCtr(1001, "MyOpen", DoingWhat, MyUniverse.SysGen.Constants.DrillDown_FileName, "", "", "", "", "", "", "")
            End Select
        End Sub


        'This fills temp MyArrays with a Symbols information
        ' changed on 20200711
        'This will return the index to to the Symbol graphics for this Symbol name
        Public Shared Function GetSelfCorrectingIndexes(SymbolName As String) As Int32
            Dim IndexNamed, IndexSymbol As Int32
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2953, 10, "GetSelfCorrectingIndexes")
#End If
            IndexNamed = FindIndexInISAMTable("Named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, SymbolName)
            If (IndexNamed <= ConstantMyErrorCode) Or (IndexNamed = 0) Then
                'A I N F O 2 (5)
                Return ConstantMyErrorCode ' This name is not a valid Symbol name in the table, so ignore it
            End If ' we have a valid Symbol, that shoul have graphics with it.

            'If there is a short cut then
            ' Get the short cut
            GetSelfCorrectingIndexes = Named_TableSymbolIndexes(IndexNamed) 'Named_TableSymbolIndexes(SymbolName, IndexNamed)
            If GetSelfCorrectingIndexes > 0 Then ' then it might be valid
                If Symbol_TableCoded_String(GetSelfCorrectingIndexes) = "/name" Then ' it is the first of the Symbol graphics then every thing is ok
                    If Symbol_TableSymbolName(GetSelfCorrectingIndexes) = SymbolName Then
                        ' We have matching names, and it is the start of the Symbol graphics with a /name
                        'A I N F O 2 (-6)
                        Return GetSelfCorrectingIndexes        ' This is a good record
                        'else we have to find/update it
                    End If ' Pointing to the start of the wrong Symbol So Fix it
                End If ' Pointing to something other than the start of the Symbol so fix it
                'Is the short cut valid
            End If ' We have a valid named Symbol, but not graphics (or the graphics point got lost) so fix it

            'if mydebug(9) then follow(2424, 8, "Get Self Correcting Index to Symbol Named" & SymbolName)
            ' IndexNamed is valid
            ' but index_Symbol is not so we have to fix it  [ by checking every one ]
            ' Find the name again to correct
            For GetSelfCorrectingIndexes = 1 To TopOfFile("Symbol")
                If Symbol_TableCoded_String(GetSelfCorrectingIndexes) = "/name" Then ' it is the first of the Symbol graphics then every thing is ok
                    If Symbol_TableSymbolName(GetSelfCorrectingIndexes) = SymbolName Then ' we also have a match so save it
                        Named_TableSymbolIndexes(IndexNamed, GetSelfCorrectingIndexes)
                        If mydebug(9) Then follow(2424, 1, "Get Self Correcting Index to Symbol Named changed to " & GetSelfCorrectingIndexes.ToString & " from " & Named_TableSymbolIndexes(IndexNamed) & " " & SymbolName)
                        Return GetSelfCorrectingIndexes
                    End If
                End If
            Next GetSelfCorrectingIndexes
            IndexSymbol = NewTopOfFile("Symbol")
            Named_TableSymbolIndexes(IndexNamed, IndexSymbol) ' an error as it has no Symbol graphics, only a name
            If IndexNamed <= 0 And MyOptionTest(25) = True Then
                Named_TableSymbolIndexes(IndexNamed, AddNewSymbol(SymbolName))
            Else
                IndexSymbol = FindInSymbolList(SymbolName)
                If IndexSymbol <= 0 Then
                    IndexSymbol = NewTopOfFile("Symbol")
                    MSG_ABug(2751, "Symbol graphics Not found ", SymbolName, "")
                End If
                Symbol_TableCode(IndexSymbol, "/name")
                Symbol_TableSymbolName(IndexSymbol, SymbolName)
                Symbol_TableX1(IndexSymbol, 0)
                Symbol_TableY1(IndexSymbol, 0)
                Symbol_Table_X2(IndexSymbol, 0)
                Symbol_Table_Y2(IndexSymbol, 0)
                Symbol_Table_NameOfPoint(IndexSymbol, "NoPointName")
                'AddNewNamedRecord(SymbolName, "?", "?", "?", "?", "?", "?", "?", "?")
                FMB(5006)
                If IndexNamed > 0 And IndexSymbol <= 0 Then
                    MyInsertSymbolLineRecord(NewTopOfFile("Symbol"), SymbolName, "/name", MyLine1(0, 0, 0, 0), "")
                End If
                FMB(5007)
                Return FindInSymbolList(SymbolName)
            End If

            GetSelfCorrectingIndexes = ConstantMyErrorCode
        End Function


        Public Shared Function ReplaceWithactualControlCharacter(A As String) As String
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2954, 10, "ReplaceWithactualControlCharacter")
#End If
            Select Case UCase(A)
                Case "CRLF"
                    Return vbCrLf
                Case "FL_NUL" '(null)" This should not be allowed
                    Return Chr(0)
                Case "FL_SOH" '(start of heading)"
                    Return Chr(1)
                Case "FL_STX" '(start of text)"
                    Return Chr(2)
                Case "FL_ETX" '(end of text)"
                    Return Chr(3)
                Case "FL_EOT" '(end of transmission)"
                    Return Chr(4)
                Case "FL_ENQ" '(enquiry)"
                    Return Chr(5)
                Case "FL_ACK" '(acknowledge)"
                    Return Chr(6)
                Case "FL_BEL" '(bell)"
                    Return Chr(7)
                Case "FL_BS" '(backspace)"
                    Return Chr(8)
                Case "FL_TAB" '(horizontal tab)"
                    Return Chr(9)
                Case "FL_LF" '(NL line feed, new line)"
                    Return Chr(10)
                Case "FL_VT" '(vertical tab)"
                    Return Chr(11)
                Case "FL_FF" '(NP form feed, new page)"
                    Return Chr(12)
                Case "FL_CR" '(carriage return)"
                    Return Chr(13)

                Case "FL_SO" '(shift out)"
                    Return Chr(14)
                Case "FL_SI" '(shift in)"
                    Return Chr(15)
                Case "FL_DLE" '(data link escape)"
                    Return Chr(16)
                Case "FL_DC1" '(device control 1)"
                    Return Chr(17)
                Case "FL_DC2" '(device control 2)"
                    Return Chr(18)
                Case "FL_DC3" '(device control 3)"
                    Return Chr(19)
                Case "FL_DC4" '(device control 4)"
                    Return Chr(20)
                Case "FL_21 NAK" '(negative acknowledge)"
                    Return Chr(21)
                Case "FL_SYN" '(synchronous idle)"
                    Return Chr(22)
                Case "FL_ETB" '(end of trans.block)"
                    Return Chr(23)
                Case "FL_CAN" '(cancel)"
                    Return Chr(24)
                Case "FL_EM" '(end of medium)"
                    Return Chr(25)
                Case "FL_SUB" '(substitute)"
                    Return Chr(26)
                Case "FL_ESC" '(escape)"
                    Return Chr(27)
                Case "FL_FS" '(file separator)"
                    Return Chr(28)
                Case "FL_GS" '(group separator)"
                    Return Chr(29)
                Case "FL_RS" '(record separator)"
                    Return Chr(30)
                Case "FL_US" '(unit separator)"
                    Return Chr(31)
                Case Else
                    Return A
            End Select
        End Function

        Public Shared Function FlowChart_Replacement_Text(IndexFlowChart As Int32) As String ', MyString As String) As String
            Dim MyStringTemp As String
            Dim EditedString As String
            Dim FindingString As String
            Dim RePlaceMentString As String
            Dim temp As String
            Dim IndexNamed, FDLen, Z As Int32
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2955, 10, "FlowChart_Replacement_Text")
#End If
            FDLen = Len(MyUniverse.SysGen.Constants.RMStart)
            'Find the Symbol
            IndexNamed = FindIndexInISAMTable("Named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, FlowChart_TableSymbol_Name(IndexFlowChart))
            If IndexNamed < 1 Then
                'A I N F O 2 (1047)
                Return Nothing
            End If
            EditedString = Named_TableSyntax(IndexNamed)
            MyStringTemp = MyShowAndUpDateProperties(IndexFlowChart)
            While Len(MyStringTemp) > 1
                Z = MyFirstOne(MyStringTemp, "?/")
                MyStringTemp = Mid(MyStringTemp, Z, Len(MyStringTemp))
                'While MyLeft(MyStringTemp & "?", 1) <> "/" And Len(MyStringTemp) > 0
                ' MyStringTemp = Mid(MyStringTemp, 2)
                ' End While
                'Z = MyFirstOne(MyStringTemp, MyUniverse.SysGen.Constants.ConstantDelimiters)
                temp = Pop(MyStringTemp, MyUniverse.SysGen.Constants.ConstantDelimiters)
                FindingString = Mid(temp, 2, Len(temp))
                RePlaceMentString = Pop(MyStringTemp, "/") 'MyUniverse.SysGen.Constants.ConstantDelimiters)
                temp = EditedString
                EditedString = MyReplace(EditedString, FindingString, RePlaceMentString)
                If temp <> EditedString Then
                    MyInfo(2110, "replaced from ", temp, "to " & EditedString)
                End If
            End While
            Return EditedString
        End Function


        Public Shared Sub MyDeCompile(Where As PictureBox, InputFileName As String)  ' Converts from language into FlowChart
            Dim InputFileText As String
            Dim IndexFlowChart As Int32
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2956, 10, "MyDeCompile")
#End If

            ' Bugs:
            ' It does not make /paths for all of the connections to a Symbol.
            ' It does not connect paths of the same name to each other.(UpdatedLinks to do this)
            ' It does not place Symbols in the 'best' place
            'ReDim Named_FileSyntax_ISAM(UBound(Named_FileSymbolName)) ' and deleted afterwards

            ' no one had this many lines of code (or it would destroy the program anyway)
            MyUniverse.MySS = FillImportLine()
            'MyUniverse.SymbolPointCount = 1 ' First point 
            'todo need to not reset ths .use? if it has already been used.

            MyPlacement(False) 'sets the min's

            'MyMsgCtr(1116, "MyDeCompile", "Starting to convert source code to FlowChart computer language", "", "", "", "", "", "", "", "")

            If Len(InputFileName) < 4 Then
                InputFileName = XOpenFile("decompile", "Open The Source Code File")
            End If
            If InputFileName = Nothing Then Return

            If Dir(InputFileName) = "" Then ' need to create the file if it does not exist then you can ...
                Return
            End If

            ' Now open it for output

            'MyMsgCtr(1149, "MyDeCompile", InputFileName, "", "", "", "", "", "", "", "")
            ShowAllForms(ShowWindow, HideWindow, HideWindow, HideWindow)
            Clear_Window_Only(Where)

            ' make Symbols for everything that has MicroCodeText and no Syntax
            CheckAndFixSyntax()

            Using reader As System.IO.TextReader = System.IO.File.OpenText(InputFileName)
                InputFileText = reader.ReadToEnd()
            End Using
            MyUniverse.MySS.Inputs.LineNumberIn += 1
            MyPlacement(True) 'Only place it should add 
            MyUniverse.MySS.Inputs.AllText = InputFileText
            ShowAllForms(ShowWindow, HideWindow, HideWindow, HideWindow)
            DisplayMyStatus(7, "Line Number " & MyUniverse.MySS.Inputs.LineNumberIn.ToString)
            'A I N F O 2 (166) 'hack
            MyDeCompileLine(MyUniverse.MySS.Inputs.AllText)
            FindingMyBugs(15) 'hack Least amount of checking here
            MyReSort("Named", Named_FileSyntax, Named_FileSyntax_ISAM, TopOfFile("named"))
            MyDeCompileLine("/route")
            'ReDim Named_FileSyntax_ISAM(1) ' and deleted afterwards
            For IndexFlowChart = TopOfFile("FlowChart") To 1 Step -1
                DisplayMyStatus(7, "Linking " & IndexFlowChart)
                'passing a /use SymbolName as a pathname here.
                MyShowAndUpDateProperties(IndexFlowChart) ',MyUniverse.MySS.Inputs.LineNumberIn,Net_TableNames(FindIndex_In_TableNetLinks(IndexFlowChart)))
                PaintAll(Where, IndexFlowChart, IndexFlowChart)
            Next
            DisplayMyStatus(3, "Finished Doing the Compile.")
        End Sub

        Public Shared Sub MyDeCompileLine(tall As String) ' Converts each line of source code into a FlowChart (and Symbol if required)
            Dim SymbolName As String
            Dim PathName As String
            Dim TPar As String
            Dim MyErrors As Int32
            Dim IndexNamed As Int32
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(2957, 10, "MyDeCompileLine")
#End If

            FindingMyBugsFlowChart()
            tall = MyTrim(tall)
            If Len(tall) < 1 Then Return
            If MyLeft(MyTrim(tall), 1) = "/" Then
                If MyLeft(tall, 2) <> "//" Then   'For C code lines starting with a comment
                    ImportLineOrFile(tall)
                    Return
                End If
            End If


            DisplayMyStatus(7, "Line Number " & MyUniverse.MySS.Inputs.LineNumberIn.ToString)
            FMB(3520, "Line Number " & MyUniverse.MySS.Inputs.LineNumberIn.ToString)
            PathName = "??"

            FMB(3522, tall)
            MyErrors = 1000000 'number of lines of code or errors '9,223,372,036,854,775,807 ' This should be enough to avoid a forever loop
            MyReSort("Named", Named_FileSyntax, Named_FileSyntax_ISAM, TopOfFile("named"))
            While MyErrors > 0  ' will exit when the end of file is reached.
                'DoEvents(2691)
                MyErrors -= 1
                TPar = MyTrim(PopLine(tall))
                If MyDebug(7) Then FMB(3523, TPar)
                TPar = FCCL_PreProcessor(TPar)
                If MyDebug(7) Then FMB(3524, TPar)
                While Len(tall) > 0 Or Len(TPar) <> 0
                    DoEvents(2692)
                    If mydebug(9) Then follow(2724, 1, "De Compile Line " & TPar)
                    If MyDebug(7) Then FMB(3525, TPar)
                    MyUniverse.MySS.Inputs.LineNumberIn += 1
                    DisplayMyStatus(7, "Line Number " & MyUniverse.MySS.Inputs.LineNumberIn.ToString)
                    MyPlacement(True) 'Second place it should add
                    FMB(5008)
                    ShowAllForms(ShowWindow, HideWindow, HideWindow, HideWindow)
                    FindingMyBugs(16)
                    MyMakeArraySizesBigger()
                    IndexNamed = FindSymbolSyntax(TPar)
                    FMB(3543, IndexNamed.ToString)
                    If IndexNamed > ConstantMyErrorCode Then
                        SymbolName = Named_TableSymbolName(IndexNamed)
                        PathName = "?"
                    Else
                        SymbolName = Nothing
                    End If
                    'FindingMyBugsTOF_Indexes(0, 0, IndexNamed, 0, 0)
                    If IndexNamed <= 0 Then
                        FMB(3527, TPar)
                        IndexNamed = MakeSymbolFromSyntax(TPar)
                        FMB(3528, TPar)
                        If IndexNamed > 0 Then
                            SymbolName = Named_TableSymbolName(IndexNamed)
                            'todo to speed up Mydoevents(210)
                            PaintAll(FlowChartWindow.PictureBox1, TopOfFile("FlowChart") - 1, TopOfFile("FlowChart") + 1)
                            'todo to speed up Mydoevents(211)
                        Else
                            MSG_ABug(1051, " added a line, and did not get a Symbol named in return ", IndexNamed.ToString, TPar)
                            If MyOptionTest(25) = True Then
                            Else
                            End If
                        End If
                        '        SymbolName = AddNewName("Error_")
                        FMB(5009)
                        MyPlacement(False)
                        FMB(5010)

                        'todo  the Symbol is added twice here,.,
                        MakeUseANDPath(TPar, SymbolName, IndexNamed, PathName)
                        FMB(5011)
                        TPar = ""
                        TPar = MyTrim(PopLine(tall))
                        FMB(3529, TPar)
                        TPar = FCCL_PreProcessor(TPar)
                        FMB(3530, TPar)
                        'todo to speed up Mydoevents(212)
                        Clear_Window(FlowChartWindow.PictureBox1)
                        FMB(5012)
                        PaintAll(FlowChartWindow.PictureBox1, TopOfFile("FlowChart") - 3, TopOfFile("FlowChart") + 1)
                        FMB(5013)
                        SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownSelectSymbol, Named_TableSymbolName(IndexNamed))
                        'todo to speed up Mydoevents(213)
                        FMB(5014)
                    Else
                        FMB(5015)
                        MakeUseANDPath(TPar, SymbolName, IndexNamed, PathName)
                        TPar = "" ' End of this line?

                        PaintAll(FlowChartWindow.PictureBox1, TopOfFile("FlowChart") - 1, TopOfFile("FlowChart") + 1)
                        FMB(5016)

                    End If

                    'should we be searching for keylin, or SymbolName? (Changed to SymbolName 2020 08 17 for no reason
                    IndexNamed = FindIndexInISAMTable("Named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, SymbolName) 'TPar)
                    If IndexNamed = ConstantMyErrorCode Then
                        IndexNamed = CheckNotInList("named", Named_FileSymbolName, SymbolName) 'TPar)
                    End If
                    If IndexNamed < 1 Then
                        MSG_ABug(1052, " The Symbol " & SHL(SymbolName), "was not found!", IndexNamed.ToString)
                        If MyOptionTest(25) = True Then
                            AddNewSymbol(SymbolName) ' todo this needs to create the named, or Symbol graphics
                        Else
                            FMB(5017)
                            '
                        End If
                    Else
                        FMB(5018)
                        AddSymbolToDropDown(Named_TableSymbolName(IndexNamed))
                        SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownSelectSymbol, Named_TableSymbolName(IndexNamed))
                        FMB(5019)
                    End If

                    FMB(5020)
                    Clear_Window(SymbolWindow.PictureBox1)
                    CheckAllSymbolsOnFlowChart(FlowChartWindow.PictureBox1)
                End While
                If SymbolOnTopOfSymbol(TopOfFile("FlowChart") - 1, TopOfFile("FlowChart")) = True Then
                    Clear_Window(SymbolWindow.PictureBox1)
                End If
                If SymbolOnTopOfSymbol(TopOfFile("FlowChart") - 1, TopOfFile("FlowChart") + 1) = True Then
                    Clear_Window(SymbolWindow.PictureBox1)
                End If
                If Len(tall) <= 0 Then Return ' to avoid error count
                FMB(5021)
            End While
            ReSortSymbolList()
            CheckAllSymbolsOnFlowChart(FlowChartWindow.PictureBox1)
            FMB(5022)
        End Sub


        'Public Shared Function Syntax2MicroCodeText(IndexFlowChart As Int32) As String
        'todo 
        '  Dim IndexNamed As Int32
        '      IndexNamed = FindInNamedList(FlowChart_TableSymbol_Name(IndexFlowChart))
        '  Return CompileEachSymbol(IndexFlowChart)
        '  End Function


        Public Shared Function MicroCodeText2Syntax(ByRef MyArray() As String, MicroCodeText As String) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(2958, 10, "MicroCodeText2Syntax")
#End If
            Dim I As Int32
            'todo need to return if same as last
            Static LastMicroCodeText As String
            Static LastPathNames As String
            Static LastMyArray(64) As String
            'todo make this work
            If LastMicroCodeText = MicroCodeText Then
                For I = 1 To UBound(LastMyArray)
                    MyArray(I) = LastMyArray(I)
                Next
                Return Trim(MakeStatementSyntax(MyArray))
            End If
            FMB(3532, "Syntax = " & MicroCodeText)
            MyUniverse.MyStaticData.Path_Names = MyParse(MyArray, MicroCodeText)
            FMB(3533, "Variable Names --> " & MyUniverse.MyStaticData.Path_Names & vbCrLf & "for code --> " & MicroCodeText)
            MyUniverse.MyStaticData.Path_NamesCounted = CountPathNames(MyUniverse.MyStaticData.Path_Names)

            LastMicroCodeText = MicroCodeText
            LastPathNames = MyUniverse.MyStaticData.Path_Names
            For I = 1 To UBound(MyArray)
                LastMyArray(I) = MyArray(I)
            Next I

            Return Trim(MakeStatementSyntax(MyArray))
        End Function


        Public Shared Function ReCompileThisSymbol(Syntax As String, IndexFlowChart As Int32) As String
            Dim Marker, ReplaceWith, Question, Answers As String
            Dim i, j, k, l As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2959, 10, "ReCompileThisSymbol")
#End If
            Question = Syntax
            Answers = MyShowAndUpDateProperties(IndexFlowChart)
            i = InStr(Question, MyUniverse.SysGen.Constants.RMStart)
            j = InStr(Question, MyUniverse.SysGen.Constants.RMEnd)
            While i > 0
                If i > 0 Then
                    If j > 0 Then
                        Marker = Mid(Question, i, j - i + Len(MyUniverse.SysGen.Constants.RMEnd))
                        k = InStr(Answers, Marker)
                        If k <> 0 Then
                            l = InStr(k, Answers, "=")
                            i = InStr(l, Answers, "/")
                            ReplaceWith = Mid(Answers, l, i - l)
                        Else
                            If MyDebug(10) Then follow(2960, 10, Question.Replace(Marker, " Error "))
                            Question = Question.Replace(Marker, " Error ")
                            If mydebug(9) Then follow(2735, 1, "marker " & Marker & " was not found in " & Mid(Answers, i, j - i + 1))
                        End If
                    End If
                End If
                i = InStr(Question, MyUniverse.SysGen.Constants.RMStart)
                j = InStr(Question, MyUniverse.SysGen.Constants.RMEnd)
            End While
            Return Question
        End Function


        ' This should update all of the links to this 'set' of paths connect to this link's (X-Y)
        ' And return the next use index number to compile
        'todo why am i compiling /paths? 
        Public Shared Function CompileThisSymbolText(IndexFlowChart As Int32) As String

            Dim DebugCode, DebugSymbolName As String
            Dim Temp, Temp2 As String
            Dim TS, TE As String
            Dim StartAT, PeriodAT, EndAT, EndOfSwitchAT As Integer
            Dim IndexNamed As Int32
            Dim MyConnectionsToMyCode As String
            Dim ThisIs As String
            Dim ThisIsExtensionName As String
            Dim ThisIsValue As String
            Dim SymbolName As String



#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2961, 10, "CompileThisSymbolText")
#End If
            SymbolName = FlowChart_TableSymbol_Name(IndexFlowChart)

            TS = MyUniverse.SysGen.Constants.RMStart
            TE = MyUniverse.SysGen.Constants.RMEnd

            CheckForAnySortNeeded(114)
            IndexNamed = FindIndexInISAMTable("Named", "DoNotadd", Named_FileSymbolName, Named_FileSymbolName_ISAM, FlowChart_TableSymbol_Name(IndexFlowChart))
            If IndexNamed < 1 Then
                MSG_ABug(2111, "No Symbol Name for index ", IndexFlowChart.ToString, MyShowFlowChartRecord(True, IndexFlowChart))
                If MyOptionTest(25) = True Then
                Else
                End If

            End If
            CheckForAnySortNeeded(115)
            FindingMyBugsTOF_Indexes(IndexFlowChart, 0, IndexNamed, 0, 0)

            CompileThisSymbolText = Named_TableSyntax(IndexNamed)


            'this is to replace any quotes with the value of the path
            Temp = Chr(34).ToString & TS & SymbolName & ".Constant" & TE & Chr(34).ToString
            CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxQuotes, Temp)

            'Temp = MakePathName(SymbolName)
            'CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxVariables, Temp)
            'CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxNumbers, Temp)
            'CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxAlphas, Temp)
            'CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxAlphaNumeric, Temp)
            'CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxSpecialCharacters, Temp)
            'CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.ConstantSpecialCharacters, Temp)
            'CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxComments, Temp)
            'CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxKeyWords, Temp)
            'CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxOperators, Temp)
            'CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxFunctions, Temp)
            'CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxFieldDelimiters, FD)
            'CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxUnknowns, "Unknown")
            'CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxCameFromLine, "CameFromLine")
            CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine, "Go_To")
            'CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.SyntaxWhiteSpaces, MyUniverse.ProgramOptions.FCCL_WhiteSpace)

            Select Case LCase(FlowChart_TableCode(IndexFlowChart)) ' Should only get /USE codes
                Case My_keyWord(My_KeyConstUse)
                    MyConnectionsToMyCode = MyShowAndUpDateProperties(IndexFlowChart) '  "" ' FlowChart_TableCompiledMacroCodeText(IndexFlowChart )
                    If Len(MyConnectionsToMyCode) = 0 Then Return MyConnectionsToMyCode
                    ' Find The Next Go_To Symbol to compile As The Next One  (If already processed then Pick one not done (at Random?))
                    IndexNamed = FindIndexInISAMTable("Named", "DoNotadd", Named_FileSymbolName, Named_FileSymbolName_ISAM, FlowChart_TableSymbol_Name(IndexFlowChart))
                    'CompileThisSymbolText = FlowChart_Replacement_Text(IndexFlowChart) ', Named_TableMicroCodeText(IndexNamed)) '3/16/19
                    'Now Get all of the names of the variables that connect to this use and replace them.
                    FindingMyBugsSyntax1(IndexFlowChart)
                    StartAT = 1
                    While StartAT + 3 < Len(MyConnectionsToMyCode)
                        MyConnectionsToMyCode = Mid(MyConnectionsToMyCode, MyFirstOne(MyConnectionsToMyCode, "/") + 1)
                        If Len(MyConnectionsToMyCode) = 0 Then Exit While
                        'While MyLeft(MyConnectionsToMyCode, 1) = "/"
                        'MyConnectionsToMyCode = Mid(MyConnectionsToMyCode, 2)
                        'End While
                        StartAT = InStr(StartAT, MyConnectionsToMyCode & "/", "/") + 1 'start 
                        PeriodAT = InStr(StartAT, MyConnectionsToMyCode & ".", ".") 'middle of it
                        EndAT = InStr(StartAT, MyConnectionsToMyCode & "=", "=") 'end of it
                        EndOfSwitchAT = InStr(StartAT + 1, MyConnectionsToMyCode & "/", "/")  'start of the Next and end of the line



                        If MyDebug(9) Then DebugPrint("201 ," & "Startat,period,EndAt,end")
                        If MyDebug(9) Then DebugPrint("202 ," & StartAT.ToString & FD & PeriodAT.ToString & FD & EndAT.ToString & FD & EndOfSwitchAT.ToString)


                        If PeriodAT = 0 And EndAT = 0 And EndOfSwitchAT = 0 Then Return CompileThisSymbolText
                        If StartAT = PeriodAT Then Return CompileThisSymbolText
                        If PeriodAT > EndAT Then Return CompileThisSymbolText
                        If EndAT > EndOfSwitchAT Then Return CompileThisSymbolText

                        If MyDebug(9) Then follow(3426, "A::: Name.    =" & SHL(Mid(MyConnectionsToMyCode, StartAT, PeriodAT - StartAT)))
                        If MyDebug(9) Then follow(3427, "B::: attribute=" & SHL(Mid(MyConnectionsToMyCode, PeriodAT + 1, EndAT - PeriodAT - 1)))
                        If MyDebug(9) Then follow(3428, "C::: Value    =" & SHL(Mid(MyConnectionsToMyCode, EndAT + 1, EndOfSwitchAT - EndAT - 1)))

                        ThisIsValue = Mid(MyConnectionsToMyCode, EndAT + 1, EndOfSwitchAT - EndAT - 1) 'from = to [
                        'ThisIsValue = PopLine(ThisIsValue)
                        ThisIsExtensionName = Mid(MyConnectionsToMyCode, PeriodAT + 1, EndAT - PeriodAT - 1) 'from .to ]
                        ThisIs = Mid(MyConnectionsToMyCode, PeriodAT + 1, EndAT - PeriodAT - 1)

                        If MyDebug(9) Then DebugPrint("203 ," & SHL(ThisIsValue))
                        If MyDebug(9) Then DebugPrint("204 ," & SHL(ThisIsExtensionName))
                        If MyDebug(9) Then DebugPrint("205 ," & SHL(ThisIs))

                        While InStr(MyConnectionsToMyCode, "/") > 0 And MyLeft(MyConnectionsToMyCode & "/", 1) <> "/"
                            If MyDebug(8) Then
                                Follow(3451, "remove  " & Mid(MyConnectionsToMyCode, 1, InStr(MyConnectionsToMyCode & "/", "/")))
                            End If
                            MyConnectionsToMyCode = Mid(MyConnectionsToMyCode, InStr(MyConnectionsToMyCode & "/", "/"))
                        End While

                        Temp2 = CompileThisSymbolText
                        If MyDebug(8) Then
                            Follow(3452, "Replace " & TS & SymbolName & "." & ThisIsExtensionName & TE & " <<WITH>> " & ThisIsValue)
                        End If
                        CompileThisSymbolText = MyReplace(CompileThisSymbolText, TS & SymbolName & "." & ThisIsExtensionName & TE, ThisIsValue)
                        If MyDebug(9) Then
                            If Temp2 <> CompileThisSymbolText Then
                                If MyDebug(1) Then follow(2125, "**a**" & TS & SymbolName & "." & ThisIsExtensionName & TE & vbCrLf)
                                If MyDebug(1) Then follow(2126, "**b**" & ThisIsValue & vbCrLf)
                                If MyDebug(1) Then follow(2127, "**c**" & MyUniverse.MyStaticData.Path_Names & vbCrLf)
                                If MyDebug(1) Then follow(2128, "**d**" & MyConnectionsToMyCode & vbCrLf)
                                If MyDebug(1) Then follow(2129, "**e**" & Temp & vbCrLf)
                                If MyDebug(1) Then follow(2130, "**f**" & Temp2 & vbCrLf)
                                If MyDebug(1) Then follow(2131, "**g**" & CompileThisSymbolText & vbCrLf)
                                'not used? Temp2 = ""
                            End If
                        End If

                    End While ' Get the next item of this use status
                    If MyDebug(10) Then follow(2132, CompileThisSymbolText & vbCrLf)

                    If InStr(CompileThisSymbolText, TS) <> 0 Then
                        'todo should try to reverse it, and find out the replcement value from the this Symbol
                        ReCompileThisSymbol(CompileThisSymbolText, IndexFlowChart)
                        FindingMyBugsSyntax1(IndexFlowChart)
                        MSG_ABug(1060, "The syntax is incorrect, a marker has not been replaced.", vbCrLf & "Code = " & CompileThisSymbolText, MyShowNamedRecords(True, IndexNamed))
                        'start with index to a flowchat record
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                        DebugCode = FlowChart_TableCode(IndexFlowChart)
                        DebugSymbolName = FlowChart_TablePathName(IndexFlowChart) 'long get
                        DebugSymbolName = FlowChart_TablePath_Name(IndexFlowChart) 'gets anything
                        'FindingMyBugsSyntax(IndexFlowChart)

                    End If
                Case "/error" 'ignore all errors for now
                Case "/delete"
                Case "/Constant" 'ignore all Constants for now
                Case "/path" ' Ignore all paths for now
                    ConnectPath(IndexFlowChart)
                Case Else 'Not a Use so Go_To the next Go_To
                    MyMsgCtr(1117, "CompileThisSymbolText", FlowChart_TableCode(IndexFlowChart), "", "", "", "", "", "", "", "")
            End Select
        End Function

        Public Shared Sub MyCompile(Where As PictureBox) ' Converts from a FlowChart into Source Code
            Dim IndexFlowChart As Int32
            Dim IndexNamed As Int32
            Dim IndexSymbol As Int32
            Dim IndexNetLinks As Int32
            Dim OutputFileName As String
            Dim MyCode As String
            Dim Temp As String
            'Dim MyWriter As StreamWriter
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2962, 10, "MyCompile")
#End If
            MyUniverse.MySS = FillImportLine()

            Clear_Window_Only(Where)
            OutputFileName = XOpenFile("compile", "Saving the compiled source For " & MyUniverse.SysGen.Constants.DrillDown_FileName & "." & ThisExtension(MyUniverse.ProgramOptions.FCCL_Extension, 1)) ' 2020 08 10 , DrillDownFileName)
            If OutputFileName = Nothing Then Return

            If Dir(OutputFileName) = "" Then ' need to create the file if it does not exist then you can ...
                'System.IO.File.Create(OutputFileName)
                Using Writer As System.IO.StreamWriter = System.IO.File.CreateText(OutputFileName)
                End Using
            End If

            Using mywriter As New StreamWriter(OutputFileName)

                Clear_Window_Only(Where)
                FindingMyBugs(17) 'hack Least amount of checking here
                For IndexNetLinks = 1 To UBound(Net_FileLinks)
                    'todo need to make this into a valid statement to define a variable's data type (Dim X as DataType,  Datatype X; )
                    MSG_AInfo1(1062, MyShowNetLnks(IndexNetLinks), "", "")
                    Temp = Net_TableLinks(IndexNetLinks)
                    MyCode = FlowChart_Table_DataType(PopNonZeroValue(Temp))
                    MyCode &= MyUniverse.ProgramOptions.FCCL_WhiteSpace
                    MyCode &= Net_TableNames(IndexNetLinks)
                    'MyCode &= MyUniverse.ProgramOptions.FCCL_Comment
                    'Temp = Net_TableLinks(IndexNetLinks)
                    'MyCode &= MyShowFlowChartRecord(False, PopNonZeroValue(Temp))
                    MyWriteLine1(mywriter, MyCode)
                Next IndexNetLinks


                For IndexFlowChart = 1 To TopOfFile("FlowChart")
                    FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol)
                    FindingMyBugsTOF_Indexes(IndexFlowChart, 0, IndexNamed, 0, 0)
                    MyShowAndUpDateProperties(IndexFlowChart) ',MyUniverse.MySS.Inputs.LineNumberIn,FlowChart_FilePathSymbolName(IndexFlowChart))
                    ReSetScrollBars(IndexFlowChart)
                    Select Case LCase(FlowChart_TableCode(IndexFlowChart))
                        Case My_keyWord(My_KeyConstUse)
                            CheckForAnySortNeeded(118)
                            IndexNamed = FindIndexInISAMTable("Named", "DoNotadd", Named_FileSymbolName, Named_FileSymbolName_ISAM, FlowChart_TableSymbol_Name(IndexFlowChart))
                            CheckForAnySortNeeded(119)
                            FindingMyBugsTOF_Indexes(IndexFlowChart, 0, IndexNamed, 0, 0)
                            IndexSymbol = Named_FileSymbolName_ISAM(IndexNamed)
                            FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol)
                            FindingMyBugsTOF_Indexes(IndexFlowChart, 0, IndexNamed, 0, 0)
                            ' Added 3/16/19 for check of replacements
                            MyCode = CompileEachSymbol(IndexFlowChart)
                            'CheckBoxOutputLineNumbers
                            If MyOptionTest(16) = True Then
                                MyCode = MyCode & MyUniverse.ProgramOptions.FCCL_Comment & " Line " & MyUniverse.MySS.Inputs.LineNumberIn
                            Else
                            End If
                            MyWriteLine1(mywriter, MyCode)
                            MyUniverse.MySS.Inputs.LineNumberIn += 1
                            DisplayMyStatus(7, "Line Number " & MyUniverse.MySS.Inputs.LineNumberIn.ToString)
                            MyPlacement(True)'THird place it should add
                        Case "/path"
                            ConnectPath(IndexFlowChart)
                        Case "/error"
                        Case "/Constant"

                        Case Else
                            MyMsgCtr(1031, "MyCompile", FlowChart_TableCode(IndexFlowChart), IndexFlowChart.ToString, "", "", "", "", "", "", "")
                    End Select
                Next
            End Using
            'FileClose(MyWriter)
            'End Using
            Clear_Window(Where)
            DisplayMyStatus(3, "Translation into source code Finished.")
        End Sub



        'Routine 'Compile' is where it starts checking, then makes the text output
        Public Shared Function CompileEachSymbol(IndexFlowChart As Int32) As String
            'Get the links between the Symbols (path names)
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2963, 10, "CompileEachSymbol")
#End If
            'Replace the code with the names of the paths (And other information)
            CompileEachSymbol = CompileThisSymbolText(IndexFlowChart) ' Write out this Symbol then get the next one to do
            If MyDebug(7) Then follow(2134, CompileEachSymbol & vbCrLf)
        End Function


        Public Shared Sub MakePaths(IndexFlowChart1 As Int32, IndexFlowChart2 As Int32) 'todo make new paths connecting two together
            Dim SymbolNamed As String 'Links,DataTypeIs 
            Dim X1, Y1, X2, Y2 As Int32
            Dim NetIndex1, NetIndex2 As Int32
            Dim NetLinks1, NetLinks2 As String
            Dim A1, A2 As String
            Dim InNetLinksAt As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2964, 10, "MakePaths")
#End If

            If IndexFlowChart1 = IndexFlowChart2 Then Return ' do not make a path from itself to itself

            'must be /paths
            If FlowChart_TableCode(IndexFlowChart1) <> "/path" Then Return
            If FlowChart_TableCode(IndexFlowChart2) <> "/path" Then Return

            NetIndex1 = FlowChart_TablePathNumber(IndexFlowChart1)
            If NetIndex1 < 1 Then MSG_AInfo(1064, "Path Name Problem A)" & NetIndex1, MyShowFlowChartRecord(True, IndexFlowChart1), FindIndex_In_TableNetLinks(IndexFlowChart1))
            NetIndex2 = FlowChart_TablePathNumber(IndexFlowChart2)
            If NetIndex2 < 1 Then MSG_AInfo(1065, "Path Name Problem B)" & NetIndex2, MyShowFlowChartRecord(True, IndexFlowChart1), FindIndex_In_TableNetLinks(IndexFlowChart1))
            NetLinks1 = Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart1))
            If Len(NetLinks1) < 1 Then MSG_AInfo(1066, "Path Name Problem C)" & NetLinks1, MyShowFlowChartRecord(True, IndexFlowChart1), FindIndex_In_TableNetLinks(IndexFlowChart1))
            NetLinks2 = Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart2))
            If Len(NetLinks2) < 1 Then MSG_AInfo(1067, "Path Name Problem D)" & NetLinks2, MyShowFlowChartRecord(True, IndexFlowChart1), FindIndex_In_TableNetLinks(IndexFlowChart1))

            If NetLinks1 = "" Or NetLinks2 = "" Then
                MSG_ABug(1068, "Net is empty", NetLinks1, NetLinks2) 'MyShowNetLnks(IndexFlowChart1  ), MyShowNetLnks(IndexFlowChart2  ))
                If MyOptionTest(25) = True Then
                Else
                End If
            End If

            'error two nets are the same, so should delete one
            If IndexFlowChart1 <> IndexFlowChart2 Then
                If NetLinks1 = NetLinks2 Then
                    MSG_ABug(1069, " Two paths are the same ", MyShowNetLnks(NetIndex1), MyShowNetLnks(NetIndex2))
                    MSG_ABug(1070, " Two paths are the same ", MyShowFlowChartRecord(True, IndexFlowChart1), MyShowFlowChartRecord(True, IndexFlowChart2))
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                Else
                    MSG_ABug(1071, "Problem with these two paths ", MyShowNetLnks(IndexFlowChart1), MyShowNetLnks(IndexFlowChart2))
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                    Return 'cause the paths are already connected
                End If
            Else
                MSG_ABug(1072, "Making the same path again", IndexFlowChart1.ToString, IndexFlowChart2.ToString)
                If MyOptionTest(25) = True Then
                Else
                End If
            End If


            InNetLinksAt = FindIndex_In_TableNetLinks(IndexFlowChart1)
            If InNetLinksAt < 0 Then MakeNew_NetLinks(IndexFlowChart1, Net_TableNames(FlowChart_TablePathNumber(IndexFlowChart1)))

            If NetLinks1 <> NetLinks2 Then
                'we should be combine two deferent named nets together?
                MSG_ABug(1073, "Two deferent paths " & IndexFlowChart1 & " : " & IndexFlowChart2, MyShowNetLnks(NetIndex1), MyShowNetLnks(NetIndex2))
                If MyOptionTest(25) = True Then
                Else
                End If
                SymbolNamed = FlowChart_TablePathName(IndexFlowChart1) & "&" & FlowChart_TablePathName(IndexFlowChart1)
            Else
                SymbolNamed = FlowChart_TablePathName(IndexFlowChart1)
            End If

            ' Must have the same name (maybe, or else it is an error , it is an error, )
            If FlowChart_TablePathName(IndexFlowChart1) <> FlowChart_TablePathName(IndexFlowChart2) Then Return

            'From the second point in one
            X1 = FlowChart_TableX2(IndexFlowChart1)
            Y1 = FlowChart_TableY2(IndexFlowChart1)
            'To the second point in the other
            X2 = FlowChart_TableX2(IndexFlowChart2)
            Y2 = FlowChart_TableY2(IndexFlowChart2)
            ' should also clean the two of them out 
            A1 = Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart1))
            A2 = Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart2))
            MyDrawPath(FlowChartWindow.PictureBox1, MyLine1(X1, Y1, X2, Y2), "yelow")
            MyShowAndUpDateProperties(TopOfFile("FlowChart")) ', LineNumber, SymbolNamed)
            AddNEWFlowChartRecordPath(SymbolNamed, "/path", X1, Y1, X2, Y2, "error") ')
        End Sub

        'todo it is not getting CommandLine.* when starting 'bug
        Public Shared Function MyShowAndUpDateProperties(IndexFlowChart As Int32) As String '/Use fills in information /Path adds to net number list and saves netnumber into links
            'Dim LocalIndex As Int32
            Dim RTN, PathName As String
            Dim IndexNamed, IndexSymbol, IndexPath As Int32
            Dim MY_DataTypeName, My_RotationName, My_Input_Output_Both, MyPathName As String
            Dim My_DataTypeIndex As Int32
            Dim ThisPointName, ThisSymbolName As String ' holds the name
            Dim Temp As String
            Dim SymbolXY As MyPointStructure
            Dim MyPathX, MyPathY As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2965, 10, "MyShowANDUpdateProperties")
#End If

            RTN = ""
            'todo which one?  
            PathName = FlowChart_TablePathName(IndexFlowChart)
            PathName = CheckThisPathName(PathName, IndexFlowChart)
            'The following causes the links to be save twice in size
            Select Case LCase(FlowChart_TableCode(IndexFlowChart))
                Case My_keyWord(My_KeyConstUse)  ' Find all of the points of a Symbol (And Put them Together in FCStatus)
                    If MyCheckValidUse(IndexFlowChart) = False Then Return RTN
                    CheckForAnySortNeeded(120)
                    IndexNamed = FindIndexInISAMTable("Named", "Add", Named_FileSymbolName, Named_FileSymbolName_ISAM, FlowChart_TableSymbol_Name(IndexFlowChart))
                    If IndexNamed = ConstantMyErrorCode Then ' We can not find the index, so we whould add it.
                        Return RTN
                    End If
                    CheckForAnySortNeeded(121)
                    FindingMyBugsTOF_Indexes(IndexFlowChart, IndexSymbol, IndexNamed, 0, 0)
                    'ThisSymbolName = Named_FileSymbolName(IndexNamed) ' need to check for error of -1 return
                    IndexSymbol = GetSelfCorrectingIndexes(FlowChart_TableSymbol_Name(IndexFlowChart))
                    FindingMyBugsTOF_Indexes(IndexFlowChart, IndexSymbol, IndexNamed, 0, 0)
                    ThisSymbolName = FlowChart_TableSymbol_Name(IndexFlowChart)
                    RTN = ""

                    'hack only need one of these two.
                    Temp = vbCrLf & "/" & ThisSymbolName & ".name" & "=" & PrintAbleNull(ThisSymbolName) ' This Symbol name
                    RTN &= Temp ' I am doing this twice, because I throw away the first one.
                    RTN &= Temp

                    Temp = vbCrLf & "/" & ThisSymbolName & ".index" & "=" & PrintAbleNull(IndexFlowChart.ToString)
                    RTN &= Temp
                    Temp = vbCrLf & "/" & ThisSymbolName & ".x" & "=" & FlowChart_TableX1(IndexFlowChart).ToString
                    RTN &= Temp
                    Temp = vbCrLf & "/" & ThisSymbolName & ".y" & "=" & FlowChart_TableY1(IndexFlowChart).ToString
                    RTN &= Temp
                    'rotation
                    Temp = vbCrLf & "/" & ThisSymbolName & ".Rotation" & "=" & FlowChart_Table_Rotation(IndexFlowChart)
                    RTN &= Temp
                    Temp = vbCrLf & "/" & ThisSymbolName & ".DataType" & "=" & PrintAbleNull(FlowChart_Table_DataType(IndexFlowChart))
                    RTN &= Temp
                    Temp = vbCrLf & "/" & ThisSymbolName & ".OpCode" & "=" & PrintAbleNull(Named_TableOpCode(IndexNamed))
                    RTN &= Temp
                    Temp = vbCrLf & "/" & ThisSymbolName & ".notes" & "=" & PrintAbleNull(Named_TableNotes(IndexNamed))
                    RTN &= Temp
                    Temp = vbCrLf & "/" & ThisSymbolName & ".FileName" & "=" & PrintAbleNull(Named_TableNameofFile(IndexNamed))
                    RTN &= Temp
                    Temp = vbCrLf & "/" & ThisSymbolName & ".Author" & "=" & PrintAbleNull(Named_TableAuthor(IndexNamed))
                    RTN &= Temp
                    Temp = vbCrLf & "/" & ThisSymbolName & ".Version" & "=" & PrintAbleNull(Named_TableVersion(IndexNamed))
                    RTN &= Temp
                    Temp = vbCrLf & "/" & ThisSymbolName & ".Stroke" & "=" & PrintAbleNull(Named_TableStroke(IndexNamed))
                    RTN &= Temp
                    Temp = vbCrLf & "/" & ThisSymbolName & ".Indexes" & "=" & Named_TableSymbolIndexes(IndexNamed)
                    RTN &= Temp

                    If IndexSymbol > 0 Then
                        If Symbol_TableCoded_String(IndexSymbol) = "/name" Then
                            My_RotationName = FlowChart_Table_Rotation(IndexFlowChart)
                            Temp = vbCrLf & "/" & ThisSymbolName & ".name" & "=" & PrintAbleNull(Symbol_TableSymbolName(IndexSymbol))
                            RTN &= Temp
                            Temp = vbCrLf & "/" & ThisSymbolName & ".xa" & "=" & MyRotated(IndexSymbol, IndexFlowChart).x
                            RTN &= Temp
                            Temp = vbCrLf & "/" & ThisSymbolName & ".ya" & "=" & MyRotated(IndexSymbol, IndexFlowChart).y
                            RTN &= Temp
                            Temp = vbCrLf & "/" & ThisSymbolName & ".rotation" & "=" & PrintAbleNull(My_RotationName)
                            RTN &= Temp
                            If LCase(Symbol_TableSymbolName(IndexSymbol)) = LCase(FlowChart_TableSymbol_Name(IndexFlowChart)) Then ' Making sure that is right
                                Temp = vbCrLf & "/" & ThisSymbolName & ".code" & "=" & PrintAbleNull(ReplaceRM(" ", Named_TableMicroCodeText(IndexSymbol), " "))
                                RTN &= Temp & "*****"
                                IndexSymbol += 1
                                FindingMyBugsTOF_Indexes(IndexFlowChart, IndexSymbol, IndexNamed, 0, 0)
                                While Symbol_TableCoded_String(IndexSymbol) <> "/name" And IndexSymbol <= TopOfFile("Symbol")
                                    Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                                        Case "/point"
                                            FixSyntaxCode(IndexNamed)
                                            ThisPointName = NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol))
                                            Temp = vbCrLf & "/" & ThisPointName & ".name" & "=" & PrintAbleNull(ThisPointName)
                                            RTN &= vbCrLf & "\\" & Temp
                                            Temp = vbCrLf & "/" & ThisPointName & ".index" & "=" & PrintAbleNull(IndexSymbol.ToString)
                                            RTN &= Temp
                                            My_RotationName = FlowChart_Table_Rotation(IndexFlowChart)
                                            My_Input_Output_Both = Symbol_Table_InputOutput(IndexSymbol)
                                            MY_DataTypeName = Symbol_Table_DataType(IndexSymbol)
                                            My_DataTypeIndex = FindDataTypeIndex(MY_DataTypeName)
                                            Temp = vbCrLf & "/" & ThisPointName & ".name" & "=" & PrintAbleNull(Symbol_Table_NameOfPoint(IndexSymbol))
                                            RTN &= Temp
                                            SymbolXY.x = MyRotated(IndexSymbol, IndexFlowChart).x
                                            SymbolXY.y = MyRotated(IndexSymbol, IndexFlowChart).y
                                            Temp = vbCrLf & "/" & ThisPointName & ".x" & "=" & PrintAbleNull(MyRotated(IndexSymbol, IndexFlowChart).x.ToString)
                                            MyPathX = MyRotated(IndexSymbol, IndexFlowChart).x
                                            RTN &= Temp
                                            Temp = vbCrLf & "/" & ThisPointName & ".y" & "=" & PrintAbleNull(MyRotated(IndexSymbol, IndexFlowChart).y.ToString)
                                            MyPathY = MyRotated(IndexSymbol, IndexFlowChart).y
                                            RTN &= Temp
                                            Temp = vbCrLf & "/" & ThisPointName & ".IO" & "=" & PrintAbleNull(My_Input_Output_Both)
                                            RTN &= Temp
                                            Temp = vbCrLf & "/" & ThisPointName & ".Rotation" & "=" & PrintAbleNull(My_RotationName)
                                            RTN &= Temp
                                            Temp = vbCrLf & "/" & ThisPointName & ".DataType" & "=" & PrintAbleNull(MY_DataTypeName)
                                            RTN &= Temp

                                            IndexPath = FindPathNameAt(MyPoint1XY(MyPathX, MyPathY))
                                            If IndexPath > 0 Then
                                                MyPathName = FlowChart_TablePathName(IndexPath) 'data type
                                                'PathX = MyRotated_1(IndexSymbol, IndexPath, My_RotationName).X
                                                'PathY = MyRotated_1(IndexSymbol, IndexPath, My_RotationName).Y
                                                ' 2020  07 16 change it to have not rotation aor Symbol (Cause Im calling the wrong subroutine.) 

                                                If MyDistance(MyPoint1XY(FlowChart_TableX1(IndexPath), FlowChart_TableY1(IndexPath)), MyPoint2XY(SymbolXY.x, SymbolXY.y)) < MyDistance(MyPoint1XY(FlowChart_TableX2(IndexPath), FlowChart_TableY2(IndexPath)), MyPoint2XY(SymbolXY.x, SymbolXY.y)) Then
                                                    MyPathX = FlowChart_TableX1(IndexPath)
                                                    MyPathY = FlowChart_TableY1(IndexPath)
                                                Else
                                                    MyPathX = FlowChart_TableX2(IndexPath)
                                                    MyPathY = FlowChart_TableY2(IndexPath)
                                                End If
                                                'PathX = MyRotated_1(0, IndexPath, "default").X
                                                'PathY = MyRotated_1(0, IndexPath, "default").Y
                                                Temp = vbCrLf & "/" & ThisPointName & ".PathName" & "=" & PrintAbleNull(MyPathName)
                                                RTN &= Temp
                                                'Temp = vbcrlf & "/" &  ThisPointName & ".Name") & "=" & PrintAbleNull(MyPathName)
                                                'RTN &= Temp
                                                Temp = vbCrLf & "/" & ThisPointName & ".Variable" & "=" & PrintAbleNull(MyPathName)
                                                RTN &= Temp
                                                Temp = vbCrLf & "/" & ThisPointName & ".PathX" & "=" & PrintAbleNull(MyPathX.ToString)
                                                RTN &= Temp
                                                Temp = vbCrLf & "/" & ThisPointName & ".pathY" & "=" & PrintAbleNull(MyPathY.ToString)
                                                RTN &= Temp
                                                'todo This is not the distance from the Symbol to the path
                                                Temp = vbCrLf & "/" & ThisPointName & ".Distance =" & MyDistance(MyRotated_1(IndexSymbol, FlowChart2Point(IndexFlowChart), My_RotationName), MyPoint2XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)))
                                                RTN &= vbCrLf & "\\" & Temp
                                                Temp = vbCrLf & "/" & ThisPointName & ".Distance" & "=" & MyDistance(MyPoint2XY(MyPathX, MyPathY), MyPoint2XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)))
                                                RTN &= vbCrLf & "\\" & Temp
                                                Temp = vbCrLf & "/" & ThisPointName & ".DataTypeName" & "=" & MY_DataTypeName
                                                RTN &= Temp
                                                Temp = vbCrLf & "/" & ThisPointName & ".DataTypeDescription" & "=" & DataType_TableDescription(My_DataTypeIndex)
                                                RTN &= Temp
                                                Temp = vbCrLf & "/" & ThisPointName & ".Bytes" & "=" & DataType_TableNumberOfBytes(My_DataTypeIndex)
                                                RTN &= Temp

                                                Temp = vbCrLf & "/" & ThisPointName & ".DataTypeColor" & "=" & FindColorFromDataType(DataType_TableName(My_DataTypeIndex))
                                                If MyDebug(9) Then follow(2136, "MyShow&Update " & IndexFlowChart.ToString & " " & Temp & vbCrLf)
                                                RTN &= Temp
                                                Temp = vbCrLf & "/" & ThisPointName & ".Width" & "=" & DataType_TableWidth(My_DataTypeIndex)
                                                RTN &= Temp
                                            Else 'no path connected
                                                Temp = vbCrLf & "/" & MakeNewName("Errored_", "NoPathConnected") & ".PathName" & "=NULL)"
                                                RTN &= vbCrLf & "\\" & Temp
                                            End If
                                            'hack removed??
                                            ' removed this cause we are in a /use 
                                            'If FindIndex_In_TableNetLinks(IndexFlowChart) < 1 Then
                                            'MakeNew_NetLinks(IndexFlowChart, FlowChart_TablePath_Name(IndexFlowChart))
                                            'End If
                                            ' Takes more time to move all of this sting but it's easier to debug for now
                                            MyCheckValidUse(IndexFlowChart)
                                        Case "/line" ' Ignore
                                        Case Else
                                            MSG_ABug(1076, "Unknown code ", MyShowSymbolRecords(True, IndexSymbol), Symbol_TableCoded_String(IndexSymbol))
                                            If MyOptionTest(25) = True Then
                                            Else
                                            End If
                                    End Select
                                    FindingMyBugsTOF_Indexes(IndexFlowChart, IndexSymbol, IndexNamed, 0, 0)
                                    IndexSymbol += 1
                                End While
                            End If
                        End If
                    End If
    'Change the /path links to point to Net_TableLinks() number of this net link
                Case "/path" 'Find all of the lines of a path (And put them together in FCStatus)
                    ConnectPath(IndexFlowChart)
                    FindAllPaths(IndexFlowChart, MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), PathName) 'byXY
                    FindAllPaths(IndexFlowChart, MyPoint1XY(FlowChart_TableX2(IndexFlowChart), FlowChart_TableY2(IndexFlowChart)), PathName) 'byXY
                    FindAllPaths_2(IndexFlowChart) ', LineNumber, PathName) 'By Path Name
                    ConnectPath(IndexFlowChart)
                Case "/Constant" 'I'm ignoring this for now.
                    If FindIndex_In_TableNetLinks(IndexFlowChart) < 1 Then MakeNew_NetLinks(IndexFlowChart, FlowChart_TablePath_Name(IndexFlowChart))
                Case "/error"
                    'MSG_ABug(1078, "MyShowAndUpDateProperties", 0, 2)    ' Not sure if this is a bug
                    'FlowChart_TableCompiledMacroCodeText(IndexFlowChart , "/error" & FD & FlowChart_TableX1(IndexFlowChart ) & FD & FlowChart_TableY1(IndexFlowChart ) & FD & FlowChart_Table_DataType(IndexFlowChart ) & FD & FlowChart_Tablepath_Name(IndexFlowChart ))
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                Case Else
                    MSG_AInfo(1079, "not updating Links for ", FlowChart_TableCode(IndexFlowChart), IndexFlowChart)
            End Select
            'FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol)
            Return RTN
        End Function

        Public Shared Sub MyMouseWheel(e As MouseEventArgs) 'catches the mouse wheel to zoom in or out
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2966, 10, "MyMouseWheel")
#End If
            If e.Delta() > 0 Then
                MyZoomIn()
            ElseIf e.Delta < 0 Then
                MyZoomOut()
            End If
        End Sub



        Public Shared Sub LimitScale()
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2967, 10, "LimitScale")
#End If
            If MyUniverse.SysGen.MyFlowChartScale < ConstantMinFlowChartScale Then
                MyUniverse.SysGen.MyFlowChartScale = ConstantMinFlowChartScale '1/16
                MSG_MyTrace1(1083, "Shared:  Scaled Size changed ()" & MyShowScale() & vbCrLf)
                'todo   ''''' DisplayStatus(FlowChartWindow.LabelProgramStatus.Text, "FlowChart Scale limit is " & CStr(MyUniverse.SysGen.MyFlowChartScale))
            End If
            If MyUniverse.SysGen.MyFlowChartScale > ConstantMaxFlowChartScale Then
                MyUniverse.SysGen.MyFlowChartScale = ConstantMaxFlowChartScale
                MSG_MyTrace1(1085, "Shared:  Scaled Size changed ()" & MyShowScale() & vbCrLf)
                DisplayStatus(FlowChartWindow.LabelProgramStatus, "FlowChart Scale limit is " & CStr(MyUniverse.SysGen.MyFlowChartScale))
            End If
            'todo need to also limit the Symbol scale from 1 to 4?
            If MyUniverse.SysGen.MySymbolScale > 8 Then
                MyUniverse.SysGen.MySymbolScale = 2
                MSG_MyTrace1(1087, "Shared:  Scaled Size changed ()" & MyShowScale() & vbCrLf)
                DisplayStatus(FlowChartWindow.LabelProgramStatus, "Symbol Scale limit is " & MyUniverse.SysGen.MySymbolScale.ToString)
            End If
            If MyUniverse.SysGen.MySymbolScale < 1 Then
                MyUniverse.SysGen.MySymbolScale = 1
                MSG_MyTrace1(1089, "Shared:  Scaled Size changed ()" & MyShowScale())
                DisplayStatus(FlowChartWindow.LabelProgramStatus, "Symbol Scale limit is " & MyUniverse.SysGen.MySymbolScale.ToString)
            End If
        End Sub


        'Routine Makes the pictures bigger
        Public Shared Sub MyZoomIn()
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2968, 10, "MyZoomIn")
#End If
            MyUniverse.SysGen.MyFlowChartScale *= ConstantFlowChartScaleChange
            LimitScale()
            Clear_Window(FlowChartWindow.PictureBox1)
            MyButtonsEnableRules()
        End Sub

        'Routine makes the picture smaller
        Public Shared Sub MyZoomOut() 'e As MouseEventArgs) ' steps scale down
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2969, 10, "MyZoomout")
#End If
            MyUniverse.SysGen.MyFlowChartScale /= ConstantFlowChartScaleChange
            LimitScale()
            Clear_Window(FlowChartWindow.PictureBox1)
        End Sub



        Public Shared Function FillMyPoint() As MyPointStructure
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2970, 10, "FillMyPoint")
#End If
            FillMyPoint.x = 0
            FillMyPoint.y = 0
            FillMyPoint.Named.PathName = ""
            FillMyPoint.Named.SymbolName = ""
            FillMyPoint.Named.PointName = ""
        End Function

        Public Shared Function Rect2MyLine(XYXY As Rectangle) As MyLineStructure
            Rect2MyLine = Nothing
            Rect2MyLine.a.x = XYXY.X
            Rect2MyLine.a.y = XYXY.Y
            Rect2MyLine.b.x = XYXY.Width
            Rect2MyLine.b.y = XYXY.Height
            Return Rect2MyLine
        End Function

        Public Shared Function XY2Rect(x1 As Int32, Y1 As Int32, X2 As Int32, Y2 As Int32) As Rectangle
            Dim Temp As MyPointStructure
            Temp = Copy2WindowXY(FlowChartWindow.PictureBox1, MyPoint1XY(x1, Y1))
#If MINEDEBUG Then
  if mydebug(9) then follow(3453, 1, "Copy from world " & MyShowLineXYXY(x1, Y1, X2, X2) & " to window " & MyShowPoint(Temp))
#End If
            XY2Rect.X = Temp.x
            XY2Rect.Y = Temp.y
#If MINEDEBUG Then
            Temp = Copy2WindowXY(FlowChartWindow.PictureBox1, MyPoint1XY(X2, Y2))
  if mydebug(9) then follow(3454, 1, "Copy from world " & MyShowLineXYXY(x1, Y1, X2, X2) & " to window " & MyShowPoint(Temp))
#End If
            XY2Rect.Width = Temp.x
            XY2Rect.Height = Temp.y
        End Function


        Public Shared Sub MarkWorldHere(X As Int32, y As Int32, MyText As String, ColorName As String)
            Dim size As Int32
            Dim RectXY As Rectangle
            Dim XY1 As Point
            Dim XY2 As F_C.MyPointStructure
#If MINEDEBUG Then
                    If MyDebug(7 ) then follow(2971, 7, "MarkWorldHere " & X.ToString & FD & y.ToString & FD & SHL(MyText) & FD & MyShowWindowSizes() & FMB(X, y))
#End If

            size = 4
            RectXY = XY2Rect(X, y, X + size, y + size)
            XY1.X = X + size : XY2.x = X + size
            XY1.Y = y + size : XY2.y = y + size

            'CaptionFont        Gets a Font that Is used to display text in the title bars of windows.
            'DefaultFont        Gets the default font that applications can use for dialog boxes And forms.
            'DialogFont         Gets a font that applications can use for dialog boxes And forms.
            'IconTitleFont      Gets a Font that Is used for icon titles.
            'MenuFont           Gets a Font that Is used for menus.
            'MessageBoxFont     Gets a Font that Is used for message boxes.
            'SmallCaptionFont   Gets a Font that Is used To display text In the title bars Of small windows, such as tool windows.
            'StatusFont         Gets a Font that Is used to display text in the status bar.
#If MINEDEBUG Then
  if mydebug(9) then follow(3376, 1, " Draw at " & MyShowLineXYXY(Rect2MyLine(RectXY)))
#End If
            FlowChartWindow.PictureBox1.CreateGraphics.DrawString(MyText, SystemFonts.GetFontByName("DefaultFont"), GetBrush(ColorName), RectXY)
            'MyDrawText(FlowChartWindow.PictureBox1, XY, MyText, 60)
            XY2 = Nothing
            XY2.x = X
            XY2.y = y
            XY2 = Copy2WindowXY(FlowChartWindow.PictureBox1, XY2)

            QuickDrawLine(RectXY.X + size, RectXY.Y + size, RectXY.X - size, RectXY.Y - size)
            QuickDrawLine(RectXY.X + size, RectXY.Y - size, RectXY.X - size, RectXY.Y + size)
            QuickDrawLine(RectXY.X - size, RectXY.Y, RectXY.X + size, RectXY.Y)
            QuickDrawLine(RectXY.X, RectXY.Y + size, RectXY.X, RectXY.Y - size)
        End Sub






        Public Shared Sub MarkHere(X As Int32, y As Int32, MyText As String, ColorName As String)
            DebugPrint("206 ," & "World or window " & MyShowPoint(X, y) & ColorName)
            MarkWindowHere(X, y, MyText, ColorName)
        End Sub



        Public Shared Sub MarkWindowHere(X As Int32, y As Int32, MyText As String, ColorName As String)
            Dim size As Int32
            Dim XYXY As Rectangle
            Dim XY As Point
#If MINEDEBUG Then
                    If MyDebug(5 ) then follow(2971, 5, "MarkWindowHere " & X.ToString & FD & y.ToString & FD & SHL(MyText) & MyShowWindowSizes() & FMB(X, y))
#End If
            size = 4
            XYXY.X = X
            XYXY.Y = y
            XYXY.Height = y + size * 2
            XYXY.Width = X + size * 2
            XY.X = X + size
            XY.Y = y + size
            'CaptionFont        Gets a Font that Is used to display text in the title bars of windows.
            'DefaultFont        Gets the default font that applications can use for dialog boxes And forms.
            'DialogFont         Gets a font that applications can use for dialog boxes And forms.
            'IconTitleFont      Gets a Font that Is used for icon titles.
            'MenuFont           Gets a Font that Is used for menus.
            'MessageBoxFont     Gets a Font that Is used for message boxes.
            'SmallCaptionFont   Gets a Font that Is used To display text In the title bars Of small windows, such as tool windows.
            'StatusFont         Gets a Font that Is used to display text in the status bar.
            FlowChartWindow.PictureBox1.CreateGraphics.DrawString(MyShowXY(X, y) & MyText, SystemFonts.GetFontByName("DefaultFont"), GetBrush(ColorName), XYXY)
            'MyDrawText(FlowChartWindow.PictureBox1, XY, MyText, 60)
            If X < 2000 Then
                XYXY.X = XY.X
                XYXY.Y = XY.Y
                QuickDrawLine(XYXY.X + size, XYXY.Y + size, XYXY.X - size, XYXY.Y - size)
                QuickDrawLine(XYXY.X + size, XYXY.Y - size, XYXY.X - size, XYXY.Y + size)
                QuickDrawLine(XYXY.X - size, XYXY.Y, XYXY.X + size, XYXY.Y)
                QuickDrawLine(XYXY.X, XYXY.Y + size, XYXY.X, XYXY.Y - size)
            End If
        End Sub

        Public Shared Sub QuickDrawLine(x1 As Int32, y1 As Int32, x2 As Int32, y2 As Int32)
            Dim XY1, XY2 As Point
            XY1.X = x1
            XY1.Y = y1
            XY2.X = x2
            XY2.Y = y2
            FlowChartWindow.PictureBox1.CreateGraphics.DrawLine(Pens.Black, XY1, XY2)
        End Sub

        Public Shared Sub PanTo(X As Int32, Y As Int32)
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2972, 10, "PanTo " & MyShowPoint(X, Y))
#End If


            MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.x = X - CInt(FlowChartWindow.PictureBox1.Width / MyUniverse.SysGen.MyFlowChartScale / 2)
            MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.y = Y - CInt(FlowChartWindow.PictureBox1.Height / MyUniverse.SysGen.MyFlowChartScale / 2)


            Clear_Window_Only(FlowChartWindow.PictureBox1)
            PaintAll(FlowChartWindow.PictureBox1, 1, TopOfFile("FlowChart"))
            MarkWorldHere(X, Y, "Pan to Center", "Brown")
            Return
        End Sub


        'Routine just save where the mouse went down at.
        Public Shared Sub MyMouseDown(e As MouseEventArgs) 'saves xy for mouse button pushed down
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2973, 10, "MyMouseDown")
#End If
            MyUniverse.Area.MyInputWindowXY.a.x = e.X
            MyUniverse.Area.MyInputWindowXY.a.y = e.Y
            MyUniverse.MyMouseAndDrawing.MouseStroke = "" 'New Symbol
        End Sub

        Public Shared Sub MyPlacement(AddOrNot As Boolean)
            Dim x, y, s, maxXY1 As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2974, 10, "MyPlacement")
#End If
            'Const PlaceMent As Int32 = 4 'times the size of the Symbol (/2)
            ''''''  MyUniverse.SysGen.Snaps.MaxSymbolInYSpacing = MyUniverse.SysGen.Constants.ConstantSymbolCenter * MyUniverse.SysGen.Constants.ConstantSpacingFactor
            x = MyUniverse.SysGen.Placement.x
            y = MyUniverse.SysGen.Placement.y
            s = MyUniverse.SysGen.Constants.ConstantSymbolCenter
            maxXY1 = MyUniverse.SysGen.Snaps.MySymbolSnap * 100
            If AddOrNot = True Then
                y += MyUniverse.SysGen.Snaps.MySymbolSnap
            End If
            If y > maxXY1 Then
                x += MyUniverse.SysGen.Snaps.MySymbolSnap               ' Move over 
                y = s * 2
            End If
            If x < MyUniverse.SysGen.Snaps.MySymbolSnap Then
                x = MyUniverse.SysGen.Snaps.MySymbolSnap
            End If
            If y < s Then
                y = MyUniverse.SysGen.Snaps.MySymbolSnap
            End If
            MyUniverse.SysGen.Placement = MySymbolSnap(MyPoint1XY(x - CInt(FlowChartWindow.PictureBox1.Width / 20), y - CInt(FlowChartWindow.PictureBox1.Height / 20)))
            If MyDebug(5) = True Then If mydebug(9) Then follow(2775, 5, " ZeroZero = " & MyShowPoint(x, y))
            If MyDebug(5) = True Then If mydebug(9) Then follow(2776, 5, " ZeroZero = " & MyShowPoint(0, 0))
            PanTo(x, y) 'should pan to this xy location to be the center of the picture window
            MarkWorldHere(x, y, "Placement center", "Yellow")
        End Sub


        Public Shared Function MySnapindex(IndexFlowChart As Int32) As MyLineStructure ', XY As Int32)
            Dim XYZ As MyLineStructure
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2975, 10, "MySnapIndex")
#End If
            XYZ.a.x = FlowChart_TableX1(IndexFlowChart)
            XYZ.a.y = FlowChart_TableY1(IndexFlowChart)
            XYZ.b.x = FlowChart_TableX2(IndexFlowChart)
            XYZ.b.y = FlowChart_TableY2(IndexFlowChart)
            MySnapindex = MySnapXYXY(FlowChart_TableCode(IndexFlowChart), XYZ.a.x, XYZ.a.y, XYZ.b.x, XYZ.b.y)
        End Function

        Public Shared Function MySnapXYXY(FlowChartCOde As String, X1 As Int32, Y1 As Int32, X2 As Int32, Y2 As Int32) As MyLineStructure
            'IndexFlowChart As Int32) As MyLineStructure
            Dim XY As MyLineStructure
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2976, 10, "MySnapXYXY")
#End If
            MySnapXYXY = Nothing
            XY = Nothing
            MySnapXYXY.a.Named.SymbolName = "?998?"
            'XYZ.a.x = FlowChart_TableX1(IndexFlowChart)
            'XYZ.a.y = FlowChart_TableY1(IndexFlowChart)
            XY.a.Named.PathName = "?999?"
            XY.a.x = X1
            XY.a.y = Y1
            Select Case LCase(FlowChartCOde) 'FlowChart_TableCode(IndexFlowChart)
                Case "/Constant"
                    Return MyLineXY(MyPoint1XY(X1, Y1), MyUniverse.MyStaticData.ZeroZero)
                Case My_keyWord(My_KeyConstUse)
                    Return MyLineXY(MySymbolSnap(MyPoint1XY(X1, Y1)), MyUniverse.MyStaticData.ZeroZero)
                Case "/path"
                    XY.b.x = X2 'FlowChart_TableX2(IndexFlowChart)
                    XY.b.y = Y2 'FlowChart_TableY2(IndexFlowChart)
                    MyPathSnap(MySnapXYXY, XY)
                Case "/error"
                    Return MyLineXY(MyPoint1XY(X1, Y1), MyUniverse.MyStaticData.ZeroZero)
                Case "/unknown"
                    Return MyLineXY(MyPoint1XY(X1, Y1), MyUniverse.MyStaticData.ZeroZero)
                Case "/point"
                    MSG_ABug(1096, "Can not have a point in a flow chart, only inside a Symbol", MyShowPoint(X1, Y1), "")
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                Case Nothing
                    Return MyLineXY(MyPoint1XY(X1, Y1), MyUniverse.MyStaticData.ZeroZero)
                Case "/delete"
                    Return MyUniverse.MyStaticData.ZeroZeroZeroZero
                Case Else
                    MSG_ABug(1097, "This is not movable to a grid", FlowChartCOde, X1.ToString & "," & Y1.ToString & "," & X2.ToString & "," & Y2.ToString)
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                    Return MyLineXY(MyPoint1XY(X1, Y1), XY.b) ' no snap
            End Select
        End Function

        'todo need to also have a snaptoline-1, snaptoSymbol-1000
        Public Shared Sub AllPaths2PointSnap(Where As PictureBox) ' moves all path ends to connect to something
            Dim IndexFlowChart, Jdex As Int32
            Dim XY As MyPointStructure
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2977, 10, "AllPaths2PointSnap")
#End If
            XY = Nothing
            For IndexFlowChart = 1 To TopOfFile("FlowChart")
                MyShowAndUpDateProperties(IndexFlowChart) ', 0, FlowChart_FilePathSymbolName(IndexFlowChart))
                Select Case LCase(FlowChart_TableCode(IndexFlowChart))
                    Case MyKeyword_2_Byte("/path").ToString  'KeyConstPath
                        XY.x = FlowChart_TableX1(IndexFlowChart)
                        XY.y = FlowChart_TableY1(IndexFlowChart)
                        Jdex = MyFindPoint(Where, XY, IndexFlowChart)
                        XY.x = FlowChart_TableX2(IndexFlowChart)
                        XY.y = FlowChart_TableY2(IndexFlowChart)
                        Jdex = MyFindPoint(Where, XY, IndexFlowChart)
                End Select
            Next
        End Sub


        Public Shared Function RandomColor() As String
            Static LastColor As Int32 = 0
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2978, 10, "RandomColor")
#End If
            LastColor = (LastColor + 1) Mod TopOfFile("Color")
            Return Color_TableName(LastColor)
        End Function


        'Routine Most everything is done in mouse up button
        Public Shared Sub MyMouseMove(Where As PictureBox, e As MouseEventArgs)
            Dim XY As MyPointStructure
            Dim XY2 As MyPointStructure
            Dim What As String
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2979, 10, "MyMouseMove")
#End If
            If ProgramBuzzy("Begin") Then Return

            If Where.Parent.Name = FlowChartWindow.Name Then
                What = "/path"
            Else
                What = "/line"
            End If


            'todo is this nessary '''XY = Nothing
            XY2 = Nothing
            XY2.x = e.X
            XY2.y = e.Y


            ' This is here only to remind me to do something about it.
            Select Case (e.Button)
                Case MouseButtons.Left
                Case MouseButtons.Right
                Case MouseButtons.Middle
                Case MouseButtons.None
                Case MouseButtons.XButton1
                Case MouseButtons.XButton1
            End Select

            Select Case LCase(Trim(MyUniverse.SysGen.Constants.MyCmdModeString))
                Case "CmdMoveHand" ' This should move the pictures to where the mouse is let go.
                    If MyDebug(9) Then follow(2140, "Move hand was selected")
    'todo need to add a bit map move of the picture1 bit map image.(phase 2)
                Case "CmdAddPath" ' do nothing (later draw line where line should go (and delete the previous line))
                    XY = Copy2WorldXY("/path", Where, XY2)
                    Select Case (e.Button)
                        Case MouseButtons.Left ' Draw a following line only if you use the left button
                            MyDrawLineXY_XY(Where, MyUniverse.Area.MyWorldXY, "WHITE") 'Erase the last line
                            MyUniverse.Area.MyInputWindowXY.b.x = e.X
                            MyUniverse.Area.MyInputWindowXY.b.y = e.Y
                            MyUniverse.Area.MyWorldXY.a = Copy2WorldXY("/path", Where, MyUniverse.Area.MyInputWindowXY.a)
                            MyUniverse.Area.MyWorldXY.b = Copy2WorldXY("/path", Where, MyUniverse.Area.MyInputWindowXY.b)
                            'MakePathOrthogonal(MyUniverse.Area)
                            MyDrawLineXY_XY(Where, MyUniverse.Area.MyWorldXY, "Black")   ' width should/can only be one 
                        Case MouseButtons.Right ' Reserved for /Stroke
                        Case MouseButtons.Middle
                        Case MouseButtons.None
                        Case MouseButtons.XButton1
                        Case MouseButtons.XButton1
                    End Select
                Case "CmdDelete"
                Case "Command_Add_Symbol" ' do nothing (We should be in the select Symbol mode just before this
                Case "CmdAddPoint"
                Case "CmdAddLine"
                Case "CmdMove"
                    MyUniverse.SysGen.Constants.MyCmdModeString = MyUniverse.SysGen.Constants.MyCmdModeString
                Case Nothing, "", "?"
                    MarkWorldHere(MyUniverse.Area.MyWorldXY.a.x, MyUniverse.Area.MyWorldXY.a.y, "MoveMouse ", "BLUE")
                    MarkWorldHere(MyUniverse.Area.MyWorldXY.b.x, MyUniverse.Area.MyWorldXY.b.y, "Move to ", "ORANGE")
                    MyDrawLineXY_XY(Where, MyUniverse.Area.MyWorldXY, "RED") 'todo remove this
                    'todo need to change this to the 'background color"
                    MyDrawLineXY_XY(Where, MyUniverse.Area.MyWorldXY, "lightGray") 'Erase the last line
                    MyUniverse.Area.MyInputWindowXY.b.x = e.X
                    MyUniverse.Area.MyInputWindowXY.b.y = e.Y
                    MyUniverse.Area.MyWorldXY.a = Copy2WorldXY(What, Where, MyUniverse.Area.MyInputWindowXY.a)
                    MyUniverse.Area.MyWorldXY.b = Copy2WorldXY(What, Where, MyUniverse.Area.MyInputWindowXY.b)
                    MyDrawLineXY_XY(Where, MyUniverse.Area.MyWorldXY, RandomColor()) 'Erase the last line
                Case Else
                    MSG_ABug(1102, "MyMouseMove() : Error ", HighLight(MyUniverse.SysGen.Constants.MyCmdModeString), "Unknown Command Mode")
                    If MyOptionTest(25) = True Then
                    Else
                    End If
            End Select
        End Sub


        Public Shared Sub FlashLine_NotUsed(where As PictureBox, NewXY As MyPointStructure)
            Dim Temp As MyLineStructure
            Dim What As String
            'todo get rid of not used stuff (After making sure it's not called.
            If where.Parent.Name = FlowChartWindow.Name Then
                What = "/path"
            Else
                What = "/line"
            End If
            Temp = MyUniverse.Area.MyWorldXY
            MyDrawLineXY_XY(where, Temp, "WHITE") 'Erase the last line
            Temp.b = Copy2WorldXY(What, where, NewXY)
            MyDrawLineXY_XY(where, MyUniverse.Area.MyWorldXY, RandomColor()) 'Erase the last line
        End Sub

        'Routine This is the major routines to do everything the user wanted with the mouse button UP .
        Public Shared Sub MyMouseUp(Where As PictureBox, e As MouseEventArgs)
            Dim IndexNamed, IndexSymbol, IndexFlowChart As Int32
            Dim TempDebug As String
            Dim Temp As MyPointStructure
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2980, 10, "MyMouseMove")
#End If
            Temp = Nothing
            MyUniverse.Area.MyInputWindowXY.b.x = e.X 'Where the mouse button is up
            MyUniverse.Area.MyInputWindowXY.b.y = e.Y

            'Convert the mouse down and mouse up to be in real world (vs Window world) numbers
            ' This is now failing, and always returns -500,-500
            If MyUniverse.SysGen.MinBox < MyUniverse.SysGen.Constants.ConstantMinBoxSize Then MyUniverse.SysGen.MinBox = MyUniverse.SysGen.Constants.ConstantMinBoxSize
            Select Case LCase(Trim(MyUniverse.SysGen.Constants.MyCmdModeString))
                Case "", Nothing
                Case "CmdMoveHand"
                    MSG_AInfo(1104, MyUniverse.SysGen.MyFlowChartScale.ToString, MyShowPoint(MyUniverse.Area.MyInputWindowXY.a) & vbTab & MyShowPoint(MyUniverse.Area.MyInputWindowXY.b.x), MyDistance(MyUniverse.Area.MyInputWindowXY.a, MyUniverse.Area.MyInputWindowXY.b))
                    MSG_ABug(1106, MyUniverse.Area.MyInputWindowXY.a.x.ToString, MyUniverse.Area.MyInputWindowXY.b.x.ToString, ((MyUniverse.Area.MyInputWindowXY.b.x - MyUniverse.Area.MyInputWindowXY.a.x) * MyUniverse.SysGen.MyFlowChartScale).ToString)
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                    Temp.x = MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.x + (MyUniverse.Area.MyInputWindowXY.a.x - MyUniverse.Area.MyInputWindowXY.b.x) * 4
                    Temp.y = MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.y + (MyUniverse.Area.MyInputWindowXY.a.y - MyUniverse.Area.MyInputWindowXY.b.y) * 4
                    Temp = Copy2WorldXY("/", FlowChartWindow.PictureBox1, Temp)

                    'Reset to Window coordinate ..
                    MyUniverse.MyMouseAndDrawing.MyScrenZeroZero = Copy2WindowXY(FlowChartWindow.PictureBox1, Temp)
                    'todo is this nessary '''Temp = MyUniverse.MyMouseAndDrawing.MyScrenZeroZero  'hack to wach for debug
                    Clear_Window_Only(FlowChartWindow.PictureBox1)
                    PaintAll(Where, TopOfFile("FlowChart") - 2, TopOfFile("FlowChart"))
                Case "CmdAddPath"
                    MyUniverse.Area.MyWorldXY.a = Copy2WorldXY("/path", Where, MyUniverse.Area.MyInputWindowXY.a) 'Mouse button down
                    MyUniverse.Area.MyWorldXY.b = Copy2WorldXY("/path", Where, MyUniverse.Area.MyInputWindowXY.b) ' Mouse button up

                    MyMakeArraySizesBigger()
                    'Search for the closest point First and then connect it
                    IndexFlowChart = NewFlowChartRecord()
                    'FlowChart_TablePathName(IndexFlowChart , MakeNewName("Path1", 0))   'unnamed path
                    If Len(FlowChartWindow.ToolStripTextBoxMyInputText.Text) = 0 Then
                        FlowChartWindow.ToolStripTextBoxMyInputText.Text = FindPathNameAtLine()
                        If Len(FlowChartWindow.ToolStripTextBoxMyInputText.Text) = 0 Then
                            FlowChartWindow.ToolStripTextBoxMyInputText.Text = InputBox("Enter the path name", "Unnamed path")
                            If Len(FlowChartWindow.ToolStripTextBoxMyInputText.Text) = 0 Then
                                FlowChartWindow.ToolStripTextBoxMyInputText.Text = MakeNewName("Path", "AutoPath")
                                If Len(FlowChartWindow.ToolStripTextBoxMyInputText.Text) = 0 Then
                                    FlowChartWindow.ToolStripTextBoxMyInputText.Text = "Path Name Error"
                                    MSG_ABug(1107, "Failed to name a new path segment", "", FlowChartWindow.ToolStripTextBoxMyInputText.Text)
                                    If MyOptionTest(25) = True Then
                                    Else
                                    End If
                                End If
                            End If
                        End If
                    End If
                    FlowChart_TablePathSymbolName(IndexFlowChart, FlowChartWindow.ToolStripTextBoxMyInputText.Text)

                    FlowChart_TableCode(IndexFlowChart, MyKeyword_2_Byte("/path").ToString)
                    MyPathSnap(MyUniverse.Area.MyWorldXY, MyUniverse.Area.MyWorldXY)

                    FlowChart_TableX1(IndexFlowChart, MyUniverse.Area.MyWorldXY.a.x)
                    FlowChart_TableY1(IndexFlowChart, MyUniverse.Area.MyWorldXY.a.y)
                    FlowChart_TableX2(IndexFlowChart, MyUniverse.Area.MyWorldXY.b.x)
                    FlowChart_TableY2(IndexFlowChart, MyUniverse.Area.MyWorldXY.b.y)
                    FlowChart_Table_DataType(IndexFlowChart, MyUniverse.ProgramOptions.FlowChartTextBox) 'No Information

                    MakePathOrthogonal(IndexFlowChart)
                    'Paint the original end of table record then 
                    PaintAll(Where, IndexFlowChart - 1, IndexFlowChart + 1)
                    ' assume that MakePathOrthogonal adds a record at the end of the table, if not, still no harm? just slower
                    PaintAll(Where, TopOfFile("FlowChart") - 1, TopOfFile("FlowChart") + 1)
                Case "Command_Add_Symbol"

                    MyUniverse.Area.MyWorldXY.a = Copy2WorldXY(My_keyWord(My_KeyConstUse), Where, MyUniverse.Area.MyInputWindowXY.a) 'Mouse button down
                    MyUniverse.Area.MyWorldXY.b = Copy2WorldXY(My_keyWord(My_KeyConstUse), Where, MyUniverse.Area.MyInputWindowXY.b) ' Mouse button up

                    MyMakeArraySizesBigger()
                    If MyUniverse.ProgramOptions.SelectedSymbolName = "" Then
                        ShowAllForms(HideWindow, ShowWindow, HideWindow, ShowWindow)
                        FlowChart_TablePathSymbolName(TopOfFile("FlowChart"), MakeNewName("UseA", "UnknowSymbol" & MyRnd()))
                        Return
                    Else
                    End If
                    IndexFlowChart = NewFlowChartRecord() ' need to have a resort, for the last item added only
                    FlowChart_TableCode(IndexFlowChart, MyKeyword_2_Byte(My_keyWord(My_KeyConstUse)).ToString) 'KeyConstUse) '"/use")
                    FlowChart_TablePathSymbolName(IndexFlowChart, MyUniverse.ProgramOptions.SelectedSymbolName) '
                    FlowChart_TableCode(IndexFlowChart, MyKeyword_2_Byte(My_keyWord(My_KeyConstUse)).ToString) 'KeyConstUse) '"/use")

                    MyUniverse.Area.MyWorldXY.a = MySymbolSnap(MyUniverse.Area.MyWorldXY.a)
                    MyUniverse.Area.MyWorldXY.b = MySymbolSnap(MyUniverse.Area.MyWorldXY.b)

                    FlowChart_TableX1(IndexFlowChart, MyUniverse.Area.MyWorldXY.a.x)
                    FlowChart_TableY1(IndexFlowChart, MyUniverse.Area.MyWorldXY.a.y)
                    FlowChart_Table_Rotation(IndexFlowChart, MyUniverse.ProgramOptions.SelectedRotation) 'Rotation is assumed to be none for now
                    FlowChart_TableOption(IndexFlowChart, "") ' Future opotions

                    CheckForAnySortNeeded(122) 'hack
                    ShowSorts("FlowChart", ReSortFlowChart(IndexFlowChart))
                    CheckForAnySortNeeded(123) 'hack
                    PaintAll(Where, IndexFlowChart - 1, IndexFlowChart + 1)

                Case "CommandAddConstant"
                    MyUniverse.Area.MyWorldXY.a = Copy2WorldXY("/Constant", Where, MyUniverse.Area.MyInputWindowXY.a) 'Mouse button down
                    MyUniverse.Area.MyWorldXY.b = Copy2WorldXY("/Constant", Where, MyUniverse.Area.MyInputWindowXY.b) ' Mouse button up

                    MyMakeArraySizesBigger()

                    IndexFlowChart = NewFlowChartRecord()
                    FlowChart_TableCode(IndexFlowChart, "/Constant")


                    MyUniverse.Area.MyWorldXY.a = MyPointSnap(MyUniverse.Area.MyWorldXY.a)
                    'Why am I snapping to grid the second XY??????? ' Hack need to sdee what I am doing here.
                    MyUniverse.Area.MyWorldXY.b = MyPointSnap(MyUniverse.Area.MyWorldXY.b)

                    FlowChart_TableX1(IndexFlowChart, MyUniverse.Area.MyWorldXY.a.x)
                    FlowChart_TableY1(IndexFlowChart, MyUniverse.Area.MyWorldXY.a.y)
                    FlowChart_Table_DataType(IndexFlowChart, MyUniverse.ProgramOptions.SelectedDataType)

                    'I do not need another record!
                    'IndexFlowChart = NewFlowChartRecord()
                    FlowChart_TableX2(IndexFlowChart, MyUniverse.Area.MyWorldXY.b.x)
                    FlowChart_TableY2(IndexFlowChart, MyUniverse.Area.MyWorldXY.b.y)

                    PaintAll(Where, IndexFlowChart - 1, IndexFlowChart + 1)
                    CheckForAnySortNeeded(124) 'hack
                    ShowSorts("FlowChart", ReSortFlowChart(IndexFlowChart)) ' need to have a resort, for the last item added only
                    CheckForAnySortNeeded(125) 'hack

                Case "CmdAddLine"
                    MyUniverse.Area.MyWorldXY.a = Copy2WorldXY("/line", Where, MyUniverse.Area.MyInputWindowXY.a) 'Mouse button down
                    MyUniverse.Area.MyWorldXY.b = Copy2WorldXY("/line", Where, MyUniverse.Area.MyInputWindowXY.b) ' Mouse button up

                    MyMakeArraySizesBigger()
                    CheckForAnySortNeeded(126)
                    ShowSorts("Named", MyReSort("Named", Named_FileSymbolName, Named_FileSymbolName_ISAM, IndexNamed)) '3/12/19
                    IndexNamed = FindIndexInISAMTable("Named", "add", Named_FileSymbolName, Named_FileSymbolName_ISAM, MyUniverse.ProgramOptions.SelectedSymbolName) '
                    If IndexNamed < 1 Then
                        FindingMyBugs(18)
                        'MyMsgCtr(, "MyMouseUp", MyUniverse.ProgramOptions.SelectedSymbolName, "", "", "", "", "", "", "", "") '
                    End If
                    IndexSymbol = Named_TableSymbolIndexes(IndexNamed)

                    If IndexSymbol = ConstantMyErrorCode Then
                        IndexSymbol = GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName)
                        If IndexSymbol < 1 Then
                            FindingMyBugs(19) 'hack Least amount of checking here 2020 08 04
                            MyInsertSymbolLineRecord(NewTopOfFile("Symbol"), MyUniverse.ProgramOptions.SelectedSymbolName, "/name", MyLine1(MyUniverse.MyStaticData.ZeroZero, MyUniverse.MyStaticData.ZeroZero), "")
                        Else
                            MyInsertSymbolLineRecord(NewTopOfFile("Symbol"), MyUniverse.ProgramOptions.SelectedSymbolName, "/line", MyUniverse.Area.MyWorldXY, "")
                        End If
                        FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol)
                    Else
                        MyInsertSymbolLineRecord(IndexSymbol + 1, Named_TableSymbolName(IndexNamed), "/line", MyUniverse.Area.MyWorldXY, SymbolWindow.ToolStripDropDownButtonColor.ToString)
                        FindingMyBugs(21) 'hack Least amount of checking here 2020 08 04
                    End If
                Case "CmdAddPoint" 'Places a point on the Symbol Window, NOT a Symbol on the FlowChart Window
                    MyUniverse.Area.MyWorldXY.a = Copy2WorldXY("/point", Where, MyUniverse.Area.MyInputWindowXY.a) 'Mouse button down
                    MyUniverse.Area.MyWorldXY.b = Copy2WorldXY("/point", Where, MyUniverse.Area.MyInputWindowXY.b) ' Mouse button up
                    CheckForAnySortNeeded(130)
                    ShowSorts("Named", MyReSort("Named", Named_FileSymbolName, Named_FileSymbolName_ISAM, IndexNamed)) '3/12/19
                    IndexNamed = FindIndexInISAMTable("Named", "add", Named_FileSymbolName, Named_FileSymbolName_ISAM, MyUniverse.ProgramOptions.SelectedSymbolName)
                    IndexSymbol = Named_TableSymbolIndexes(IndexNamed)
                    FixSyntaxCode(IndexNamed)
                    If IndexSymbol <= 0 Then
                        IndexSymbol = GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName)
                        If IndexSymbol < 1 Then
                            ' Add a missing name record to the table
                            MyInsertSymbolLineRecord(NewTopOfFile("Symbol"), Named_TableSymbolName(IndexNamed), "/name", MyUniverse.Area.MyWorldXY, "")
                            IndexSymbol = GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName)
                        Else
                        End If
                    Else
                        If Symbol_TableCoded_String(IndexSymbol) <> "/name" Then ' We have  a wrong Indexes
                            F_C.GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName)
                        End If
                    End If

                    NumberOfGraphicsInASymbol(FindInSymbolList(MyUniverse.ProgramOptions.SelectedSymbolName), 0) 'Get Symbol info only
                    ' This makes sure that the names of the points, and the color of the lines are in the list box 
                    TempDebug = MyUniverse.ProgramOptions.SelectedInputOutput
                    If PrintAbleNull(TempDebug) = "_" Then
                        TempDebug = "Both"
                    End If

                    MyUniverse.Area.MyWorldXY.b.x = MyEnumValue(Pop(TempDebug, MyUniverse.SysGen.Constants.ConstantDelimiters), SymbolWindow.ToolStripDropDownInputOutput)

                    TempDebug = MyUniverse.ProgramOptions.SelectedInputOutput

                    MyUniverse.Area.MyWorldXY.b.x = MyEnumValue(Pop(MyUniverse.ProgramOptions.SelectedInputOutput, MyUniverse.SysGen.Constants.ConstantDelimiters), SymbolWindow.ToolStripDropDownInputOutput)
                    MyUniverse.Area.MyWorldXY.b.y = FindIndexInISAMTable("DataType", "DoNotAdd", DataType_FileName, DataType_Name_ISAM, MyUniverse.ProgramOptions.SelectedDataType)
                    'todo bug in that this is not giving the correct name, and needs to be written
                    FMB1(8000)
                    '''''''''''''''''' if mydebug(9) then follow(2752, 1, MyShowComboBox(SymbolWindow.ComboBoxPointNameList))
                    If MyDebug(10) Then follow(2777, 11, SymbolWindow.ComboBoxPointNameList.ToString)
                    MyInsertSymbolLineRecord(IndexSymbol + 1, MyUniverse.ProgramOptions.SelectedSymbolName, "/point", MyUniverse.Area.MyWorldXY, SymbolWindow.ComboBoxPointNameList.Text)
                    ''''''''''''''''''  if mydebug(9) then follow(2753, 1, MyShowComboBox(SymbolWindow.ComboBoxPointNameList))
                    FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol)
                    FixSyntaxCode(IndexNamed)
                    FindingMyBugs(23) 'hack Least amount of checking here 2020 08 04
                    ' 2020 07 18 meaningless !!!    MyUniverse.Area.MyWorldXY.b.x = SymbolWindow.ToolStripDropDownInputOutput.SelectedIndex
                    FMB1(8001)
                Case "CmdMove"
                    MyCmdMove(Where)
                    FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol)
                Case "CmdDelete"
                    FMB1(8002)
                    MyUniverse.Area.MyWorldXY.a = Copy2WorldXY("/", Where, MyUniverse.Area.MyInputWindowXY.a) 'Mouse button down
                    MyUniverse.Area.MyWorldXY.b = Copy2WorldXY("/", Where, MyUniverse.Area.MyInputWindowXY.b) ' Mouse button up
                    Select Case LCase(Where.Parent.Name)
                        Case "FlowChartwindow"
                            MyUniverse.ProgramOptions.SelectedObject = MyFindPoint(Where, MyUniverse.Area.MyWorldXY.a, 0)
                            PaintErase(Where, MyUniverse.ProgramOptions.SelectedObject)
                            FlowChart_TableCode(MyUniverse.ProgramOptions.SelectedObject, "/delete") 'Delete Mark Only
                            ' We should be turning off the item
                            PaintAll(Where, MyUniverse.ProgramOptions.SelectedObject - 1, MyUniverse.ProgramOptions.SelectedObject + 1)
                        Case "Symbolwindow"
                            MyUniverse.ProgramOptions.SelectedObject = MyFindPoint(Where, MyUniverse.Area.MyWorldXY.a, 0)
                            'PaintErase(Where, MyUniverse.ProgramOptions.SelectedObject)
                            Symbol_TableCode(MyUniverse.ProgramOptions.SelectedObject, "/delete") 'Delete Mark Only
                            FindingMyBugs(24) 'hack Least amount of checking here
                            CheckForAnySortNeeded(134)
                            IndexNamed = FindIndexInISAMTable("Named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, MyUniverse.ProgramOptions.SelectedSymbolName) '
                            CheckForAnySortNeeded(135)
                            If IndexFlowChart = ConstantMyErrorCode Then
                            Else
                                'Named_TableSymbolIndexes( IndexFlowChart , 0) ' Delete the old Indexes (for now)
                                IndexFlowChart = GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName)
                                Clear_Window(Where)
                            End If
                            ' IndexFlowChart  = MyUniverse.SysGen.Constants.ConstantSymbolCenter + MyUniverse.SysGen.Constants.ConstantSymbolCenter
                            PaintEach(SymbolWindow.PictureBox1, MyPoint1XY(MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter), MyUniverse.ProgramOptions.SelectedSymbolName, "Default")'
        ' We should be turning off the item
                        Case "optionswindow"
                    End Select
                Case Else
                    MyMsgCtr(1283, "MyMouseUp", MyUniverse.SysGen.Constants.MyCmdModeString, "", "", "", "", "", "", "", "")
            End Select
            FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol)
            FindingMyBugs(25)
        End Sub



        Public Shared Sub MyCmdMove(Where As PictureBox)
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2981, 10, "MyCmdMove")
#End If
            Select Case LCase(Where.Parent.Name)
                Case "FlowChartwindow"
                    'Get the closest object (/path could be either end of the path)
                    MyUniverse.ProgramOptions.SelectedObject = MyFindPoint(Where, MyUniverse.Area.MyWorldXY.a, 0)
                    'We should flash this object 
                    If MyUniverse.ProgramOptions.SelectedObject > ConstantMyErrorCode Then
                        PaintAll(Where, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.ProgramOptions.SelectedObject)
                        Select Case LCase(FlowChart_TableCode(MyUniverse.ProgramOptions.SelectedObject))
                            Case "/path"
                                ' need to find the closest end to change
                                MyUniverse.Area.MyWorldXY = MySnapindex(MyUniverse.ProgramOptions.SelectedObject)
                                If MyABS(MyUniverse.Area.MyWorldXY.a.x - FlowChart_TableX1(MyUniverse.ProgramOptions.SelectedObject)) +
       MyABS(MyUniverse.Area.MyWorldXY.a.y - FlowChart_TableY1(MyUniverse.ProgramOptions.SelectedObject)) >
       MyABS(MyUniverse.Area.MyWorldXY.a.x - FlowChart_TableX2(MyUniverse.ProgramOptions.SelectedObject)) +
       MyABS(MyUniverse.Area.MyWorldXY.a.y - FlowChart_TableY2(MyUniverse.ProgramOptions.SelectedObject)) Then
                                    PaintErase(Where, MyUniverse.ProgramOptions.SelectedObject)
                                    FlowChart_TableX2(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.x)
                                    FlowChart_TableY2(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.y)
                                Else
                                    PaintErase(Where, MyUniverse.ProgramOptions.SelectedObject)
                                    FlowChart_TableX1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.x)
                                    FlowChart_TableY1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.y)
                                End If
                            Case My_keyWord(My_KeyConstUse)
                                MoveSymbolAndAllPaths(Where, MyUniverse.ProgramOptions.SelectedObject, MyPoint1XY(MyUniverse.Area.MyWorldXY.b.x - MyUniverse.Area.MyWorldXY.a.x, MyUniverse.Area.MyWorldXY.b.y - MyUniverse.Area.MyWorldXY.a.y))
        'Case My_keyWord(My_KeyConstUse)
        '    PaintErase(Where, MyUniverse.ProgramOptions.SelectedObject)
        '    FlowChart_TableX1(MyUniverse.ProgramOptions.SelectedObject, MySymbolSnap(MyUniverse.Area.MyWorldXY.b.x))
        '    FlowChart_TableY1(MyUniverse.ProgramOptions.SelectedObject, MySymbolSnap(MyUniverse.Area.MyWorldXY.b.y))
                            Case "/Constant"
                                PaintErase(Where, MyUniverse.ProgramOptions.SelectedObject)
                                MyUniverse.Area.MyWorldXY.b = MyPointSnap(MyUniverse.Area.MyWorldXY.b)
                                FlowChart_TableX1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.x)
                                FlowChart_TableY1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.y)
                            Case Else
                                MSG_ABug(1110, "Did not move this item", LCase(Trim(FlowChart_TableCode(MyUniverse.ProgramOptions.SelectedObject))), "")
                                'move to where the mouse button let up
                                If MyOptionTest(25) = True Then
                                Else
                                End If
                        End Select

                        'redisplay 1 (We should be turning off the old location)
                        PaintAll(Where, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.ProgramOptions.SelectedObject)
                    Else
                        PaintAll(Where, TopOfFile("FlowChart") - 1, TopOfFile("FlowChart") + 1)
                        MSG_ABug(1111, "invalid movement attempted ", "could not find selected object", MyShowALine(MyUniverse.Area.MyWorldXY))
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                    End If
                Case "Symbolwindow" 'Move
                    'Get the closest object (/path could be either end of the path)
                    MyUniverse.ProgramOptions.SelectedObject = MyFindSymbolPoint(MyUniverse.Area.MyWorldXY.a, MyUniverse.ProgramOptions.SelectedSymbolName) '
                    'We should flash this object 
                    'PaintAll(FlowChartWindow.PictureBox1, MyStaticData.SelectedObject, MyStaticData.SelectedObject)
                    Select Case LCase(Symbol_TableCoded_String(MyUniverse.ProgramOptions.SelectedObject))
                        Case "/line"
                            FindingMyBugs(26) 'hack Least amount of checking here
                            ' need to find the closest end to change
                            If MyABS(MyUniverse.Area.MyWorldXY.a.x - Symbol_TableX1(MyUniverse.ProgramOptions.SelectedObject)) + MyABS(MyUniverse.Area.MyWorldXY.a.y - Symbol_TableY1(MyUniverse.ProgramOptions.SelectedObject)) > MyABS(MyUniverse.Area.MyWorldXY.a.x - Symbol_Table_X2(MyUniverse.ProgramOptions.SelectedObject)) + MyABS(MyUniverse.Area.MyWorldXY.a.y - Symbol_Table_Y2(MyUniverse.ProgramOptions.SelectedObject)) Then

                                Symbol_Table_X2(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.x)
                                Symbol_Table_Y2(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.y)
                            Else
                                Symbol_TableX1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.x)
                                Symbol_TableY1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.y)
                            End If
                        Case "/point"
                            FindingMyBugs(27) 'hack Least amount of checking here
                            'move to where the mouse button let up
                            Symbol_TableX1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.x)
                            Symbol_TableY1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.y)
                        Case Else
                            MSG_ABug(1112, "did not move ", Symbol_TableCoded_String(MyUniverse.ProgramOptions.SelectedObject), "")
                            If MyOptionTest(25) = True Then
                            Else
                            End If
                    End Select
                    'redisplay 1 (We should be turning off the old location)
                    PaintAll(Where, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.ProgramOptions.SelectedObject)
            End Select
        End Sub


        'Gives the Indexes to the data
        Public Shared Function FindISAM_IN_Table(MyTable As String, Myfunction As String, ByRef MyArray() As String, ByRef ISAM() As Int32, WhatToFind As String) As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2982, 10, "FindISAM_IN_Table")
#End If
            If MyCompared1_a(MyUniverse.MyCheatSheet.LastString, WhatToFind) = 0 Then
                If MyUniverse.MyCheatSheet.LastIndex < UBound(MyArray) And MyUniverse.MyCheatSheet.LastIndex > 0 Then
                    If MyCompared1_a(MyArray(MyUniverse.MyCheatSheet.LastIndex), WhatToFind) = 0 Then
                        'A I N F O 2 (8)
                        Return MyUniverse.MyCheatSheet.LastIndex
                    End If
                End If
            End If
            CheckForAnySortNeeded(136)
            FindISAM_IN_Table = FindIndexInISAMTable(MyTable, Myfunction, MyArray, ISAM, WhatToFind)
            CheckForAnySortNeeded(137)
            If FindISAM_IN_Table = ConstantMyErrorCode Then
                FindingMyBugs(28)
            Else
                FindISAM_IN_Table = ISAM(MyMinMax(FindISAM_IN_Table, 1, UBound(MyArray)))
            End If
        End Function



        'Gives the Indexes to the data
        Public Shared Function FindISAM_IN_Table(MyTable As String, ByRef Myfunction As String, ByRef MyArrayLong() As Int32, ByRef ISAM() As Int32, WhatToFind As Int32) As Int32
            Dim I As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2983, 10, "FindISAM_IN_Table")
#End If
            CheckForAnySortNeeded(138)
            I = FindIndexInISAMTable(MyTable, Myfunction, MyArrayLong, ISAM, WhatToFind)
            CheckForAnySortNeeded(139)
            If I = ConstantMyErrorCode Then
                MSG_ABug(1115, MyTable, Myfunction, "")
                If MyOptionTest(25) = True Then
                Else
                End If
                FindISAM_IN_Table = I
            Else
                FindISAM_IN_Table = ISAM(MyMinMax(I, 1, UBound(MyArrayLong)))
            End If
        End Function



        Public Shared Sub SelectInToolStripDropDownButton(CB As ToolStripDropDownButton, WhatToSelect As String)
            Dim I As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2984, 10, "SelectInToolStripDropDownButton")
#End If
            If MyIsNothing(WhatToSelect) Then
                Return
            End If
            'CB.DropDownItems.Find(WhatToSelect, True) ' undone not sure if this will work yet
            If CB.DropDownItems.Count < 1 Then
                Return
            End If
            For I = 0 To CB.DropDownItems.Count - 1
                If CB.DropDownItems(I).Text = WhatToSelect Then
                    If MyDebug(5) Then Follow(2332, "Selecting " & WhatToSelect & " from dropdown " & CB.Name & ".")
                    CB.DropDownItems(I).Select()
                    CB.Text = WhatToSelect
                    Return
                End If
                'todo need to make sure that there is a comma FD there (should pop() it
                If MyLeft(CB.DropDownItems(I).Text, Len(WhatToSelect & FD)) = WhatToSelect & FD Then
                    If MyDebug(5) Then Follow(2333, "Selecting " & WhatToSelect & " from dropdown " & CB.Name)
                    CB.DropDownItems(I).Select()
                    CB.Text = WhatToSelect
                    Return
                End If
            Next
            MSG_ABug(1118, "Unable to find ", WhatToSelect, " Integer dropdown " & CB.Name)
            'todo need to check if something was selected, and if not then select as close as you can get (ie, whattoselct="both", but the button has "Both,3" or "Both, 3")
            If MyOptionTest(25) = True Then
            Else
            End If
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'checking that the Symbol name is not already in the Symbol table
        Public Shared Function CheckNotInList(MyTable As String, ByRef MyArray() As String, ByRef SymbolName As String) As Int32
            Dim LocalIndex As Int32
            For LocalIndex = 1 To TopOfFile(MyTable)
                If MyArray(LocalIndex) = SymbolName Then Return LocalIndex
            Next
            ' Still Not Found 
#If MINEDEBUG Then
                    If MyDebug(7 ) then follow(2985, 7, "CheckNotInList " & MyTable & FD & HighLight(SymbolName))
#End If
            Return ConstantMyErrorCode
        End Function


        Public Shared Function FindMyKeyword(What As String) As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2986, 10, "FindMyKeyWord " & What)
#End If
            Return FindInSortedLanguageList(MyUniverse.SysGen.Constants.SyntaxKeyWords, What, Language_KeyWord)
        End Function

        Public Shared Function FindMyOperator(What As String) As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2987, 10, "FindMyOperator " & What)
#End If
            Return FindInSortedLanguageList(MyUniverse.SysGen.Constants.SyntaxOperators, What, Language_Operator)
        End Function




        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'returns the Indexes to the index of the ISAM 
        Public Shared Function FindIndexInISAMTable(MyTable As String, MyFunction As String, ByRef MyArray() As String, ByRef ISAM() As Int32, WhatToFind As String) As Int32
            ' Follow LocalIndex it is using the top of file twice
            '@@@@@@@@@@@@@@@@@@@@@@@@@ This needs to be changed to a binary search instead of a=going through all of the list
            Dim Jdex, Kdex, LocalIndex As Int32
            Dim ErrorCount As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2988, 10, "FindIndexInISAMTable")
#End If
            If Trim(WhatToFind) = "" Then
                Return ConstantMyErrorCode
            End If
            '20200711 updated cheat 
            ' If what you want to find is already found last time and so check if you do not have to find it again
            If LCase(Trim(MyTable)) = LCase(Trim(MyUniverse.MyCheatSheet.LastISAMStringTable)) Then
                If MyCompared1_a(MyUniverse.MyCheatSheet.LastISAMStringString, WhatToFind) = 0 Then
                    If MyUniverse.MyCheatSheet.LastISAMStringIndex <= TopOfFile(MyTable) Then
                        'A I N F O 2 (-40)
                        Return MyUniverse.MyCheatSheet.LastISAMStringIndex
                    End If
                End If
            End If

            ' Now do binary search for it
            Kdex = TopOfFile(MyTable)

            LocalIndex = MyMinMax(CInt(Kdex / 2), 1, Kdex)
            Jdex = MyMinMax(CInt(LocalIndex / 2), 1, Kdex)

            ErrorCount = 2048


            While ErrorCount > 0
                ErrorCount -= 1
                ' Need test when to exit while
                LocalIndex = MyMinMax(LocalIndex, 1, Kdex)
                Select Case MyCompared3(MyArray(ISAM(LocalIndex)), WhatToFind, MyArray(ISAM(LocalIndex + 1)))
                    Case -5 '-5 A is not <= than C (A>C) Error
                        MSG_ABug(1121, "Compare returns possible error at " & LocalIndex.ToString & " low==>" & MyArray(ISAM(LocalIndex)), " Searching for ===> " & WhatToFind, " Below "(LocalIndex + 1).ToString & " high==>" & MyArray(ISAM(LocalIndex + 1)))
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                        ShowSorts(MyTable, MyReSort(MyTable, MyArray, ISAM, LocalIndex))
                        ShowSorts(MyTable, MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1))
                        ShowSorts(MyTable, MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1))
                        'A I N F O 2 (12)
                        Return FindIndexInISAMTable(MyTable, MyFunction, MyArray, ISAM, WhatToFind)
                    Case -4 '-4 A = start Of list (So Lowest)
                        'When it should be before a list of the same thing.

                        While MyCompared3(MyArray(ISAM(LocalIndex)), WhatToFind, MyArray(ISAM(LocalIndex + 1))) = -4
                            LocalIndex -= 1
                            If LocalIndex = 1 Then
                                LocalIndex = Kdex
                                Exit While
                            End If
                        End While
                        If LocalIndex = 1 Then
                            LocalIndex = Kdex
                            Exit While
                        End If
                        LocalIndex = MyMinMax(LocalIndex + 1, 1, Kdex)
                    Case -3 '-3 A is higher than B  and C = nothing
                        If LocalIndex = 1 Then
                            LocalIndex = Kdex
                            Exit While ' In case what we want is before the beginning
                        End If
                        LocalIndex = MyMinMax(LocalIndex - Jdex, 1, Kdex)
                        Jdex = MyMinMax(CInt(Jdex / 2), 1, Kdex)
                    Case -2 '-2 B is higher than C ' So you have to look forwards 
                        LocalIndex = MyMinMax(LocalIndex + Jdex, 1, Kdex)
                        Jdex = MyMinMax(CInt(Jdex / 2), 1, Kdex)
                    Case -1  '-1 is equal to A and 0 is between A and C
                        MyUniverse.MyCheatSheet.LastISAMStringTable = MyTable
                        MyUniverse.MyCheatSheet.LastISAMStringString = WhatToFind
                        MyUniverse.MyCheatSheet.LastISAMStringIndex = ISAM(LocalIndex)
                        ''A I N F O 2 (-39)
                        Return ISAM(LocalIndex)
                    Case 0 'test 2 & 10 A and C = nothing or A<b<C should be between these two
                        ' binary search is failing here, but check it is not in list is finding it ERROR 'hack
                        'This is all extra code
                        FindIndexInISAMTable = CheckNotInList(MyTable, MyArray, WhatToFind)
                        If FindIndexInISAMTable = ConstantMyErrorCode Then
                            'MSG_AInfo1(1123,  MyArray(ISAM(LocalIndex)), WhatToFind, MyArray(ISAM(LocalIndex + 1)))
                            Exit While
                        Else
                            'MSG_AInfo (1124,  MyArray(ISAM(FindIndexInISAMTable)), WhatToFind, MyArray(ISAM(FindIndexInISAMTable + 1)))
                            'MSG_AInfo1(1125, "binary search Found Item", WhatToFind, MyArray(FindIndexInISAMTable))
                            MyUniverse.MyCheatSheet.LastISAMStringTable = MyTable
                            MyUniverse.MyCheatSheet.LastISAMStringString = WhatToFind
                            MyUniverse.MyCheatSheet.LastISAMStringIndex = FindIndexInISAMTable
                            Return FindIndexInISAMTable
                        End If
                    Case 1 ' 1 B = C
                        LocalIndex = MyMinMax(LocalIndex + 1, 1, Kdex) ' forward on so that you have what you found the one before
                        Jdex = MyMinMax(CInt(Jdex / 2), 1, Kdex)
                    Case 2 ' 2 A is lower than B 
                        LocalIndex = MyMinMax(LocalIndex + Jdex, 1, Kdex) ' back up one
                        Jdex = MyMinMax(CInt(Jdex / 2), 1, Kdex)
                    Case 3 ' 3 Or C is higher then B
                        LocalIndex = MyMinMax(LocalIndex - Jdex, 1, Kdex) ' back up one
                        Jdex = MyMinMax(CInt(Jdex / 2), 1, Kdex)
                    Case 4 ' 4 C is the end of the list (So Highest) [ Found this to not be true when B>A and C=nothing ]  and B > A 
                        LocalIndex += 1 ' To point the the end of the list
                        If MyArray(ISAM(LocalIndex)) > WhatToFind Then
                            MSG_ABug(1126, "Program data error!!! An invalid assumption because the list is not sorted correctly", PrintAbleNull(MyArray(ISAM(LocalIndex))) & " : " & PrintAbleNull(WhatToFind & " : " & MyArray(ISAM(LocalIndex + 1))), "")
                            If MyOptionTest(25) = True Then
                            Else
                            End If
                        End If
                        Exit While 'Insert it at the end if "Add"
                    Case 5 ' 5 Error (unknown relationship)
                        MSG_ABug(1127, MyTable, MyFunction, "")
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                        Return NewTopOfFile(MyTable)
                End Select
            End While
            If WhatToFind = "_" Or WhatToFind = "" Or MyIsNothing(WhatToFind) Then
                'A I N F O 2 (14)
                Return ConstantMyErrorCode
            End If

            If LCase(Trim(MyFunction)) = "add" Then
                LocalIndex = MyMinMax(LocalIndex, 1, NewTopOfFile(MyTable))
                If MyCompared1_a(MyArray(LocalIndex), WhatToFind) = 0 Then ' then we have relly found it
                    CheckThisStringArray(6, MyArray, ISAM, LocalIndex)
                    'A I N F O 2 (23)
                    Return LocalIndex '3/13/19 Should return the one found
                End If



                '20200625 Below fixes a issues' of adding something where there is something already.
                LocalIndex = NewTopOfFile(MyTable)
                While Not MyIsNothing(MyArray(LocalIndex))
                    LocalIndex += 1
                End While

                MyArray(LocalIndex) = WhatToFind
                ISAM(LocalIndex) = LocalIndex
                ShowSorts(MyTable, MyReSort(MyTable, MyArray, ISAM, LocalIndex)) 'sorted
                Select Case LCase(MyTable)'220200711 changed to resort instead of flagging to resort it all
                    Case "color"
                        ShowSorts("Color", MyReSort("Color", Color_FileName, Color_Name_ISAM, LocalIndex)) ' Try to only sort the one added
        'MyUniverse.MyCheatSheet.ColorsSorted += 1 ' Mark as needs sorting
                    Case "DataType"
                        ShowSorts("DataType", MyReSort("DataType", DataType_FileName, DataType_Name_ISAM, LocalIndex))
        'MyUniverse.MyCheatSheet.DataTypeSorted += 1
                    Case "named"
                        ShowSorts("Named", MyReSort("Named", Named_FileSymbolName, Named_FileSymbolName_ISAM, LocalIndex))
        'MyUniverse.MyCheatSheet.NamedSorted += 1
                    Case "FlowChart"
                        ReSortFlowChart(LocalIndex)
                        'MyUniverse.MyCheatSheet.FlowChartSorted += 1
                    Case Else
                        ShowSorts("Color", MyReSort("Color", Color_FileName, Color_Name_ISAM, LocalIndex)) ' Try to only sort the one added
                        ShowSorts("DataType", MyReSort("DataType", DataType_FileName, DataType_Name_ISAM, LocalIndex))
                        ShowSorts("Named", MyReSort("Named", Named_FileSymbolName, Named_FileSymbolName_ISAM, LocalIndex))
                        ShowSorts("Named", MyReSort("Named", Named_FileSyntax, Named_FileSyntax_ISAM, LocalIndex))
                        ReSortFlowChart(LocalIndex)
                End Select
                FindIndexInISAMTable = LocalIndex
            Else ' Not a bug, it just can not be found 
                FindIndexInISAMTable = CheckNotInList(MyTable, MyArray, WhatToFind)
                If FindIndexInISAMTable <= 0 Then
                    FindIndexInISAMTable = ConstantMyErrorCode
                End If
            End If
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' Find the string name in the array of names (table listed for referance only)
        Public Shared Function FindInSortedLanguageList(MyTable As String, ByRef WhatToFind As String, ByRef MyArray() As String) As Int32
            Dim Jdex, Kdex, MaxDex, MinDex, MyErrors As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2989, 10, "FindInSortedLanguageList")
#End If
            ' Never search for no name
            If Trim(WhatToFind) = "" Or MyIsNothing(WhatToFind) Then
                Return ConstantMyErrorCode
            End If
            WhatToFind = MyTrim(WhatToFind)
            If WhatToFind = vbCr Or WhatToFind = vbLf Or WhatToFind = vbCrLf Then
                Return ConstantMyErrorCode
            End If


            MyErrors = 1024  'This is only to avoid looping for ever if there is a issues'
            Kdex = UBound(MyArray) ' Get the top of the array
            FindInSortedLanguageList = MyMinMax(CInt(Kdex / 2), 1, Kdex)    ' The current location of this name 
            Jdex = MyMinMax(CInt(FindInSortedLanguageList / 2), 1, Kdex)    ' How much to move up or down the list

            ' This is to avoid a repeat search of the same thing.Os I check and save the last one that was found, and reuse it again
            If MyUniverse.MyCheatSheet.LastLanguageTable = MyTable Then
                If MyUniverse.MyCheatSheet.LastLanguageString = WhatToFind Then
                    FindInSortedLanguageList = MyUniverse.MyCheatSheet.LastLanguageIndex
                    If FindInSortedLanguageList > UBound(MyArray) Then
                        MSG_ABug(1131, "Index outside the boundaries Array ", FindInSortedLanguageList.ToString, UBound(MyArray).ToString)
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                        FindInSortedLanguageList = UBound(MyArray)
                    End If
                    If MyArray(FindInSortedLanguageList) <> WhatToFind Then 'todo remove this
                        If MyDebug(9) Then follow(2375, WhatToFind)
                    End If
                    Return FindInSortedLanguageList
                End If
            End If

            If MyDebug(8) Then FMB(8005, WhatToFind)
            While MyErrors > 0 ' just to avoid a loop forever
                MyErrors -= 1 ' Can only loop X number of times.
                FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList, 1, Kdex)
                MaxDex = MyMinMax(FindInSortedLanguageList + 1, 1, Kdex)
                MinDex = MyMinMax(FindInSortedLanguageList, 1, Kdex)
                FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList, 1, Kdex) '2020 09 25

                'If MinDex = MaxDex Then
                'BUG min and max get set to be the same
                'End If
                If MyArray(MinDex) = MyArray(MaxDex) And MinDex <> MaxDex And Len(MyArray(MinDex)) <> 0 Then
                    MSG_ABug(2376, "List should never have a duplicate ", MyTable, MyArray(MinDex) & vbCrLf & WhatToFind & vbCrLf & MyArray(MaxDex))
                    If MyOptionTest(25) = True Then
                        MyArray(MaxDex) = MyArray(MaxDex) & MyConstantIgnoreFunctionOperatorKeyWord & MyRnd()
                    Else
                    End If
                End If
                If MyDebug(5) Then Follow(2378, MyArray(MinDex) & vbTab & WhatToFind & vbTab & MyArray(MaxDex))
                If MyDebug(8) Then FMB(1119, vbCrLf & vbTab & MyArray(MinDex) & vbCrLf & vbTab & WhatToFind & vbCrLf & vbTab & MyArray(MaxDex))
                Select Case MyCompared3(MyArray(MinDex), WhatToFind, MyArray(MaxDex))
                    Case -5 '-5 A is not <= than C (A>C) Error
                        MSG_ABug(1132, "FindInSortedLanguageList()", "Sorting bug somewhere else", FindInSortedLanguageList.ToString)
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", MyArray, MinDex))
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", MyArray, FindInSortedLanguageList))
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", MyArray, MaxDex))
                        FindInSortedLanguageList = ConstantMyErrorCode
                        If FindInSortedLanguageList > UBound(MyArray) Then
                            MSG_ABug(1133, "Index outside the boundaries Array ", FindInSortedLanguageList.ToString, UBound(MyArray).ToString)
                            FindInSortedLanguageList = UBound(MyArray)
                            If MyOptionTest(25) = True Then
                            Else
                            End If
                        End If
                        'A I N F O 2 (17)
                        Return FindInSortedLanguageList
                    Case -4 '-4 A = start Of list (So Lowest)
                        If Jdex = 1 Then
                            FindInSortedLanguageList = Kdex
                            Exit While
                        End If
                        If MinDex = MaxDex And FindInSortedLanguageList > 1 Then 'hack
                            FindInSortedLanguageList -= 2 'hack
                        End If 'hack
                        FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList + 1, 1, Kdex)
                    Case -3 'A is higher than B  and C = nothing
                        If MyArray(0) = WhatToFind Then Return 0 'hack
                        If MyArray(1) = WhatToFind Then Return 1 'hack
                        If FindInSortedLanguageList = 1 Then
                            '? Why the end of the list instead of the beginning of the list, 
                            'because A > B, so we should return 1 or not found
                            'todo I removed tjhis !!!!!!!!!!!   FindInSortedLanguageList = Kdex - 1
                            Exit While ' In case what we want is before the beginning
                        End If
                        FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList - Jdex, 1, Kdex)
                        Jdex = MyMinMax(CInt(Jdex / 2), 1, Kdex)
                    Case -2 '-2 B is higher than C ' So you have to look forwards 
                        If FindInSortedLanguageList >= Kdex And Jdex = 1 Then
                            Exit While ' This is then at the end of the list
                        End If
                        FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList + Jdex, 1, Kdex)
                        Jdex = MyMinMax(CInt(Jdex / 2), 1, Kdex)
                    Case -1  '-1 is equal to A and 0 is between A and C
                        MyUniverse.MyCheatSheet.LastLanguageTable = MyTable
                        MyUniverse.MyCheatSheet.LastLanguageString = WhatToFind
                        MyUniverse.MyCheatSheet.LastLanguageIndex = FindInSortedLanguageList
                        If FindInSortedLanguageList > UBound(MyArray) Then
                            MSG_ABug(1134, "Index outside the boundaries Array ", FindInSortedLanguageList.ToString, UBound(MyArray).ToString)
                            If MyOptionTest(25) = True Then
                            Else
                            End If
                            FindInSortedLanguageList = UBound(MyArray)
                        End If
                        'A I N F O 2 (-18)
                        If MyArray(FindInSortedLanguageList) <> WhatToFind Then 'todo remove this
                            If MyDebug(10) Then follow(2379, WhatToFind)
                        End If
                        Return FindInSortedLanguageList
                    Case 0 'test 2 & 10 A and C = nothing or A<b<C should be between these two
                        'resetting it to tray again
                        If MinDex = MaxDex Then 'hack This is to trap issues' when Binary search can not find it.
                            If MinDex = 1 Then 'hack
                                If MyArray(MinDex) = Nothing Then 'hack
                                    'A I N F O 2 (-42)
                                    Return ConstantMyErrorCode 'start of the list, it should have return this already
                                End If
                                If MyArray(MaxDex) = Nothing Then
                                    MSG_AInfo(1135, "error can not find in search " & MinDex & " : " & HighLight(MyArray(MinDex)) & HighLight(WhatToFind) & MaxDex & " : " & HighLight(MyArray(MaxDex)), "", "")
                                    Return ConstantMyErrorCode
                                End If
                            End If
                            If MyArray(MinDex) > WhatToFind Then 'should not have returned zero
                                'MSG_ABug(1136, "error can not find in search " & MinDex & " : " & HighLight(MyArray(MinDex)) & HighLight(WhatToFind) & MaxDex & " : " & HighLight(MyArray(MaxDex)), "", "")
                                If MyOptionTest(25) = True Then
                                Else
                                End If
                                Return ConstantMyErrorCode
                            End If
                            If MyArray(MaxDex) = "" Then
                                If MyArray(MaxDex - 1) = WhatToFind Then 'Should not return zero
                                    FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList - 1, 1, Kdex) ' forward on so that you have what you found the one before' 2020 09 07
                                    Jdex = 1
                                    Exit Select
                                End If
                                If MyArray(MaxDex - 1) <= WhatToFind Then 'Should not return zero
                                    'A I N F O 2 (46)
                                    Return ConstantMyErrorCode ' This is past the end of the file.
                                End If
                                'MSG_ABug(1137, "error can not find in search " & MinDex & " : " & HighLight(MyArray(MinDex)) & HighLight(WhatToFind) & MaxDex & " : " & HighLight(MyArray(MaxDex)), MinDex & vbCrLf & WhatToFind & vbCrLf & MaxDex, "")
                                If MyOptionTest(25) = True Then
                                Else
                                End If
                                Return ConstantMyErrorCode
                            Else
                                'if the min and max is deferent then they must be between them , or else something else, so lets find out
                                If MinDex > MaxDex Then
                                    MSG_ABug(1138, "The search is faulty " & MyTable & " is out of order Report internal bug 7", MinDex.ToString, MaxDex.ToString)
                                    If MyOptionTest(25) = True Then
                                    Else
                                    End If
                                    Return ConstantMyErrorCode
                                End If
                                If MyArray(MinDex) >= MyArray(MaxDex) Then
                                    MSG_ABug(1139, "The list " & MyTable & " is out of order and needs to be sorted - Internal error 7", MyArray(MinDex), MyArray(MaxDex))
                                    If MyOptionTest(25) = True Then
                                    Else
                                    End If
                                    Return ConstantMyErrorCode
                                End If
                            End If

                        Else
                            If MaxDex > 1 Then 'something in the table ??
                                If WhatToFind <> MyArray(MinDex) Then ' Must be placed past the end
                                    'A I N F O 2 (44)
                                    Return ConstantMyErrorCode '-5'end of the file
                                End If
                                'A I N F O 2 (45)
                                Return ConstantMyErrorCode '-6 'issues'
                            End If
                            '? Is this needed?
                            'todo is this nessary '''FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList - Jdex, 1, Kdex) 'hack
                        End If
                        ' FindInSortedLanguageList = ConstantMyErrorCode ' Means that it is not found where it should be at.
                        Exit While
                    Case 1 ' 1 B = C
                        FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList + 1, 1, Kdex) ' forward on so that you have what you found the one before' 2020 09 07
                        Jdex = 1
                    Case 2 ' 2 A is lower than B 
                        FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList + Jdex, 1, Kdex) ' back up one
                        Jdex = MyMinMax(CInt(Jdex / 2), 1, Kdex)
                    Case 3 ' 3 Or C is higher then B
                        FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList - Jdex, 1, Kdex) ' back up one
                        Jdex = MyMinMax(CInt(Jdex / 2), 1, Kdex)

        'todo there is an error here, sometimes , A > B and C=nothing
                    Case 4 ' 4 C is the end of the list (So Highest) and B > A 
                        '2020 09 07 added if it is the last one in the list
                        'If MyIsNothing(MyArray(MaxDex)) Then 'extra
                        'If MyArray(MinDex) > WhatToFind Then
                        'MSG_ABug(1140, "The comparing at the end of a list is wrong", HighLight(MyArray(MinDex)) & HighLight(WhatToFind) & HighLight(MyArray(MaxDex)), "")
                        'End If 'extra
                        'End If 'extra
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                        If MinDex = MaxDex And FindInSortedLanguageList > 2 Then 'hack
                            FindInSortedLanguageList -= 2 'hack
                        End If 'hack
                        If MyArray(FindInSortedLanguageList) = WhatToFind Then
                            MyUniverse.MyCheatSheet.LastLanguageTable = MyTable
                            MyUniverse.MyCheatSheet.LastLanguageString = WhatToFind
                            MyUniverse.MyCheatSheet.LastLanguageIndex = FindInSortedLanguageList
                            If FindInSortedLanguageList > UBound(MyArray) Then
                                MSG_ABug(1141, "Index outside the boundaries Array ", FindInSortedLanguageList.ToString, UBound(MyArray).ToString)
                                FindInSortedLanguageList = UBound(MyArray)
                                If MyOptionTest(25) = True Then
                                Else
                                End If
                            End If
                            Return FindInSortedLanguageList
                        End If
                        Return ConstantMyErrorCode
                    Case 5 ' 5 Error (unknown relationship)
                        If MyIsNothing(WhatToFind) Then
                            Exit While
                        End If
                        If Trim(WhatToFind) = "" Then
                            Exit While
                        End If
                        If WhatToFind = FD Then
                            Exit While
                        End If
                        If WhatToFind = vbCr Or WhatToFind = vbLf Or WhatToFind = vbCrLf Then
                            Exit While
                        End If
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", MyArray, MinDex))
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", MyArray, FindInSortedLanguageList))
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", MyArray, MaxDex))
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", MyArray, UBound(MyArray) - 2))
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", MyArray, UBound(MyArray) - 1))
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", MyArray, UBound(MyArray)))
                        FindInSortedLanguageList = UBound(MyArray)
                        If FindInSortedLanguageList > UBound(MyArray) Then
                            MSG_ABug(1142, "Index outside the boundaries Array ", FindInSortedLanguageList.ToString, UBound(MyArray).ToString)
                            If MyOptionTest(25) = True Then
                            Else
                            End If
                            FindInSortedLanguageList = UBound(MyArray)
                        End If
                        'A I N F O 2 (21)
                        Return FindInSortedLanguageList
                End Select
            End While
            FindInSortedLanguageList = ConstantMyErrorCode
        End Function



        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Gives the Indexes to the index of the ISAM 
        Public Shared Function FindIndexInISAMTable(MyTable As String, ByRef MyFunction As String, ByRef MyArrayLong() As Int32, ByRef ISAM() As Int32, ByRef WhatToFind As Int32) As Int32
            '@@@@@@@@@@@@@@@@@@@@@@@@@ This needs to be changed to a binary search instead of a=going through all of the list
            Dim Index, J, Kdex As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2990, 10, "FindIndexInISAMTable")
#End If

            Kdex = MyMinMax(TopOfFile(MyTable), 1, TopOfFile(MyTable)) '3/15/19 Removed +1  to the index
            Index = MyMinMax(Index, 1, Kdex)
            J = CInt(Index / 2)
            If MyIsNothing(MyArrayLong(1).ToString) Then ' Test for first one
            Else

                'This does no good if I do not set them on finding a match last time
                If MyUniverse.MyCheatSheet.LastISAMNumberTable = MyTable Then
                    If MyCompared1(MyUniverse.MyCheatSheet.LastISAMNumberNumber, WhatToFind) = 0 Then
                        If MyUniverse.MyCheatSheet.LastISAMNumberIndex <= Kdex Then
                            If MyArrayLong(ISAM(MyUniverse.MyCheatSheet.LastISAMNumberIndex)) = WhatToFind Then
                                'A I N F O 2 (49)
                                Return ISAM(MyUniverse.MyCheatSheet.LastISAMNumberIndex)
                            End If
                        End If
                    End If
                End If
                While 1 = 1 ' Forever loop
                    'todo need to see if this needs to be added back     Mydoevents(214)
                    If MyCompared2(MyArrayLong, ISAM, Index - 1, Index) = 1 And '  MyArrayLong(ISAM(Index - 1)), MyArrayLong(ISAM(Index))) = 1 And
        MyCompared2(MyArrayLong, ISAM, Index, Index + 1) = -1 Then 'MyArrayLong(ISAM(Index)), MyArrayLong(ISAM(Index + 1))) = -1 Then
                        'The MyArrayLong is not in the correct order
                        CheckForAnySortNeeded(144) 'hack
                        ShowSorts(MyTable, MyReSort_long(MyTable, MyArrayLong, ISAM, MyMinMax(Index - 1, 1, Kdex)))
                        ShowSorts(MyTable, MyReSort_long(MyTable, MyArrayLong, ISAM, MyMinMax(Index, 1, Kdex)))
                        ShowSorts(MyTable, MyReSort_long(MyTable, MyArrayLong, ISAM, MyMinMax(Index + 1, 1, Kdex)))
                        CheckForAnySortNeeded(145) 'hack
                    End If

                    If MyCompared1(MyArrayLong(ISAM(Index)), WhatToFind) < 0 And
        MyCompared1(MyArrayLong(ISAM(Index + 1)), WhatToFind) > 0 Then
                        'FindIndexInISAMTable = Index
                        Exit While
                    End If

                    Select Case MyCompared1(MyArrayLong(ISAM(Index)), WhatToFind)
                        Case -3
                            Index += J
                        Case -2
                            Index += J
                        Case -1
                            Index += J
                        Case 0 ' Match so return
                            While Index > 0 And MyArrayLong(Index) = WhatToFind
                                Index -= 1
                            End While
                            'FindIndexInISAMTable = Index
                            MyUniverse.MyCheatSheet.LastISAMNumberTable = MyTable
                            MyUniverse.MyCheatSheet.LastISAMNumberNumber = WhatToFind
                            MyUniverse.MyCheatSheet.LastISAMNumberIndex = Index
                            'A I N F O 2 (50)
                            Return ISAM(MyUniverse.MyCheatSheet.LastISAMNumberIndex)
                        Case 1
                            Index -= J
                        Case 2
                            Index -= J
                        Case 3
                            Index -= J
                        Case Else
                            Index += J
                    End Select
                    If Index > Kdex And J = 1 Then
                        'J = 0
                        Exit While
                    End If

                    'This return the negitive if between
                    If Index < 1 Then
                        If MyCompared1(MyArrayLong(ISAM(1)), WhatToFind) = 1 Then
                            'J = 0
                            Index = -Index
                            Exit While
                        End If
                    End If
                    Index = MyMinMax(Index, 1, Kdex)
                    If Index = 1 Then
                        If MyCompared1(MyArrayLong(ISAM(1)), WhatToFind) = 1 Then
                            Index = ConstantMyErrorCode
                            Exit While
                        End If
                    End If
                    If ISAM(Index) <> 0 Then
                        If J = 1 Then
                            If MyCompared1(MyArrayLong(ISAM(Index)), WhatToFind) = -1 Then
                                If MyCompared1(MyArrayLong(ISAM(MyMinMax(Index + 1, 1, Kdex))), WhatToFind) >= 1 Then
                                    'J = 0
                                    Exit While
                                End If
                            End If
                        End If
                    End If
                    J = MyMinMax(CInt(J / 2), 1, Kdex)
                End While
            End If

            If LCase(MyFunction) = "add" Then
                FindingMyBugs(29)
                '@@@@@@@ hack because I still have a bug keeping the MyArray sorted.
                'Last attempt to find be3cause I've got a bug
                For Index = 1 To UBound(MyArrayLong)
                    If MyCompared1(MyArrayLong(Index), WhatToFind) = 0 Then
                        MyMsgCtr(1215, "FindIndexInISAMTable", MyArrayLong(Index).ToString, WhatToFind.ToString, "", "", "", "", "", "", "")
                        SortALLISAM() 'Resort everything 
                        FindingMyBugs(31)
                        Return Index
                    End If
                Next Index
                ' If the above fails then try a SLOW loop of everything
                '@@@@@@@@ End of hack 

                Index = TopOfFile(MyTable)
                If MyIsNothing(MyArrayLong(Index).ToString) Then
                Else
                    Index += 1
                End If


                FindingMyBugs(32)
                MyArrayLong(Index) = WhatToFind
                FindIndexInISAMTable = Index
                ISAM(Index) = Index
                CheckForAnySortNeeded(148) 'hack
                ShowSorts(MyTable, MyReSort(MyTable, MyArrayLong, ISAM, Index))
                CheckForAnySortNeeded(149) 'hack
            Else
                FindIndexInISAMTable = Index - 1
            End If
            Return FindIndexInISAMTable
        End Function


        Public Shared Function FindIndex1(ISAM() As Int32) As Int32
            Dim I As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2991, 10, "FindIndex1")
#End If
            For I = 1 To UBound(ISAM) - 1
                If ISAM(I) = 1 Then
                    Return I 'First in the list
                End If
            Next
            MSG_ABug(1145, "This ISAM has no beginning", "", "")
            If MyOptionTest(25) = True Then
            Else
            End If
            Return ConstantMyErrorCode
        End Function


        Public Shared Function IsMyDigit(A As String) As Boolean
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2992, 10, "IsMyDigit")
#End If
            If MyLeft(A, 1) >= "0" And MyLeft(A, 1) <= "9" Then
                Return True
            End If
            Return False
        End Function

        Public Shared Function PowerOf3(K As String) As Boolean
            Dim j1, j2, j3, j4 As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2993, 10, "PowerOfThree")
#End If
            If K = "" Then Return False
            j1 = CInt(Fix(Val(Mid(K, 1, 1))))
            j2 = CInt(Fix(Val(Mid(K, 2, 1))))
            j3 = CInt(Fix(Val(Mid(K, 3, 1))))
            j4 = j1 + j2 + j3
            If j4 Mod 3 = 0 Then Return True
            If j4 = 3 Then Return True
            If j4 = 6 Then Return True
            If j4 = 9 Then Return True
            If Len(K.ToString) < 2 Then Return False
            If PowerOf3(j4.ToString) = True Then Return True
            Return False
        End Function


        Public Shared Function SK(I As Int32, A As String) As String
            Dim K As String
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2994, 10, "SK")
#End If
            K = Mid(A, I, 1)
            If PopValue(K) > 3 Then
                Mid(A, I, 1) = "Y"
            Else
                Mid(A, I, 1) = "N"
            End If
            Return A
        End Function
        'todo needs to save the key in the registery
        Public Shared Function SecurityKey(ByRef X As String) As String
            Dim K As String
            Dim I As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2995, 10, "SecurityKey")
#End If

            'for security key
            '1 must be 16 digits long
            If Len(X) <> 16 Then
                ' A I N F O 2 (53)
                Return X
            End If

            '2 They must all be digits.
            For I = 1 To 16
                If IsMyDigit(Mid(X, I, 1)) = False Then
                    ' A I N F O 2 (52)
                    Return X
                End If
            Next

            '3 digits they must add up to 9
            For I = 1 To 14 Step 3
                K = Mid(X, I, 1) & Mid(X, I + 1, 1) & Mid(X, I + 2, 1)
                If PowerOf3(K) = False Then
                    Return X
                End If
            Next I

            If X = "1234567891234560" Then Return X

            For I = 1 To 16
                X = SK(I, X)
            Next
            'byte 1 means they do something (disallow this program from running (just in case), disable all buttons (except maybe the select a computer language? may be not )
            'Byte 2 means not demo, they can input or output
            'byte 3 means read only, they can not make changes to anything.(Or save anything?)
            'byte 4 means student they can make changes to the Symbol.)Or save Symbols?
            'byte 5 is the level they are allowed (A-Z)
            'byte 6 is the level they are at.(A-Z)
            Return X
        End Function


        Public Shared Function Security_Option(Level As Int32) As Int32
            'This will return if this option is on(1) or off (0) or the level of this option (student, beginning, etc)
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2996, 10, "SecurityOption")
#End If
            If Level > Len(MyUniverse.Security) Then Return 0
            Select Case Mid(MyUniverse.Security, Level, 1)
                Case "N", "n"
                    Return 0
                Case "Y", "y"
                    Return 1
                    'future security options
                Case "a", "A"
                    Return 2
                Case "b", "B"
                    Return 2
                Case "c", "C"
                    Return 3
                Case "d", "D"
                    Return 4
                Case "e", "E"
                    Return 5
                Case "f", "F"
                    Return 6
                Case "g", "G"
                    Return 7
                Case "h", "H"
                    Return 8
                Case "i", "I"
                    Return 9
                Case "j", "J"
                    Return 10
                Case Else
                    Return Asc(Mid(MyUniverse.Security, Level, 1))
            End Select
        End Function



        'This return the security level from saved keys in the registery
        'byte 1 means they do something (disallow this program from running (just in case), disable all buttons (except maybe the select a computer language? may be not )
        'Byte 2 means not demo, they can input or output
        'byte 3 means read only, they can not make changes to anything.(Or save anything?)
        'byte 4 means student they can make changes to the Symbol.)Or save Symbols?
        'byte 5 is the level they are allowed (A-Z)
        'byte 6 is the level they are at.(A-Z)

        'The string is a list of the items that can be done.
        Public Shared Function SetSecurityOption() As String
            Dim X As String
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2997, 10, "SetSecurityOption")
#End If
            SetSecurityOption = "NNNNNNNNNNNNNNNN"
            MyUniverse.PaidFor.FCRName = My.Application.Info.ProductName.ToString
            MyUniverse.PaidFor.FCRVersion = My.Application.Info.Version.ToString
            MyUniverse.PaidFor.FCRCPUid = CPUID1.CPU_ID() 'For now it is junk (Maybe the username, or some such junk

            MyUniverse.PaidFor.FCRKey = CStr(My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\FlowChart", "Key", "Needs FlowChart To Be Registered"))
            MyUniverse.PaidFor.FCRUserProfession = CStr(My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\FlowChart", "TopLevel", "Needs FlowChart To Be Registered"))
            MyUniverse.PaidFor.FCRUserLevel = CStr(My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\FlowChart", "AtLevel", "Needs FlowChart To Be Registered"))

            If Mid(MyUniverse.PaidFor.FCRUserProfession, 3, 1) >= "A" And Mid(MyUniverse.PaidFor.FCRUserProfession, 3, 1) <= "Z" Then
                Mid(SetSecurityOption, 7, 1) = Mid(MyUniverse.PaidFor.FCRUserProfession, 3, 1)
            End If

            If Mid(MyUniverse.PaidFor.FCRUserLevel, 3, 1) >= "A" And Mid(MyUniverse.PaidFor.FCRUserLevel, 3, 1) <= "Z" Then
                Mid(SetSecurityOption, 7, 1) = Mid(MyUniverse.PaidFor.FCRUserLevel, 3, 1)
            End If
            If MyUniverse.PaidFor.FCRName <> CStr(My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\FlowChart", "Name", "Needs FlowChart To Be Registered")) Then
                X = InputBox("This copy of Flow Chart has not been registered for this machine", "Enter User Code for " & Environment.UserName, "Student")
                'bug I never save this so it always comes here
                'todo save this into the register
                Select Case (LCase(X))
                    Case "Student"
                        Return "YNNYYNYYYYNNYYYN" 'not allowed to do anything
                    Case "Teacher"
                        Return "YNNYYNYYYYNNYYYN" 'not allowed to do anything
                    Case "Programmer"
                        Return "YNNYYNYYYYNNYYYN" 'not allowed to do anything
                    Case "Expert"
                        Return "YNNYYNYYYYNNYYYN" 'not allowed to do anything
                    Case Else
                        Return SecurityKey(X) 'not allowed to do anything
                End Select
                Return SecurityKey(X) 'hack
            End If
        End Function


        'returns the index to the path/variable name (or adds one, and returns that index)
        Public Shared Function FindIndex_In_TableNetLinks(IndexFlowChart As Int32) As Int32 ' Return the Net Link Index
            Dim I As Int32
            Dim PathName As String
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2998, 10, "FindIndex_In_TableNetLinks")
#End If
            'todo a /use record could be connected to this path should be tested ?????
            If FlowChart_TableCode(IndexFlowChart) = My_keyWord(My_KeyConstUse) Then Return ConstantMyErrorCode ' paths are automatically connected to any Symbol no matter what the name

            PathName = FlowChart_TablePath_Name(IndexFlowChart)
            If MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastIndex = IndexFlowChart Then
                If MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName = PathName Then
                    Return MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound
                End If
            End If

            If FlowChart_TableCode(IndexFlowChart) <> "/path" Then
                MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = -1
                MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName = Nothing
                MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = IndexFlowChart
                Return ConstantMyErrorCode
            End If
            'This should be in the FindingMyBugs test's
            For I = LBound(Net_FileLinks) To UBound(Net_FileLinks)
                If InStr(Net_TableLinks(I), FD & IndexFlowChart & FD) > 0 Then
                    MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = I
                    MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName = PathName
                    MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = IndexFlowChart
                    'MSG_AInfo1(1149, "FindIndex Integer the NetLinks ShortCut ", LastFound.ToString & LastPathName.ToString & LastPathName, "")
                    Return I
                End If
                If Net_TableNames(I) = PathName Then
                    MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = I
                    MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName = PathName
                    MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = IndexFlowChart
                    Net_TableLinks(I, Net_TableLinks(I) & FD & IndexFlowChart & FD)
                    'MSG_AInfo1(1150, "FindIndex Integer the NetLinks ShortCut ", LastFound.ToString & LastPathName.ToString & LastPathName, "")
                    Return I
                End If
            Next
            MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = -1
            MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName = Nothing
            MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastIndex = -2
            'MSG_AInfo1(1151, "FindIndex Integer the NetLinks ShortCut ", MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastIndex & ":" & MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound & ":" & MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName, "")
            Return 0 ' not in this list anywhere
        End Function



        Public Shared Function UseNetLinksNumber(IndexFlowChart As Int32) As Int32
            Dim I As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2999, 10, "UseNetLinksNumber")
#End If
            I = FindIndex_In_TableNetLinks(IndexFlowChart)
            If I > 0 Then
                Return I
            End If
            Return ConstantMyErrorCode
        End Function


        'returns the index of this index, and puts in this name as a pathname
        Public Shared Function MakeNew_NetLinks(IndexFlowChart As Int32, PathName As String) As Int32 '
            Dim IndexNet As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2300, 10, "MakeNew_NetLinks")
#End If
            If Len(PathName) = 0 Then
                PathName = My_VariableName("BlankVariableName", CInt(MyRnd()))
                MSG_ABug(1154, "Can not make a path from a blank path name", MyShowFlowChartRecord(False, IndexFlowChart), PathName)
                If MyOptionTest(25) = True Then
                Else
                End If
            End If
            PathName = CheckThisPathName(PathName, IndexFlowChart)

            IndexNet = UseNetLinksNumber(IndexFlowChart)
            If IndexNet > 0 Then
                Return IndexNet
            End If

            For IndexNet = LBound(Net_FileNames) To UBound(Net_FileNames)
                If PathName = Net_FileNames(IndexNet) Then
                    Return IndexNet
                End If
            Next IndexNet


            ReDim Preserve Net_FileLinks(UBound(Net_FileLinks) + 1)
            ReDim Preserve Net_FileNames(UBound(Net_FileNames) + 1)
            IndexNet = UBound(Net_FileLinks)
            Net_TableLinks(IndexNet, Net_TableLinks(IndexNet) & FD & IndexFlowChart & FD)
            Net_TableNameS(IndexNet, PathName)
            Return IndexNet
        End Function


        Public Shared Function MyShowColumns(Input As String, Columns() As Int32) As String
            ' make this comma delimited string into a string in columns (size of each column in columns)
            Dim I As Int32
            Dim RTN As String = ""
            Dim T As String
            T = Input
            I = 1
            While Len(T) > 0 And I < UBound(Columns)
                RTN &= Spaced(Columns(I), MyTrim(Pop(T, FD & vbCrLf & vbCr & vbLf)))
                I += 1
            End While
            Return RTN
        End Function


        Public Shared Function MyShowEveryThingAtXY(x As Int32, y As Int32) As String
            Dim RTN As String = ""
            Dim IndexFlowChart, IndexNamed, IndexSymbol As Int32
            Dim xy As MyPointStructure
            Dim heading As String
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2301, 10, "MyShowEveryThingAtXY")

#End If
            heading = ""
            For IndexFlowChart = 1 To TopOfFile("FlowChart")
                Select Case FlowChart_TableCode(IndexFlowChart)
                    Case "/use"
                        IndexNamed = FindInNamedList(FlowChart_TableSymbol_Name(IndexFlowChart))
                        IndexSymbol = Named_TableSymbolIndexes(IndexNamed) + 1
                        heading = MyShowFlowChartRecord(True, IndexFlowChart) & vbCrLf
                        While IndexSymbol <= TopOfFile("Symbol") And Symbol_TableCoded_String(IndexSymbol) <> "/named"
                            Select Case Symbol_TableCoded_String(IndexSymbol)
                                Case "/point"
                                    xy.x = FlowChart_TableX1(IndexFlowChart) + Symbol_TableX1(IndexSymbol)
                                    xy.y = FlowChart_TableY1(IndexFlowChart) + Symbol_TableY1(IndexSymbol)
                                    If x = xy.x And y = xy.y Then
                                        If MyDebug(10) Then follow(2142, heading & MyShowSymbolGraphic(True, IndexSymbol))
                                        RTN &= MyShowSymbolGraphic(True, IndexSymbol) & vbCrLf
                                        heading = ""
                                    End If
                                Case "/line"
                                Case "/name"
                                    Exit While
                                Case Else
                                    RTN &= MyShowSymbolGraphic(True, IndexSymbol) & vbCrLf
                                    heading = ""
                            End Select
                            IndexSymbol += 1
                        End While

                    Case "/path"
                        If FlowChart_TableX1(IndexFlowChart) = x And FlowChart_TableY1(IndexFlowChart) = y Then
                            If MyDebug(9) Then follow(2144, "Point problem " & MyShowFlowChartRecord(True, IndexFlowChart))
                            RTN &= MyShowSymbolGraphic(True, IndexSymbol) & vbCrLf
                        End If
                        If FlowChart_TableX2(IndexFlowChart) = x And FlowChart_TableY2(IndexFlowChart) = y Then
                            If MyDebug(9) Then follow(2145, "Point problem " & MyShowFlowChartRecord(True, IndexFlowChart))
                            RTN &= MyShowSymbolGraphic(True, IndexSymbol) & vbCrLf
                        End If

                    Case Else
                        MyInfo(2113, "Point problem " & FlowChart_TableCode(IndexFlowChart), "", heading)
                        RTN &= MyShowSymbolGraphic(True, IndexSymbol) & vbCrLf
                        'My_KeyConstUnknown
                        'My_KeyConstUnKnownError
                        'My_KeyConstError
                        'My_KeyConstDelete , 14
                        'My_KeyConstConstant , 15
                        'My_KeyConstOption , 25
                End Select
            Next IndexFlowChart
            RTN = RTN.Replace(vbCrLf & vbCrLf, vbCrLf)
            RTN = RTN.Replace(vbCrLf & vbCrLf, vbCrLf)
            RTN = RTN.Replace(vbCrLf & vbCrLf, vbCrLf)
            Return RTN
        End Function

        'todo this is noot used.
        Public Shared Function MyShowInputOutput(expanded As Boolean, Pt As IOTypeStructure) As String
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2302, 10, "MyShowInputOutput")
#End If
            If expanded = True Then
                MyShowInputOutput = "(:Input>" & Pt.Input & ":output<" & Pt.Output & ":both<,>" & Pt.Both & ":other?" & Pt.Other & ")"
            Else
                MyShowInputOutput = ":>" & Pt.Input & ":<" & Pt.Output & ":<,>" & Pt.Both & ":?" & Pt.Other
            End If
            Return MyShowInputOutput & vbCrLf
        End Function

        Public Shared Sub AddSymbolUp(ByRef A As MySymbolCountsStructure)
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2303, 10, "AddSymbolUp")
#End If
            AddUp(A.Path.NumberOfConnectionsToOtherPaths)
            AddUp(A.Path.NumberOfConnectionsToSymbols)
            A.Path.Total = A.Path.NumberOfConnectionsToOtherPaths.Total + A.Path.NumberOfConnectionsToSymbols.Total + A.Path.NumberOfErrors

            AddUp(A.Symbol.NumberOfLines)
            AddUp(A.Symbol.NumberOfOther)
            AddUp(A.Symbol.NumberOfPoints)
            A.Symbol.Total = A.Symbol.NumberOfLines.Total + A.Symbol.NumberOfOther.Total + A.Symbol.NumberOfPoints.Total

            A.Total = A.Path.Total + A.Symbol.Total

        End Sub



        Friend Shared Sub AddUp(ByRef A As PointTypeStructure)
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2304, 10, "AddUp")
#End If
            A.Data.Total = A.Data.Both + A.Data.Input + A.Data.Output + A.Data.Other
            A.Logic.Total = A.Logic.Both + A.Logic.Input + A.Logic.Output + A.Logic.Other
            A.Total = A.Data.Total + A.Logic.Total
        End Sub

        Friend Shared Sub MakeZero(ByRef A As PointTypeStructure)
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2305, 10, "MakeZero")
#End If
            A.Data.Both = 0
            A.Data.Input = 0
            A.Data.Output = 0
            A.Data.Other = 0
            A.Data.Total = 0
            A.Logic.Both = 0
            A.Logic.Input = 0
            A.Logic.Output = 0
            A.Logic.Other = 0
            A.Logic.Total = 0
            A.Total = 0
        End Sub



        ' counts the type of the number of points in an existing Symbol
        Public Shared Sub NumberOfGraphicsInASymbol(IndexSymbol As Int32, IndexFlowChart As Int32)
            Dim LocalIndex, Jdex As Int32
            Dim SymbolName, PointName As String
            Dim I As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2306, 10, "NumberOfGraphicsInASymbol")
#End If
            SymbolName = Symbol_TableSymbolName(IndexSymbol)
            MyUniverse.SymbolAndPath.Name = SymbolName
            MakeZero(MyUniverse.SymbolAndPath.Symbol.NumberOfLines)
            MakeZero(MyUniverse.SymbolAndPath.Symbol.NumberOfOther)
            MakeZero(MyUniverse.SymbolAndPath.Symbol.NumberOfPoints)
            MakeZero(MyUniverse.SymbolAndPath.Symbol.NumberOfPoints)

            MakeZero(MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths)
            MakeZero(MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther)
            MakeZero(MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines)
            MakeZero(MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints)

            MyUniverse.SymbolAndPath.Symbol.Total = 0
            MyUniverse.SymbolAndPath.Path.Total = 0
            MyUniverse.SymbolAndPath.Uses.Total = 0
            MyUniverse.SymbolAndPath.Total = 0

            AddSymbolUp(MyUniverse.SymbolAndPath)

            'todo is this nessary '''  LocalIndex = IndexSymbol + 1
            If IndexSymbol >= 1 Then
                For LocalIndex = IndexSymbol + 1 To TopOfFile("Symbol")
                    Select Case PrintAbleNull(Symbol_TableCoded_String(LocalIndex).ToString)
                        Case "/name" ' Start of the next Symbol
                            Return
                        Case "/point"
                            FMB1(8005)
                            'todo this is adding extra names to the list of point names, to allow you to just add a point
                            While MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total + 1 > SymbolWindow.ComboBoxPointNameList.Items.Count
                                FMB1(8006)
                                If Len(Symbol_Table_NameOfPoint(LocalIndex)) > 0 Then
                                    ''''''''''''''''''  if mydebug(9) then follow(2754, 7, "Add Point Name " & Symbol_Table_NameOfPoint(LocalIndex) & FD & vbTab & MyShowComboBox(SymbolWindow.ComboBoxPointNameList))
                                    AddPointNameToDropDownX(Symbol_Table_NameOfPoint(LocalIndex))
                                    ''''''''''''''''''  if mydebug(9) then follow(2755, 7, MyShowComboBox(SymbolWindow.ComboBoxPointNameList))
                                Else Return
                                End If
                                FMB1(8007)
                                LocalIndex += 1
                            End While
                            FMB1(8008)
                            AddPointNameToDropDownX(Symbol_Table_NameOfPoint(LocalIndex))
                            FMB1(8009)
                            'if mydebug(9) then follow(2745, 6, MyShowComboBoxItems(SymbolWindow.ComboBoxPointNameList))
                            FMB1(8010)
                            If MyUniverse.MyProgramStatus <> "Begin" Then
                                If MyDebug(6) = True Then If mydebug(9) Then follow(2756, 6,
                                   "total # points=" & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total.ToString & vbTab & "# Names = " & SymbolWindow.ComboBoxPointNameList.Items.Item(MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total).ToString & vbTab & "#=" & LocalIndex.ToString & vbTab & " Name= " & Symbol_Table_NameOfPoint(LocalIndex).ToString)
                            End If
                            'todo this is placing a variable in the wrong spot 
                            '                            SymbolWindow.ComboBoxPointNameList.Items.Item(MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total) = CStr(Symbol_Table_NameOfPoint(LocalIndex).ToString)
                            FMB1(8011)
                            MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total += 1
                            'PointName = Symbol_Table_NameOfPoint(LocalIndex).ToString()
                            PointName = Symbol_Table_InputOutput(LocalIndex)
                            FMB1(8012)
                            Select Case LCase(Pop(PointName, FD))
                                Case "logic"
                                    Select Case LCase(Pop(Symbol_Table_InputOutput(LocalIndex), FD))
                                        Case "input", "optionalinput"
                                            MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Input += 1
                                        Case "output", "optionaloutput"
                                            MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Output += 1
                                        Case "both", "optionalboth"
                                            MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Both += 1
                                        Case Nothing
                                            MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Other += 1
                                        Case Else
                                            MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Other += 1
                                    End Select
                                Case Else
                                    Select Case LCase(Pop(Symbol_Table_InputOutput(LocalIndex), FD))
                                        Case "input", "optionalinput"
                                            MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Input += 1
                                        Case "output", "optionaloutput"
                                            MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Output += 1
                                        Case "both", "optionalboth"
                                            MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Both += 1
                                        Case Nothing
                                            MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other += 1 'error of come kind
                                        Case Else
                                            MSG_ABug(1160, "Unknow input output code", LocalIndex.ToString, Symbol_Table_InputOutput(LocalIndex) & MyShowSymbolGraphic(True, LocalIndex))
                                            If MyOptionTest(25) = True Then
                                            Else
                                            End If
                                            MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other += 1
                                    End Select
                            End Select
                        Case "/line"
                            For I = 0 To SymbolWindow.ComboBoxLineNameList.Items.Count - 1
                                If SymbolWindow.ComboBoxLineNameList.Items(I).ToString = Symbol_Table_NameOfPoint(LocalIndex) Then
                                    Exit Select
                                End If
                            Next I
                            If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Total > SymbolWindow.ComboBoxLineNameList.Items.Count Then
                                AddLineNameToDropDown("Line Color" & CStr(SymbolWindow.ComboBoxLineNameList.Items.Count))
                            End If

                            MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Other += 1
                            AddLineNameToDropDown(Symbol_Table_NameOfPoint(LocalIndex) & ",  " & MyShowSymbolLines1(True, LocalIndex))
                            If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Other <> SymbolWindow.ComboBoxLineNameList.Items.Count Then
                                MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Other = SymbolWindow.ComboBoxLineNameList.Items.Count
                            End If
                        Case "/error"
                            MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Other += 1 ' just counting the number of error records found in the table
                        Case "/unknown"
                        Case "/delete" ' do not count these 
                        Case Else
                            MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Other += 1 ' just counting the number of error records found in the table
                            MSG_ABug(1163, "unknown code ", Symbol_TableCoded_String(LocalIndex), MyShowSymbolGraphic(True, LocalIndex))
                            If MyOptionTest(25) = True Then
                            Else
                            End If
                            MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Other += 1 ' just count other things (not accounted for)
                    End Select
                    AddSymbolUp(MyUniverse.SymbolAndPath)
                    FMB1(8013)
                Next
            End If
            FMB1(8014)
            If IndexFlowChart >= 1 Then
                'count path and use
                For LocalIndex = 1 To TopOfFile("FlowChart")
                    If FlowChart_TableCode(LocalIndex) = "/path" Then
                        For Jdex = 1 To TopOfFile("FlowChart")
                            If FlowChart_TableCode(Jdex) = "/path" Then
                                If LocalIndex <> Jdex Then
                                    If FlowChart_TablePathName(LocalIndex) = FlowChart_TablePathName(Jdex) Then
                                        MSG_ABug(1164, "There are two entities for the name ", FlowChart_TablePathName(LocalIndex) & " " & FlowChart_TablePathName(Jdex), FindIndex_In_TableNetLinks(LocalIndex) & " : " & FindIndex_In_TableNetLinks(Jdex))
                                        If MyOptionTest(25) = True Then
                                        Else
                                        End If
                                    End If
                                End If
                            End If
                        Next
                    End If
                Next
            End If
            AddSymbolUp(MyUniverse.SymbolAndPath)
            If MyDebug(6) = True Then
                If mydebug(9) Then follow(2757, 6, MyShowPointCounts(False))
                If mydebug(9) Then follow(2758, 6, MyShowPointCounts(True))
            End If
        End Sub
        '''<summary>   
        '''<param name="FromWhat" Fromwhat ="From"> This is the old Symbol Name</param>
        '''<param name="ToWhat" ToWhat = "To" >This is the the new Symbol name</param>
        '''<para> Function MyRenameSymbol  This will rename the Symbol and all of the use
        '''<!-- returns the number of times it change the Symbol name (one for the Symbol, and the rest in the FlowChart.-->
        '''if thier is not a Symbol with this name already.</para>
        '''<remarks>The Symbol name can not be changed to be nothing.</remarks>
        '''</summary> 
        Public Shared Function MyRenameSymbol(FromWhat As String, ToWhat As String) As Int32 ' Returns the number of names changed, or <0 if there is an error during the process of changing the name
            Dim Indexs, Kounter As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2307, 10, "MyRenameSymbol")
#End If
            If FromWhat = ToWhat Then
                Return 0 'Equal
            End If
            If PrintAbleNull(ToWhat) = "_" Then
                Return 0
            End If
            MSG_AInfo(1167, "Rename Symbol from/to ", FromWhat, ToWhat)
            'First need to check that there is no old name
            If FindInNamedList(ToWhat) > 0 Then
                Return -2 'Symbol name already exist
            End If
            If FindInSymbolList(ToWhat) > 0 Then
                Return -3 'Symbol graphics already exist
            End If

            If FindInNamedList(FromWhat) < 0 Then
                Return -4 ' the old name does not exist
            End If
            If FindInSymbolList(FromWhat) < 0 Then
                Return -5 ' There is no graphic records.
            End If

            Kounter = 0
            'First go throuth the Symbols
            For Indexs = 1 To TopOfFile("Symbol")
                If Symbol_TableCoded_String(Indexs) = "/name" Then
                    If Symbol_TableSymbolName(Indexs) = FromWhat Then
                        Symbol_TableSymbolName(Indexs, ToWhat) 'Rename what it uses.
                        Kounter += 1
                    End If
                End If
            Next

            'then go through the name (control of the Symbols)
            For Indexs = 1 To TopOfFile("Symbol")
                If Named_TableSymbolName(Indexs) = FromWhat Then
                    Named_TableSymbolName(Indexs, ToWhat) ' update the name
                    Kounter += 1
                End If
            Next

            'then go through the FlowChart and rename all of the /use
            For Indexs = 1 To TopOfFile("FlowChart")
                If FlowChart_TableCode(Indexs) = My_keyWord(My_KeyConstUse) Then
                    If FlowChart_TableSymbol_Name(Indexs) = FromWhat Then
                        FlowChart_TablePathSymbolName(Indexs, ToWhat) ' update the name
                        Kounter += 1
                    End If
                End If
            Next
            MSG_AInfo(1168, "Change the Symbol name " & FromWhat & " to " & ToWhat, Kounter & " times", "")
            ' A I N F O 2 (82)
            Return Kounter
        End Function

        Public Shared Function FindInNamedList(SymbolNameToFind As String) As Int32
            Dim IndexNamed As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2308, 10, "FindInNamedList")
#End If
            ' Cheat first now
            If SymbolNameToFind = "" Then
                ' A I N F O 2 (83)
                Return ConstantMyErrorCode
            End If
            If MyDebug(9) Then follow(2886, 9, "Searching for " & SymbolNameToFind & FD & FindingMyBugs(34).ToString)
            If MyUniverse.MyCheatSheet.Last_UnSortedStringTable = "named" Then
                If MyUniverse.MyCheatSheet.Last_UnSortedStringString = SymbolNameToFind Then
                    ' A I N F O 2 (84)
                    Return MyUniverse.MyCheatSheet.Last_UnSortedStringIndex
                End If
            End If
            IndexNamed = FindIndexInISAMTable("Named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, SymbolNameToFind)
            If MyDebug(9) Then follow(2887, 9, "Searching for " & SymbolNameToFind & FD & FindingMyBugs(35).ToString)
            If IndexNamed <= 0 Then
                ' A I N F O 2 (85)
                Return CheckNotInList("named", Named_FileSymbolName, SymbolNameToFind)
            Else
                ' A I N F O 2 (86)
                Return IndexNamed
            End If
        End Function


        ' rewrote 20200711
        'Gets the index in Symbol from just the name (looks it up in named first)
        Public Shared Function FindInSymbolList(ByRef SymbolNameToFind As String) As Int32 'Gets the index in Symbol from just the name (looks it up in named first)
            Dim Temp As String
            Dim IndexNamed, IndexSymbol, I, J As Int32    'MyArray() As String,  is always Symbol file name
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2309, 10, "FindInSymbolList")
#End If
            ' Cheat first now
            If MyUniverse.MyCheatSheet.Last_UnSortedStringTable = "Symbol" Then
                If MyUniverse.MyCheatSheet.Last_UnSortedStringString = SymbolNameToFind Then
                    ' A I N F O 2 (87)
                    Return MyUniverse.MyCheatSheet.Last_UnSortedStringIndex
                End If
            End If

            If SymbolNameToFind = "" Then
                ' A I N F O 2  ( 9 0)
                Return ConstantMyErrorCode
            End If

            IndexNamed = FindIndexInISAMTable("Named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, SymbolNameToFind)
            If IndexNamed <= 0 Then
                IndexNamed = CheckNotInList("named", Named_FileSymbolName, SymbolNameToFind)
            End If
            If IndexNamed <= 0 Then
                IndexNamed = IndexNamed 'hack
                ' Invalid Symbol name to find so exit the cheat way, and try harder
            Else
                IndexSymbol = Named_TableSymbolIndexes(IndexNamed)
                If IndexSymbol <= 0 Then ' We have no cheater/faster Indexes to the name of this Symbol.(We might need to complete re-find all of the Indexes?)
                    For I = 1 To TopOfFile("Symbol")
                        If Symbol_TableSymbolName(IndexNamed) = SymbolNameToFind Then
                            Named_TableSymbolIndexes(IndexNamed, I)
                            Return I
                        End If
                    Next
                    'IndexSymbol = GetSelfCorrectingIndexes(SymbolNameToFind) ' At least fix this Indexes
                    ' in the name table, but not in the Symbol table
                    Return ConstantMyErrorCode
                Else
                    Temp = Symbol_TableSymbolName(IndexSymbol)
                    If Len(Temp) = 0 And Len(SymbolNameToFind) <> 0 Then Symbol_TableSymbolName(IndexSymbol, SymbolNameToFind)
                    If MyCompared1_a(SymbolNameToFind, Temp) = 0 Then    'GREAT we found a match
                        Return IndexSymbol
                    Else ' The Indexes is off again
                        For J = 1 To TopOfFile("Symbol") + 1
                            If Symbol_TableSymbolName(J) = SymbolNameToFind Then
                                Return J
                            End If
                        Next
                        IndexSymbol = GetSelfCorrectingIndexes(SymbolNameToFind) ' The Indexes are off so fix them if possible

                        ' So Do We need to search it again"
                        MSG_ABug(1172, "Fixing named and Symbol for " & SymbolNameToFind, IndexNamed & " : " & Named_TableSymbolName(IndexNamed), IndexSymbol & " : " & Symbol_TableSymbolName(IndexSymbol))
                    End If
                End If
                ' END OF THE SHORT CUT CHEAT 
            End If
            ' Failed above so we have to do this the hard way.
            ' And assume that it is an unsorted list now
            For IndexSymbol = 1 To TopOfFile("Symbol")
                Temp = Symbol_TableSymbolName(IndexSymbol)
                ' Finds the first one, not the /name one
                If MyCompared1_a(SymbolNameToFind, Temp) = 0 Then    'GREAT we found a match
                    If Symbol_TableCoded_String(IndexSymbol) = "/name" Then
                        MSG_ABug(1173, "We had to find a Symbol name match the hard way! Program data error", IndexSymbol.ToString, SymbolNameToFind & " : " & Temp)
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                        GetSelfCorrectingIndexes(SymbolNameToFind)
                        MyUniverse.MyCheatSheet.Last_UnSortedStringTable = "Symbol"
                        MyUniverse.MyCheatSheet.Last_UnSortedStringString = SymbolNameToFind
                        FindingMyBugsCheckForErrors(0, IndexNamed, IndexSymbol)
                        Return IndexSymbol ' If we find it this way then there is a issues' some where
                    Else ' we found a match of the Symbol name, but not the /name record ' report it, and continue on
                        MSG_ABug(1174, "The Symbols must be out of order, because the first one found was not a /name code at " & IndexSymbol, SymbolNameToFind, Temp)
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                        GetSelfCorrectingIndexes(SymbolNameToFind)
                        FindingMyBugs(36)  ' Because the /name should be the first on in the list
                    End If
                End If
            Next IndexSymbol
            'failed to find it the hard way so it's not there
            ' A I N F O 2 (-92)
            Return ConstantMyErrorCode
        End Function



        Public Shared Function AddInTable(MyTable As String, ByRef MyFunction As String, ByRef MyArray() As String, ByRef ISAM() As Int32, WhatToFind As String, IndexPassed As Int32) As Int32
            Dim index As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2310, 10, "AddInTable")
#End If
            MyMakeArraySizesBigger()

            'AddInTable = IndexPassed
            CheckForAnySortNeeded(150) 'hack
            ShowSorts(MyTable, MyReSort(MyTable, MyArray, ISAM, 1))
            CheckForAnySortNeeded(151) 'hack
            ShowSorts(MyTable, MyReSort(MyTable, MyArray, ISAM, IndexPassed))
            CheckForAnySortNeeded(152) 'hack
            'Not in the list so add it, or not
            If LCase(Trim(MyFunction)) = "add" Then
                FindingMyBugs(37)
                'Last attempt to find because I've got a bug
                For index = 1 To TopOfFile(MyTable)
                    CheckThisStringArray(10, MyArray, ISAM, index)
                    If MyCompared1_a(MyArray(index), WhatToFind) = 0 Then
                        MyMsgCtr(1270, "AddInTable", MyArray(index), WhatToFind, "", "", "", "", "", "", "")
                        Return index
                    End If
                    FindingMyBugs(38)
                Next index

                MyMakeArraySizesBigger() '? Do I need This
                index = TopOfFile(MyTable)
                AddInTable = index
                MyArray(index) = WhatToFind
                ISAM(index) = index
                MyUniverse.MyCheatSheet.LastString = WhatToFind
                MyUniverse.MyCheatSheet.LastIndex = AddInTable
                CheckThisStringArray(11, MyArray, ISAM, index)
                CheckForAnySortNeeded(153) 'hack
                MyReSort(MyTable, MyArray, ISAM, index) 'hack    trying to find any problems here.
                CheckForAnySortNeeded(154) 'hack
            Else
                AddInTable = IndexPassed
            End If
            CheckForAnySortNeeded(10)
            FindingMyBugs(39)
        End Function



        Public Shared Function FindMessageNumber(Level As Integer) As Integer
            Dim LocalIndex, Jdex, Kdex As Int32
            Dim X As String
            Dim Zdex As Int32
            Dim ErrorKounter As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2311, 10, "FindMessageNumber")
#End If
            'todo is this nessary '''FindMessageNumber = My_KeyConstError
            ErrorKounter = -16

            Kdex = OptionsWindow.ComboBoxDebug.Items.Count - 1
            If Kdex < 4 Then
                ' A I N F O 2  ( 9 3)
                Return Nothing
            End If
            LocalIndex = MyMinMax(CInt(Kdex / 2), 0, Kdex)
            Jdex = MyMinMax(CInt(LocalIndex / 2), 1, Kdex)
            While 1 = 1
                'MyDoEvents(140)
                ErrorKounter += 1
                If ErrorKounter > OptionsWindow.ComboBoxDebug.Items.Count Then
                    MSG_ABug(1177, ErrorKounter.ToString, "No Messages in the buffer yet", "Message # " & Level) ' just not found, but need to escape
                    'Tried to many times must be a issues' (most likely not found in a sorted list
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                    Return 0 ' default to the first message, what ever it might be.
                End If
                X = OptionsWindow.ComboBoxDebug.Items.Item(LocalIndex).ToString
                Zdex = PopValue(X)
                If Zdex > Level Then
                    LocalIndex = MyMinMax(LocalIndex - Jdex, 0, Kdex)
                    Jdex = MyMinMax(CInt(Jdex / 2), 1, LocalIndex)
                ElseIf Zdex < Level Then
                    LocalIndex = MyMinMax(LocalIndex + Jdex, 0, Kdex)
                    Jdex = MyMinMax(CInt(Jdex / 2), 1, LocalIndex)
                ElseIf Zdex = Level Then
                    ' A I N F O 2 (-94)
                    Return LocalIndex
                    '?Else
                    '?  FindMessageNumber = 0 ' default to the first message, what ever it might be.
                End If
                ' Need to put in a test for end of file
            End While
            FindMessageNumber = 0 ' default to the first message, what ever it might be.
        End Function


        'Routine Just gets the size of the circle or path width 
        Public Shared Function FindMySize(DataTypeName As String, ColorName As String) As Int32
            Dim IndexDataType, IndexColor As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2312, 10, "FindMySize")
#End If
            CheckForAnySortNeeded(155)
            IndexColor = FindIndexInISAMTable("Color", "DoNotAdd", Color_FileName, Color_Name_ISAM, Trim(ColorName))
            IndexDataType = FindIndexInISAMTable("DataType", "DoNotAdd", DataType_FileName, DataType_Name_ISAM, Trim(DataTypeName))
            CheckForAnySortNeeded(156)
            If IndexDataType = ConstantMyErrorCode Then
                If IndexColor = ConstantMyErrorCode Then
                    'MyMsgCtr(1291, "FindMySize", DataTypeName, ColorName, IndexDataType.ToString, IndexColor.ToString, "", "", "", "", "")
                    Return ConstantMyErrorCode
                Else
                    Return MyUniverse.SysGen.Constants.ConstantMinPenSize
                End If
            Else
                ' A I N F O 2  ( 9 6)
                Return MyMinMax(DataType_TableWidth(IndexDataType), MyUniverse.SysGen.Constants.ConstantMinPenSize, MyUniverse.SysGen.Constants.ConstantMaxPenSize)
            End If
            ' A I N F O 2  ( 9 7)
            Return MyUniverse.SysGen.Constants.ConstantMinPenSize
        End Function


        'Routine This is called to draw the inside Symbol lines 
        Public Shared Sub MyDrawLineXY_XY(Where As PictureBox, Xy As MyLineStructure, ColorName As String)
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2313, 10, "MyDrawLineXY_XY " & Where.Parent.Name & ", " & MyShowLineXYXY(Xy.a.x, Xy.a.y, Xy.b.x, Xy.b.y))
#End If
            My_Draw_Line_Or_Path(Where, Xy, ColorName, 10)
        End Sub


        'This is called to draw the inside Symbol lines with a width of 1
        Public Shared Sub MyDrawLineWithIndex(Where As PictureBox, IndexSymbol As Int32, XYOffSet As MyPointStructure, RotationName As String)
            Dim MyLine As MyLineStructure
            Dim MyColor As String
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2314, 10, "MyDrawLineWithIndex")
#End If
            '' Cheat and use the path to draw the line
            If FMBRecurse("MyDrawLineWithIndex") > 2 Then Return
            MyLine = MyLine1(MyRotated_1(IndexSymbol, XYOffSet, RotationName), MyRotated_2(IndexSymbol, XYOffSet, RotationName))
            If MyDebug(10) Then follow(2718, 10, MyShowSymbolGraphic(True, IndexSymbol))
            If Symbol_TableCoded_String(IndexSymbol) = "/line" Then
                MyColor = Symbol_Table_LineColor(IndexSymbol)
            Else
                MyColor = FindColorFromDataType(Symbol_Table_DataType(IndexSymbol))
            End If
            If MyDebug(11) Then follow(2719, 11, "Color is " & SHL(MyColor)) ' & MyShowSymbolRecords(True, IndexSymbol))
            If Len(MyColor) < 1 Then
                If Symbol_TableCoded_String(IndexSymbol) = "/Line" Then
                    If MyDebug(10) Then follow(2725, 10, MyShowLineRecord(True, IndexSymbol))
                    Symbol_Table_LineColor(IndexSymbol, "Black")
                    If MyDebug(10) Then follow(2726, 10, MyShowLineRecord(True, IndexSymbol))
                Else
                    Symbol_Table_DataType(IndexSymbol, "Errored")
                End If
                MSG_ABug(2694, "No Color Or Data Type Named.  Set to black ", MyShowSymbolGraphic(True, IndexSymbol), "")
                If MyOptionTest(25) = True Then
                    MyColor = "Black"
                    ''''''''''''''''''''''''''''''''''''''''''''''''                    Symbol_table(IndexSymbol, MyColor)
                Else
                End If
                MyColor = "Black"
            End If

            My_Draw_Line_Or_Path(Where, MyLine, MyColor, 1)

        End Sub
        'MyDrawLineWithIndex(Where, IndexSymbol, XYOffSet, RotationName)
        'Routine This is used to draw the paths between the Symbol points (with a min width of 3
        Public Shared Sub MyDrawPath(Where As PictureBox, XY As MyLineStructure, DataTypeName As String)
            Dim ColorName As String
            Dim IndexDataTypeOrColor As Int32
            Dim Width As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2315, 10, "MyDrawPath")
#End If
            MyMakeArraySizesBigger()

            'ColorName = "Errored" ' default color if any errors
            CheckForAnySortNeeded(157)
            IndexDataTypeOrColor = FindIndexInISAMTable("DataType", "DoNotAdd", DataType_FileName, DataType_Name_ISAM, PrintAbleNull(DataTypeName))
            If IndexDataTypeOrColor = ConstantMyErrorCode Then ' Not a DataType, but a color name passed
                IndexDataTypeOrColor = FindColor(DataTypeName)
                If IndexDataTypeOrColor = ConstantMyErrorCode Then
                    MSG_ABug(1183, "Error : ALSO Invalid DataType or Color ", DataTypeName, "")
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                    IndexDataTypeOrColor = FindColor("Black")
                    If IndexDataTypeOrColor = ConstantMyErrorCode Then
                        MSG_ABug(1184, "ERROR: Invalid Color/Code for black : " & DataTypeName, IndexDataTypeOrColor.ToString, "Made into " & Color_TableName(1))
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                        IndexDataTypeOrColor = 1
                        ColorName = MyUniverse.ProgramOptions.SelectedColor
                    Else
                        ColorName = Color_TableName(IndexDataTypeOrColor) ' For color black
                        Width = 1 'default width for all non DataTypes
                    End If
                Else ' Was A Color Name
                    ColorName = Color_TableName(IndexDataTypeOrColor)
                    Width = 1 'default width for all non DataTypes
                End If
            Else
                'Found a DataType
                ColorName = Color_TableName(Color_Name_ISAM(DataType_TableColorIndex(IndexDataTypeOrColor)))
                Width = MyMinMax(DataType_TableWidth(IndexDataTypeOrColor), MyUniverse.SysGen.Constants.ConstantMinPenSize, MyUniverse.SysGen.Constants.ConstantMaxPenSize)
            End If
            If ColorName = "" Or MyIsNothing(ColorName) Then
                DataType_TableColorIndex(IndexDataTypeOrColor, FindColor(MyUniverse.ProgramOptions.SelectedColor))
                MSG_ABug(1185, "the color name gets set to black because of the invalid color name.", DataTypeName, ColorName)
                If MyOptionTest(25) = True Then
                Else
                End If
                ColorName = "Black"
            End If
            My_Draw_Line_Or_Path(Where, XY, ColorName, Width)
        End Sub


        Public Shared Function InsertFlowChartRecord(SymbolName As String, CodedString As String, xy1 As MyPointStructure, xy2 As MyPointStructure, DataType_Color As String) As Int32
            Dim IndexFlowChart As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2316, 10, "InSertFlowChartRecord")
#End If
            MyMakeArraySizesBigger()
            IndexFlowChart = NewTopOfFile("FlowChart")
            FlowChart_TableCode(IndexFlowChart, MyKeyword_2_Byte(CodedString).ToString)
            FlowChart_TablePathSymbolName(IndexFlowChart, SymbolName)
            FlowChart_Table_DataType(IndexFlowChart, DataType_Color)
            FlowChart_TableX1(IndexFlowChart, xy1.x)
            FlowChart_TableY1(IndexFlowChart, xy1.y)
            FlowChart_TableX2(IndexFlowChart, xy2.x)
            FlowChart_TableY2(IndexFlowChart, xy2.y)
            InsertFlowChartRecord = IndexFlowChart
            ShowSorts("FlowChart", SortFlowChart())
            PaintAll(FlowChartWindow.PictureBox1, IndexFlowChart - 1, IndexFlowChart + 1)
        End Function


        'need to make sure that this error message is not already in the list.
        Public Shared Sub MakeErrorAt(Where As PictureBox, myXY As MyPointStructure, ErrorMessage As String)
            Dim LocalIndex As Int32
            Dim IndexSymbol As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2317, 10, "MakeErrorAt")
#End If
            Select Case LCase(Where.Parent.Name)
                Case "FlowChartwindow"
                    'LocalIndex = MyFindPoint(Where, myXY) 'Find the closest point
                    ' Need to find the closest if this error is already in the FlowChart file, other wise it will go on forever building errors
                    For LocalIndex = 1 To TopOfFile("FlowChart")
                        If FlowChart_TableCode(LocalIndex) = "/error" Then ' only check errors
                            If myXY.x = FlowChart_TableX1(LocalIndex) Then
                                If myXY.y = FlowChart_TableY1(LocalIndex) Then
                                    ' Do not put errors ontop of the same errors
                                    If ErrorMessage = FlowChart_TableSymbol_Name(LocalIndex) Then
                                        Return ' not at the same message?
                                    End If
                                End If
                            End If
                        End If
                    Next
                    InsertFlowChartRecord(ErrorMessage, "/error", myXY, MyUniverse.MyStaticData.ZeroZero, "red") ' color??
                    MarkWorldHere(myXY.x, myXY.y, "Error?", "RED")
                Case "Symbolwindow"
                    If MyUniverse.ProgramOptions.SelectedSymbolName <> "" Then ' Only do it if there is a selected Symbol
                        LocalIndex = FindInSymbolList(MyUniverse.ProgramOptions.SelectedSymbolName)
                        IndexSymbol = LocalIndex + 1
                        While IndexSymbol <= TopOfFile("Symbol") And Symbol_TableCoded_String(IndexSymbol) <> "/name"
                            If Symbol_TableCoded_String(IndexSymbol) = "/error" Then
                                If myXY.x = Symbol_FileX1(IndexSymbol) Then
                                    If myXY.y = Symbol_FileY1(IndexSymbol) Then
                                        Return ' It is already in the Symbol
                                    End If
                                End If
                            End If
                            IndexSymbol += 1
                        End While

                        'Will insert multiply of this right now
                        MyInsertSymbolLineRecord(LocalIndex, MyUniverse.ProgramOptions.SelectedSymbolName, "/error", MyLine1(myXY.x, myXY.y, 0, 0), ErrorMessage)
                        MSG_ABug(1188, LocalIndex & " : " & MyUniverse.ProgramOptions.SelectedSymbolName, MyShowSymbolGraphic(False, LocalIndex), ErrorMessage)
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                    End If
            End Select

        End Sub


        'Routine This draws all text on the Window
        Public Shared Sub MyDrawText(Where As PictureBox, xy As MyPointStructure, MyString As String, BrushOptionNumber As Int32)
            Dim XY1 As Point
            Dim MyFonts As Font
            Dim MyPenDrawer As Pen 'Brush
            Dim XYXY As Rectangle
            Dim MyBrush As Brush
            Dim MyColor As Color

            Dim A, R, G, B As Byte
            Dim IndexColor As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2318, 10, "MyDrawText")
#End If
            If Len(MyString) = 0 Then Return
            If MyOptionTest(BrushOptionNumber) = False Then Return
            If ProgramBuzzy("Begin") = True Then Return

            XY1 = MyPointStruct2Point(Copy2WindowXY(Where, xy))
            MyFonts = SystemFonts.DefaultFont


            'todo ned to be able to set another size for the text (lok into aq definition for each of the fonts.)
            If MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis = False Then
                MyPenDrawer = Pens.White 'Brushes.White
            Else
                MyPenDrawer = MyGetPen(MyUniverse.OptionDisplay(BrushOptionNumber).ColorName, "")
                '= MyUniverse.OptionDisplay(BrushOptionNumber).ColorPen 'Brush
            End If
            'Where.CreateGraphics.DrawString(BrushOptionNumber.ToString & " : " & MyString, MyFonts, MyPenDrawer, XY1)
            XYXY.X = XY1.X + 4
            XYXY.Y = XY1.Y + 4
            XYXY.Height = MyUniverse.OptionDisplay(BrushOptionNumber).Textwidth
            XYXY.Width = MyUniverse.OptionDisplay(BrushOptionNumber).Textheight



            'todo remove this if mydebug(9) then follow()
            If MyDebug(9) Then follow(2709, "Drawing string " & SHL(MyString) & "  " & MyShowPoint(XYXY.X, XYXY.Y))

            '                    If MyDebug(10 ) then follow(2790,10,"Color of option : " & MyUniverse.OptionDisplay(BrushOptionNumber).ColorName)

            IndexColor = FindColorIndexFromName(MyUniverse.OptionDisplay(BrushOptionNumber).ColorName)
            A = Color_TableAlpha(IndexColor)
            R = Color_TableRed(IndexColor)
            G = Color_TableGreen(IndexColor)
            B = Color_TableBlue(IndexColor)
            MyColor = Color.FromArgb(A, R, G, B)
            If MyColor.IsSystemColor = True Then
                If MyDebug(10) Then follow(1100, 10, "System Color Used is a system color ")
            End If
            If MyColor.IsKnownColor = True Then
                If MyDebug(10) Then follow(1101, 10, "System color used is known")
            End If
            If MyColor.IsNamedColor = True Then
                If MyDebug(10) Then follow(1105, 10, "system color used is named " & MyColor.Name)
            End If


            '  if mydebug(9) then follow(2791,10," Closest Color TypeOf " & MyUniverse.OptionDisplay(BrushOptionNumber).ColorName & vbTab & TestIfColorStandardMicroSoftColorName(FindColorIndexFromName(MyUniverse.OptionDisplay(BrushOptionNumber).ColorName)).ToString)


            MyBrush = New Drawing.SolidBrush(MyColor)
            '        If MyDebug(10 ) then follow(2888, 9, "Drawing string " & shl(MyString) & "  " & MyShowPoint(XYXY.X, XYXY.Y))
            If MyOptionTest(BrushOptionNumber) = True Then
                Where.CreateGraphics.DrawString(BrushOptionNumber.ToString & " : " & MyString, MyFonts, MyPenDrawer.Brush, XYXY)
            Else
                Where.CreateGraphics.DrawString(MyString, MyFonts, MyPenDrawer.Brush, XYXY)
            End If
            MyBrush.Dispose()
        End Sub




        'Routine This is the actual routine that write out text , called by everything else

        Public Shared Sub MyDrawLineS_PathS(Where As PictureBox, IndexFlowChart As Int32)
            Dim MyLine As MyLineStructure
            Dim MyColor As String
            Dim MyWidth As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(2319, 1, "MyDrawLiineS_PathS " & MyShowFlowChartRecord(True, IndexFlowChart))
#End If
            MyLine = MyLine1(MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)),
    MyPoint2XY(FlowChart_TableX2(IndexFlowChart), FlowChart_TableY2(IndexFlowChart)))
            MyColor = FindColorFromDataType(FlowChart_Table_DataType(IndexFlowChart))
            MyWidth = FindWidthFromDataType(FlowChart_Table_DataType(IndexFlowChart))
            My_Draw_Line_Or_Path(Where, MyLine, MyColor, MyWidth)
        End Sub




        'color name is not being passed
        Public Shared Sub My_Draw_Line_Or_Path(Where As PictureBox, ByRef XY As MyLineStructure, ColorName As String, Width As Int32)
            Dim XY_a, XY_b As Point
            Dim MinePen As Pen
            Dim indexColor As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2320, 10, "MY_Draw_Line_Or_Path " & MyShowLineXYXY(XY.a.x, XY.a.y, XY.b.x, XY.b.y))
            MarkWindowHere(XY.a.x, XY.a.y, "  Draw X " & ColorName & MyShowLineXYXY(XY.a.x, XY.a.y, XY.b.x, XY.b.y))
            MarkWindowHere(XY.b.x + 10, XY.b.y + 10, "  Draw Y " & Where.Parent.Name)
#End If
            If ProgramBuzzy("begin") Then Return
            If Len(ColorName) = 0 Then
                MSG_AInfo1(1192, Where.Parent.Name & " Blank color name to draw line/path at " & MyShowALine(XY), "Width " & Width.ToString, "")
                MinePen = Pens.Black
                ColorName = MyUniverse.ProgramOptions.SelectedColor
            Else
                '                MyGetPen(ColorName, "")
                MinePen = MyGetPen(ColorName, "")
            End If

            'flow10'  MinePen.Width = MyMinMax(Width, 1, 24)
            'MarkWindowHere(XY.a.x, XY.a.y, "a At .x ", "Green")
            'MarkWindowHere(XY.b.x + 10, XY.b.y + 10, "b At .Y", "Blue")
            XY_a = MyPointStruct2Point(Copy2WindowXY(Where, XY.a))
            XY_b = MyPointStruct2Point(Copy2WindowXY(Where, XY.b))
            'MarkWindowHere(XY_a.X, XY_a.Y, "c At .x", "Orange")
            'MarkWindowHere(XY_b.X + 10, XY_b.Y + 10, "d At .y", "Yellow")
            If XY_a.X = XY_b.X And XY_a.Y = XY_b.Y Then
                XY_b.X += 25
                XY_b.Y += 25
                'MarkWindowHere(XY_b.X, XY_b.Y, "f +25", "Orange")
            End If
            Where.CreateGraphics.DrawLine(MinePen, XY_a, XY_b)
            'MarkWindowHere(XY_a.X, XY_a.Y, "a.X", "Purple")
            'MarkWindowHere(XY_b.X + 10, XY_b.Y + 10, "b.X", "DarkBlue")
            'todo remove these two lines If the line is a point (which you will never see.
            'If Width <= 1 Then Width = 2 'flow10' This is to force drawing 'ERROR 
            If Width > 1 Then ' Then This is a path
                CheckForAnySortNeeded(163)
                indexColor = FindIndexInISAMTable("Color", "DoNotAdd", Color_FileName, Color_Name_ISAM, ColorName)
                CheckForAnySortNeeded(164)
                'todo these were drawing at the wrong place
                If indexColor > 0 Then
                    MarkWindowHere(XY_a.X, XY_a.Y, "end of path A", "LimeGreen")
                    MarkWindowHere(XY_b.X + 10, XY_b.Y + 10, "end of path B", "Orange")
                    MyDrawCircle(Where, Point2MyPointStruct(XY_a), Color_TableName(indexColor), "")
                    MyDrawCircle(Where, Point2MyPointStruct(XY_b), Color_TableName(indexColor), "")
                End If
            End If
            If IsHex(MinePen.Color.Name) Then
                'can only dispose hex named pens
                '                        If MyDebug(10 ) then follow(2792,10,"Dispose pen " & vbTab & MinePen.Color.Name.ToString() & vbTab & ColorName)
                MinePen.Dispose()
                Return
            End If
            Return
        End Sub


        'Routine This draws a big cross where the Symbol is at.
        Public Shared Sub MyDrawCross(Where As PictureBox, xy As MyPointStructure, MyDataType As String, PathName As String)
            Dim XY1, XY2 As Point
            Dim tempsize As Int32
            Dim IsColor As String
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2321, 10, "MyDrawCross")
#End If

            tempsize = 10

            XY1 = MyPointStruct2Point(Copy2WindowXY(Where, xy))
            XY2.X += tempsize
            XY2.Y += tempsize
            XY1.X -= tempsize
            XY1.Y -= tempsize

            'todo this needs to be changed so that the cross color is based on the data type
            IsColor = FindColorFromDataType(MyDataType)
            MyGetPen(IsColor, MyDataType)
            '        If MyDebug(2 ) then follow(2673, 2, "Draw Line " & MyShowPoints(XY1.X, XY1.Y, XY2.X, XY2.Y))
            MarkHere(XY1.X, XY1.Y, MyDataType & PathName, IsColor)
            MarkHere(XY2.X, XY2.Y, MyDataType & PathName, IsColor)
            Where.CreateGraphics.DrawLine(Pens.Black, XY1, XY2)

            XY1 = MyPointStruct2Point(Copy2WindowXY(Where, xy))
            XY2.X -= tempsize
            XY2.Y += tempsize
            XY1.X += tempsize
            XY1.Y -= tempsize
            '        If MyDebug(2 ) then follow(2675, 2, "Draw Line " & MyShowPoints(XY1.X, XY1.Y, XY2.X, XY2.Y))
            Where.CreateGraphics.DrawLine(Pens.Black, XY1, XY2)

        End Sub 'mydrawcross

        Public Shared Function MyDistancePath(XY1 As MyLineStructure, XY2 As MyLineStructure) As Int32 'Find The Distance From XY1  to XY2
            Dim T1, T2, T3, T4 As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2322, 10, "MyDistancePath")
#End If
            T1 = MyABS(XY1.a.x - XY2.a.x) + MyABS(XY1.a.y - XY2.a.y) '1A to 2A
            T2 = MyABS(XY1.b.x - XY2.a.x) + MyABS(XY1.b.y - XY2.a.y) '1B to 2A
            T3 = MyABS(XY1.a.x - XY2.b.x) + MyABS(XY1.a.y - XY2.b.y) '1A to 2B
            T4 = MyABS(XY1.b.x - XY2.b.x) + MyABS(XY1.b.y - XY2.b.y) '1b to 2B
            MyDistancePath = MyMin(T1, T2) ' Between t1 & t2
            MyDistancePath = MyMin(MyDistancePath, T3) ' Between t1 & t2
            MyDistancePath = MyMin(MyDistancePath, T4) ' Between t1 & t2
            MSG_AInfo1(1196, "MyDistancePath" & ": " & MyDistancePath.ToString, "(" & XY1.a.x & FD & XY1.a.y & ")" & ":" & "(" & XY1.b.x & FD & XY1.b.y & ")" & ":" & "(" & XY2.a.x & FD & XY2.a.y & ")" & ":" & "(" & XY2.b.x & FD & XY2.b.y & ")", T1.ToString & ":" & T2.ToString & ":" & T3.ToString & ":" & T4.ToString)
        End Function



        'routine to see the distance between two points (OK, so I didn't square amounts and take the root
        Public Shared Function MyDistance(A As MyPointStructure, B As MyPointStructure) As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2323, 10, "MyDistance")
#End If
            MyDistance = CInt(Math.Sqrt(MyABS(A.x - B.x) ^ 2 + MyABS(A.y - B.y) ^ 2))
        End Function


        'Routine This routine returns a 16 unit clock of the direction of the second point from the first point
        Public Shared Function MyDirection(XY1 As MyPointStructure, XY2 As MyPointStructure) As Byte
            Dim dX, dY As Int32
            ' This should return the following 'clock' of the direction of the second from the centered first points
            'TDistant = myUniverse.SysGen.Constants.ConstantSymbolCenter * 2
            '14 15 16 01 02
            '13 /  |   / 03
            '12 ---0-----04
            '11 /  |   / 05
            '10 09 08 07 06
            '
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2324, 10, "MyDirection")
#End If
            'Just to make it simple
            dX = XY2.x - XY1.x
            dY = XY2.y - XY1.y

            If dX = 0 And dY = 0 Then ' ontop of each other
                Return 0
            End If

            If dX = 0 Then
                If dY < 0 Then
                    Return 16
                Else
                    Return 8
                End If
            End If

            If dY = 0 Then
                If dX > 0 Then
                    Return 4
                Else
                    Return 12
                End If
            End If


            If dX > 0 Then '1-7
                If dY > 0 Then '1, 2, 3
                    If MyABS(dX) = MyABS(dY) Then
                        Return 6
                    End If
                    If MyABS(dX) > MyABS(dY) Then
                        Return 5
                    Else
                        Return 7
                    End If
                Else '5, 6, 7
                    If MyABS(dX) = MyABS(dY) Then
                        Return 2
                    End If
                    If MyABS(dX) > MyABS(dY) Then
                        Return 3
                    Else
                        Return 1
                    End If
                End If
            Else ' dx <08-15
                If dY > 0 Then '13, 14, 15
                    If MyABS(dX) = MyABS(dY) Then
                        Return 10
                    End If
                    If MyABS(dX) > MyABS(dY) Then
                        Return 11
                    Else
                        Return 9
                    End If
                Else    '9, 10, 11
                    If MyABS(dX) = MyABS(dY) Then
                        Return 14
                    End If
                    If MyABS(dX) > MyABS(dY) Then
                        Return 13
                    Else
                        Return 15
                    End If
                End If
            End If
            Return 0
            ' For now only returning up
        End Function




        'Routine This draws the input/output arrows at each point
        Public Shared Sub MyDrawPointArrow(Where As PictureBox, CenterXY As MyPointStructure, ArrowXY As MyPointStructure, DataTypeName As String, RotationName As String, InputOrOutPut As Int32)
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2325, 10, "MyDrawPointArrow")
#End If
            Dim MyArrow As ThisArrow

            ReDim MyArrow.IO_SizeModifier(16)

            'todo This is bombing out string to integer
            MyArrow.Temp = MyUnEnum(InputOrOutPut, SymbolWindow.ToolStripDropDownInputOutput, 1)
            ' if mydebug(9) then follow(2635, 4, HighLight(RotationName) & FD & MyEnumValue(RotationName, SymbolWindow.ToolStripDropDownRotation).ToString)
            MyArrow.Input_Output_Both_Direction = PopValue(MyArrow.Temp)
            'This changes the size based on the direction of the arrow.

            MyArrow.IO_SizeModifier(0) = 2
            MyArrow.IO_SizeModifier(1) = 6    'input
            MyArrow.IO_SizeModifier(2) = -6    'output
            MyArrow.IO_SizeModifier(3) = 8    'both
            MyArrow.IO_SizeModifier(4) = 8    'Optionalinput
            MyArrow.IO_SizeModifier(5) = -4    'optional output
            MyArrow.IO_SizeModifier(6) = 4   'optional both
            MyArrow.IO_SizeModifier(7) = 2    ' anything else
            MyArrow.IO_SizeModifier(8) = 2    ' anything else
            MyArrow.IO_SizeModifier(9) = 2 'Future
            MyArrow.IO_SizeModifier(10) = 2 'Future
            MyArrow.IO_SizeModifier(11) = 2 'Future
            MyArrow.IO_SizeModifier(12) = 2 'Future
            MyArrow.IO_SizeModifier(13) = 2 'Future
            MyArrow.IO_SizeModifier(14) = 2 'Future
            MyArrow.IO_SizeModifier(15) = 2 'Future
            MyArrow.IO_SizeModifier(16) = 2 'Future

            MyArrow.ArrowFactor = 1
            If Len(DataTypeName) = 0 Then
                MSG_ABug(1200, "MyDrawPointArrow", "No DataTypename passed", HighLight(DataTypeName))
                If MyOptionTest(25) = True Then
                Else
                End If
                DataTypeName = "Errored"
            End If
            MyArrow.IndexDataType = FindIndexInISAMTable("DataType", "DoNotAdd", DataType_FileName, DataType_Name_ISAM, DataTypeName) ' Add this DataType 
            If MyArrow.IndexDataType = ConstantMyErrorCode Then
                MSG_ABug(1201, "This DataType Is Not In the DataType table : ",
     HighLight(MyArrow.IndexDataType.ToString),
     HighLight(DataTypeName))
                If MyOptionTest(25) = True Then
                Else
                End If
                'todo need to catch where this DataType is not being set when adding points to the Symbol
                MyArrow.ColorName = Color_TableName(FindColorIndexFromName("Black"))
            Else
                MyArrow.ColorName = Color_TableName(DataType_TableColorIndex(MyArrow.IndexDataType))
            End If
            MyMakeArraySizesBigger()           ' Make sure we are not over flowing the MyArrays'
            MyArrow.ColorName = FindColorFromDataType(DataType_TableName(MyArrow.IndexDataType))
            '    myarrow.ColorName = DataType_TableColor(myarrow.IndexDataType)

            If MyIsNothing(MyArrow.ColorName) Then 'We get here when a new DataType name was added
                If MyIsNothing(DataType_TableColorIndex(MyArrow.IndexDataType).ToString) Then
                    DataType_TableColorIndex(MyArrow.IndexDataType, FindColor("Red"))
                End If
                MyArrow.ColorName = "Red"
            End If
            MyArrow.TempPenWidthSize = 1 'MyMinMax(FindMySize(Where, Trim(DataTypeName)), 1, 550) ' Already set between 10 and 250 


            ' Get this pen color
            MyArrow.MinePen = MyGetPen(Trim(MyArrow.ColorName), "")
            'myarrow.MinePen.Width = MyMinMax(ScaledSize(myarrow.TempPenWidthSize), 1, 250) '?
            If ScaledSize(MyArrow.TempPenWidthSize) < 1 Then
                'todo need to make a disposable pen before each .draw...() and fill it in with the rbg,size,color etc (and get rid of the MicroSoft dependent color names)
                ' MyArrow.MinePen.Width = 1
            ElseIf ScaledSize(MyArrow.TempPenWidthSize) > 250 Then
                MyArrow.MinePen.Width = 250
            Else
                'flow10 'myarrow.MinePen.Width = 10 'myarrow.TempPenWidthSize
            End If
            '    MyXYCenter.X = myuniverse.SysGen.Constants.ConstantSymbolCenter
            '   MyXYCenter.Y = myuniverse.SysGen.Constants.ConstantSymbolCenter

            MyArrow.DirectionIs = MyDirection(MyUniverse.MyStaticData.ZeroZero, ArrowXY)


            Select Case LCase(Where.Parent.Name)
                Case "Symbolwindow"
                    MyArrow.MyXY1 = CenterXY      'Save the center of where we should show
                    MyArrow.MyXY1.y -= MyUniverse.OptionDisplay(10).x ' Display Input/output text
                    MyDrawText(Where, MyArrow.MyXY1, SymbolWindow.ToolStripDropDownInputOutput.DropDownItems(MyMinMax(MyArrow.IO_SizeModifier(MyArrow.DirectionIs), 1, SymbolWindow.ToolStripDropDownInputOutput.DropDownItems.Count - 1)).ToString, 10)
                Case "FlowChartwindow"
                    ' For Direction, for the second part of the line
                    MyArrow.MyXY1 = CenterXY
                    MyArrow.MyXY2 = CenterXY 'Save the center of where we should show

                    MyArrow.MyXY2.x += CInt(MyDirections(MyArrow.DirectionIs, 1, 1) * MyArrow.TempPenWidthSize * MyArrow.IO_SizeModifier(MyMinMax(MyArrow.IO_SizeModifier(MyArrow.DirectionIs), 0, 8)) / MyArrow.ArrowFactor)
                    MyArrow.MyXY2.y += CInt(MyDirections(MyArrow.DirectionIs, 1, 2) * MyArrow.TempPenWidthSize * MyArrow.IO_SizeModifier(MyMinMax(MyArrow.IO_SizeModifier(MyArrow.DirectionIs), 0, 8)) / MyArrow.ArrowFactor)
                    MyArrow.XY1 = Copy2WindowXY(Where, MyArrow.MyXY1) : MyArrow.XY2 = Copy2WindowXY(Where, MyArrow.MyXY2)
                    'MarkWindowHere(MyArrow.MyXY1.x, MyArrow.MyXY1.y, DataTypeName & FD & RotationName)
                    'MarkWindowHere(MyArrow.MyXY2.x + 10, MyArrow.MyXY2.y + 10, DataTypeName & FD & RotationName)
                    Where.CreateGraphics.DrawLine(MyArrow.MinePen, MyPointStruct2Point(MyArrow.XY1), MyPointStruct2Point(MyArrow.XY2))
                    MarkWindowHere(MyArrow.XY1.x, MyArrow.XY1.y, DataTypeName & FD & RotationName, "black")
                    'MarkWindowHere(MyArrow.XY2.x + 10, MyArrow.XY2.y + 10, DataTypeName & FD & RotationName)
                    MyArrow.MyXY1 = CenterXY : MyArrow.MyXY2 = CenterXY 'Save the center of where we should show
                    MyArrow.MyXY2.x += CInt(MyDirections(MyArrow.DirectionIs, 2, 1) * MyArrow.TempPenWidthSize * MyArrow.IO_SizeModifier(MyMinMax(MyArrow.IO_SizeModifier(MyArrow.DirectionIs), 0, 8)) / MyArrow.ArrowFactor)
                    MyArrow.MyXY2.y += CInt(MyDirections(MyArrow.DirectionIs, 2, 2) * MyArrow.TempPenWidthSize * MyArrow.IO_SizeModifier(MyMinMax(MyArrow.IO_SizeModifier(MyArrow.DirectionIs), 0, 8)) / MyArrow.ArrowFactor)
                    MyArrow.XY1 = Copy2WindowXY(Where, MyArrow.MyXY1) : MyArrow.XY2 = Copy2WindowXY(Where, MyArrow.MyXY2)
                    If MyDebug(9) Then follow(2891, 9, "Drawing arrows " & MyShow4Points(MyArrow.MyXY1, MyArrow.MyXY2, MyArrow.XY1, MyArrow.XY2))
                    Where.CreateGraphics.DrawLine(MyArrow.MinePen, MyPointStruct2Point(MyArrow.XY1), MyPointStruct2Point(MyArrow.XY2)) ' Second part of the Indexes (v, or ^ or < or > )
                    'MarkWindowHere(MyArrow.XY1.x, MyArrow.XY1.y, "Arrow")
                    'MarkWindowHere(MyArrow.XY2.x + 10, MyArrow.XY2.y + 10, "Arrow")
                    'flow10;'MyArrow.MinePen.Dispose()
            End Select
        End Sub


        'Routine The draws a circle where each point is
        Public Shared Sub MyDrawCircle(Where As PictureBox, XY As MyPointStructure, MyColorName As String, DataTypeName As String)
            Dim MyRec As Rectangle
            Dim TempSize As Int32
            Dim WindowPoint As MyPointStructure
            Dim IndexColor As Int32
            Dim IndexDataType As Int32
            Dim MinePen As Pen
            Dim ColorNameIs As String
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2326, 10, "MyDrawCircle at " & MyShowPoint(XY))
#End If
            ColorNameIs = MyColorName

            If MyIsNothing(ColorNameIs) Then
                ColorNameIs = "Red"
            ElseIf ColorNameIs = "" Then
                ColorNameIs = "Red"
            Else
                If FindColor(ColorNameIs) = ConstantMyErrorCode Then
                    ColorNameIs = "Black"
                End If
            End If
            'ColorNameIs = "Red"

            CheckForAnySortNeeded(170)
            IndexColor = FindIndexInISAMTable("Color", "DoNotAdd", Color_FileName, Color_Name_ISAM, ColorNameIs)


            If IndexColor = ConstantMyErrorCode And IndexDataType = ConstantMyErrorCode Then
                MSG_ABug(1203, "Neither Color name or DataType name is valid", HighLight(ColorNameIs) & HighLight(DataTypeName), MyShowPoint(XY))
                If MyOptionTest(25) = True Then
                Else
                End If
                Return
            End If


            If IndexColor < 0 Then
                IndexDataType = FindDataTypeIndex(DataTypeName)
                If IndexDataType > 0 Then 'if no color name but DataType name then use the color of that DataType
                    IndexColor = DataType_TableColorIndex(IndexDataType)
                    If IndexColor > 0 Then 'if color in DataType table is valid then use it
                        ColorNameIs = Color_TableName(IndexColor)
                    Else 'if the DataType has an invalid color then make it red
                        ColorNameIs = "Black"
                    End If
                Else ' both are invalid, so just use green
                    ColorNameIs = "Red"
                End If
            ElseIf IndexColor > 0 Then
                'TempSize = 2
                ColorNameIs = MyColorName
                '?IndexDataType = ConstantMyErrorCode
            End If

            TempSize = FindMySize(DataTypeName, ColorNameIs) 'size is only valid for DataTypes
            MinePen = MyGetPen(ColorNameIs, "")

            WindowPoint = Copy2WindowXY(Where, XY)
            MyRec.X = WindowPoint.x - CInt(TempSize / 2)
            MyRec.Y = WindowPoint.y - CInt(TempSize / 2)
            MyRec.Width = TempSize
            MyRec.Height = TempSize
            If MyDebug(10) = True Then If mydebug(9) Then follow(2892, 10, "Drawing Ellipse " & SHL(MyShowXY(MyRec.X, MyRec.Y) & "-" & MyShowXY(MyRec.X + MyRec.Width, MyRec.Y + MyRec.Height)) & ", " & MyShowPoint(XY))
            Where.CreateGraphics.DrawEllipse(MinePen, MyRec)
            'flow10''MinePen.Dispose()
#If MINEDEBUG Then
  if mydebug(9) then follow(2326, 1, "MyDrawCircle at " & MyShowPoint(XY) & vbTab & MyShowRect(MyRec))
#End If
        End Sub


        'Routine this draws a circle where each error is 
        'bug 'todo ColorName is being passed the name of the point
        Public Shared Sub MyDrawCircle_At(Where As PictureBox, xy As MyPointStructure, SymbolNameOfPoint As String, ColorName As String)
            Dim IndexColor As Int32
            Dim MyColorName As String
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2327, 10, "MyDrawCircle_At")
#End If
            '  Just to make sure we have a valid color (Do I need this?)
            CheckForAnySortNeeded(176)
            IndexColor = FindIndexInISAMTable("Color", "DoNotAdd", Color_FileName, Color_Name_ISAM, ColorName)
            CheckForAnySortNeeded(177)
            If IndexColor = ConstantMyErrorCode Then
                MyColorName = MyUniverse.ProgramOptions.SelectedColor
                IndexColor = FindIndexInISAMTable("Color", "DoNotAdd", Color_FileName, Color_Name_ISAM, MyColorName)
                If IndexColor = ConstantMyErrorCode Then
                    MyColorName = ColorName
                End If
            Else
                MyColorName = ColorName
            End If

            MyDrawCircle(Where, xy, MyColorName, "") ' Color, not DataType

            'Display Point Names @@@@ This actuality displayed Symbol name
            'todo fix the correct display option number (not 1 for SymbolNameofpoint
            MyDrawText(Where, MyOffset(xy, CStr(MyUniverse.OptionDisplay(1).x), CStr(MyUniverse.OptionDisplay(1).y)), SymbolNameOfPoint, 20)
            MyDrawText(Where, MyOffset(xy, CStr(MyUniverse.OptionDisplay(1).x), CStr(MyUniverse.OptionDisplay(1).y)), ColorName, 20)
        End Sub



        Public Shared Sub Clear_Window_Only(Where As PictureBox)
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2328, 10, "Clear_Window_Only")
  if mydebug(9) then follow(2893, 9, "Clear " & SHL(Where.Parent.Name))
#End If
            Where.CreateGraphics.Clear(DefaultBackColor)
            DoThisEvent(2897)
            'DoEvents(132000)
            'DoEvents(133000)
        End Sub


        'Routine This will clear the Window and then redraw everything

        Public Shared Sub Clear_Window(Where As PictureBox)
            'Dim Temp As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2329, 10, "Clear_Window")
#End If
            If FMBRecurse("Clear_Window") > 5 Then Return
            If IsNothing(Where.Parent) Then Return
            If MyIsNothing(Where.Parent.ToString) Then Return
            If MyDebug(9) Then follow(2430, 9, "clear Window " & Where.Parent.Name)
#If MINEDEBUG Then
            FindingMyBugsChangeOfWindows()
#End If

            Select Case LCase(Where.Parent.Name)
                Case "FlowChartwindow"
                    If Where.Parent.Visible = False Then Return
                    Clear_Window_Only(Where)
                    SetWindowArea()
                    MyUniverse.SysGen.ReSize = 987
                    If FlowChartWindow.PictureBox1.Width = FlowChartWindow.Width - FlowChartWindow.VScrollBar1.Width - 10 Then
                        MyUniverse.SysGen.ReSize = 0
                    Else
                        MyUniverse.SysGen.ReSize = 987 ' Flag to not let resize call it's self
                        FlowChartWindow.PictureBox1.Width = FlowChartWindow.Width - FlowChartWindow.VScrollBar1.Width - 10
                    End If
                    PaintAll(FlowChartWindow.PictureBox1, 1, TopOfFile("FlowChart"))
                Case "Symbolwindow"
                    If Where.Visible = False Then Return
                    Clear_Window_Only(Where)

                    'Temp = MyUniverse.SysGen.Constants.ConstantSymbolCenter
                    If MyUniverse.ProgramOptions.SelectedSymbolName <> "" Then
                        'PaintEach(SymbolWindow.PictureBox1, MyPoint1XY(Temp, Temp), MyUniverse.ProgramOptions.SelectedSymbolName, "Default")
                        PaintEach(SymbolWindow.PictureBox1, MyUniverse.MyStaticData.ZeroZero, MyUniverse.ProgramOptions.SelectedSymbolName, "Default")
                    End If
                Case Else
                    MSG_ABug(1206, "Wrong use of drawing ", Where.Parent.Name, "")
                    If MyOptionTest(25) = True Then
                    Else
                    End If
            End Select
        End Sub




        'Routine this keeps track of where the working area is located, 
        Public Shared Sub SetWindowArea()
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2330, 10, "SetWindowArea From) " & MyShowALine(MyUniverse.MyMouseAndDrawing.MyWindow))
#End If
            MyUniverse.MyMouseAndDrawing.MyWindow.a.x = MyUniverse.MyStaticData.MinXY.x - ScaledSize(100)
            MyUniverse.MyMouseAndDrawing.MyWindow.a.y = MyUniverse.MyStaticData.MinXY.y - ScaledSize(100)
            MyUniverse.MyMouseAndDrawing.MyWindow.b.x = MyUniverse.MyStaticData.MaxXY.x + ScaledSize(100)
            MyUniverse.MyMouseAndDrawing.MyWindow.b.y = MyUniverse.MyStaticData.MaxXY.y + ScaledSize(100)
            'This should set the origin to the top right from what ever it is .(No snap)
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2330, 10, "SetWindowArea  to ) " & MyShowALine(MyUniverse.MyMouseAndDrawing.MyWindow))
#End If
        End Sub




        Public Shared Function FindSymbol_StartIndex(SymbolName As String) As Int32
            Dim IndexNamed As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2331, 10, "FindSymbol_StartIndex")
#End If
            CheckForAnySortNeeded(180) 'hack
            FindSymbol_StartIndex = FindInSymbolList(SymbolName)
            CheckForAnySortNeeded(181) 'hack
            If FindSymbol_StartIndex = ConstantMyErrorCode Then
                MSG_ABug(1208, "Not able To find Symbol name ", SymbolName, "")
                If MyOptionTest(25) = True Then
                Else
                End If
                Return FindSymbol_StartIndex ' not named Symbol
            End If
            If LCase(Symbol_TableSymbolName(FindSymbol_StartIndex)) = LCase(SymbolName) Then
                ' A I N F O 2  ( 9  9)
                Return FindSymbol_StartIndex  ' Indexes is to the right place
            End If

            'wrong Indexes here, so fix if possible, otherwise change Indexes back to a 0 to search every time(yuck)
            For IndexNamed = 1 To TopOfFile("named")
                FindSymbol_StartIndex = Named_TableSymbolIndexes(IndexNamed)
                If Symbol_TableCoded_String(FindSymbol_StartIndex) = "/name" Then
                    If LCase(Symbol_TableSymbolName(FindSymbol_StartIndex)) = LCase(SymbolName) Then
                        Named_TableSymbolIndexes(IndexNamed) ' short cut
                        ' A I N F O 2 (100)
                        Return FindSymbol_StartIndex
                    Else
                        Named_TableSymbolIndexes(FindSymbol_StartIndex, 0) ' Lost the Indexes
                    End If
                Else
                    Named_TableSymbolIndexes(FindSymbol_StartIndex, 0) ' Lost the Indexes
                End If
            Next
            Named_TableSymbolIndexes(FindSymbol_StartIndex, 0) ' Fix wrong point, and not able to find it anyway.
            MSG_ABug(1209, "Unable To find this Symbol name.", SymbolName, "")
            If MyOptionTest(25) = True Then
            Else
            End If
            Return ConstantMyErrorCode ' not findable
        End Function

        'Routine 
        Public Shared Sub DisplayObject(Where As PictureBox, XYOffsets As MyPointStructure, SymbolName As String, RotationName As String)
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2332, 10, "DisplayObject")
#End If
            If FMBRecurse("DisplayObject") > 5 Then Return
            If MyDebug(7) Then follow(1103, 7, "Displaying Object " & SHL(SymbolName))
            If MyIsValidSymbolName(SymbolName) = False Then Return
            PaintEach(Where, XYOffsets, SymbolName, RotationName)
        End Sub

        Public Shared Function MyIsValidSymbolName(SymbolName As String) As Boolean
            Dim I As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2333, 10, "MyIsValidSymbolName")
#End If
            For I = 0 To TopOfFile("Named")
                If Named_TableSymbolName(I) = SymbolName Then Return True
            Next
            'todo add error message (and fix by adding Symbol?
            Return False
        End Function
        Public Shared Function MyFindSymbolPoint(MyXY As MyPointStructure,
             SymbolName As String) As Int32
            Dim IndexSymbol As Int32
            Dim IndexStart As Int32
            Dim Distance1, Distance3 As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2334, 10, "MyFindSymbolPoint")
#End If
            Distance1 = 10000000 ' biggest number possible
            Distance3 = Distance1

            IndexStart = FindSymbol_StartIndex(SymbolName)

            MyFindSymbolPoint = ConstantMyErrorCode
            If IndexStart = ConstantMyErrorCode Then
                MSG_ABug(1211, "Can Not find the Symbol name ", SymbolName, "")
                If MyOptionTest(25) = True Then
                Else
                End If
                Return ConstantMyErrorCode
            End If
            IndexStart += 1
            For IndexSymbol = IndexStart To TopOfFile("Symbol")
                Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                    Case "/name" ' Next name so skip it
                        Exit For
                    Case "/point"
                        Distance1 = MyDistance(MyXY, MyRotated_1(IndexSymbol, MyUniverse.MyStaticData.ZeroZero, "Default"))
                        If Distance1 < Distance3 Then
                            MyFindSymbolPoint = IndexSymbol
                            Distance3 = Distance1
                        End If
                    Case "/line"
                        'Distance1 = MyABS(MyXY.x - Symbol_TableX1(Index)) + MyABS(Myxy.y - Symbol_TableY1(Index))
                        Distance1 = MyDistance(MyXY, MyRotated_1(IndexSymbol, MyUniverse.MyStaticData.ZeroZero, "Default"))
                        If Distance1 < Distance3 Then
                            MyFindSymbolPoint = IndexSymbol
                            Distance3 = Distance1
                        End If
                        Distance1 = MyDistance(MyXY, MyRotated_2(IndexSymbol, MyUniverse.MyStaticData.ZeroZero, "Default"))
                        If Distance1 < Distance3 Then
                            MyFindSymbolPoint = IndexSymbol
                            Distance3 = Distance1
                        End If
                    Case Else

                End Select

            Next

        End Function


        'finds the closest Symbol center, each end of the paths, 
        ' Does not search itself FromIndex
        Public Shared Function MyFindPoint(Where As PictureBox, MyXY As MyPointStructure, FromIndexFlowChart As Int32) As Int32 ' Find the Symbol/Path/point/Line closest to X & Y
            Dim IndexFlowChart, IndexNamed As Int32, StartIndexNamedAt As Int32
            Dim LocalIndex As Int32
            Dim Distance1, Distance3 As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2335, 10, "MyFindPoint")
#End If
            MyFindPoint = ConstantMyErrorCode
            Distance1 = 10000000 ' biggest number possible
            Distance3 = Distance1
            Select Case LCase(Where.Parent.Name)
                Case "FlowChartwindow"
                    MyFindPoint = ConstantMyErrorCode
                    For IndexFlowChart = 1 To TopOfFile("FlowChart")
                        If IndexFlowChart <> FromIndexFlowChart Then
                            Select Case LCase(Trim(FlowChart_TableCode(IndexFlowChart)))
                                Case My_keyWord(My_KeyConstUse)
                                    Distance1 = MyDistance(MyXY, MyPoint1XY(IndexFlowChart))
                                    If Distance1 < Distance3 Then
                                        MyFindPoint = IndexFlowChart
                                        Distance3 = Distance1
                                    End If
                                Case "/path"
                                    Distance1 = MyDistance(MyXY, MyPoint1XY(IndexFlowChart))
                                    If Distance1 < Distance3 Then
                                        MyFindPoint = IndexFlowChart
                                        Distance3 = Distance1
                                    End If
                                    'Distance1 = MyABS(MyXY.x - FlowChart_TableX2(IndexFlowChart  )) + MyABS(Myxy.y - FlowChart_TableY2(IndexFlowChart  ))
                                    Distance1 = MyDistance(MyXY, MyPoint2_2XY(IndexFlowChart))
                                    If Distance1 < Distance3 Then
                                        MyFindPoint = IndexFlowChart
                                        Distance3 = Distance1
                                    End If
                                Case "/Constant"
                                    'Distance1 = MyABS(MyXY.x - FlowChart_TableX1(IndexNamed)) + MyABS(Myxy.y - FlowChart_TableY1(IndexNamed))
                                    Distance1 = MyDistance(MyXY, MyPoint1XY(IndexFlowChart))
                                    If Distance1 < Distance3 Then
                                        MyFindPoint = IndexFlowChart
                                        Distance3 = Distance1
                                    End If
                                Case "/unknown"
                                Case "/delete"
                                Case "/error"
                                Case Else
                                    MSG_ABug(1212, "Ignore FlowChart TypeOf ", "", MyShowFlowChartRecord(True, IndexFlowChart))
                                    If MyOptionTest(25) = True Then
                                    Else
                                    End If
                            End Select
                        End If ' skip searching for yourself
                    Next
                Case "Symbolwindow" ' Find the active point for the selected Symbol table
                    CheckForAnySortNeeded(182)
                    StartIndexNamedAt = FindIndexInISAMTable("Named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, MyUniverse.ProgramOptions.SelectedSymbolName)
                    CheckForAnySortNeeded(183)
                    If StartIndexNamedAt > ConstantMyErrorCode Then
                        'Bug This is wrong because the selected item is a string, and the p() requires a number
                        ''hack  If I stop here then find and fix the issues'
                        StartIndexNamedAt = Named_TableSymbolIndexes(My_INT(MyUniverse.ProgramOptions.SelectedSymbolName)) ', IndexNamed) ' Shortcut
                    Else
                        MSG_ABug(1213, "Failed finding point for " & StartIndexNamedAt.ToString, MyXY.x.ToString, MyXY.y.ToString)
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                        StartIndexNamedAt = 1
                    End If

                    If LCase(Symbol_TableSymbolName(StartIndexNamedAt)) <> "/name" Then
                        Named_TableSymbolIndexes(StartIndexNamedAt, 1)
                        StartIndexNamedAt = 1
                    End If


                    For IndexNamed = StartIndexNamedAt To TopOfFile("Symbol")
                        If Symbol_TableCoded_String(IndexNamed) = "/name" Then
                            '
                            If LCase(Trim(Symbol_TableSymbolName(IndexNamed))) = LCase(Trim(MyUniverse.ProgramOptions.SelectedSymbolName)) Then
                                LocalIndex = IndexNamed
                                While LocalIndex <= TopOfFile("Symbol") - 1
                                    FindingMyBugs(10)
                                    'MyMsgCtr(1038, "MyFindPoint", Symbol_TableCoded_String(LocalIndex), LocalIndex.ToString, MyXY.x.ToString, MyXY.y.ToString, "", "", "", "", "")
                                    LocalIndex += 1
                                    Select Case LCase(Symbol_TableCoded_String(LocalIndex))
                                        Case "/name", "/Constant" ' Added Constant incase we are at the end
                                            ' A I N F O 2 (146)
                                            Exit Function
                                        Case "/point"
                                            'Distance1 = MyABS(MyXY.x - Symbol_TableX1(LocalIndex)) + MyABS(Myxy.y - Symbol_TableY1(LocalIndex))
                                            Distance1 = MyDistance(MyXY, MyPoint1XY(LocalIndex))
                                            If Distance1 < Distance3 Then
                                                MyFindPoint = LocalIndex
                                                Distance3 = Distance1
                                            End If
                                        Case "/line"
                                            'Distance1 = MyABS(MyXY.x - Symbol_TableX1(LocalIndex)) + MyABS(Myxy.y - Symbol_TableY1(LocalIndex))
                                            Distance1 = MyDistance(MyXY, MyPoint1XY(LocalIndex))
                                            If Distance1 < Distance3 Then
                                                MyFindPoint = LocalIndex
                                                Distance3 = Distance1
                                            End If
                                            'Distance1 = MyABS(MyXY.x - Symbol_TableX2_io(index)) + MyABS(Myxy.y - Symbol_TableY2_dt(index))
                                            Distance1 = MyDistance(MyXY, MyPoint2_2XY(LocalIndex))
                                            If Distance1 < Distance3 Then
                                                MyFindPoint = LocalIndex
                                                Distance3 = Distance1
                                            End If
                                        Case Else
                                    End Select
                                End While
                            End If
                        End If
                    Next

                Case "optionsWindow" 'Never happen
                    FindingMyBugs(10)
                Case "fileIOWindow"
                    FindingMyBugs(10)
                Case "statusWindow"
                    FindingMyBugs(10)
                Case Else
                    FindingMyBugs(10)
            End Select
            'FindingMyBugs(10) 
        End Function



        'Routine this finds where to start everything at
        Public Shared Function Find_Start(Where As PictureBox) As Int32
            Dim Index As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2336, 10, "Find_Start")
#End If
            MyMsgCtr(1090, "Find_Start", "", "", "", "", "", "", "", "", "")
            ' This sets up to run the interactive
            For Index = 1 To TopOfFile("FlowChart")
                If LCase(Trim(FlowChart_TableCode(Index))) = My_keyWord(My_KeyConstUse) Then
                    If UCase(FlowChart_TableSymbol_Name(Index)) = "START" Or UCase(FlowChart_TableSymbol_Name(Index)) = "MAIN" Then
                        MyUniverse.ProgramOptions.SelectedObject = Index
                        Find_Start = Index
                        ReSetScrollBars(Index)
                        Clear_Window(Where)
                        ' A I N F O 2 (147)
                        Exit Function
                    End If
                End If
            Next
            'MyMsgCtr(1214, "Find_Start", "", "", "", "", "", "", "", "", "")
            Find_Start = ConstantMyErrorCode
            FindingMyBugs(10)
        End Function


        'Routine while getpoint is 1 (true) then getting the next point
        Public Shared Function GetPoint(IndexFlowChart As Int32, ByRef atXY As MyPointStructure, CountOfPoints As Int32) As MyPointStructure  'Get the closest Point to X & Y 
            Dim IndexSymbol As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2337, 10, "GetPoint")
#End If
            CheckForAnySortNeeded(184) 'hack
            IndexSymbol = FindInSymbolList(FlowChart_TableSymbol_Name(IndexFlowChart))
            CheckForAnySortNeeded(185) 'hack
            If IndexSymbol = ConstantMyErrorCode Then
                MSG_ABug(1214, CountOfPoints.ToString, FlowChart_TableSymbol_Name(IndexFlowChart), TopOfFile("Symbol").ToString)
                If MyOptionTest(25) = True Then
                Else
                End If
                GetPoint = MyUniverse.MyStaticData.ZeroZero ' failed to get this point number (because the Symbol doesn't exist)
                ' A I N F O 2 (148)
                Exit Function
            End If

            IndexSymbol += 1 ' Jump over the name of this Symbol

            'Count down till we have the point number
            FindingMyBugs(10)
            While CountOfPoints > 1 And IndexSymbol <= TopOfFile("Symbol") - 1
                'MyMsgCtr(1028, "GetPoint", Symbol_TableCoded_String(IndexSymbol), IndexSymbol.ToString, "", "", "", "", "", "", "")
                Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                    Case "/name"    'Next Symbol
                        GetPoint = MyUniverse.MyStaticData.ZeroZero    ' No more points in the Symbol table
                        ' A I N F O 2 (149)
                        Exit Function
                    Case "/point"
                        If CountOfPoints < 0 Then ' we are trying to get more points than exist somehow
                            GetPoint = MyUniverse.MyStaticData.ZeroZero    ' No more points in the Symbol table
                            ' A I N F O 2 (150)
                            Exit Function
                        End If
                        If CountOfPoints = 0 Then
                            atXY = MyRotated(IndexSymbol, IndexFlowChart)
                            GetPoint = atXY ' We have the count of points into the simbol
                            ' A I N F O 2 (151)
                            Exit Function
                        End If
                        CountOfPoints -= 1 'CountOfPoints = CountOfPoints -1 ' get the next one
                    Case Else
                        MSG_ABug(1215, "GetPoint unknown code", Symbol_TableCoded_String(IndexSymbol), "")
                        '?GetPoint = MyUniverse.MyStaticData.Zerozero    ' No more points in the Symbol table
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                End Select
            End While
            FindingMyBugs(10)
            GetPoint = MyUniverse.MyStaticData.ZeroZero    'Should never get here 
        End Function


        'Routine 
        Public Shared Function GetSymbolPoint_Unused(SymbolName As String, ByRef xy As MyPointStructure, PointCount As Int32) As Boolean
            Dim IndexSymbol As Int32
            Dim Index As Int32
            Dim NumberOfThisPoint As Int32
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2338, 10, "GetSymbolPoint_Unused")
#End If
            GetSymbolPoint_Unused = False

            CheckForAnySortNeeded(186) 'hack

            IndexSymbol = FindInSymbolList(SymbolName)
            CheckForAnySortNeeded(187) 'hack
            If IndexSymbol = ConstantMyErrorCode Then
                MSG_ABug(1216, "Symbol name not found ", SymbolName, "")
                If MyOptionTest(25) = True Then
                Else
                End If
                Exit Function
            End If

            IndexSymbol += 1 ' Get it off of the name
            NumberOfThisPoint = 0
            FindingMyBugs(10)
            For Index = IndexSymbol To PointCount
                Select Case LCase(Symbol_TableCoded_String(Index))
                    Case "/name"
                        ' A I N F O 2 (156)
                        Exit Function 'no more points
                    Case "/point"
                        NumberOfThisPoint += 1 ' Count of the number of points
                        If NumberOfThisPoint = PointCount Then
                            xy = MyRotated_1(Index, MyUniverse.MyStaticData.ZeroZero, "Default")
                            GetSymbolPoint_Unused = True ' Means that is has found a point
                            Exit Function
                        End If
                    Case Else
                        'ignore everything else
                End Select
            Next
            FindingMyBugs(10)
            ' A I N F O 2 (158)
        End Function


        'Routine Testing for two points inside the Window
        'Routine Texting for single point inside the Window
        Public Shared Function InSideMyWindow(Where As PictureBox, RealWorld As MyPointStructure) As Boolean
            Dim WhereAt1XY As MyPointStructure
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2339, 6, "IsSideMyWindow " & MyShowWindowSizes())
#End If
            'If MyUniverse.MyMouseAndDrawing.MyWindow.a.x = 0 Then
            'If MyUniverse.MyMouseAndDrawing.MyWindow.a.y = 0 Then
            'If MyUniverse.MyMouseAndDrawing.MyWindow.b.x = 0 Then
            'If MyUniverse.MyMouseAndDrawing.MyWindow.b.y = 0 Then
            'Return True ' cause we DoNot know yet how big the Window is , so everything i sconsidered inside
            'End If
            'End If
            'End If
            'End If
            'DEBUG ONLY            Return True

            WhereAt1XY = Copy2WindowXY(Where, RealWorld)

            ' All Left of my Window
            If WhereAt1XY.x < MyUniverse.MyMouseAndDrawing.MyWindow.a.x Then
#If MINEDEBUG Then
                'MyMsgCtr(1260, "InSideMyWindow", MyUniverse.MyMouseAndDrawing.MyWindow.a.x.ToString, MyUniverse.MyMouseAndDrawing.MyWindow.a.y.ToString, MyUniverse.MyMouseAndDrawing.MyWindow.b.x.ToString, MyUniverse.MyMouseAndDrawing.MyWindow.b.y.ToString, "", "", "", "", "")
#End If
                InSideMyWindow = False
                Exit Function
            End If
            ' All Right of my Window
            If WhereAt1XY.x > MyUniverse.MyMouseAndDrawing.MyWindow.b.x Then
#If MINEDEBUG Then
                'MyMsgCtr(1260, "InSideMyWindow", MyUniverse.MyMouseAndDrawing.MyWindow.a.x.ToString, MyUniverse.MyMouseAndDrawing.MyWindow.a.y.ToString, MyUniverse.MyMouseAndDrawing.MyWindow.b.x.ToString, MyUniverse.MyMouseAndDrawing.MyWindow.b.y.ToString, "", "", "", "", "")
#End If
                InSideMyWindow = False
                Exit Function
            End If
            ' All above my Window
            If WhereAt1XY.y < MyUniverse.MyMouseAndDrawing.MyWindow.a.y Then
#If MINEDEBUG Then
                'MyMsgCtr(1260, "InSideMyWindow", MyUniverse.MyMouseAndDrawing.MyWindow.a.x.ToString, MyUniverse.MyMouseAndDrawing.MyWindow.a.y.ToString, MyUniverse.MyMouseAndDrawing.MyWindow.b.x.ToString, MyUniverse.MyMouseAndDrawing.MyWindow.b.y.ToString, "", "", "", "", "")
#End If
                InSideMyWindow = False
                Exit Function
            End If
            If WhereAt1XY.y > MyUniverse.MyMouseAndDrawing.MyWindow.b.y Then
#If MINEDEBUG Then
                'MyMsgCtr(1260, "InSideMyWindow", MyUniverse.MyMouseAndDrawing.MyWindow.a.x.ToString, MyUniverse.MyMouseAndDrawing.MyWindow.a.y.ToString, MyUniverse.MyMouseAndDrawing.MyWindow.b.x.ToString, MyUniverse.MyMouseAndDrawing.MyWindow.b.y.ToString, "", "", "", "", "")
#End If
                InSideMyWindow = False
                Exit Function
            End If
            ' Else It miight be true, 

            InSideMyWindow = True
        End Function

        'test of it is all ouside of the other
        Public Shared Function IsBetween(A As MyLineStructure, B As MyLineStructure) As Boolean
#If MINEDEBUG Then
                    If MyDebug(10 ) then follow(2340, 10, "IsBetween")
#End If
            If A.b.x < B.a.x Then Return False 'a left of b
            If A.a.x > B.b.x Then Return False 'a right of b
            If A.b.y < B.a.y Then Return False 'a below b
            If A.a.y > B.b.y Then Return False ' a above b
            ' A I N F O 2 (102)
            Return True
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' Between the first value and the third value, this compares where the second (middle) value belongs at.
        'Test # Results Testing A, b, C
        '1   5     b=nothing
        '2   0   A And C = nothing
        '3   -1     A=b
        '4   1   b=C
        '5   -4  A=nothing And b< C
        '6   4     C=nothing And b > A
        '7   -4  A=Nothing
        '8   4     C = nothing
        '9   -5  A > C 'Unsorted List
        '10  0     A<b<C 'not in the list but should go between these
        '11  -3     A>b
        '12  -2  b > C
        '13  3     b < C
        '14  2   A < b
        '15  5     default fails everything above (Should never happen)


        Public Shared Function MyCompared3(StringA As String, StringB As String, StringC As String) As SByte
            Dim A, B, C As String
            'Test # Results Testing A, b, C
            '1   5 b=nothing (So you are at the end of the list (Assume that B > a or A = nothing)
            '2   0   A And C = nothing (No Items in the list , empty list)
            '3   -1 A=b
            '4   1   b=C
            '5   -4  A=nothing And b< C
            '6   4 C=nothing And b > A
            '7   -4  A=Nothing
            '8   4 C = nothing
            '9   -5  A > C 'Unsorted List
            '10  0 A<b<C 'not in the list but should go between these
            '11  -3 A>b
            '12  -2  b > C
            '13  3 b < C
            '14  2   A < b
            '15  5 default fails everything above (Should never happen)
#If MINEDEBUG Then
            if MyDebug(11 ) then follow(2341, 11, "MyCompared3")
#End If
            A = LCase(MyTrim(StringA))
            B = LCase(MyTrim(StringB))
            C = LCase(MyTrim(StringC))

            '2020-12-12 Added test to make sure that A is not null (or nothing)
            If MyIsNothing(StringA) Or A = "" Then
                If MyIsNothing(StringB) Or B = "" Then
                    'MSG_ABug(1217, HighLight(A), HighLight(B), HighLight(C))
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                    Return 5 'End of the list (and not the beginning of the list
                End If
            End If
            'First One in the List is between them 
            If IsNullOrNothing(A) And IsNullOrNothing(C) And Not MyIsNothing(StringB) Then
                ' A I N F O 2 (-104)
                Return 0 'First item in the list
            End If
            '-1 A = B
            If A = B Then
                '' A I N F O 2 (105)
                Return -1
            End If
            ' 1 B = C
            If B = C Then
                '' A I N F O 2 ( 1 0 6 )
                Return 1
            End If
            '-4 A = start Of list (So Lowest)
            If IsNullOrNothing(A) And B < C Then
                ' A I N F O 2 (-107)
                Return -4 ' Start of the list (See below also)
            End If
            ' 4 C is the end of the list (So Highest)
            If IsNullOrNothing(C) And B > A Then
                '' A I N F O 2 (108)
                Return 4 ' end of the list (See below also)
            End If

            '2020 07 31 'special case if there is a sorted list at the top or bottom
            If A = C And B < C Then
                ' A I N F O 2 (-109)
                Return -4 ' Start of the list (See below also)' Or ELSE you have A and B the same (index array item)
            End If
            ' 4 C is the end of the list (So Highest)
            If A = C And B > A Then
                '' A I N F O 2 (110)
                Return 4 ' end of the list (See below also)
            End If

            If IsNullOrNothing(A) Then
                ' A I N F O 2 (-111)
                Return -4 ' Start of the list?
            End If
            If IsNullOrNothing(C) And A > B Then 'A Is higher than B  And C = nothing
                ' A I N F O 2 (-112)
                Return -3 ' Added 2021/01/07
            End If
            ' 4 C is the end of the list (So Highest)
            If IsNullOrNothing(C) Then
                ' A I N F O 2 (113)
                Return 4 ' end of the list (Also)?
            End If
            '-5 A is not <= than C (A>C) Error
            If A > C Then
                ' A I N F O 2 (-114)
                Return -5
            End If
            ' 0 B is between A and C
            If (A < B) And (B < C) Then
                '' A I N F O 2 (115)
                Return 0
            End If
            '-3 A is higher than B  and C = nothing
            If A > B Then
                '' A I N F O 2 (116)
                Return -3
            End If
            '-2 B is higher than C
            If B > C Then
                '    ' A I N F O 2 (117)
                Return -2
            End If
            ' 3 C is higher then B
            If B < C Then
                ' A I N F O 2 (118)
                Return 3
            End If
            ' 2 A is lower than B 
            If A < B Then
                ' A I N F O 2 (119)
                Return 2
            End If
            ' 5 Error
            MSG_ABug(1218, A, B, C)
            If MyOptionTest(25) = True Then
            Else
            End If
            ' A I N F O 2 (120)
            Return 5 ' default error
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This is used for checking if the indexes are valid or not
        Public Shared Function MyCompared2(ByRef MyArray() As String, ByRef ISAM() As Int32, A As Int32, B As Int32) As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2342, 10, "MyCompared2")
#End If
            If InvalidIndex(A, MyArray, ISAM) Then
                Return -5
            End If
            If InvalidIndex(B, MyArray, ISAM) Then
                Return -5
            End If
            If InvalidIndex(ISAM(A), MyArray, ISAM) Then
                Return -5
            End If
            If InvalidIndex(ISAM(B), MyArray, ISAM) Then
                Return -5
            End If
            MyCompared2 = MyCompared1_a(MyArray(ISAM(A)), MyArray(ISAM(B)))
        End Function


        Public Shared Function MyCompared2(ByRef Myarraylong() As Int32, ByRef ISAM() As Int32, A As Int32, B As Int32) As Integer
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2343, 10, "MyCompared2")
#End If
            If InvalidIndex(A, Myarraylong, ISAM) Then
                MyCompared2 = -5
                Exit Function
            End If
            If InvalidIndex(B, Myarraylong, ISAM) Then
                MyCompared2 = -5
                Exit Function
            End If
            If InvalidIndex(ISAM(A), Myarraylong, ISAM) Then
                MyCompared2 = -5
                Exit Function
            End If
            If InvalidIndex(ISAM(B), Myarraylong, ISAM) Then
                MyCompared2 = -5
                Exit Function
            End If
            MyCompared2 = MyCompared1(Myarraylong(ISAM(A)), Myarraylong(ISAM(B)))
        End Function



        Public Shared Function MyCompared1(A As Int32, B As Int32) As SByte
            '-2 A = start Of list (So Lowest)
            '-1 A is lower than B (Default if nothing else)
            ' 0 A and B match 
            ' 1 A is higher than B
            ' 2 B is the end of the list (So Highest)
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2344, 10, "MyCompared1")
#End If
            If A = B Then
                ' A I N F O 2 (128)
                Return 0
            End If
            'If the first Is nothing then it is considered the largest
            If MyIsNothing(A.ToString) Then
                ' A I N F O 2 (129)
                Return -2 'Nothing or null is always the highest
            End If
            ' If the second is nothing then 
            If MyIsNothing(B.ToString) Then
                ' A I N F O 2 (130)
                Return 2 ' You are always searching for something less than nothing or a null
            End If

            'Now we can actually test the two string
            If A > B Then
                ' A I N F O 2 (131)
                Return 1
            End If
            'The default is A < B and anything else is false
            If B > A Then
                ' A I N F O 2 (132)
                Return -1
            End If
            ' Al conditions should have been meet
            MSG_ABug(1219, "A And B Is Not comparable ", A.ToString, B.ToString)
            If MyOptionTest(25) = True Then
            Else
            End If
            Return -5 'Error
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        '-2=(start), -1=(A<B), 0=(A=B),1=(A>B),2=(B=End)
        ' Compare two strings to see the order they should be in
        '-2 A = start Of list (So Lowest)
        '-1 A is lower than B (Default if nothing else)
        ' 0 A and B match 
        ' 1 A is higher than B
        ' 2 B is the end of the list (So Highest)


        Public Shared Function MyCompared1_a(StringA As String, StringB As String) As SByte
            Dim A, B As String
#If MINEDEBUG Then
            if MyDebug(11 ) then follow(2345, 11, "MyCompare1_a")
#End If

            '-2 A = start Of list (So Lowest)
            '-1 A is lower than B (Default if nothing else)
            ' 0 A and B match 
            ' 1 A is higher than B
            ' 2 B is the end of the list (So Highest)

            A = LCase(MyTrim(StringA))
            B = LCase(MyTrim(StringB))
            If A = B Then
                Return 0
            End If
            If StringA = "," Then A = ","
            If StringB = "," Then B = ","
            'If the first Is nothing then it is considered the largest
            If A = "_" Or A = "" Or MyIsNothing(A) Then
                Return -2 'Nothing or null is always the highest
            End If
            ' If the second is nothing then 
            If B = "_" Or B = "" Or MyIsNothing(B) Then
                Return 2 ' You are always searching for something less than nothing or a null
            End If

            'Now we can actually test the two string
            If A > B Then
                Return 1
            End If
            'The default is A < B and anything else is false
            If B > A Then
                Return -1
            End If
            ' Al conditions should have been meet
            MSG_ABug(1220, "A And B Is Not comparable ", A, B)
            If MyOptionTest(25) = True Then
            Else
            End If
            Return -5 'Error
        End Function

        Public Shared Function ComputerFileNamesAre() As String
            Dim i As Int32
            Dim C, E, F As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2346, 10, "ComputerFileNamesAre")
#End If
            'todo this needs to add multiply extensions (and the correct ones)
            E = MyUniverse.ProgramOptions.FCCL_Extension
            C = MyUniverse.ProgramOptions.FCCL_LanguageClassName
            F = ""

            i = 1
            While Len(E) > 1
                F &= C & " (*" & ThisExtension(MyUniverse.ProgramOptions.FCCL_Extension, i) & ")" & "|*" & ThisExtension(MyUniverse.ProgramOptions.FCCL_Extension, i) & "|"
                i += 1
                Pop(E, FD)
            End While
            F &= "all files (*.*)|*.*"
            Return F
        End Function


        'CHeck if this name is used, and then return one that is not used.
        Public Shared Function MakeNextName(SymbolName As String) As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2348, 10, "MakeNextName")
#End If
            MakeNextName = SymbolName & MyRnd()
            While FindInNamedList(MakeNextName) > 1
                MakeNextName &= Rnd(10)
            End While
        End Function






        Public Shared Function FindSymbolName(IndexSymbol As Int32) As String ' Finds tha name of the Symbol from the index in the graphic Symbols
            Dim LocalIndex As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2349, 10, "FindSymbolName")
#End If
            LocalIndex = IndexSymbol
            While LocalIndex > 0 And Symbol_TableCoded_String(LocalIndex) <> "/name"
                LocalIndex -= 1
            End While
            ' A I N F O 2 (121)
            Return Symbol_TableSymbolName(LocalIndex)
        End Function


        Public Shared Function MyGrammarName(BNF As String) As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2350, 10, "MyGrammarName")
#End If
            ' removed not needed ?MyGrammarName = BNF
            MyGrammarName = Pop(BNF, MyUniverse.SysGen.Constants.ConstantDelimiters)
        End Function


        Public Shared Function My_VariableName(CodeLine As String, RandomNumber As Int32) As String 'This should return the name of the variabl
            'ERROR this is not getting the correct variable name
            Dim MyArray(1) As String
            Dim Temp As String
            Temp = PopLine(MyNoCR(CodeLine))
            MyUniverse.MyStaticData.Path_Names = MyParse(MyArray, CodeLine)
            MyUniverse.MyStaticData.Path_NamesCounted = CountPathNames(MyUniverse.MyStaticData.Path_Names)
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2352, 10, "MY_VariableName : " & ReturnPathName(NumberOfTheVariable, MyUniverse.MyStaticData.Path_Names))
  if mydebug(9) then follow(2352, 1, "MY_VariableName : " & ReturnPathName(NumberOfTheVariable, MyUniverse.MyStaticData.Path_Names))
#End If

            Return ReturnPathName(RandomNumber, MyUniverse.MyStaticData.Path_Names)
        End Function



        Public Shared Function KeyWordForCodeLine(CodeLine As String) As String
            Dim Temp(1) As String
            Dim I As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2353, 10, "KeyWordForCodeLine " & CodeLine)
#End If
            KeyWordForCodeLine = ""
            MyUniverse.MyStaticData.Path_Names = MyParse(Temp, CodeLine) ' Parse the code line then
            MyUniverse.MyStaticData.Path_NamesCounted = CountPathNames(MyUniverse.MyStaticData.Path_Names)
            For I = 1 To UBound(Temp)
                Select Case IsThisAWhat(Temp(I))
                    Case MyUniverse.SysGen.Constants.SyntaxKeyWords, MyUniverse.SysGen.Constants.SyntaxFunctions
                        KeyWordForCodeLine &= Temp(I)
                    Case MyUniverse.SysGen.Constants.SyntaxCameFromLine ' Ignore for a name
                        KeyWordForCodeLine &= "1"
                    Case MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine ' Ignore for a name
                        KeyWordForCodeLine &= "2"
                    Case MyUniverse.SysGen.Constants.SyntaxOperators
                        KeyWordForCodeLine &= Temp(I)
                    Case MyUniverse.SysGen.Constants.SyntaxSpecialCharacters
                        KeyWordForCodeLine &= "_"
                    Case MyUniverse.SysGen.Constants.SyntaxQuotes
                        KeyWordForCodeLine &= "Q"
                    Case MyUniverse.ProgramOptions.FCCL_MultiLine
                        KeyWordForCodeLine &= "" 'Multiline not allowed right now"
                    Case Nothing
                        'MSG_AInfo1(1227,  "Nothing, comma", IsThisAWhat(Temp(I)), "")
                        Return KeyWordForCodeLine '&= ""
                    Case MyUniverse.SysGen.Constants.SyntaxFieldDelimiters, FD
                        'MSG_AInfo1(1228,  "Nothing, comma", IsThisAWhat(Temp(I)), "")
                        KeyWordForCodeLine &= "_"
                    Case MyUniverse.ProgramOptions.FCCL_Comment
                        KeyWordForCodeLine &= ""
                    Case MyUniverse.ProgramOptions.FCCL_Extensions
                        KeyWordForCodeLine &= ""
                    Case MyUniverse.ProgramOptions.FCCL_MultiLine
                        KeyWordForCodeLine &= "COLON"
                    Case MyUniverse.ProgramOptions.FCCL_VarChars
                        KeyWordForCodeLine &= MyUniverse.ProgramOptions.FCCL_VarChars
                    Case MyUniverse.SysGen.Constants.SyntaxComments
                        KeyWordForCodeLine &= ""
                    Case Else 'todo need to check if this is a marker for a keyword 
                        KeyWordForCodeLine &= "Variable" 'NameOfPointOnly(Temp(I))
                End Select
            Next I
        End Function

        Public Shared Function MakeNewName(StartOfName As String, CodeLine As String) As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2354, 10, "MakeNewName")
#End If
            MyMakeArraySizesBigger()
            If MyUniverse.SysGen.HighestSymbolNumber < 100 Then
                MyUniverse.SysGen.HighestSymbolNumber = PopValue(Mid(TimeString, 7, 2) & Mid(TimeString, 4, 2) & Mid(TimeString, 1, 2))
            End If
            MyUniverse.SysGen.HighestSymbolNumber += 1

            'MakeNewName = StartOfName & "_" & MyUniverse.MySS.Inputs.LineNumberIn & "_" & MyUniverse.SysGen.HighestSymbolNumber & "_" & keyWordForCodeLine()
            MakeNewName = StartOfName & MyUniverse.MySS.Inputs.LineNumberIn & "_" & KeyWordForCodeLine(CodeLine)
            Return MakeNextName(MakeNewName)
        End Function


        ' This inserts all new records after the end of the /name, instead of at the end of the list after name (before the next /name)
        Public Shared Function AddNEWFlowChartRecordPath(SymbolName As String,
             Coded As String, X1 As Int32, Y1 As Int32, X2_io As Int32,
             Y2_dt As Int32, MyDataType As String) As Int32
            '
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2355, 10, "AddNewFlowChartRecordPath")
#End If
            MyMakeArraySizesBigger()
            'AddNEWFlowChartRecordPath = NewTopOfFile("FlowChart")
            AddNEWFlowChartRecordPath = AddFlowChartRecordOther(SymbolName, Coded, X1, Y1, X2_io, Y2_dt, MyDataType.ToString, "")
            ConnectPath(AddNEWFlowChartRecordPath)
        End Function
        Public Shared Function AddNEWFlowChartRecordUse(SymbolName As String, Coded As String, X1 As Int32, Y1 As Int32, X2_io As String, Y2_dt As String, MyDataType As String) As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2356, 10, "AddNewFlowChartRecordUse")
#End If
            MyMakeArraySizesBigger()
            'AddNEWFlowChartRecordUse = NewTopOfFile("FlowChart")
            AddNEWFlowChartRecordUse = AddFlowChartRecordOther(SymbolName, Coded, X1, Y1, My_INT(X2_io), My_INT(Y2_dt), MyDataType.ToString, "") ', LineNumber
        End Function


        Public Shared Sub AddNEWSymbolLineRecord(SymbolName As String, Coded As String, X1 As Int32, Y1 As Int32, X2 As Int32, Y2 As Int32, MyName_Of_Point As String)
            Dim IndexSymbol, IndexNamed As Int32
            Dim PointName As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2357, 10, "AddNewSymbolLineRecord")
            FindingMyBugs(9)
#End If
            PointName = MyName_Of_Point
            PointName = Pop(PointName, MyUniverse.SysGen.Constants.ConstantDelimiters) ' make sure that it is only one word
            MyMakeArraySizesBigger()

            IndexNamed = FindIndexInISAMTable("named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, SymbolName)
            If IndexNamed = ConstantMyErrorCode Then
                IndexNamed = CheckNotInList("named", Named_FileSymbolName, SymbolName)
                If IndexNamed = ConstantMyErrorCode Then
                    IndexNamed = AddNewNamedRecord(SymbolName, "Missing", "Opcode", "Added Named that was missing", CreateFileNameFromSyntax(Coded & MyName_Of_Point), "Auto", "Version", "", "") 'MyUniverse.ProgramOptions.FCCL_LanguageClassName,
                    If IndexNamed = ConstantMyErrorCode Then
                        MSG_ABug(1229, "Trying to add Symbol graphics to a Symbol that has not been created yet", HighLight(SymbolName), "Unable to add this record")
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                    End If
                    ReSortStringArray("named", Named_FileSymbolName, Named_FileSymbolName_ISAM)
                    ReSortStringArray("named", Named_FileSyntax, Named_FileSyntax_ISAM)
                End If
            End If
            ' The following is not return correctly
            IndexSymbol = FindInSymbolList(SymbolName) ' Search the named 
            'FindingMyBugs(80) 
            If IndexSymbol > 0 Then
                IndexSymbol += 1 ' move to one after the name
                'FindingMyBugs(20) 
                If Coded <> "/name" Then MyInsertSymbolLineRecord(IndexSymbol, SymbolName, Coded, MyLine1(X1, Y1, X2, Y2), PointName)
                MyMakeArraySizesBigger()
                'FindingMyBugs(80)  2020 08 04
            Else
                ' New name and record so add name if not already there (which its not) and then this record
                IndexSymbol = NewTopOfFile("Symbol")
                ' AddFlowChartRecord() the record to the end after a New name record cause there is no name record now.
                If LCase(Coded) = "/name" Then ' We have to add a missing /name record
                    UpdateSymbollineRecordAt(IndexSymbol, SymbolName, Coded, X1, Y1, X2, Y2, PointName)
                    FindingMyBugs(50)
                    Return
                Else
                    IndexSymbol += 1 ' To one after the end of the end of the file 2020 08 06
                    FindingMyBugs(40)
                    MyInsertSymbolLineRecord(IndexSymbol, SymbolName, Coded, MyLine1(X1, Y1, X2, Y2), PointName)
                    FindingMyBugs(30) 'hack Least amount of checking here 2020 08 04
                End If
            End If
            ReSortSymbolList()
            ''FindingMyBugs(10)
            TopOfFile("Symbol") ' This is to update the top of the file counter
            'FindingMyBugs(10)
        End Sub




        ' This inserts all new records after the end of the /name, instead of at the end of the list after name (before the next /name)
        Public Shared Sub AddNEWSymbolpointRecord(SymbolName As String, Coded As String, X1 As Int32, Y1 As Int32, IO As String, DT As String, MyName_Of_Point As String)
            Dim IndexSymbol, IndexNamed As Int32
            Dim PointName As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2358, 10, "AddNewSymbolPointRecord")
#End If
            'FindingMyBugs(80) 'hack Least amount of checking here
            PointName = MyName_Of_Point
            PointName = Pop(PointName, MyUniverse.SysGen.Constants.ConstantDelimiters) ' make sure that it is only one word
            MyMakeArraySizesBigger()

            IndexNamed = FindIndexInISAMTable("named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, SymbolName)
            If IndexNamed = ConstantMyErrorCode Then
                IndexNamed = CheckNotInList("named", Named_FileSymbolName, SymbolName)
                If IndexNamed = ConstantMyErrorCode Then
                    'IndexNamed =
                    AddNewNamedRecord(SymbolName, "Missing", "Opcode", "Added Named that was missing", CreateFileNameFromSyntax(Coded & MyName_Of_Point), "Auto", "Version", "", "") ', MyUniverse.ProgramOptions.FCCL_LanguageClassName
                    ReSortStringArray("named", Named_FileSymbolName, Named_FileSymbolName_ISAM)
                    ReSortStringArray("named", Named_FileSyntax, Named_FileSyntax_ISAM)
                End If
            End If
            ' The following is not return correctly
            IndexSymbol = FindInSymbolList(SymbolName) ' Search the named 
            If IndexSymbol > 0 Then
                'FindingMyBugs(10) 'hack Least amount of checking here
                IndexSymbol += 1 ' move to one after the name
                'FindingMyBugs(10) 'hack Least amount of checking here
                If LCase(Coded) <> "/name" Then '2020 08 01 we do not want to add two name records, 
                    'FindingMyBugs(80) 'hack Least amount of checking here 2020 08 04
                    MyInsertSymbolPointRecord(IndexSymbol, SymbolName, Coded, X1, Y1, IO, DT, PointName)
                    MyMakeArraySizesBigger()
                    'FindingMyBugs(30) 'hack Least amount of checking here 2020 08 04
                Else ' 2020 08 11 but we will NOT update the record after the name name record
                    '    FindingMyBugs(10)'hack Least amount of checking here 2020 08 04
                    '    UpdateSymbolRecordAt(IndexSymbol, SymbolName, Coded, X1, Y1, NumberOrIO(X2_io), ~Y2_dt), PointName)
                    '    FindingMyBugs(10)'hack Least amount of checking here 2020 08 04
                End If
            Else
                ' New name and record so add name if not already there (which its not) and then this record
                IndexSymbol = NewTopOfFile("Symbol")
                ' AddFlowChartRecord() the record to the end after a New name record cause there is no name record now.
                If LCase(Coded) = "/name" Then ' We have to add a missing /name record
                    'FindingMyBugs(20) 'hack Least amount of checking here 2020 08 04
                    ' We have to have a sumbol name first
                    UpdateSymbolPointRecordAt(IndexSymbol, SymbolName, Coded, X1, Y1, IO, DT, PointName)
                    'FindingMyBugs(20) 'hack Least amount of checking here 2020 08 06
                    Return
                Else '2020 08 06
                    'We are not updating /name records ever here
                    'UpdateSymbolRecordAt(IndexSymbol, SymbolName, "/name", 0, 0, "both", "Default", "Default")
                    ' set the record after 
                    IndexSymbol += 1 ' To one after the end of the end of the file 2020 08 06
                    'FindingMyBugs(50) 'hack Least amount of checking here 2020 08 04
                    MyInsertSymbolPointRecord(IndexSymbol, SymbolName, Coded, X1, Y1, IO, DT, PointName)
                    'FindingMyBugs(20) 'hack Least amount of checking here 2020 08 04
                End If
            End If
            ReSortSymbolList()
            'FindingMyBugs(70) 'hack Least amount of checking here 2020 08 04
            TopOfFile("Symbol") ' This is to update the top of the file counter
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Make a new Symbol, or get the data from an old Symbol
        'based on the name in the Symbol text box
        '
        'Updates the text boxes on the Symbol Window and redraw.

        Public Shared Sub MyUpdateSymbolRecordFromSymbolWindow(What As String) 'undone needs to update the toolstrip Symbol selection on both the Symbol and FlowChart
            Dim Temp As Int32 ' max size of a Symbol
            Dim IndexNamed, IndexSymbol As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2359, 10, "MyUpdateSymbolRecordFromSymbolWindow")
#End If
            FMB1(8015)
            SymbolWindow.ComboBoxPointNameList.Text = ""
            SymbolWindow.ComboBoxLineNameList.Text = ""
            Clear_Window(SymbolWindow.PictureBox1)
            'Me.PictureBox1.Image = Nothing

            MyDoEvents(134)
            Temp = MyUniverse.SysGen.Constants.ConstantSymbolCenter * 2
            '
            'PaintEach(SymbolWindow.PictureBox1, MyPoint1XY(Temp, Temp), What, "Default") ' redraw the Symbol
            IndexNamed = FindISAM_IN_Table("named", "AddressOf", Named_FileSymbolName, Named_FileSymbolName_ISAM, What) ' Get where it is in the Symbols

            If IndexNamed = -1 Then ' Not found in the Named table, so Assume there is not defined Symbol
                'it as a new Symbol
                IndexNamed = FindISAM_IN_Table("named", "Add", Named_FileSymbolName, Named_FileSymbolName_ISAM, What)
                If IndexNamed > 0 Then
                    SymbolWindow.TextBoxNamedProgramText.Text = ""
                    MyDoEvents(135)
                    SymbolWindow.TextBoxNamedNameOfFile.Text = What
                    SymbolWindow.TextBoxNamedNotes.Text = ""
                    SymbolWindow.TextBoxNamedOpCode.Text = ""
                    SymbolWindow.TextBoxNamedStroke.Text = ""
                    MyDoEvents(136)
                    MyUniverse.ProgramOptions.SelectedSymbolName = ""
                    FMB1(8016)
                    SymbolWindow.ComboBoxPointNameList.Text = ""
                    SymbolWindow.ComboBoxPointNameList.Items.Clear()
                    FMB1(8017)
                    SymbolWindow.ComboBoxLineNameList.Text = ""
                    SymbolWindow.ComboBoxLineNameList.Items.Clear()
                    SymbolWindow.TextBoxSymbolVersionAuthor.Text = ""
                    GetSelfCorrectingIndexes(What)
                    MyDoEvents(137)
                    PaintEach(SymbolWindow.PictureBox1, MyPoint1XY(Temp, Temp), What, "Default") ' redraw the Symbol
                    Return
                End If
            Else ' If the Symbol already exist then update the Window with the data in the 'file'
                MyDoEvents(138)
                IndexNamed = Named_FileSymbolName_ISAM(IndexNamed)
                If IndexNamed <= 0 Then
                    PaintEach(SymbolWindow.PictureBox1, MyPoint1XY(Temp, Temp), What, "Default") ' redraw the Symbol
                    Return
                End If
                Named_TableMicroCodeText(IndexNamed, SymbolWindow.TextBoxNamedProgramText.Text)
                Named_TableNameOfFile(IndexNamed, SymbolWindow.TextBoxNamedNameOfFile.Text)
                Named_TableNotes(IndexNamed, SymbolWindow.TextBoxNamedNotes.Text)
                Named_TableOpCode(IndexNamed, SymbolWindow.TextBoxNamedOpCode.Text)
                Named_TableStroke(IndexNamed, SymbolWindow.TextBoxNamedStroke.Text)
                Named_TableSymbolName(IndexNamed, MyUniverse.ProgramOptions.SelectedSymbolName)
                'todo make sure that the verssion and author is formated right (What ever right happends to end up being.)
                Named_TableVersion(IndexNamed, SymbolWindow.TextBoxSymbolVersionAuthor.Text)
                FMB1(8018)
                SymbolWindow.ComboBoxPointNameList.Text = ""
                FMB1(8019)
                MyDoEvents(141)
                ' Updating the quick Indexes to the Symbol
                IndexSymbol = Named_TableSymbolIndexes(IndexNamed)
                If IndexSymbol > 0 Then ' make sure we have a Indexes
                    FindingMyBugsCheckForErrors(0, IndexNamed, IndexSymbol)
                    If Named_TableSymbolName(IndexNamed) = Symbol_TableSymbolName(IndexSymbol) Then ' make sure its the same Symbol still
                        If Symbol_TableCoded_String(IndexSymbol) = "/name" Then ' make sure its the start of the Symbol
                            IndexSymbol += 1
                            While Symbol_TableCoded_String(IndexSymbol) <> "/name" And IndexSymbol <= TopOfFile("Symbol")
                                If Symbol_TableCoded_String(IndexSymbol) = "/point" Then
                                    FMB1(8020)
                                    SymbolWindow.ComboBoxPointNameList.Text = SymbolWindow.ComboBoxPointNameList.Text & ", " & Symbol_Table_NameOfPoint(IndexSymbol)
                                    MyDoEvents(142)
                                    FMB1(8021)
                                End If
                                IndexSymbol += 1
                            End While
                        Else
                            GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName)
                        End If
                    Else
                        GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName)
                    End If
                Else
                    GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName)
                End If
            End If
            PaintEach(SymbolWindow.PictureBox1, MyPoint1XY(Temp, Temp), What, "Default") ' redraw the Symbol
        End Sub


        Public Shared Sub UpdateSymbollineRecordAt(LocalIndex As Int32, SymbolName As String, Coded As String, X1 As Int32, Y1 As Int32, X2 As Int32, Y2 As Int32, NameOfPoint As String)
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2360, 10, "UpdateSymbolLineRecordAt")
#End If
            TopOfFile("Symbol") ' This is to reset the top of file counter only
            FindingMyBugs(10)
            If InvalidIndex(LocalIndex, Symbol_FileSymbolName) Then
                MSG_ABug(1231, "UpdateSymbolRecordAt has an index issue", LocalIndex.ToString, " So can Not update Name=" & SymbolName & " code= " & Coded)
                If MyOptionTest(25) = True Then
                Else
                End If
                Return
            End If
            Symbol_FileCoded(LocalIndex) = MyKeyword_2_Byte(Coded) ' I think that I forgot this one.
            Symbol_FileSymbolName(LocalIndex) = SymbolName
            Symbol_TableX1(LocalIndex, X1)
            Symbol_TableY1(LocalIndex, Y1)
            Symbol_Table_X2(LocalIndex, X2) ' these have to check for x2 or a io-name
            Symbol_Table_Y2(LocalIndex, Y2) ' these have to check for y2 or a DataType-name
            Symbol_Table_NameOfPoint(LocalIndex, NameOfPoint)
            FindingMyBugs(10) 'hack Least amount of checking here ' 2020 07 22
            ReSortSymbolList()
        End Sub




        Public Shared Sub UpdateSymbolPointRecordAt(LocalIndex As Int32, SymbolName As String, Coded As String, X1 As Int32, Y1 As Int32, X2_io As String, Y2_dt As String, NameOfPoint As String)
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2361, 10, "UpDateSymbolPointRecordAt")
#End If
            TopOfFile("Symbol") ' This is to reset the top of file counter only
            'FindingMyBugs(80) 
            If InvalidIndex(LocalIndex, Symbol_FileSymbolName) Then
                MSG_ABug(1232, "UpdateSymbolRecordAt has an index issue", LocalIndex.ToString, " So can Not update Name=" & SymbolName & " code= " & Coded)
                If MyOptionTest(25) = True Then
                Else
                End If
                Return
            End If
            Symbol_FileCoded(LocalIndex) = MyKeyword_2_Byte(Coded) ' I think that I forgot this one.
            Symbol_FileSymbolName(LocalIndex) = SymbolName
            Symbol_TableX1(LocalIndex, X1)
            Symbol_TableY1(LocalIndex, Y1)
            Symbol_Table_InputOutput(LocalIndex, X2_io) ' these have to check for x2 or a io-nameo
            Symbol_Table_DataType(LocalIndex, Y2_dt) ' these have to check for y2 or a DataType-name
            Symbol_Table_NameOfPoint(LocalIndex, NameOfPoint)
            'FindingMyBugs(10) 'hack Least amount of checking here ' 2020 07 22
            ReSortSymbolList()
        End Sub


        Public Shared Function AddNewNamedRecord(SymbolName As String, SourceCode As String, opcode As String, notes As String, filename As String, author As String, version As String, stroke As String, Syntax As String) As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2362, 10, "AddNewNamedRecord " & SymbolName & vbTab & SourceCode)
#End If

            '2020/6/22 change to return the record numberinstead of passing it.
            ' Bugs:
            ' Does not check if this name is already there.

            MyMakeArraySizesBigger()
            AddNewNamedRecord = FindIndexInISAMTable("named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, SymbolName)
            If AddNewNamedRecord > 0 Then
                Exit Function
            End If
            AddNewNamedRecord = NewTopOfFile("named")
            Named_FileSymbolName_ISAM(AddNewNamedRecord) = AddNewNamedRecord
            Named_FileSyntax_ISAM(AddNewNamedRecord) = AddNewNamedRecord
            Named_FileSymbolName(AddNewNamedRecord) = SymbolName

            Named_TableSymbolName(AddNewNamedRecord, SymbolName) 'Name of the Symbol
            Named_TableSymbolIndexes(AddNewNamedRecord, GetSelfCorrectingIndexes(SymbolName)) ' A Indexes to this Symbol in the Symbol Graphics Table
            'todo need to always make the text into macro code text (replace the variable name with " & Myfd("variablename.Path" ) & "
            Named_TableMicroCodeText(AddNewNamedRecord, SourceCode) 'The actual program code to be 'fixed'
            Named_TableOpCode(AddNewNamedRecord, opcode) 'The Machine code of this assemble Symbol
            Named_TableNotes(AddNewNamedRecord, notes) 'Notes for this Symbol

            Named_FileNameOfFile(AddNewNamedRecord) = filename '*******'*' This is to avoid index checking not having anything
            Named_TableNameOfFile(AddNewNamedRecord, filename)  'The device:/path/Filename where this came from 

            '    Named_TableLanguage(AddNewNamedRecord, language) 'The computer language this applies to
            Named_TableAuthor(AddNewNamedRecord, author) 'Who wrote or responsable for this Symbol
            Named_TableVersion(AddNewNamedRecord, version) ' the date of the latest update
            Named_TableStroke(AddNewNamedRecord, stroke) 'The movement of the mouse that id's this Symbol
            Named_TableSyntax(AddNewNamedRecord, Syntax) ' The Syntax for this
            Named_FileSyntax_ISAM(AddNewNamedRecord) = AddNewNamedRecord

            ShowSorts("Named", MyReSort("Named", Named_FileSymbolName, Named_FileSymbolName_ISAM, AddNewNamedRecord))
            ShowSorts("named", MyReSort("Named", Named_FileSyntax, Named_FileSyntax_ISAM, AddNewNamedRecord))
            GetSelfCorrectingIndexes(SymbolName)
            ShowSorts("Named", MyReSort("Named", Named_FileSymbolName, Named_FileSymbolName_ISAM, AddNewNamedRecord))
            TopOfFile("named") ' This is to update the top of file, and make the array bigger
        End Function

        Public Shared Function AddANewFlowChartRecord() As Int32
            '2020/6/22 change to return the record numberinstead of passing it.

#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2363, 10, "AddANewFlowChartRecord")
#End If
            MyMakeArraySizesBigger()
            AddANewFlowChartRecord = NewTopOfFile("FlowChart")
            If FlowChart_ISAM_Name(AddANewFlowChartRecord) <> 0 Then
                If FlowChart_ISAM_Name(AddANewFlowChartRecord) <> AddANewFlowChartRecord() Then
                    'MyMsgCtr(1018, "AddFlowChartRecord", MyShowFlowChartRecord(true , AddANewFlowChartRecord), "", "", "", "", "", "", "", "")
                    AddANewFlowChartRecord = AddANewFlowChartRecord
                End If
            End If

            MyMakeArraySizesBigger()
            If MyReSort("FlowChart", FlowChart_FilePathSymbolName, FlowChart_ISAM_Name, AddANewFlowChartRecord) < 0 Then
                FindingMyBugs(10) 'hack Least amount of checking here
                Exit Function
            End If
            FlowChart_ISAM_Name(AddANewFlowChartRecord) = AddANewFlowChartRecord

            If MyReSort("FlowChart", FlowChart_FilePathSymbolName, FlowChart_ISAM_Name, AddANewFlowChartRecord) < 0 Then
                FindingMyBugs(10) 'hack Least amount of checking here
                Exit Function
            End If
            FlowChart_ISAM_Name(AddANewFlowChartRecord) = AddANewFlowChartRecord
            FlowChart_ISAM_X1(AddANewFlowChartRecord) = AddANewFlowChartRecord
            FlowChart_ISAM_Y1(AddANewFlowChartRecord) = AddANewFlowChartRecord
            FlowChart_ISAM_X2(AddANewFlowChartRecord) = AddANewFlowChartRecord
            FlowChart_ISAM_Y2(AddANewFlowChartRecord) = AddANewFlowChartRecord
        End Function

        Public Shared Function AddFlowChartRecordPath(named As String, coded As String, x1 As Int32, y1 As Int32, x2 As Int32, y2 As Int32, MyDataType As String, Links As String) As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2364, 10, "AddFlowChartRecordPath")
#End If
            MyMakeArraySizesBigger()
            If coded <> "/path" Then
                MSG_ABug(1233, "Adding a " & coded & " And Not a path", named, MyDataType)
                If MyOptionTest(25) = True Then
                Else
                End If
            End If
            FMB(5024)
            AddFlowChartRecordPath = NewTopOfFile("FlowChart")
            FlowChart_ISAM_Name(AddFlowChartRecordPath) = AddFlowChartRecordPath
            FlowChart_ISAM_X1(AddFlowChartRecordPath) = AddFlowChartRecordPath
            FlowChart_ISAM_Y1(AddFlowChartRecordPath) = AddFlowChartRecordPath
            FlowChart_ISAM_X2(AddFlowChartRecordPath) = AddFlowChartRecordPath
            FlowChart_ISAM_Y2(AddFlowChartRecordPath) = AddFlowChartRecordPath
            FlowChart_TablePathSymbolName(AddFlowChartRecordPath, NameOfPointOnly(named))
            FlowChart_TableCode(AddFlowChartRecordPath, MyKeyword_2_Byte(coded).ToString)
            FlowChart_TableX1(AddFlowChartRecordPath, x1)
            FlowChart_TableY1(AddFlowChartRecordPath, y1)
            FlowChart_TableX2(AddFlowChartRecordPath, x2)
            FlowChart_TableY2(AddFlowChartRecordPath, y2)

            FlowChart_Table_DataType(AddFlowChartRecordPath, MyDataType) 'The DataType for /Path /Constant
            If FindIndex_In_TableNetLinks(AddFlowChartRecordPath) < 1 Then
                MakeNew_NetLinks(AddFlowChartRecordPath, named)
            End If
            ShowSorts("FlowChart", ReSortFlowChart(AddFlowChartRecordPath))
            'FindingMyBugs(40) 'hack Least amount of checking here
            TopOfFile("FlowChart") ' This is to update the top of file, and make the array bigger
            'MSG_AInfo(1234, " updated links FLow Chart record()", MyShowFlowChartRecord(true , AddFlowChartRecordPath), MyShowNetLnks(FindIndex_In_TableNetLinks(AddFlowChartRecordPath)))
            FMB(5025)
            Return AddFlowChartRecordPath
        End Function

        Public Shared Function AddFlowChartRecordUse(named As String, coded As String, x1 As Int32, y1 As Int32, Rotation As String, MyDataType As String) As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2365, 1, "AddFlowChartRecordUse " & coded & "=" & named)
#End If
            MyMakeArraySizesBigger()
            If coded <> My_keyWord(My_KeyConstUse) Then
                MSG_ABug(1235, "Adding a " & coded & " And Not a /use", named, MyDataType)
                If MyOptionTest(25) = True Then
                Else
                End If
            End If
            FMB(5026)
            AddFlowChartRecordUse = NewTopOfFile("FlowChart")
            FlowChart_ISAM_Name(AddFlowChartRecordUse) = AddFlowChartRecordUse
            FlowChart_ISAM_X1(AddFlowChartRecordUse) = AddFlowChartRecordUse
            FlowChart_ISAM_Y1(AddFlowChartRecordUse) = AddFlowChartRecordUse
            FlowChart_ISAM_X2(AddFlowChartRecordUse) = AddFlowChartRecordUse
            FlowChart_ISAM_Y2(AddFlowChartRecordUse) = AddFlowChartRecordUse
            FlowChart_TableCode(AddFlowChartRecordUse, MyKeyword_2_Byte(coded).ToString)
            FMB(5027)
            'FlowChart_FilePathSymbolName(AddFlowChartRecordUse) = named
            FlowChart_TablePathSymbolName(AddFlowChartRecordUse, named)

            FMB(5028)
            If MyDebug(10) Then follow(2900, 10, My.Application.Info.StackTrace)
            FlowChart_TableX1(AddFlowChartRecordUse, x1)
            FlowChart_TableY1(AddFlowChartRecordUse, y1)
            FlowChart_Table_Rotation(AddFlowChartRecordUse, Rotation)
            '    FlowChart_Table_DataType(AddFlowChartRecordUse, DataType)
            If FlowChartRecordMatches(AddFlowChartRecordUse, AddFlowChartRecordUse - 1) Then
                FlowChartDelete(AddFlowChartRecordUse)
            End If
            FMB(5029)
            If MyDebug(10) Then follow(2902, 10, My.Application.Info.StackTrace)
            FlowChart_Table_DataType(AddFlowChartRecordUse, MyDataType) 'The DataType for /Path /Constant
            ShowSorts("FlowChart", ReSortFlowChart(AddFlowChartRecordUse))
            FMB(5030)
            TopOfFile("FlowChart") ' This is to update the top of file, and make the array bigger
            Return AddFlowChartRecordUse
        End Function



        Public Shared Function AddFlowChartRecordOther(named As String, coded As String, x1 As Int32, y1 As Int32, x2 As Int32, y2 As Int32, MyDataType As String, Links As String) As Int32 '
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2366, 10, "AddFlowChartRecordOther")
#End If
            MyMakeArraySizesBigger()
            FMB(5031)
            AddFlowChartRecordOther = NewTopOfFile("FlowChart")
            FlowChart_ISAM_Name(AddFlowChartRecordOther) = AddFlowChartRecordOther
            FlowChart_ISAM_X1(AddFlowChartRecordOther) = AddFlowChartRecordOther
            FlowChart_ISAM_Y1(AddFlowChartRecordOther) = AddFlowChartRecordOther
            FlowChart_ISAM_X2(AddFlowChartRecordOther) = AddFlowChartRecordOther
            FlowChart_ISAM_Y2(AddFlowChartRecordOther) = AddFlowChartRecordOther

            FlowChart_TableCode(AddFlowChartRecordOther, MyKeyword_2_Byte(coded).ToString)
            'FlowChart_FilePathSymbolName(AddFlowChartRecordOther) = named
            FlowChart_TablePathSymbolName(AddFlowChartRecordOther, named)

            FlowChart_TableX1(AddFlowChartRecordOther, x1)
            FlowChart_TableY1(AddFlowChartRecordOther, y1)
            FlowChart_TableX2(AddFlowChartRecordOther, x2)
            FlowChart_TableY2(AddFlowChartRecordOther, y2)
            FlowChart_Table_DataType(AddFlowChartRecordOther, MyDataType) 'The DataType for /Path /Constant
            'MSG_AInfo(1236, "Added New Flow Chart Record", MyShowFlowChartRecord(true , AddFlowChartRecordOther), "")
            ShowSorts("FlowChart", ReSortFlowChart(AddFlowChartRecordOther))
            'FindingMyBugs(70) 'hack Least amount of checking here
            TopOfFile("FlowChart") ' This is to update the top of file, and make the array bigger
            If FindIndex_In_TableNetLinks(AddFlowChartRecordOther) < 1 Then
                MakeNew_NetLinks(AddFlowChartRecordOther, FlowChart_TablePath_Name(AddFlowChartRecordOther))
            End If
            FMB(5032)
            Return AddFlowChartRecordOther
        End Function



        Public Shared Function ReSortFlowChart(Index As Int32) As Int32
            '03/12/19 changed to only resort the top added item
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2367, 10, "ReSortFlowChart")
            if MyDebug(10 ) then follow(2793, 10, "Sort FlowChart at " & Index.ToString)
#End If
            ReSortFlowChart = MyReSort("FlowChart", FlowChart_FilePathSymbolName, FlowChart_ISAM_Name, Index)
            ReSortFlowChart += MyReSort("FlowChart", FlowChart_FileX1, FlowChart_ISAM_X1, Index)
            ReSortFlowChart += MyReSort("FlowChart", FlowChart_FileY1, FlowChart_ISAM_Y1, Index)
            ReSortFlowChart += MyReSort("FlowChart", FlowChart_File_X2_Rotation, FlowChart_ISAM_X2, Index)
            ReSortFlowChart += MyReSort("FlowChart", FlowChart_File_Y2_Option, FlowChart_ISAM_Y2, Index)

            ReSortFlowChart += MyReSort("FlowChart", FlowChart_FilePathSymbolName, FlowChart_ISAM_Name, Index)


            CheckThisStringArray(12, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name, Index) 'hack
        End Function


        Public Shared Function MyReSortAll_long(MyTable As String, ByRef MyArrayLong() As Int32, ByRef ISAM() As Int32) As Int32
            Dim LocalIndex As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(1153, 10, "MyReSortAll_Long")
            if MyDebug(10 ) then follow(2794, 10, "Sort  " & MyTable)
#End If
            MyReSortAll_long = 0
            For LocalIndex = 1 To TopOfFile(MyTable)
                MyReSortAll_long += (MyReSort_long(MyTable, MyArrayLong, ISAM, LocalIndex))
            Next
            'FindingMyBugs(10) 'hack Least amount of checking here
        End Function

        Public Shared Function MyReSort_long(MyTable As String, ByRef MyArrayLong() As Int32, ByRef ISAM() As Int32, Index As Int32) As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(1010, 10, "MyReSort_Long " & MyTable & " at " & Index.ToString)
#End If
            MyReSort_long = 0
            If InvalidIndex(Index, MyArrayLong, ISAM) Then
                Exit Function
            End If
            If ISAM(Index) <> 0 Then
                If ISAM(Index - 1) > 0 Then
                    If MyArrayLong(ISAM(Index - 1)) > MyArrayLong(ISAM(Index)) Then
#If MINEDEBUG Then
                        if MyDebug(10 ) then follow(2795, 10, "Sort " & MyTable & " At " & Index.ToString & " ---> " & MyArrayLong(ISAM(Index - 1)) & " <---> " & MyArrayLong(ISAM(Index)))
#End If
                        MySwapNn(MyTable, MyArrayLong, ISAM, Index - 1, Index)
                        MyReSort_long += 1
                        MyReSort_long += (MyReSort_long(MyTable, MyArrayLong, ISAM, Index - 1))
                        MyReSort_long += (MyReSort_long(MyTable, MyArrayLong, ISAM, Index + 1))
                        MyReSort_long += (MyReSort_long(MyTable, MyArrayLong, ISAM, Index))
                        MyReSort_long += (MyReSort_long(MyTable, MyArrayLong, ISAM, Index + 2))
                    End If
                End If
            End If
            'FindingMyBugs(10) 'hack Least amount of checking here
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This is used to resort the array at the indexinput (Recursive if change is needed)
        'This needs to be changed to an insert sort (Faster)
        Public Shared Function MyReSort(MyTable As String, ByRef MyArray() As String, ByRef ISAM() As Int32, Index_Input As Int32) As Int32
            Dim TopMost As Int32
            Dim LocalIndex, Jdex As Int32
            Dim LocalIndexTemp As Int32
            Dim ErrorCount As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2370, 10, "MyReSort(A)")
            if MyDebug(10 ) then follow(2796, 10, "Sort " & MyTable & " at " & Index_Input.ToString)
#End If
            MyReSort = 0
            TopMost = TopOfFile(MyTable)
            LocalIndex = Index_Input

            If Index_Input > UBound(MyArray) Then Exit Function '2020 09 25
            If Index_Input > TopMost Then Exit Function '2020 09 25

            ErrorCount = 1024


            While ErrorCount > 0
                ErrorCount -= 1
                LocalIndex = MyMinMax(LocalIndex, 1, UBound(MyArray) - 1) ' 2020 09 25
                Select Case MyCompared3(MyArray(ISAM(LocalIndex - 1)), MyArray(ISAM(LocalIndex)), MyArray(ISAM(LocalIndex + 1)))
                    Case 5
                        If PrintAbleNull(MyArray(ISAM(LocalIndex - 1))) = "_" Then
                            Return 5
                        End If
                        If PrintAbleNull(MyArray(ISAM(LocalIndex))) = "_" Then
                            Return 5
                        End If
                        If PrintAbleNull(MyArray(ISAM(LocalIndex + 1))) = "_" Then
                            Return 5
                        End If
                        '15    5 if none of the below (Error in logic)"
                        MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                        MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                        FindingMyBugs(100) 'hack Least amount of checking here
                        Exit While
                    Case 4
                        '6    4 if  C = Null And C > A
                        '8    4 if C = ''
                        If LocalIndex = MyMinMax(LocalIndex, 1, TopMost) Then
                            LocalIndexTemp = LocalIndex
                            'C is null but is A > B then we...
                            While MyCompared2(MyArray, ISAM, LocalIndex - 1, LocalIndex) = 1
                                MySwapN(MyTable, MyArray, ISAM, LocalIndex - 1, LocalIndex)
                                '
                                MyReSort += 1
                                LocalIndex = MyMinMax(LocalIndex - 1, 1, TopMost)
                            End While
                            If MyReSort > 0 Then
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                                LocalIndex = LocalIndexTemp
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                                'MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex))
                            End If
                        End If
                        Exit Function
                    Case 3 ' So that we swap every thing up and down from here
                        '13    3 if B < C
                        LocalIndex = LocalIndexTemp
                        While MyCompared2(MyArray, ISAM, LocalIndex, LocalIndex + 1) < 0
                            MySwapN(MyTable, MyArray, ISAM, LocalIndex, LocalIndex + 1)
                            '
                            MyReSort += 1
                            LocalIndex = MyMinMax(LocalIndex + 1, 1, TopMost)
                        End While
                        If MyReSort > 0 Then
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                            LocalIndex = LocalIndexTemp
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                            'MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex))
                        End If
                        FindingMyBugs(100)'hack Least amount of checking here
                    Case 2
                        '14    2 if A > B
                        If MyCompared2(MyArray, ISAM, LocalIndex - 1, LocalIndex) >= 0 Then
                            'If MyArray(ISAM(LocalIndex - 1)) > MyArray(ISAM(LocalIndex)) Then 'hack
                            MySwapN(MyTable, MyArray, ISAM, LocalIndex - 1, LocalIndex)
                            '
                            MyReSort += 1
                            FindingMyBugs(100) 'hack Least amount of checking here
                        Else ' Error 'hack
                            LocalIndex = MyMinMax(LocalIndex, 1, TopMost) 'hack
                            FindingMyBugs(10) 'hack Least amount of checking here
                        End If 'hack
                        If MyReSort > 0 Then
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                            LocalIndex = LocalIndexTemp
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                            'MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex))
                        End If
                    Case 1 ' Duplication' check to make sure it is not out of order at the beginning of the dup's
                        If LocalIndex <= 1 Then
                            Exit Function
                        End If
                        If MyArray(ISAM(LocalIndex - 1)) = MyArray(ISAM(LocalIndex)) And MyArray(ISAM(LocalIndex)) = MyArray(ISAM(LocalIndex + 1)) Then
                            Exit Function
                        End If
                        LocalIndex -= 1
                    Case 0 ' This should never happen but when it does, we should do nothing
                        '1    0 if the middle Is null
                        '2    0 if first = third are null
                        '10    0 if A < B & B < C
                        LocalIndex = Index_Input
                        While MyCompared2(MyArray, ISAM, LocalIndex - 1, LocalIndex) = 1
                            MySwapN(MyTable, MyArray, ISAM, LocalIndex - 1, LocalIndex)
                            '
                            LocalIndex = MyMinMax(LocalIndex - 1, 1, TopMost)
                        End While
                        While MyCompared2(MyArray, ISAM, LocalIndex, LocalIndex + 1) = 1 'MyCompared(MyArray(ISAM(LocalIndex)), MyArray(ISAM(LocalIndex + 1))) = 1
                            MySwapN(MyTable, MyArray, ISAM, LocalIndex, LocalIndex + 1)
                            '
                            LocalIndex = MyMinMax(LocalIndex + 1, 1, TopMost)
                        End While
                        If MyReSort > 0 Then
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                            LocalIndex = LocalIndexTemp
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                        End If
                        Exit Function ' Should not swap anything up or down
                    Case -1 ' Duplication
                        '3    -1 if A = B
                        Jdex = LocalIndex
                        While MyCompared2(MyArray, ISAM, Jdex, Jdex + 1) > 0
                            MySwapN(MyTable, MyArray, ISAM, Jdex, Jdex + 1)
                            '
                            Jdex += 1
                        End While
                        Jdex = LocalIndex


                        ' Find the beginning and cause a sort from there
                        'While MyCompared2(MyArray(ISAM(LocalIndex)), MyArray(ISAM(LocalIndex - 1)) = 0' Same
                        While MyCompared2(MyArray, ISAM, LocalIndex - 1, LocalIndex) = 0
                            LocalIndex -= 1
                        End While
                        While MyCompared2(MyArray, ISAM, LocalIndex - 1, LocalIndex) = 0
                            'While MyCompared2(MyArray(ISAM(Jdex)), MyArray(ISAM(Jdex + 1)) = 0
                            Jdex += 1
                        End While


                        'If MyCompared2(MyArray(ISAM(LocalIndex)), MyArray(ISAM(LocalIndex - 1)) <= 0 Then' 
                        If MyCompared2(MyArray, ISAM, LocalIndex - 1, LocalIndex) >= 0 Then
                            MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                            MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                            MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                            MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                        End If

                        If MyCompared2(MyArray, ISAM, Jdex, Jdex + 1) > 0 Then
                            'If MyCompared2(MyArray(ISAM(Jdex)), MyArray(ISAM(LocalIndex + 1)) > 0 Then
                            MyReSort(MyTable, MyArray, ISAM, Jdex)
                            MyReSort(MyTable, MyArray, ISAM, Jdex + 1)
                            MyReSort(MyTable, MyArray, ISAM, Jdex)
                            MyReSort(MyTable, MyArray, ISAM, Jdex + 1)
                        End If
                        Exit Function
                    Case -2
                        '12    -2 if B > C
                        While MyCompared2(MyArray, ISAM, LocalIndex, LocalIndex + 1) = 1 'MyCompared(MyArray(ISAM(LocalIndex)), MyArray(ISAM(LocalIndex + 1))) = 1 'hack
                            MySwapN(MyTable, MyArray, ISAM, LocalIndex, LocalIndex + 1)
                            '
                            MyReSort += 1
                            LocalIndex = MyMinMax(LocalIndex + 1, 1, TopMost)
                        End While

                    Case -3
                        '11    -3 A is higher than B  and C = nothing
                        If MyCompared2(MyArray, ISAM, LocalIndex - 1, LocalIndex) = 1 Then
                            LocalIndexTemp = LocalIndex
                            While MyCompared2(MyArray, ISAM, LocalIndex - 1, LocalIndex) = 1 'MyCompared(MyArray(ISAM(LocalIndex - 1)), MyArray(ISAM(LocalIndex))) = 1
                                MySwapN(MyTable, MyArray, ISAM, LocalIndex - 1, LocalIndex)
                                '
                                MyReSort += 1
                                LocalIndex = MyMinMax(LocalIndex - 1, 1, TopMost)
                            End While
                            If MyReSort > 0 Then
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                                LocalIndex = LocalIndexTemp
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                                'MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex))
                            End If
                        End If
                        If MyCompared2(MyArray, ISAM, LocalIndex, LocalIndex + 1) = 1 Then 'mycompared(MyArray(ISAM(LocalIndex)), MyArray(ISAM(LocalIndex + 1))) = 1 Then 'hack
                            LocalIndexTemp = LocalIndex
                            While MyCompared2(MyArray, ISAM, LocalIndex, LocalIndex + 1) = 1 'MyCompared(MyArray(ISAM(LocalIndex)), MyArray(ISAM(LocalIndex + 1))) = 1
                                MySwapN(MyTable, MyArray, ISAM, LocalIndex, LocalIndex + 1)
                                '
                                MyReSort += 1
                                LocalIndex = MyMinMax(LocalIndex + 1, 1, TopMost)
                            End While
                            If MyReSort > 0 Then
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                                LocalIndex = LocalIndexTemp
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                                'MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex))
                            End If
                        End If
                        'MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                        MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                        MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                        LocalIndex = LocalIndexTemp
                        MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                        MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
        'MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex))
                    Case -4
                        '5    -4 if A = Null & B < C
                        '7    -4 if A = ''
                        LocalIndexTemp = LocalIndex
                        If LocalIndex > 1 Then
                            While MyCompared2(MyArray, ISAM, LocalIndex, LocalIndex + 1) = 1 'MyCompared(MyArray(ISAM(LocalIndex)), MyArray(ISAM(LocalIndex + 1))) = 1
                                '
                                MySwapN(MyTable, MyArray, ISAM, LocalIndex, LocalIndex + 1)
                                MyReSort += 1
                                LocalIndex = MyMinMax(LocalIndex + 1, 1, TopMost)
                            End While
                            If MyReSort > 0 Then
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                                LocalIndex = LocalIndexTemp
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                                MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                            End If
                        End If
                        Exit Function
                    Case -5
                        '9    -5 if A > C (error in list)
                        MySwapN(MyTable, MyArray, ISAM, LocalIndex - 1, LocalIndex + 1) ' swap A & C which is being wrong

                        While MyCompared2(MyArray, ISAM, LocalIndex, LocalIndex + 1) = 1 'MyCompared(MyArray(ISAM(LocalIndex)), MyArray(ISAM(LocalIndex + 1))) = 1
                            MySwapN(MyTable, MyArray, ISAM, LocalIndex, LocalIndex + 1)
                            '
                            MyReSort += 1
                            LocalIndex = MyMinMax(LocalIndex + 1, 1, TopMost)
                        End While
                        While MyCompared2(MyArray, ISAM, LocalIndex - 1, LocalIndex) = 1 'MyCompared(MyArray(ISAM(LocalIndex - 1)), MyArray(ISAM(LocalIndex))) = 1
                            MySwapN(MyTable, MyArray, ISAM, LocalIndex - 1, LocalIndex)
                            '
                            MyReSort += 1
                            LocalIndex = MyMinMax(LocalIndex - 1, 1, TopMost)
                        End While
                        If MyReSort > 0 Then
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                            LocalIndex = LocalIndexTemp
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                            ' Taken out for now 
                            '        For LocalIndex = 1 To TopMost 'kludge
                            '       MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex) 'kludge
                            '        Next LocalIndex 'hack kludge
                        End If
                        'maybe below we should just exit?
                        If MyCompared2(MyArray, ISAM, LocalIndex - 1, LocalIndex) = 1 Then 'MyCompared(MyArray(ISAM(LocalIndex - 1)), MyArray(ISAM(LocalIndex))) = 0 Then
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                            Exit Function
                        End If
                        If MyCompared2(MyArray, ISAM, LocalIndex, LocalIndex + 1) = 0 Then 'MyCompared(MyArray(ISAM(LocalIndex)), MyArray(ISAM(LocalIndex + 1))) = 0 Then
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                            MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                            Exit Function
                        End If

                    Case Else ' Invalid return from compared3() sHOULD NEVER HAPPEN
                        If MyReSort <> 0 Then DisplayMyStatus(7, MyTable & " = " & MyReSort)
                        MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                        MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                        MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                        LocalIndex = LocalIndexTemp
                        MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                        MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                        MyReSort += MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                        Exit Function
                End Select
            End While
        End Function


        'Only sort the last inserted NOT the whole MyArray
        Public Shared Function MyReSort(MyTable As String, ByRef MyArrayLong() As Int32, ByRef ISAM() As Int32, IndexInput As Int32) As Int32
            Dim TopMost, LocalIndex As Int32
            Dim Flag As Boolean
            'todo check this level back to 6 from 0
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2371, 10, "MyReSort")
            if MyDebug(10 ) then follow(2797, 6, "Sorting " & MyTable & " at " & IndexInput)
#End If
            MyReSort = 0
            TopMost = TopOfFile(MyTable)
            If IndexInput <> MyMinMax(IndexInput, 1, UBound(ISAM)) Then
                Exit Function
            End If

            If InvalidIndex(IndexInput, MyArrayLong, ISAM) Then
                Exit Function
            End If

            If InvalidIndex(IndexInput - 1, MyArrayLong, ISAM) Then
            Else
                LocalIndex = IndexInput
                Flag = False
                While (LocalIndex > 0 And
        InvalidIndex(LocalIndex, MyArrayLong, ISAM) = False And
        InvalidIndex(LocalIndex - 1, MyArrayLong, ISAM) = False And
        MyArrayLong(ISAM(LocalIndex)) < MyArrayLong(ISAM(LocalIndex - 1)))
                    If MyDebug(10) Then
                        If MyArrayLong(ISAM(LocalIndex - 1)) > MyArrayLong(ISAM(LocalIndex)) Then
                            If mydebug(9) Then follow(2895, 10, "Swapping " & MyTable & FD & MyArrayLong(ISAM(LocalIndex - 1)) & " > " & MyArrayLong(ISAM(LocalIndex)))
                        End If
                    End If
                    MySwapNn(MyTable, MyArrayLong, ISAM, LocalIndex - 1, LocalIndex)
                    Flag = True
                    MyReSort += 1
                    LocalIndex -= 1
                    'FindingMyBugs(100) 'hack Least amount of checking here
                End While
                If Flag = True Then
                    MyReSort += MyReSort(MyTable, MyArrayLong, ISAM, LocalIndex - 1)
                    MyReSort += MyReSort(MyTable, MyArrayLong, ISAM, IndexInput - 1)
                    MyReSort += MyReSort(MyTable, MyArrayLong, ISAM, IndexInput)
                    MyReSort += MyReSort(MyTable, MyArrayLong, ISAM, IndexInput + 1)
                    MyReSort += MyReSort(MyTable, MyArrayLong, ISAM, LocalIndex + 1)
                End If
            End If

            If InvalidIndex(LocalIndex + 1, MyArrayLong, ISAM) Then
            Else
                LocalIndex = IndexInput
                Flag = False
                While LocalIndex > 0 And
        InvalidIndex(LocalIndex, MyArrayLong, ISAM) = False And
        InvalidIndex(LocalIndex + 1, MyArrayLong, ISAM) = False And
        MyArrayLong(ISAM(LocalIndex + 1)) < MyArrayLong(ISAM(LocalIndex))
                    MySwapNn(MyTable, MyArrayLong, ISAM, LocalIndex, LocalIndex + 1)
                    Flag = True
                    MyReSort += 1
                    LocalIndex -= 1
                    FindingMyBugs(100) 'hack Least amount of checking here
                End While
                If Flag = True Then
                    MyReSort += MyReSort(MyTable, MyArrayLong, ISAM, LocalIndex - 1)
                    MyReSort += MyReSort(MyTable, MyArrayLong, ISAM, IndexInput - 1)
                    MyReSort += MyReSort(MyTable, MyArrayLong, ISAM, IndexInput)
                    MyReSort += MyReSort(MyTable, MyArrayLong, ISAM, IndexInput + 1)
                    MyReSort += MyReSort(MyTable, MyArrayLong, ISAM, LocalIndex + 1)
                End If
            End If
        End Function

        Public Shared Function SortISAMs() As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(2372, 10, "SortISAMs")
  if mydebug(9) then follow(2798, 10, "Sort Indexes ")
#End If
            SortISAMs = 0
            SortISAMs += (SortColors())
            SortISAMs += (SortDataType())
            SortISAMs += (SortNamed())
            SortISAMs += (SortFlowChart())
            FindingMyBugs(10) 'hack Least amount of checking here
        End Function

        Public Shared Function SortColors() As Int32    'First Sort Color ISAMe (again?)
#If MINEDEBUG Then
  if mydebug(9) then follow(2373, 10, "SortColors")
  if mydebug(9) then follow(2799, 10, "Sort Colors ")
#End If
            SortColors = (MySortStringArray("Color", Color_FileName, Color_Name_ISAM))
            MyUniverse.MyCheatSheet.ColorsSorted = 0
        End Function
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This sorts the DataType array
        Public Shared Function SortDataType() As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(2374, 10, "SortDataType")
  if mydebug(9) then follow(2800, 10, "Sort All Data types ")
#End If
            SortDataType = MySortStringArray("DataType", DataType_FileName, DataType_Name_ISAM)
            MyUniverse.MyCheatSheet.DataTypeSorted = 0
        End Function
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'sorts the Symbol array by the name of the Symbol
        Public Shared Function SortNamed() As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(2375, 10, "SortNamed")
  if mydebug(9) then follow(2801, 10, "Sort A;; Symbol names  ")
#End If
            SortNamed = MySortStringArray("Named", Named_FileSymbolName, Named_FileSymbolName_ISAM)
            SortNamed += MySortStringArray("named", Named_FileSyntax, Named_FileSyntax_ISAM) ' added 2020 08 12
            MyUniverse.MyCheatSheet.NamedSorted = 0
        End Function

        Public Shared Function SortFlowChart() As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(2376, 10, "SortFlowChart")
  if mydebug(9) then follow(2802, 10, "Sort All of FlowCharts ISAMs ")
#End If
            SortFlowChart = 0
            If TopOfFile("FlowChart") = 1 Then Exit Function
            SortFlowChart += (MySortStringArray("FlowChart", FlowChart_FilePathSymbolName, FlowChart_ISAM_Name))
            SortFlowChart += (MyReSortAll_long("FlowChart", FlowChart_FileX1, FlowChart_ISAM_X1))
            SortFlowChart += (MyReSortAll_long("FlowChart", FlowChart_FileY1, FlowChart_ISAM_Y1))
            SortFlowChart += (MyReSortAll_long("FlowChart", FlowChart_File_X2_Rotation, FlowChart_ISAM_X2))
            SortFlowChart += (MyReSortAll_long("FlowChart", FlowChart_File_Y2_Option, FlowChart_ISAM_Y2))
            MyUniverse.MyCheatSheet.FlowChartSorted = 0
        End Function


        Public Shared Sub SortAllList()
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(2377, 10, "SortAllList")
            FMB1(8022)
  if mydebug(9) then follow(2803, 10, "Sort All keywords, functions, operators, Grammar ")
#End If
            For I = LBound(Language_KeyWord) + 1 To UBound(Language_KeyWord)
                ReSortLanguagekeyWord("LanguagekeyWord", Language_KeyWord, I)
            Next
            For I = LBound(Language_Function) + 1 To UBound(Language_Function)
                ReSortLanguagekeyWord("LanguageFunction", Language_Function, I)
            Next
            For I = LBound(Language_Operator) + 1 To UBound(Language_Operator)
                ReSortLanguagekeyWord("LanguageOperator", Language_Operator, I)
            Next
            For I = LBound(Language_Grammar) + 1 To UBound(Language_Grammar)
                ReSortLanguagekeyWord("LanguageGrammar", Language_Grammar, I)
            Next
            If MyDebug(8) Then FMB1(8023)
        End Sub

        Public Shared Function CorrectOrder(a As Object, b As Object) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(2378, 10, "CorrectOrder")
#End If
            If IsNothing(a) Then Return True
            If IsNothing(b) Then Return True
            If MyDebug(10) Then follow(2804, 10, "Sort " & a.ToString & "  " & b.ToString)
            If IsNothing(a) Then Return False 'never compare with nulls
            If IsNothing(b) Then Return False
            If MyDebug(6) Then Follow(2368, a.GetType().Name & vbTab & b.GetType().Name)
            If a.GetType().Name <> b.GetType().Name Then
                MSG_ABug(2369, "Mis match compare " & a.GetType().Name, b.GetType().Name, "")
                If MyOptionTest(25) = True Then
                Else
                End If
            End If
            'todo this need to compare Numeric instead of string (cause 100 is greater than 99, but string is lessor
            If a.GetType().Name = "String" And b.GetType().Name = "String" Then
                If a.ToString > b.ToString Then Return True
            End If
            If a.GetType().Name = "int32" And b.GetType().Name = "int32" Then
                If CInt(a) > CInt(b) Then Return True
            End If
            If a.GetType().Name <> "String" And b.GetType().Name <> "Int32" Then Return False
            If b.GetType().Name <> "String" And b.GetType().Name <> "Int32" Then Return False

            Return False
        End Function


        Public Shared Function CheckAllSorted() As Boolean
            Dim Index As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(2370, 10, "CheckAllSorted")
            if mydebug(8) then  follow(2370, 8, "Check all is Sorted,  Stack = ")
#End If
            For Index = 1 To TopOfFile("Color")
                If CorrectOrder(Color_TableName(Color_Name_ISAM(Index - 1)), Color_TableName(Color_Name_ISAM(Index))) Then
                    Return False
                End If
                If Color_TableName(Color_Name_ISAM(Index - 1)) > Color_TableName(Color_Name_ISAM(Index)) Then
                    Return False
                End If
            Next Index
            For Index = 1 To TopOfFile("DataType")
                If CorrectOrder(DataType_TableName(DataType_Name_ISAM(Index - 1)), DataType_TableName(DataType_Name_ISAM(Index))) Then
                    Return False
                End If
                If DataType_TableName(DataType_Name_ISAM(Index - 1)) > DataType_TableName(DataType_Name_ISAM(Index)) Then
                    Return False
                End If
            Next Index
            For Index = 1 To TopOfFile("named")
                If CorrectOrder(Named_TableSymbolName(Named_FileSymbolName_ISAM(Index - 1)), Named_TableSymbolName(Named_FileSymbolName_ISAM(Index))) Then
                    Return False
                End If
                If Named_TableSymbolName(Named_FileSymbolName_ISAM(Index - 1)) > Named_TableSymbolName(Named_FileSymbolName_ISAM(Index)) Then
                    Return False
                End If
            Next Index

            For Index = 1 To TopOfFile("FlowChart")
                If CorrectOrder(FlowChart_TableX1(FlowChart_ISAM_X1(Index) - 1), FlowChart_TableX1(FlowChart_ISAM_X1(Index))) Then Return False
                If CorrectOrder(FlowChart_TableX1(FlowChart_ISAM_Y1(Index) - 1), FlowChart_TableX1(FlowChart_ISAM_Y1(Index))) Then Return False
                If CorrectOrder(FlowChart_TableY1(FlowChart_ISAM_X2(Index) - 1), FlowChart_TableY1(FlowChart_ISAM_X2(Index))) Then Return False
                If CorrectOrder(FlowChart_TableX2(FlowChart_ISAM_Y2(Index) - 1), FlowChart_TableX2(FlowChart_ISAM_Y2(Index))) Then Return False
                If CorrectOrder(FlowChart_TableY2(FlowChart_ISAM_Name(Index) - 1), FlowChart_TableY2(FlowChart_ISAM_Name(Index))) Then Return False

            Next
            SortAllList()

            Return True
        End Function


        Public Shared Sub SortALLISAM()
            Dim Index As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3000, 10, "SortAllISAM")
  if mydebug(9) then follow(2805, 10, "Sort All ISAMs")
#End If
            If CheckAllSorted() = True Then Return 'first check that it is unsorted and needs to be completely resorted.
            For Index = 1 To TopOfFile("Color")
                Color_Name_ISAM(Index) = Index
            Next Index
            For Index = TopOfFile("Color") + 1 To UBound(Color_FileName)
                Color_Name_ISAM(Index) = 0
            Next Index

            ShowSorts("Colors", SortColors())

            'MyStatus("Setting Sort ...DataTypes")
            For Index = 1 To TopOfFile("DataType")
                DataType_Name_ISAM(Index) = Index
            Next Index
            'For Index = TopOfFile("DataType") + 1 To UBound(DataType_FileName)
            ' DataType_Name_ISAM(Index) = 0
            ' Next Index

            ShowSorts("DataType", SortDataType())

            'MyStatus("Setting Sort ...Symbol Names")
            For Index = 1 To TopOfFile("named")
                Named_FileSymbolName_ISAM(Index) = Index
                Named_FileSyntax_ISAM(Index) = Index
            Next Index
            'set unused records to zero

            '    For Index = TopOfFile("named") + 1 To UBound(Named_FileSymbolName)
            '    Named_FileSymbolName_ISAM(Index) = 0
            '    Named_FileSyntax_ISAM(Index) = 0
            '    Next Index

            ShowSorts("Named", SortNamed())

            'MyStatus("Setting Sort ...FlowChart")
            For Index = 1 To TopOfFile("FlowChart")
                Select Case LCase(Trim(FlowChart_TableCode(Index)))
                    Case My_keyWord(My_KeyConstUse), "/Constant", "/error"
                        FlowChart_ISAM_Name(Index) = Index
                        FlowChart_ISAM_X1(Index) = Index
                        FlowChart_ISAM_Y1(Index) = Index
                        FlowChart_ISAM_X2(Index) = Index ' Rotation
                        FlowChart_ISAM_Y2(Index) = Index
                    Case "/path", ""
                        FlowChart_ISAM_Name(Index) = Index
                        FlowChart_ISAM_X1(Index) = Index
                        FlowChart_ISAM_Y1(Index) = Index
                        FlowChart_ISAM_X2(Index) = Index
                        FlowChart_ISAM_Y2(Index) = Index
                    Case "/delete"
                        FlowChart_ISAM_Name(Index) = Index
                        FlowChart_ISAM_X1(Index) = Index
                        FlowChart_ISAM_Y1(Index) = Index
                        FlowChart_ISAM_X2(Index) = Index ' Rotation
                        FlowChart_ISAM_Y2(Index) = Index
                    Case Else
                        MyMsgCtr(1375, "SortAllISAM", "Unknow Code ", ">" & LCase(Trim(FlowChart_TableCode(Index))) & "<", "Macro Code Text == >" & MyKeyword_2_Byte(FlowChart_TableCode(Index)) & "<", "(" & FlowChart_TableX1(Index) & FD & FlowChart_TableY1(Index) & ")", "(" & FlowChart_TableX2(Index) & FD & FlowChart_TableY2(Index) & ")", "Links = " & FindIndex_In_TableNetLinks(Index), "Named = " & FlowChart_TableSymbol_Name(Index) & FlowChart_TablePathName(Index), "DataType = " & FlowChart_Table_DataType(Index), "Index = " & Index)
                        FlowChart_ISAM_Name(Index) = Index
                        FlowChart_ISAM_X1(Index) = 0
                        FlowChart_ISAM_Y1(Index) = 0
                        FlowChart_ISAM_X2(Index) = 0
                        FlowChart_ISAM_Y2(Index) = 0
                End Select
            Next


            'Hack Why do I set it above and then here set everything to no index??
            For Index = TopOfFile("FlowChart") + 1 To UBound(FlowChart_FileCoded)
                FlowChart_ISAM_Name(Index) = 0
                FlowChart_ISAM_X1(Index) = 0
                FlowChart_ISAM_Y1(Index) = 0
                FlowChart_ISAM_X2(Index) = 0
                FlowChart_ISAM_Y2(Index) = 0
            Next Index
            ShowSorts("FlowChart", SortFlowChart())

            'SortALLISAM = SortALLISAM + ShowSorts(mytable,SortISAMs())
            ' Removed right after sorting every thing '20200628
            'MyCheatSheet.ColorsSorted += 1 : MyCheatSheet.DataTypeSorted += 1 : MyCheatSheet.NamedSorted += 1 : MyCheatSheet.FlowChartSorted += 1

            'toso add resort all language_
            SortAllList()
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to find the location of where to inset this record in an already sorted List at index
        Public Shared Function InsertReSortLanguagekeyWord(MyTable As String, ByRef MyArray() As String, Index As Int32) As Int32
            Dim CDex As Int32 ' Where to insert at
            Dim SavedItem As String
            Dim I As Int32 ' loop through and move all of the list one items
            'Finst find where it goes in the sorted list
#If MINEDEBUG Then
  if mydebug(9) then follow(3001, 10, "InsertReSortLanguageKeyWord")
  if mydebug(9) then follow(2806, 10, "Insert " & MyTable & " at " & Index.ToString)
#End If
            If UBound(MyArray) < Index Then
                ReDim Preserve MyArray(Index)
            End If

            InsertReSortLanguagekeyWord = 0 'number of swaps made
            If Index <> MyMinMax(Index, LBound(MyArray), UBound(MyArray)) Then Exit Function ' If invalid index then do nothing

            SavedItem = MyArray(Index) ' save the item to be moved

            CDex = MyMinMax(Index + 1, LBound(MyArray), UBound(MyArray)) ' The Next one
            While MyCompared1_a(MyArray(Index), MyArray(CDex)) = 1 And Index <> CDex
                CDex = MyMinMax(Index + 1, LBound(MyArray), UBound(MyArray))
            End While

            While MyCompared1_a(MyArray(Index), MyArray(CDex)) = -1 And Index <> CDex
                CDex = MyMinMax(Index - 1, LBound(MyArray), UBound(MyArray))
            End While



            'CDex should now be where Index (This insert record goes)
            If Index < CDex Then
                For I = UBound(MyArray) To CDex Step -1
                    MyArray(I) = MyArray(I - 1)
                Next
            Else
                For I = UBound(MyArray) To CDex Step -1
                    MyArray(I) = MyArray(I - 1)
                Next
            End If
            MyArray(Index) = SavedItem
        End Function
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' Make sure that the language keyWord (and operator key words) are sorted for ordered (binary) search
        Public Shared Function ReSortLanguagekeyWord(MyTable As String, ByRef MyArray() As String, KeyIndex As Int32) As Int32
            Dim ADex As Int32
            Dim LocalIndex As Int32
            '            Dim CDex As Int32
            Dim Flag As Boolean
            Dim ResortCount As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(2807, 11, "resort " & MyTable & " at " & KeyIndex.ToString)
#End If
            ResortCount = 0
            ReSortLanguagekeyWord = 0
            Flag = False

            ' This is here to just test if an insert sort works faster
            ' This seems to break sorting ReSortLanguagekeyWord = InsertReSortLanguagekeyWord(MyTable, MyArray, Index)


            If KeyIndex <> MyMinMax(KeyIndex, LBound(MyArray), UBound(MyArray)) Then Exit Function
            LocalIndex = MyMinMax(KeyIndex, LBound(MyArray), UBound(MyArray))
            ADex = MyMinMax(LocalIndex + 1, LBound(MyArray), UBound(MyArray))
            'If LocalIndex = ADex Then Return 0 ' DoNot swap with itself
            While MyCompared1_a(MyArray(LocalIndex), MyArray(ADex)) = 1 And LocalIndex <> ADex
                MySwapLanguagekeyWord(MyTable, MyArray, LocalIndex, ADex)
                ResortCount += 1
                Flag = True
                ReSortLanguagekeyWord += 1
                LocalIndex = MyMinMax(LocalIndex + 1, LBound(MyArray), UBound(MyArray) - 1)
                ADex = MyMinMax(LocalIndex + 1, LBound(MyArray), UBound(MyArray))
                If MyDebug(8) Then FMB1(8024)
            End While

            'try the other way
            LocalIndex = MyMinMax(KeyIndex, LBound(MyArray), UBound(MyArray))
            ADex = MyMinMax(LocalIndex - 1, LBound(MyArray), UBound(MyArray))
            If MyDebug(8) Then FMB1(8025)
            While MyCompared1_a(MyArray(ADex), MyArray(LocalIndex)) = 1 And ADex <> LocalIndex
                If MyDebug(8) Then FMB1(8026)
                MySwapLanguagekeyWord(MyTable, MyArray, ADex, LocalIndex)
                If MyDebug(8) Then FMB1(8027)
                Flag = True
                ReSortLanguagekeyWord += 1
                If MyDebug(8) Then FMB1(8028)
                LocalIndex = MyMinMax(LocalIndex - 1, LBound(MyArray) + 1, UBound(MyArray))
                ADex = MyMinMax(LocalIndex - 1, LBound(MyArray), UBound(MyArray))
                If MyDebug(8) Then FMB1(8029)
            End While


            ' Just to see if it does it here (to save recursion)
            LocalIndex = MyMinMax(KeyIndex, LBound(MyArray), UBound(MyArray))
            ADex = MyMinMax(LocalIndex + 1, LBound(MyArray), UBound(MyArray))
            While MyCompared1_a(MyArray(LocalIndex), MyArray(ADex)) = 1 And LocalIndex <> ADex
                MSG_ABug(1237, "ReSortLanguagekeyWord", MyArray(LocalIndex), MyArray(ADex)) ' we should never be able to do it twice
                If MyOptionTest(25) = True Then
                Else
                End If
                MySwapLanguagekeyWord(MyTable, MyArray, LocalIndex, ADex)
                Flag = True
                ReSortLanguagekeyWord += 1
                LocalIndex = MyMinMax(LocalIndex + 1, LBound(MyArray), UBound(MyArray) - 1)
                ADex = MyMinMax(LocalIndex + 1, LBound(MyArray), UBound(MyArray))
                If MyDebug(8) Then FMB1(8030)
            End While

            'try the other way
            LocalIndex = MyMinMax(KeyIndex, LBound(MyArray), UBound(MyArray))
            ADex = MyMinMax(LocalIndex - 1, LBound(MyArray), UBound(MyArray))
            While MyCompared1_a(MyArray(ADex), MyArray(LocalIndex)) = 1 And ADex <> LocalIndex
                MSG_ABug(1238, "ResortLanguagekeyWord():", MyArray(ADex), MyArray(LocalIndex)) ' we should never be able to do it twice
                If MyOptionTest(25) = True Then
                Else
                End If
                MySwapLanguagekeyWord(MyTable, MyArray, ADex, LocalIndex)
                Flag = True
                ReSortLanguagekeyWord += 1
                LocalIndex = MyMinMax(LocalIndex - 1, LBound(MyArray) + 1, UBound(MyArray))
                ADex = MyMinMax(LocalIndex - 1, LBound(MyArray), UBound(MyArray))
                If MyDebug(8) Then FMB1(8031)
            End While

            If Flag = True Then
                ResortCount = 0 ' This is to see if all (OR ANY) of this check sorting is needed!
                ResortCount += ReSortLanguagekeyWord(MyTable, MyArray, LocalIndex - 1)
                ResortCount += +ReSortLanguagekeyWord(MyTable, MyArray, LocalIndex + 1) 'hack
                ResortCount += +ReSortLanguagekeyWord(MyTable, MyArray, LocalIndex)
                '?LocalIndex = Index 'hack
                ResortCount += +ReSortLanguagekeyWord(MyTable, MyArray, KeyIndex - 1) 'hack
                ResortCount += +ReSortLanguagekeyWord(MyTable, MyArray, KeyIndex + 1) 'hack
                ResortCount += ReSortLanguagekeyWord(MyTable, MyArray, KeyIndex)
                ReSortLanguagekeyWord += ResortCount
            End If
            ' We get here only if we do nothing
            'FindingMyBugs(20) 'hack Least amount of checking here
            ' removed  FindingMyBugsSorted() 'debug
            If ResortCount > 0 Then DisplayMyStatus(6, "Resorted : " & ResortCount.ToString)
        End Function


        Public Shared Function ReSortStringArray(MyTable As String, ByRef MyArray() As String, ByRef ISAM() As Int32) As Int32
            Dim TopMost As Int32
            Dim Index As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3003, 10, "ReSortStringArray - " & MyTable)
  if mydebug(9) then follow(2808, 10, "Resort Strings " & MyTable)
#End If
            ReSortStringArray = 0
            'First Try to sort just the top
            TopMost = TopOfFile(MyTable)
            For Index = 2 To TopMost
                ReSortStringArray += MyReSort(MyTable, MyArray, ISAM, Index)
            Next Index
            ReSortStringArray += MyReSort(MyTable, MyArray, ISAM, TopMost)
            If MyIsValidCheckSortAll_String(MyTable, MyArray, ISAM) = False Then
                ReSortStringArray += ReBubbleSortAll(MyTable, MyArray, ISAM)
                MyIsValidCheckSortAll_String(MyTable, MyArray, ISAM) 'hack so I can see why it's here
            End If
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'bubble sort the array 
        'Which means sorting the index to the array and never changing the array, so that Indexes\indexs stay the same
        Public Shared Function MySortStringArray(MyTable As String, ByRef MyArray() As String, ByRef ISAM() As Int32) As Int32 ' returns the number sorted
            Dim LocalIndex As Int32
            Dim NumberSorted As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3004, 10, "MySortStringArray - " & MyTable)
  if mydebug(9) then follow(2809, 10, " sort Strings " & MyTable)
            FindingMyBugs(50) 'hack Least amount of checking here ' Check after sorting
#End If
            MySortStringArray = 0
            'FindingMyBugs(100) 'hack Least amount of checking here no reason to check and get an out of order before sorting
            For LocalIndex = TopOfFile(MyTable) To 1 Step -1
                NumberSorted = MyReSort(MyTable, MyArray, ISAM, LocalIndex) '20200703'+20200708
                MySortStringArray += NumberSorted
                If NumberSorted > 0 Then
                    NumberSorted = MyReSort(MyTable, MyArray, ISAM, LocalIndex - 1)
                    MySortStringArray += NumberSorted
                    NumberSorted = MyReSort(MyTable, MyArray, ISAM, LocalIndex)
                    MySortStringArray += NumberSorted
                    NumberSorted = MyReSort(MyTable, MyArray, ISAM, LocalIndex + 1)
                    MySortStringArray += NumberSorted
                End If
            Next

            If MyIsValidCheckSortAll_String(MyTable, MyArray, ISAM) = False Then
                MySortStringArray += (ReBubbleSortAll(MyTable, MyArray, ISAM))
            End If
            'FindingMyBugs(50) 'hack Least amount of checking here ' Check after sorting
        End Function

        Public Shared Sub MyInsertSymbolPointRecord(IndexSymbol As Int32, SymbolName As String, Code As String, x1 As Int32, y1 As Int32, IO As String, DT As String, MyNameOfPoint As String)
            Dim MyXY As MyLineStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3005, 10, "MyInsertSymbolPointRecord")
  if mydebug(9) then follow(2783, 10, "Insert Symbol record at " & IndexSymbol.ToString & FD & Code & FD & SymbolName & FD & IO & FD & DT)
#End If
            MyXY = Nothing
            If Code <> "/point" Then
                If Code <> "/name" Then
                    If Code <> "/error" Then
                        MSG_ABug(1239, "Trying to insert a " & Code & " as a /point/name/error ", SymbolName, MyNameOfPoint)
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                    End If
                End If
            End If
            MyXY.a.x = x1
            MyXY.a.y = y1
            MyXY.b.x = FindInputOutputIndex(IO)
            MyXY.b.y = FindDataTypeIndex(DT)
            MyInsertSymbolLineRecord(IndexSymbol, SymbolName, Code, MyXY, MyNameOfPoint)
        End Sub

        Public Shared Sub MyInsertSymbolLineRecord(IndexSymbol As Int32, SymbolName As String, Code As String, XY As MyLineStructure, MyNameOfPoint As String)
            ',    'Named As String)
            Dim Index As Int32
            Dim IndexAt As Int32
            Dim T1, T2 As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3006, 10, "MyInsertSymbolLineRecord")
  if mydebug(9) then follow(2810, 10, "Insert Symbol line at " & IndexSymbol.ToString & FD & Code & FD & SymbolName & FD & MyShowALine(XY) & FD & MyNameOfPoint)
#End If
            FMB(5033)
            MyMakeArraySizesBigger()
            'FindingMyBugs ( 9 0) 'hack Least amount of checking here 'hack make sure that there is no errors first  (Bug before here) 2020 08 04
            ' This extra code is because of a bug somewhere else.
            ' bug, we should never be trying to inser two name records.
            If Code = "/name" Then 'hack
                FMB(5034)
                For Index = 1 To NewTopOfFile("Symbol") 'hack
                    If Index <> IndexSymbol Then
                        If Symbol_TableCoded_String(Index) = "/name" Then 'hack
                            If Symbol_TableSymbolName(Index) = SymbolName Then 'hack
                                FMB(5035)
                                MSG_ABug(1240, "Trying to insert the /name=" & SymbolName, " record again At " & IndexSymbol & " : " & Symbol_TableCoded_Byte(IndexSymbol) & " : " & Symbol_TableCoded_String(IndexSymbol) & " : " & Symbol_TableSymbolName(IndexSymbol), "Is already at=" & Index & " : " & Symbol_TableCoded_Byte(Index) & " : " & Symbol_TableCoded_String(Index) & " : " & Symbol_TableSymbolName(Index)) 'hack
                                If MyOptionTest(25) = True Then
                                Else
                                End If
                                FMB(5036)
                                Return ' extra Just ignor the error in the program that is doing this
                            End If 'hack
                        End If 'hack
                    End If ' extra
                    FMB(5037)
                Next Index 'hack
            End If ' extra
            '2021 01 04 removed ReSortSymbolList() 'hack this might change where you are inserting at,  needs to be done at the end, or better yet after finishing all inserting
            CheckForAnySortNeeded(127)
            IndexAt = IndexSymbol
            '20200629 ShowSorts(mytable,ReSortStringArray("Symbol", Symbol_FileSymbolName, Symbol_ISAM_))
            ' 2020 07 18 FindInSymbolList(SymbolName) ' Shortcort to Indexes
            If IndexAt = ConstantMyErrorCode Then
                MyMakeArraySizesBigger()
                ' special case, it goes at the end of the file
                IndexAt = NewTopOfFile("Symbol")
                'hack indexat = FindInSymbolList(SymbolName)+1 'Should this be inserted here to force an insert right after the name
                Symbol_TableSymbolName(IndexAt, SymbolName)
                'Symbol_TableCode(IndexAt, "/name")
                Symbol_TableCode(IndexAt, Code)
                Symbol_TableX1(IndexAt, XY.a.x)
                Symbol_TableY1(IndexAt, XY.a.y)
                Symbol_Table_X2(IndexAt, XY.b.x)
                Symbol_Table_Y2(IndexAt, XY.b.y)
                Symbol_Table_NameOfPoint(IndexAt, MyNameOfPoint)
                MSG_AInfo(1241, "Inserted Symbol record", MyShowSymbolGraphic(True, IndexAt), "")
                ShowSorts("Named", MyReSort("Named", Named_FileSymbolName, Named_FileSymbolName_ISAM, IndexAt))
                IndexAt = FindInSymbolList(SymbolName) ' Shortcort to Indexes
                ReSortSymbolList()
                FMB(5038)
                If LCase(Code) = "/name" Then
                    FMB(5039)
                    Return ' so we do not add two name records
                End If
            Else
            End If

            For Index = NewTopOfFile("Symbol") To IndexAt Step -1
                'FindingMyBugs(100) 'hack Least amount of checking here 'hack 2020 08 04
                MySwapSymbolList(Index, Index + 1) ' Move it one record in the 'sorted file, because it's Import to keep them in 'order'
                'FindingMyBugs(100) 'hack Least amount of checking here 'hack 2020 08 04
            Next
            ' Add this record right after the name  record (I hope)
            'FindingMyBugs(100) 'hack Least amount of checking here 'hack 2020 08 05
            Symbol_TableSymbolName(IndexAt, SymbolName)
            Symbol_TableCode(IndexAt, Code)
            'FindingMyBugs(100) 'hack Least amount of checking here 'hack 2020 08 05
            Symbol_TableX1(IndexAt, XY.a.x)
            Symbol_TableY1(IndexAt, XY.a.y)
            If Code = "/point" Then
                Symbol_FileX2_io(IndexAt).MyNumber = XY.b.x 'todo need to set mystring with value
                Symbol_FileY2_dt(IndexAt).MyNumber = XY.b.y 'ditto

                FindingMyBugs(10)
                T1 = XY.b.x
                If T1 >= 0 And T1 <= SymbolWindow.ToolStripDropDownInputOutput.DropDownItems.Count - 1 Then
                    Symbol_FileX2_io(IndexAt).MyString = MyTrim(Pop(MyTrim(SymbolWindow.ToolStripDropDownInputOutput.DropDownItems(XY.b.x).Text), FD))
                Else
                    Symbol_FileX2_io(IndexAt).MyString = ""
                End If

                T2 = XY.b.y
                If MyDebug(6) Then Follow(2336, "Number of data types " & SymbolWindow.ToolStripDropDownDataType.DropDownItems.Count.ToString)
                If T2 >= 0 And T2 <= SymbolWindow.ToolStripDropDownDataType.DropDownItems.Count Then
                    'todo whould this be -1 off the Y ??????
                    Symbol_FileY2_dt(IndexAt).MyString = SymbolWindow.ToolStripDropDownDataType.DropDownItems(XY.b.y - 1).Text
                Else
                    'todo need a bug statement here
                    Symbol_FileY2_dt(IndexAt).MyString = ""
                End If
            Else
                Symbol_Table_X2(IndexAt, XY.b.x)
                Symbol_Table_Y2(IndexAt, XY.b.y)
            End If
            Symbol_Table_NameOfPoint(IndexAt, MyNameOfPoint)
            FMB(5040)
            ReSortSymbolList()
            FMB(5041)
            'FindingMyBugs(20) 'hack Least amount of checking here 'hack 2020 08 05
        End Sub


        'Routine Paint ALL Where is the for, (-) is to erase it
        Public Shared Sub PaintEach(Where As PictureBox, XYOffSetXY As MyPointStructure, SymbolName As String, RotationName As String)
            Dim IndexNamed As Int32
            Dim IndexSymbol As Int32
            Dim RotatedXY As MyPointStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3007, 10, "PaintEach")
  if mydebug(9) then follow(2811, 10, "draw each " & SymbolName & FD & MyShowPoint(XYOffSetXY) & FD & RotationName)
#End If
            If MyIsNothing(SymbolName) Or SymbolName = "" Then
                FMB(5042)
                Return ' Because this is not a Symbol
            End If
            If ProgramBuzzy("Begin") = True Then Return
            LimitScale()
            'TDistance = myuniverse.SysGen.Constants.ConstantSymbolCenter - (myuniverse.SysGen.Constants.ConstantSymbolCenter / 10) ' Gives me 9/10 of the distance

            'Display the Symbol name in on Window

            MyDrawText(Where, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(2).x), CStr(MyUniverse.OptionDisplay(2).y)), SymbolName, 2)

            IndexNamed = FindIndexInISAMTable("Named", "NeverAddWhilePainting", Named_FileSymbolName, Named_FileSymbolName_ISAM, SymbolName)
            If IndexNamed = ConstantMyErrorCode Then
                'MyMsgCtr(1021, "Paint Each", "Symbol Name Not Found ", HighLight(SymbolName), "", "", "", "", "", "", "")
                Return
            End If

            'Never update the Indexes while painting
            IndexNamed = CheckNotInList("Named", Named_FileSymbolName, SymbolName)
            If IndexNamed = ConstantMyErrorCode Then         ' If found in the named table
                'todo need a bug message here instead
                IndexNamed = IndexNamed 'error cant find error hack
            Else
                If MyOptionTest(3) = True Then 'stroke
                    MyDrawText(Where, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(3).x), CStr(MyUniverse.OptionDisplay(3).y)), Named_TableStroke(IndexNamed), 3)
                End If
                If MyOptionTest(4) = True Then 'filename
                    MyDrawText(Where, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(4).x), CStr(MyUniverse.OptionDisplay(4).y)), Named_TableNameofFile(IndexNamed), 4)
                End If

                If MyOptionTest(5) = True Then 'Notes
                    MyDrawText(Where, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(5).x), CStr(MyUniverse.OptionDisplay(5).y)), Named_TableNotes(IndexNamed), 5)
                    MyDoEvents(143)
                End If

                If MyOptionTest(6) = True Then ' Opcode
                    MyDrawText(Where, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(6).x), CStr(MyUniverse.OptionDisplay(6).y)), Named_TableOpCode(IndexNamed), 6)
                    MyDoEvents(144)
                End If

                If MyOptionTest(7) = True Then ' Program code text
                    MyDrawText(Where, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(7).x), CStr(MyUniverse.OptionDisplay(7).y)), Named_TableMicroCodeText(IndexNamed), 7)
                    MyDoEvents(152)
                End If

                If MyOptionTest(8) = True Then ' short cut Indexes
                    If F_C.InvalidIndex(Named_TableSymbolIndexes(IndexNamed), F_C.Named_FileSymbolName) Then
                        MyDrawText(Where, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(8).x), CStr(MyUniverse.OptionDisplay(8).y)), "?", 8)
                        MyDoEvents(153)
                    Else
                        MyDrawText(Where, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(8).x), CStr(MyUniverse.OptionDisplay(8).y)), Named_TableSymbolIndexes(IndexNamed).ToString, 8)
                        MyDoEvents(154)
                    End If
                End If
                IndexSymbol = GetSelfCorrectingIndexes(SymbolName)
                'IndexSymbol = Named_TableSymbolIndexes(IndexNamed) ' GetSelfCorrectingIndexes(SymbolName)
                If IndexSymbol < 1 Then ' update the Indexes, if and only if it is pointing to nothing
                    Named_TableSymbolIndexes(IndexNamed, GetSelfCorrectingIndexes(SymbolName))
                    IndexSymbol = Named_TableSymbolIndexes(IndexNamed) ' GetSelfCorrectingIndexes(SymbolName)
                End If

                If IndexSymbol > ConstantMyErrorCode Then       ' If there is a name in the named table then
                    If IndexSymbol > 0 Then
                        If Symbol_TableCoded_String(IndexSymbol) <> "/name" Or Symbol_TableSymbolName(IndexSymbol) <> SymbolName Then   ' If the names do note match (error)
                            IndexSymbol = FindInSymbolList(SymbolName) '20200711 '20200629   ' Find the actual location in the Symbol table
                            If IndexSymbol <= 0 Then      ' If there is a name in the Symbol table 
                            Else
                                MSG_ABug(1243, SymbolName, RotationName, IndexSymbol.ToString)
                                If MyOptionTest(25) = True Then
                                Else
                                End If
                                Return ' 20200713 because we have no graphics to show
                            End If
                            'Else
                            '    Index = IndexSymbol          'Shortcut worked here
                        Else
                            IndexSymbol = GetSelfCorrectingIndexes(SymbolName) 'not in the named table (so assumed not in the Symbol table
                        End If
                    Else
                        'This is an named Symbol with no graphics, so it's an error if we ever get here.but fix it for next time?
                        IndexSymbol = GetSelfCorrectingIndexes(SymbolName) 'not in the named table (so assumed not in the Symbol table
                        If IndexSymbol > 0 Then
                            Named_TableSymbolIndexes(IndexNamed, IndexSymbol)
                        Else
                            MSG_ABug(1244, SymbolName, IndexNamed.ToString, IndexSymbol.ToString)
                            If MyOptionTest(25) = True Then
                            Else
                            End If
                            IndexNamed = ConstantMyErrorCode          ' Not in the named table.
                        End If
                    End If
                Else
                    MSG_ABug(1245, "PaintEach(): Symbol Name Not Found in named_Table", SymbolName, RotationName) ' invalid Symbol
                    ' index?
                End If
            End If


            If IndexSymbol = ConstantMyErrorCode Then 'hack? because we have to exit if there is no graphices for the Symbol
                MSG_ABug(1246, "Symbol name not found : " & HighLight(SymbolName), "Named Index " & IndexNamed.ToString, "Graphic Index " & IndexSymbol.ToString)
                Return
            End If
            IndexSymbol += 1 ' after the MyKeyword_2_string(KeyConstName )  for the rest of the Symbol till the next name or end
            'FindingMyBugs(10) 'hack Least amount of checking here 'hack
            While (Symbol_TableCoded_String(IndexSymbol) <> "/name") And (IndexSymbol <= TopOfFile("Symbol"))
                Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                    Case "/line" 'Line Start
                        MyDrawLineWithIndex(Where, IndexSymbol, XYOffSetXY, RotationName)
                    Case "/point"
                        RotatedXY = MyRotated_1(IndexSymbol, MyUniverse.MyStaticData.ZeroZero, RotationName)
                        'todo This should be passing the DataType or color name for the point color.
                        'MyDrawCircle_At(Where, MyPoint1XY(RotatedXY.x + XYOffSetXY.x, RotatedXY.y + XYOffSetXY.y), Symbol_TableSymbolName(IndexSymbol), Symbol_Table_NameOfPoint(IndexSymbol))
                        MyDrawCircle_At(Where, MyPoint1XY(RotatedXY.x + XYOffSetXY.x, RotatedXY.y + XYOffSetXY.y), Symbol_Table_NameOfPoint(IndexSymbol), Symbol_Table_DataType(IndexSymbol))
                        ', Symbol_TableSymbolName(IndexSymbol) , 
                        MyDrawPointArrow(Where, MyRotated_1(IndexSymbol, XYOffSetXY, RotationName), MyRotated_1a(IndexSymbol, RotationName), Symbol_Table_DataType(IndexSymbol), RotationName, Symbol_Table_X2(IndexSymbol))
                        'MyUnEnum(Symbol_Table_InputOutput(IndexSymbol), SymbolWindow.ToolStripDropDownInputOutput, 1), from above
                        MyDrawText(Where, MyRotated_1(IndexSymbol, MyPoint1XY(XYOffSetXY.x + CInt(MyUniverse.OptionDisplay(1).x), XYOffSetXY.y + CInt(MyUniverse.OptionDisplay(1).x)), RotationName), Symbol_Table_NameOfPoint(IndexSymbol), 21)
                    Case "/name"
                        MyDrawText(Where, MyRotated_1(IndexSymbol, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(2).x), CStr(MyUniverse.OptionDisplay(2).y)), RotationName), Symbol_TableSymbolName(IndexSymbol), 2)
                    Case "/delete"
                        MyDrawCircle_At(Where, MyUniverse.MyStaticData.ZeroZero, "red", LCase(Symbol_Table_NameOfPoint(IndexSymbol)))
                    Case "/error"
                        'Why am I calling (11) this display ?
                        MyDrawText(Where, MyRotated_1(IndexSymbol, MyPoint1XY(XYOffSetXY.x + CInt(MyUniverse.OptionDisplay(11).x), XYOffSetXY.y + CInt(MyUniverse.OptionDisplay(11).y)), RotationName), Symbol_TableSymbolName(IndexSymbol), 11)
                        MyDrawText(Where, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(2).x), CStr(MyUniverse.OptionDisplay(2).y)), SymbolName, 2)
                        MyDrawCircle_At(Where, XYOffSetXY, "red", LCase(Symbol_TableSymbolName(IndexSymbol)))
                        MyDrawCircle_At(Where, XYOffSetXY, "red", LCase(Symbol_Table_NameOfPoint(IndexSymbol)))
                    Case Else
                        MyDrawCircle_At(Where, MyUniverse.MyStaticData.ZeroZero, "red", Symbol_TableCoded_String(IndexSymbol))
                        Return
                End Select
                IndexSymbol += 1
            End While
            'Mydoevents(155)
        End Sub

        Public Shared Sub PaintErase(Where As PictureBox, Index As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3008, 10, "PaintErase")
#End If
            MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis = False
            If mydebug(9) Then follow(2812, 10, "erase at " & Index.ToString & FD & Where.Parent.Name)
            Select Case LCase(Where.Parent.Name)
                Case "FlowChartwindow"
                    PaintAll(Where, Index, Index)
                Case "Symbolwindow"
                    PaintEach(Where, MyUniverse.MyStaticData.ZeroZero, MyUniverse.ProgramOptions.SelectedSymbolName, "default")
            End Select
            MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis = True
        End Sub


        Public Shared Sub ReSetScrollBars(Index As Int32)
            Dim A As Int32
            Dim T1, T2 As Single
            ' Make this Symbol/Path the center of the page
#If MINEDEBUG Then
  if mydebug(9) then follow(3009, 10, "ReSetScrollBars")
  if mydebug(9) then follow(2813, 10, "reset scrool bars  at " & Index.ToString)
#End If
            T1 = FlowChart_TableX1(Index) + FlowChartWindow.VScrollBar1.Minimum
            T2 = FlowChartWindow.VScrollBar1.Maximum - FlowChartWindow.VScrollBar1.Minimum
            A = CInt(T1 / T2 * (FlowChartWindow.VScrollBar1.Maximum - FlowChartWindow.VScrollBar1.Minimum) / 100)
            FlowChartWindow.VScrollBar1.Value = MyMinMax(A, FlowChartWindow.VScrollBar1.Minimum, FlowChartWindow.VScrollBar1.Maximum)

            T1 = FlowChart_TableY1(Index) + FlowChartWindow.HScrollBar1.Minimum
            T2 = FlowChartWindow.HScrollBar1.Maximum - FlowChartWindow.HScrollBar1.Minimum
            A = CInt(T2 / T1 * (FlowChartWindow.HScrollBar1.Maximum - FlowChartWindow.HScrollBar1.Minimum) / 100)
            FlowChartWindow.HScrollBar1.Value = MyMinMax(A, FlowChartWindow.HScrollBar1.Minimum, FlowChartWindow.HScrollBar1.Maximum)
            'todo PanTo(?,?)
            PaintAll(FlowChartWindow.PictureBox1, TopOfFile("FlowChart") - 1, TopOfFile("FlowChart") + 1)
        End Sub


        'Routine Paint ALL Where is the for, (-) is to erase it
        Public Shared Sub PaintAll(Where As PictureBox, Start As Int32, Ending As Int32)
            Dim MyXY As MyPointStructure
            Dim IndexFlowChart As Int32
            Dim MyRotationName As String
#If MINEDEBUG Then
  if mydebug(9) then follow(2814, 11, "PaintAll " & Start.ToString & FD & Ending.ToString)
#End If
            ''''''DoEvents(2762)
            DoThisEvent(2896)
            If FMBRecurse("PaintAll") > 1 Then Return
            If CountStackI(3) > 100 Then Return
            If Ending < Start Then Return 'nothing to paint

            DoEvents(2739)
            MyXY = Nothing
            If MyDebug(6) = True Then If mydebug(9) Then follow(2433, 6, "Paint all from, " & Start.ToString & " to " & Ending.ToString)
            If ProgramBuzzy("Begin") Then Return
            If FMBRecurse("PaintAll") > 5 Then Return
            LimitScale()
            If MyDebug(7) = True Then If mydebug(9) Then follow(2764, 7, "Scale = " & MyShowScale())
            Start = MyMinMax(Start, 1, TopOfFile("FlowChart"))
            Ending = MyMinMax(Ending, 1, TopOfFile("FlowChart"))
            'ShowAllForms(ShowWindow, LeaveWindow, LeaveWindow, LeaveWindow)
            For IndexFlowChart = Start To Ending
                'if mydebug(9) then follow(2695, 7, "Painting " & MyShowFlowChartRecord(False, IndexFlowChart))
                If IndexFlowChart = Int(IndexFlowChart / 100) * 100 Then
                    DisplayMyStatus(7, IndexFlowChart.ToString)
                    'MyDoEvents(156)
                End If
                Select Case LCase(FlowChart_TableCode(IndexFlowChart))
                    Case "/delete"
                        'deleted Text & error text flag
                        If MyDebug(10) Then follow(1149, 10, MyShowFlowChartRecord(True, IndexFlowChart))
                        MyDrawText(Where, MyOffset(MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), CStr(MyUniverse.OptionDisplay(9).x), CStr(MyUniverse.OptionDisplay(9).y)), FlowChart_TableOther_Name(IndexFlowChart), 9)
                    Case "/error"
                        'Error Text
                        MyDrawText(Where, MyOffset(MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), CStr(MyUniverse.OptionDisplay(1).x), CStr(MyUniverse.OptionDisplay(1).y)), FlowChart_TableOther_Name(IndexFlowChart), 1)
                    Case My_keyWord(My_KeyConstUse)
                        If InSideMyWindow(Where, MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart))) Then
                            MyRotationName = FlowChart_Table_Rotation(IndexFlowChart)
                            DisplayObject(Where, MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), FlowChart_TableSymbol_Name(IndexFlowChart), MyRotationName)
                            MyDrawText(Where, MyOffset(MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), CStr(MyUniverse.OptionDisplay(2).x), CStr(MyUniverse.OptionDisplay(2).y)), FlowChart_Table_DataType(IndexFlowChart), 2)
                            'input/output
                            MyDrawText(Where, MyOffset(MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), CStr(MyUniverse.OptionDisplay(10).x), CStr(MyUniverse.OptionDisplay(10).y)), FlowChart_TableSymbol_Name(IndexFlowChart), 10)
                            'Path Data Values
                            If FindIndex_In_TableNetLinks(IndexFlowChart) > 1 Then
                                MyDrawText(Where, MyOffset(MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), (MyUniverse.SysGen.Constants.ConstantSymbolCenter * -1).ToString, (-MyUniverse.SysGen.Constants.ConstantSymbolCenter).ToString), Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart)), 17)
                            End If
                            If MyOptionTest(32) = True Then
                                MyXY.x = FlowChart_TableX1(IndexFlowChart)
                                MyXY.y = FlowChart_TableY1(IndexFlowChart)
                                MyXY = MyOffset(MyXY, CStr(MyUniverse.OptionDisplay(32).x), CStr(MyUniverse.OptionDisplay(32).y))
                                MyDrawText(Where, MyXY, IndexFlowChart.ToString, 32)
                            End If
                        Else
                            'if mydebug(9) then follow(2815, 9, "outside " & MyShowFlowChartRecord(False, IndexFlowChart))
                        End If

                    Case "/path"
                        MyDrawLineS_PathS(Where, IndexFlowChart)
                        If MyOptionTest(1) = True Then 'path names
                            MyXY.x = CInt((FlowChart_TableX1(IndexFlowChart) + FlowChart_TableX2(IndexFlowChart)) / 2)
                            MyXY.y = CInt((FlowChart_TableY1(IndexFlowChart) + FlowChart_TableY2(IndexFlowChart)) / 2)
                            MyXY = MyOffset(MyXY, CStr(MyUniverse.OptionDisplay(12).x), CStr(MyUniverse.OptionDisplay(12).y))
                            MyDrawText(Where, MyXY, FlowChart_TablePath_Name(IndexFlowChart), 1)
                        End If
                    Case "/Constant"
                        If InSideMyWindow(Where, MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart))) Then
                            MyDrawCross(Where, MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), FlowChart_Table_DataType(IndexFlowChart), FlowChart_TablePath_Name(IndexFlowChart))
                            'Constants
                            MyDrawText(Where, MyOffset(MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), CStr(MyUniverse.OptionDisplay(13).x), CStr(MyUniverse.OptionDisplay(13).y)), FlowChart_Table_DataType(IndexFlowChart), 13)
                        End If
                    Case "/nothing" 'do nothing
                    Case Nothing
                        MyMsgCtr(1096, "PaintAll", IndexFlowChart.ToString, "", "", "", "", "", "", "", "")
                    Case Else
                        'This should never be drawn
                        MyMsgCtr(1278, "PaintAll", FlowChart_TableCode(IndexFlowChart), "", "", "", "", "", "", "", "")
                        'MyDrawCircle_At(Where, MyUniverse.MyStaticData.Zerozero, 0, LCase(Symbol_TableCode(index)))
                End Select
            Next
            If MyDebug(6) = True Then If mydebug(9) Then follow(2434, 6, "End PaintAll " & Start.ToString & " to " & Ending.ToString)
        End Sub

        Public Shared Function AddCameFromLine(CodeLine As String) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3011, 10, "AddCameFromLine")
#End If
            If CodeLine = "" Then Return ""
            Return AddRM("Address_" & (MyUniverse.MySS.Inputs.LineNumberIn - 1).ToString & ".PathName") & vbCrLf & CodeLine 'make it a variable.
        End Function

        Public Shared Function InsertCameFromLine(ByRef Keyline As String, IndexForInsert As Int32, SubLine As Int32) As Int32 ' returns the number of characters it added to the string
            Dim Temp As String
            Dim K As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3012, 10, "InsertCameFromLine")
#End If
            If mydebug(9) Then follow(2816, 10, "Insert CameFrom " & Keyline)
            K = Len(Keyline)
            If SubLine = 0 Then
                Temp = MyUniverse.ProgramOptions.FCCL_WhiteSpace
            Else
                Temp = "_" & Trim(Str(SubLine)) & MyUniverse.ProgramOptions.FCCL_WhiteSpace
            End If
            If IndexForInsert = 1 Then
                Keyline = MyUniverse.SysGen.Constants.SyntaxCameFromLine & Temp & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.ProgramOptions.FCCL_MultiLine & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.ProgramOptions.FCCL_WhiteSpace & Mid(Keyline, IndexForInsert, Len(Keyline)) '2020 08 20 added space between 
            Else
                Keyline = Mid(Keyline, 1, IndexForInsert) & MyUniverse.SysGen.Constants.SyntaxCameFromLine & Temp & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.ProgramOptions.FCCL_MultiLine & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.ProgramOptions.FCCL_WhiteSpace & Mid(Keyline, IndexForInsert, Len(Keyline))
            End If
            Return Len(Keyline) - K ' cause we always add something
        End Function

        Public Shared Function AddGo_ToNextLine(CodeLine As String) As String
            Dim Temp As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3013, 10, "AddGo_ToNextLine")
#End If
            If CodeLine = "" Then Return ""
            Temp = MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine & MyUniverse.ProgramOptions.FCCL_WhiteSpace & AddRM("Address_" & MyUniverse.MySS.Inputs.LineNumberIn & ".PathName")
            If MyDebug(9) Then Follow(2817, "Add : " & Temp)
            Return CodeLine & vbCrLf & Temp & vbCrLf
        End Function

        Public Shared Function InsertGo_ToNextLine(ByRef Keyline As String, IndexForInsert As Int32, SubLine As Int32) As Int32 'return the number characters it added to the string
            Dim Temp As String
            Dim K As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3014, 10, "InsertGo_ToNextLine")
  if mydebug(9) then follow(2818, 10, "Insert Go_To next " & Keyline)
#End If
            K = Len(Keyline)
            If SubLine = 0 Then
                Temp = MyUniverse.ProgramOptions.FCCL_WhiteSpace
            Else
                Temp = "_" & Trim(Str(SubLine)) & MyUniverse.ProgramOptions.FCCL_WhiteSpace

            End If
            If IndexForInsert >= Len(Keyline) Then
                Keyline = Keyline &
    MyUniverse.ProgramOptions.FCCL_WhiteSpace &
    MyUniverse.ProgramOptions.FCCL_MultiLine &
    MyUniverse.ProgramOptions.FCCL_WhiteSpace &
    MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine &
        MyUniverse.ProgramOptions.FCCL_WhiteSpace &
Temp
            Else
                Keyline = Mid(Keyline, 1, IndexForInsert - 1) &
    MyUniverse.ProgramOptions.FCCL_WhiteSpace &
    MyUniverse.ProgramOptions.FCCL_MultiLine &
    MyUniverse.ProgramOptions.FCCL_WhiteSpace &
    MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine &
    MyUniverse.ProgramOptions.FCCL_WhiteSpace &
    Temp &
    MyUniverse.ProgramOptions.FCCL_WhiteSpace &
    Mid(Keyline, IndexForInsert, Len(Keyline))
            End If
            Return Len(Keyline) - K
        End Function



        Public Shared Function Spaced(Too As Int32, What As String) As String
            'todo need to make sure that len(what is less than Too)
            If Len(What) >= Too Then
                Return Mid(What, 1, Too - 1) & "#" 'todo this is a bug (should self correct to make this wider
            Else
                Return What & Space(Too - Len(What))
            End If
        End Function



        Public Shared Function NoWhiteSpaceS(S As String) As String ' Remove all white space to return just a character string (For Filenames etc)
            Dim I, j As Int32
            Dim T As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3015, 10, "NoWhiteSpaces")
  if mydebug(9) then follow(2819, 10, "No White Space " & S)
#End If
            T = S
            For j = 1 To Len(S)
                For I = 1 To Len(MyUniverse.SysGen.Constants.ConstantDelimiters & MyUniverse.SysGen.Constants.ConstantSpecialCharacters)
                    If Mid(S, j, 1) = Mid(MyUniverse.SysGen.Constants.ConstantDelimiters & MyUniverse.SysGen.Constants.ConstantSpecialCharacters, I, 1) Then
                        Mid(T, j, 1) = MyUniverse.ProgramOptions.FCCL_WhiteSpace
                    End If
                Next I
            Next j

            NoWhiteSpaceS = ""
            For j = 1 To Len(Trim(T))
                If Mid(T, j, 1) <> MyUniverse.ProgramOptions.FCCL_WhiteSpace Then NoWhiteSpaceS &= Mid(T, j, 1)
            Next j


            'hack OK, why am I removing the digits again? (Boy itsw hard getting old and forgetful)
            While IsThisANumber(MyLeft(NoWhiteSpaceS & "a", 1))
                NoWhiteSpaceS = Mid(NoWhiteSpaceS, 2, Len(NoWhiteSpaceS))
            End While

        End Function







        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Routine This returns and removes the till the first 'white' space
        ' and returns the string without the whitespace delimiters
        Public Shared Function Pop(ByRef A As String, Delimiters As String) As String ' Returns the first "word" and never the seperating 
            Dim Z As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3016, 11, "Pop")
#End If
            Pop = A
            Z = MyFirstOne(Pop, Delimiters)
            If Z > 0 Then
                Pop = Mid(A, 1, Z)
                A = Mid(A, Z + 1, Len(A))
            Else
                Pop = A
                A = ""
            End If
            If Len(Pop) > 1 Then
                Pop = MyTrim(Pop)
            End If
            'if mydebug(9) then follow(2435, 10, "Pop = " & Pop)
            Return Pop
        End Function

        Public Shared Function PopQuote(ByRef A As String) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3017, 10, "PopQuote")
  if mydebug(9) then follow(2820, 10, "Pop Quote ")
#End If
            If MyLeft(A, Len(MyUniverse.SysGen.Constants.SyntaxQuotes)) = MyUniverse.SysGen.Constants.SyntaxQuotes Then
                A = Mid(A, Len(MyUniverse.SysGen.Constants.SyntaxQuotes) + 1, Len(A))
                Return MyUniverse.SysGen.Constants.ConstantQuote
            End If
            PopQuote = MyLeft(A, 1) 'First quote
            A = Mid(A, 2, Len(A))
            While MyLeft(A, 1) <> Chr(34) And Len(A) > 0
                PopQuote &= MyLeft(A, 1)
                A = Mid(A, 2, Len(A))
                If InStr(A, Chr(34)) <> 0 Then
                    Return MyUniverse.SysGen.Constants.ConstantQuote
                End If
            End While
            ' Save The Last Quote also
            'todo is this nessary '''PopQuote &= MyLeft(A, 1)
            A = Mid(A, 2, Len(A))
            Return MyUniverse.SysGen.Constants.ConstantQuote
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Routine This returns and removes the till the first 'white' space
        Public Shared Function Pop1(ByRef A As String, Delimiters As String) As String ' Pop the first parsed "word" or special character (See Pop)
            Dim X As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3018, 11, "Pop1 " & A)
#End If
            If IsThISAMarker(A) <> "" Then
                X = MyTrim(IsThISAMarker(A))
                A = Mid(A, Len(X) + 1, Len(Trim(A))) 'todo trim this ? 
                Return X
            End If

            ' This needs to be changed so that we find where the trim is, and then move the string only once, because this way is VERY slow.
            X = ""
            While InStr(Delimiters, MyLeft(A, 1)) = 0
                X &= MyLeft(A, 1)
                A = Mid(A, 2, Len(A))
            End While
            If X <> "" Then
                Pop1 = X
            Else
                X = MyLeft(A, 1) ' first character is a delimiters character
                A = Mid(A, 2, Len(A))
                Pop1 = X
            End If
            A = Trim(A) ' Do not get rid of the character that stopped the pop
            If Len(Pop1) = 0 And Len(A) <> 0 Then
                Pop1 = MyLeft(A, 1)
                A = Mid(Pop1, 2, Len(A))
            End If
            Pop1 = Trim(Pop1)
        End Function


        Public Shared Function ReturnPathName(WhichVariable As Int32, Names As String) As String
            Dim i As Int32
            Dim t As String
            i = 0
            t = NoFD(Names)
            While Len(t) > 0
                i += 1
                If i = WhichVariable Then Return Pop(t, FD)
                NoFD(Pop(t, FD)) ' show what is being counter as a variable
            End While
            Return ""
        End Function

        Public Shared Function CountPathNames(names As String) As Int32
            Dim i As Int32
            Dim t As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3019, 10, "CountPathNames")
  if mydebug(9) then follow(2821, 10, "Count the number of path names " & names)
#End If
            t = names
            i = 0
            t = PopLine(t)
            t = NoFD(t)
            While Len(t) > 0
                i += 1
                t = NoFD(t)
                Pop(t, FD)
                If MyDebug(10) Then follow(2740, 10, Pop(t, FD)) ' show what is being counter as a variable
            End While
            Return i
        End Function


        Public Shared Function FirstEqualsFirst(CodeLine As String, B_N_F As String) As String
            Dim A, B, C, D, bnf As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3010, 10, "FirstWEqualsFirst")
  if mydebug(9) then follow(2822, 10, "A) First Equals First " & CodeLine)
  if mydebug(9) then follow(2822, 10, "B) First Equals First " & B_N_F)
#End If
            bnf = Trim(Mid(B_N_F, InStr(B_N_F & "::=", "::=") + 3, Len(B_N_F)))
            If CodeLine = bnf Then Return AddRM("BNF." & bnf)
            If IsThisA_KeyWord(bnf) Then Return bnf
            'todo need to return if bnf is a '?' character, '?-?' character range, or '??' keyword/string
            If Len(bnf) = 3 Then
                If MyLeft(bnf, 1) = "'" Then
                    If MyRight(bnf, 1) = "'" Then
                        If MyLeft(CodeLine, 1) = Mid(bnf, 2, 1) Then Return MyLeft(CodeLine, 1)
                    End If
                End If
            End If
            A = Trim(CodeLine)
            B = Trim(bnf)
            If MyTrim(A) = MyTrim(B) Then Return AddRM("BNF." & B)
            C = Pop(A, MyUniverse.SysGen.Constants.ConstantDelimiters)
            D = Pop(B, MyUniverse.SysGen.Constants.ConstantDelimiters)
            C = NoBlock(C)
            D = NoBlock(D)
            'If MyDebug(9 ) then follow(2676, 9, "a) " & A & "." & vbCrLf & B & "." & vbCrLf & vbTab & "defined as " & C & "." & vbCrLf & vbTab & "Name is =:: " & D & "." & vbCrLf)
            'If MyDebug(9 ) then follow(2676, 9, "b) " & CodeLine)
            'If MyDebug(9 ) then follow(2676, 9, "c) " & B_N_F)
            If C = D Then Return AddRM("BNF." & D)
            If MyLeft(D, 1) = "'" And MyRight(D, 1) = "'" And Len(D) > 1 Then
                If FirstEqualsFirst(C, D) <> "" Then Return AddRM("BNF." & D)
                If FirstEqualsFirst(A, D) <> "" Then Return AddRM("BNF." & D)
            End If
            Return "" ' no match
        End Function



        'recurisve
        Public Shared Function FindGrammarFromCode(Code_line As String, IsAtCharacter As Int32) As String
            Dim A, B, C, D As String
            Dim I, J As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3013, 10, "FindGrammarFromCode")
  if mydebug(9) then follow(2824, 10, "Find Grammar from code : " & Code_line)
#End If
            FindGrammarFromCode = ""
            A = Mid(Code_line, IsAtCharacter) ' get what it is so far
            For I = 1 To TopOfFile("Grammar")
                B = Language_Grammar(I)
                J = InStr(B, "::=")
                If J <> 0 Then
                    C = Mid(B, J + 3)
                    If InStr(" ", Trim(C)) <> 0 Then
                        DebugPrint("ERROR HERE ")
                    End If

                    D = FirstEqualsFirst(A, B) ' This should tell if it matches so far
                    If D <> "" Then
                        FindGrammarFromCode &= FD & A
                        If MyDebug(10) Then follow(2903, 10, "Find Grammar from code " & A & FD & SHL(B) & FD & SHL(C) & FD & SHL(D))
                        Return FindGrammarFromCode
                    End If
                End If
            Next
            Return ""
        End Function





        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This seperates the string into parts.
        'see IsThisAWhat()
        'Basally it is parsed by trying to find 
        '   first keyWord, Operator, and other known inputs
        '   second then variable name

        Public Shared Function MyParse(ByRef MyArray() As String, From_What As String) As String ' makes array of parsed atoms from the CodeLine
            'todo is not returning the names of any variables found
            Static LastFrom_what As String = ""
            Static LastPathNames As String = ""
            Static LastSize As Int32 = -1
            Static LastMyArray(64) As String
            'todo bug removes () from Test(a)
            'todo needs to put commas between atoms of source code
            'todo needs to get Syntax of code line?
            Dim A1, B1 As String
            Dim MyErrors As Int32
            Dim Kounter As Int32
            'todo i removed this because it put in comma's

            If LastFrom_what = From_What Then
                ReDim MyArray(LastSize)
                For Kounter = 0 To UBound(MyArray)
                    MyArray(Kounter) = LastMyArray(Kounter)
                Next Kounter
                Return LastPathNames
            End If

            'clean out the array
            ReDim MyArray(1) 'UBound(MyArray))
#If MINEDEBUG Then
  if mydebug(9) then follow(3014, 10, "MyParse")
#End If
            If MyDebug(11) Then follow(2825, 11, "Parse  " & MyNoCR(From_What))
            MyParse = FD '"" ' Collect the variable names 
            A1 = From_What 'PopLine(From_What)
            Kounter = 1 ' because I DoNot use z(zero) anywhere else
            A1 = MyReplace(A1, vbCrLf & vbCrLf, vbCrLf)
            While Len(A1) > 0
                FMB(1108, "My Parse Line " & HighLight(A1))
                MyErrors = 1024
                If MyErrors < 1 Then Exit While
                While MyErrors > 1 ' so I have an exit point
                    If UBound(MyArray) - 2 < Kounter Then ReDim Preserve MyArray(Kounter + 10)
                    MyErrors -= 1
                    A1 = MyTrim(A1)

                    If Len(A1) < 1 Then Exit While
                    B1 = A1 ' so we do not loose anything in the pop (first special character is lost)
                    B1.Replace(vbCrLf, " ")
                    B1 = MyTrim(Pop1(B1, MyUniverse.SysGen.Constants.ConstantDelimiters & MyUniverse.ProgramOptions.FCCL_MultiLine & MyUniverse.SysGen.Constants.ConstantSpecialCharacters))
                    FMB(1109, " MyParse : " & B1)
                    ' Need to get all of a marker
                    Select Case IsThisAWhat(B1)'No_FieldDelimiter(IsThisAWhat(B)))
                        Case MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine
                            MyArray(Kounter) = MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine '& MyUniverse.ProgramOptions.FCCL_WhiteSpace & B
                            A1 = MyReplace(A1, B1, "")
                        Case MyUniverse.SysGen.Constants.SyntaxCameFromLine
                            'todo need to replace with the syntax for a label
                            MyArray(Kounter) = MyUniverse.SysGen.Constants.SyntaxCameFromLine '& MyUniverse.ProgramOptions.FCCL_WhiteSpace & B
                            A1 = MyReplace(A1, B1, "")
                        Case MyUniverse.ProgramOptions.FCCL_Comment
                            'MyArray(Kounter) = MyArray(Kounter) & MyLeft(A1, 1)
                            A1 = RemoveOne(A1)
                            MyArray(Kounter) = PopLine(A1)
        'A1 = MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine
                        Case MyUniverse.ProgramOptions.FCCL_Extensions
                            MyArray(Kounter) = MyArray(Kounter) & MyLeft(A1, 1)
                            A1 = Mid(A1, 2, Len(IsThisAWhat(B1)))
                        Case MyUniverse.ProgramOptions.FCCL_MultiLine
                            MyArray(Kounter) = MyUniverse.ProgramOptions.FCCL_MultiLine
                            A1 = Mid(A1, Len(MyUniverse.ProgramOptions.FCCL_MultiLine) + 1, Len(A1))
                        Case MyUniverse.ProgramOptions.FCCL_VarChars
                            MyArray(Kounter) = MyArray(Kounter) & MyLeft(A1, 1)
                            A1 = Mid(A1, 2, Len(IsThisAWhat(B1)))
                        Case MyUniverse.SysGen.Constants.SyntaxQuotes
                            ' Save The First Quote
                            MyArray(Kounter) = MyLeft(A1, 1) 'First quote
                            A1 = RemoveOne(A1)
                            While MyLeft(A1, 1) <> Trim(MyUniverse.SysGen.Constants.ConstantQuote) And Len(A1) > 0
                                MyArray(Kounter) = MyArray(Kounter) & MyLeft(A1, 1)
                                A1 = RemoveOne(A1)
                            End While
                            ' Save The Last Quote also
                            MyArray(Kounter) = MyArray(Kounter) & MyLeft(A1, 1)
                            A1 = NoFD(A1)
                            MyParse &= "SyntaxQuote" & FD
                        Case MyUniverse.SysGen.Constants.SyntaxComments
                            ' added a Go_To before the comment 
                            MyArray(Kounter) = MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine & " " & Trim(A1)
                            'A1 = "" ' everything afterwards is considered part of the comment
                            A1 = MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine' Except that we have to Go_To the next line 
                        Case MyUniverse.SysGen.Constants.SyntaxKeyWords
                            A1 = Trim(A1)
                            'B1 = Trim(A1 ) ' so we do not loose anything in the pop (first special character is lost)
                            'B1 = Pop1(B1, MyUniverse.SysGen.Constants.ConstantDelimiters)
                            MyArray(Kounter) = Trim(B1)
                            'A1 = Trim(Mid(Trim(A1), Len(B1) + 1, Len(A1))) ' re-moved B From A
                            A1 = MyReplace(A1, B1, "") ' re-moved B From A
                        Case MyUniverse.SysGen.Constants.SyntaxOperators
                            A1 = Trim(A1)
                            'B1 = Trim(A1 ) ' so we do not loose anything in the pop (first special character is lost)
                            'B1 = Pop1(B1, MyUniverse.SysGen.Constants.ConstantDelimiters)
                            MyArray(Kounter) = Trim(B1)
                            A1 = Trim(Mid(Trim(A1), Len(B1) + 1, Len(A1))) ' re-moved B From A
                        Case MyUniverse.SysGen.Constants.SyntaxFunctions
                            A1 = Trim(A1)
                            'B1 = Trim(A1 ) ' so we do not loose anything in the pop (first special character is lost)
                            'B1 = Pop1(B1, MyUniverse.SysGen.Constants.ConstantDelimiters)
                            MyArray(Kounter) = Trim(B1)
                            A1 = Trim(Mid(Trim(A1), Len(B1) + 1, Len(A1))) ' re-moved B From A
                        Case MyUniverse.SysGen.Constants.SyntaxAlphas
                            While IsThisAnAlpha(A1)
                                MyArray(Kounter) = MyArray(Kounter) & MyLeft(A1, 1)
                                A1 = RemoveOne(A1)
                            End While
                            MyParse &= MyArray(Kounter) & FD
                        Case MyUniverse.SysGen.Constants.SyntaxNumbers
                            While IsThisANumber(A1)
                                MyArray(Kounter) = MyArray(Kounter) & MyLeft(A1, 1)
                                A1 = RemoveOne(A1)
                            End While
                            MyParse &= MyArray(Kounter) & FD
                        Case MyUniverse.SysGen.Constants.SyntaxSpecialCharacters
                            MyArray(Kounter) = MyLeft(A1, 1)
                            A1 = RemoveOne(A1)
                            While IsThisASpecalCharacter(A1) And Len(A1) > 0
                                MyArray(Kounter) &= MyLeft(A1, 1)
                                A1 = RemoveOne(A1)
                            End While
                        Case MyUniverse.SysGen.Constants.SyntaxWhiteSpaces
                            MyArray(Kounter) = FD
                            A1 = RemoveOne(A1)
                            While IsThisAWhiteSpace(A1) And Len(A1) > 0
                                MyArray(Kounter) = FD ' any amount of white space is just one break between things
                                A1 = RemoveOne(A1)
                            End While
        ' assume that all variables must start with a letter, then letters or numbers or special characters
                        Case MyUniverse.SysGen.Constants.SyntaxFieldDelimiters
                            MyArray(Kounter) = FD
                            A1 = Mid(A1, Len(FD) + 1, Len(A1))
                        Case MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine
                            MyArray(Kounter) = Trim(B1)
                            A1 = Trim(Mid(Trim(A1), Len(B1) + 1, Len(A1))) ' re-moved B From A
                        Case MyUniverse.SysGen.Constants.SyntaxUnknowns
                            System.Text.Encoding.Unicode.GetBytes(A1)
                            MSG_ABug(1257, "unknown Character Classification", AscW(A1).ToString & "  " & A1, IsThisAWhat(A1))
                            MyArray(Kounter) = MyArray(Kounter) & MyLeft(A1, 1)
                            A1 = RemoveOne(A1)
        'DOC This is a What returns ☻vaiableName period pointattribute )]} 
                        Case Nothing
                            If Len(B1) > 0 Then
                                MyArray(Kounter) = B1
                                A1 = RemoveOne(A1)
                            End If
                            MSG_ABug(1258, "Parseing Nothing", A1, B1)
                        Case MyUniverse.SysGen.Constants.SyntaxGrammar
                            MyArray(Kounter) = Trim(B1)
                            A1 = Trim(Mid(Trim(A1), Len(B1) + 1, Len(A1))) ' re-moved B From A
                        Case Else
                            If InStr(B1, ".") <> 0 Then
                                If InStr(B1, MyUniverse.SysGen.Constants.RMStart) > 0 Then
                                    If InStr(B1, MyUniverse.SysGen.Constants.RMEnd) > 0 Then
                                        MyArray(Kounter) = MyArray(Kounter) & B1
                                        A1 = Mid(A1 & "  ", Len(B1) + 1, Len(A1) + 5)
                                        MyParse &= NameOfPointOnly(MyArray(Kounter)) & FD
                                    Else
                                        MSG_ABug(1259, "Variable is missing the End marker " & MyUniverse.SysGen.Constants.RMEnd, " But has the first marker " & MyUniverse.SysGen.Constants.RMStart, " and has the period" & vbCrLf & B1)
                                        MyArray(Kounter) = MyArray(Kounter) & B1
                                        A1 = Mid(A1, Len(B1) + 1, Len(A1))
                                    End If
                                Else
                                    MyArray(Kounter) = MyArray(Kounter) & B1
                                    A1 = Mid(A1, Len(B1) + 1, Len(A1))
                                End If
                            Else
                                'MyInfo(1261, "Unknown what this is, assume that it is a variable ", HighLight(B1), MakePathName(B1))
                                MyArray(Kounter) = MyArray(Kounter) & MakePathName(B1)
                                A1 = Mid(A1, Len(B1) + 1, Len(A1))
                                If MyDebug(7) Then follow(2652, 7, "Added atom " & MyArray(Kounter))
                                MyParse &= NameOfPointOnly(MyArray(Kounter)) & FD
                            End If

                            'Case MyUniverse.SysGen.Constants.SyntaxVariables
                            'If IsThisAnAlpha(A1) Then
                            ''todo need to add .pathname if no . is in the variable
                            ''todo this needs to find the end of the variable and then move the string once and update the string once (instead of moving the 'string billions of times)
                            'MyArray(Kounter) = MyArray(Kounter) & MyLeft(A1, EndOfVariableName(A1))
                            'A1 = Mid(A1, EndOfVariableName(A1) + 1, Len(A1))
                            'If InStr(MyArray(Kounter), ".") = 0 Then
                            'MyArray(Kounter) = AddRM(MyArray(Kounter) & ".PathName")
                            'End If
                            'ElseIf IsThisANumber(A1) Then
                            'While IsThisANumber(A1)
                            'MyArray(Kounter) = MyArray(Kounter) & MyLeft(A1, 1)
                            'A1 = RemoveOne(A1)
                            'End While
                            'ElseIf IsThisAVariableName(B1) Then
                            'MyArray(Kounter) = B1
                            'A1 = Trim(Mid(A1, Len(B1) + 1, Len(A1)))
                            'A1 = NoFD(A1) 'todo this is a bug where I jhust throw away the, that is messing up my system, and worst, I'm not telling anybody 
                            'ElseIf MyLeft(A1, Len(MyUniverse.SysGen.Constants.SyntaxVariables)) = MyUniverse.SysGen.Constants.SyntaxVariables Then
                            'MyArray(Kounter) = MyUniverse.SysGen.Constants.SyntaxVariables
                            'A1 = Trim(Mid(A1, Len(MyUniverse.SysGen.Constants.SyntaxVariables), Len(A1)))
                            'A1 = NoFD(A1) 'todo this is a bug where I jhust throw away the, that is messing up my system, and worst, I'm not telling anybody 'about it.
                            'End If
                            'MyParse &= NameOfPointOnly(MyArray(Kounter)) & FD
                            '
                    End Select
                    Kounter += 1
                    MyErrors -= 1
                End While
            End While
            MyUniverse.MyStaticData.LastParsed.LastCodeLine = From_What
            Kounter = UBound(MyArray)
            While Kounter > LBound(MyArray)
                If MyArray(Kounter) <> Nothing Then Exit While
                Kounter -= 1
            End While
            ReDim MyUniverse.MyStaticData.LastParsed.LastParseArray(Kounter + 1)
            For Kounter = 1 To UBound(MyUniverse.MyStaticData.LastParsed.LastParseArray) - 1
                MyUniverse.MyStaticData.LastParsed.LastParseArray(Kounter) = MyArray(Kounter)
            Next


            'hack, This is really a foolish hack
            'incase I needed more names (because of some bug somewhere else, I need it
            'MyParse &= MakePathName("V1_" & MyRight(MyRnd(), 6)) & FD
            'MyParse &= MakePathName("V2_" & MyRight(MyRnd(), 6)) & FD
            'MyParse &= MakePathName("V3_" & MyRight(MyRnd(), 6)) & FD
            'MyParse &= MakePathName("V4_" & MyRight(MyRnd(), 6)) & FD
            'hack end of the foolish hack!

            '**********
            LastFrom_what = From_What
            For Kounter = 0 To UBound(MyArray)
                LastMyArray(Kounter) = MyArray(Kounter)
            Next Kounter
            LastPathNames = MyParse
            LastSize = UBound(MyArray)
            '**********
            MyUniverse.MyStaticData.LastParsed.LastParsedVariableNames = MyParse
            FMB(3534, MyParse)
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Test if imbedded mark
        Public Shared Function IsThisAGo_ToNextLine(CodeLine As String) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3015, 10, "IsThisAGo_ToNextLine")
#End If
            If MyLeft(Trim(CodeLine), Len(MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine)) = MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine Then
                Return True
            End If
            Return False
        End Function
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Test if imbedded mark
        Public Shared Function IsThisACameFromLine(CodeLine As String) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3016, 10, "IsThisACameFromLine")
#End If
            If MyLeft(Trim(CodeLine), Len(MyUniverse.SysGen.Constants.SyntaxCameFromLine)) = MyUniverse.SysGen.Constants.SyntaxCameFromLine Then
                Return True
            End If
            Return False
        End Function


        Public Shared Sub SetNameOfPoint(ByRef XY As MyPointStructure, PointName As String, SymbolName As String, PathName As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3017, 10, "SetNameOfPoint")
#End If
            XY.Named.PointName = PointName
            XY.Named.SymbolName = SymbolName
            XY.Named.PathName = PathName
        End Sub

        Public Shared Function NameOfPointOnly(A As String) As String
            Dim B As String
            Dim I1, I2, I3, I4 As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3018, 11, "NameOfPointOnly " & A)
#End If
            B = A
            If B = "" Then Return B
            I1 = InStr(B, ".")
            I2 = InStr(B, MyUniverse.SysGen.Constants.RMStart)
            I3 = InStr(B, MyUniverse.SysGen.Constants.RMEnd)
            I4 = Len(MyUniverse.SysGen.Constants.RMStart)

            If I1 <> 0 And I2 <> 0 And I3 <> 0 Then
                If I1 > 0 And I2 > 0 And I3 > 0 And I1 - I4 - I2 > 0 Then
                    If I2 + I4 > 0 And (I1 - I4 - I2) > 0 Then
                        Return Mid(B, I2 + I4, I1 - I4 - I2)
                    End If
                End If
                If mydebug(9) Then follow(2635, 1, (I2 + I4).ToString & FD & (I1 - I4 - I2).ToString & FD & Len(B).ToString)
            End If
            Return NoFD(ReplaceRM("", A, ""))
        End Function


        Public Shared Function RemoveOne(A As String) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3019, 10, "RemoveOne ")
#End If
            Return Mid(A, 2, Len(A))
        End Function


        Public Shared Function ReplaceRM(Start As String, A As String, Ending As String) As String
            Dim B As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3020, 10, "ReplaceRM")
#End If
            If MyIsNothing(A) Then Return ""
            B = A
            If MyIsNothing(MyUniverse.SysGen.Constants.RMStart) = True Then Return A
            B = B.Replace(MyUniverse.SysGen.Constants.RMStart, Start)
            B = B.Replace(MyUniverse.SysGen.Constants.RMEnd, Ending)
            'if mydebug(9) then follow(2677, 10, "Replace " & MyUniverse.SysGen.Constants.RMStart & " with " & shl(Start) & vbTab & A & vbTab & B & vbCrLf)
            Return Trim(B)
        End Function

        Public Shared Function AddRM(A As String) As String
            Dim x, y As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3021, 10, "AddRM")
#End If
            x = MyUniverse.SysGen.Constants.RMStart
            y = MyUniverse.SysGen.Constants.RMEnd
            If MyLeft(A, Len(x)) = x And MyRight(A, Len(y)) = y Then Return A ' don't add if already a marker
            Return MyUniverse.SysGen.Constants.RMStart & A & MyUniverse.SysGen.Constants.RMEnd
        End Function




        Public Shared Function NoFD(A As String) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3022, 10, "NoFD")
#End If
            NoFD = A
            While MyLeft(NoFD, Len(FD)) = FD
                NoFD = Mid(NoFD, Len(FD) + 1, Len(NoFD))
            End While
            While MyRight(NoFD, 1) = FD
                NoFD = Mid(NoFD, 1, Len(NoFD) - Len(FD))
            End While
            ' A I N F O 2 (145)
        End Function


        Public Shared Function No_FieldDelimiter(A As String) As String
            Dim L As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3023, 10, "No_FieldDelimiter")
#End If
            L = Len(MyUniverse.SysGen.Constants.RMStart)
            No_FieldDelimiter = Trim(A)
            If MyLeft(No_FieldDelimiter, L) = MyUniverse.SysGen.Constants.RMStart Then
                No_FieldDelimiter = Mid(No_FieldDelimiter, L + 1, Len(No_FieldDelimiter))
                If MyRight(No_FieldDelimiter, L) = MyUniverse.SysGen.Constants.RMEnd Then
                    Return Mid(No_FieldDelimiter, 1, Len(No_FieldDelimiter) - L)
                End If
            End If
            ' A I N F O 2 (-146)
            Return A
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This determines what part of the code string is:
        ' A inputed language keyword
        ' A inputed language operator
        ' A inputed language function name
        ' A quote or comment
        ' and then a number, an alpha, or a variable name or special namings

        'ie:
        ' a=b & "that" 
        ' gives the symtax of 
        ' variablemarkder specialmarker variablemarkder specialmarker quotemarker

        Public Shared Function IsThisAWhat(CodeLine As String) As String
            Dim X, A As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3024, 10, "IsThisAWhat")
  if mydebug(9) then follow(2782, 10, "IsThisAWhat = " & CodeLine)
#End If
            A = MyTrim(CodeLine)
            X = IsThISAMarker(A)
            If X <> "" Then
                Return X
            End If

            If MyIsNothing(CodeLine) Then Return Nothing
            If CodeLine = "" Then Return MyUniverse.SysGen.Constants.SyntaxUnknowns
            If IsThisAWhiteSpace(CodeLine) Then Return MyUniverse.SysGen.Constants.SyntaxWhiteSpaces

            If IsThisAGo_ToNextLine(CodeLine) Then Return MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine
            If IsThisACameFromLine(CodeLine) Then Return MyUniverse.SysGen.Constants.SyntaxCameFromLine
            If IsThisAQuote(CodeLine) Then Return MyUniverse.SysGen.Constants.SyntaxQuotes
            If IsThisAComment(CodeLine) Then Return MyUniverse.SysGen.Constants.SyntaxComments
            If IsThisA_KeyWord(CodeLine) Then Return MyUniverse.SysGen.Constants.SyntaxKeyWords
            If IsThisA_Function(CodeLine) Then Return MyUniverse.SysGen.Constants.SyntaxFunctions
            If IsThisA_Operator(CodeLine) Then Return MyUniverse.SysGen.Constants.SyntaxOperators
            If IsThisAGrammar(CodeLine) Then Return MyUniverse.SysGen.Constants.SyntaxGrammar
            If IsThisAVariableName(CodeLine) Then Return CodeLine
            If IsThisANumber(CodeLine) Then Return MyUniverse.SysGen.Constants.SyntaxNumbers 'number is always a variable(Need to add option to over ride, and a mnemonic)
            If IsThisAnAlpha(CodeLine) Then Return MyUniverse.SysGen.Constants.SyntaxAlphas ' Alpha is always a variable (Need to add an option to over ride, and also a mnemonic)

            X = MyUniverse.ProgramOptions.FCCL_MultiLine : If MyLeft(CodeLine, Len(X)) = X Then Return MyUniverse.ProgramOptions.FCCL_MultiLine
            X = MyUniverse.ProgramOptions.FCCL_Comment : If MyLeft(CodeLine, Len(X)) = X Then Return MyUniverse.ProgramOptions.FCCL_Comment
            X = MyUniverse.ProgramOptions.FCCL_Extensions : If MyLeft(CodeLine, Len(X)) = X Then Return MyUniverse.ProgramOptions.FCCL_Extensions
            X = MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine : If MyLeft(CodeLine, Len(X)) = X Then Return MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine

            If IsThISAMarker(CodeLine) <> "" Then Return CodeLine ' MyUniverse.SysGen.Constants.SyntaxVariables ' this will return if it is a  Myfd(point.name )  format which is a variable
            If IsThISAMarker2(CodeLine) <> "" Then Return CodeLine 'MyUniverse.SysGen.Constants.SyntaxVariables

            If MyLeft(CodeLine, Len(FD)) = FD Then Return MyUniverse.SysGen.Constants.SyntaxFieldDelimiters

            If IsThisASpecalCharacter(CodeLine) Then Return MyUniverse.SysGen.Constants.SyntaxSpecialCharacters
            If IsThisAWhiteSpace(CodeLine) Then Return MyUniverse.SysGen.Constants.SyntaxWhiteSpaces

            If IsThisAVariableName(CodeLine) Then Return MyUniverse.SysGen.Constants.SyntaxVariable


            Return MyUniverse.SysGen.Constants.SyntaxUnknowns

        End Function

        Public Shared Function IsThisAFCKeyword(KeyWord As String) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3025, 10, "IsThisAFCKeyWord")
#End If
            Select Case LCase(KeyWord)
                Case "/Grammar"
                    Return True
                Case "/name"
                    Return True
                Case "/use"
                    Return True
                Case "/path"
                    Return True
                Case "/point"
                    Return True
                Case "/line"
                    Return True
                Case "/error"
                    Return True
                Case "/keyword", "/keyword="
                    Return True
                Case "/function", "/function="
                    Return True
                Case "/operator", "/operator="
                    Return True
                Case "/ignore", "/ignore="
                    Return True
                Case "/Grammar", "/Grammar="
                    Return True
                Case "/debug", "/debug="
                    Return True
                Case Else
                    MSG_AInfo(2373, " Not a known Grammar code ", KeyWord, "")
                    Return False
            End Select
            Return False
        End Function



        Public Shared Function IsThisAGrammar(CodeLine As String) As Boolean
            Dim A, B As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3026, 10, "IsThisAGrammar")
#End If
            'last dish effort
            'first see if this is a definition word for a Grammar syntax
            A = CodeLine
            A = PopLine(A)
            'todo need to add here if this is one of the /flow chart keywords
            If MyLeft(A, 1) = "/" Then
                If InStr(A, "::=") < InStr(A, vbCrLf) Then
                    B = Mid(A, 1, InStr(A, "::="))
                Else
                    B = PopLine(A)
                End If
                A = CodeLine
                B = Pop(B, MyUniverse.SysGen.Constants.ConstantDelimiters)
                If IsThisAFCKeyword(B) = True Then
                    Return True
                End If
                Return False
            End If


            A = MyTrim(CodeLine)
            If MyLeft(A, Len(MyConstantIgnoreFunctionOperatorKeyWord)) = MyConstantIgnoreFunctionOperatorKeyWord Then
                Return True
            End If
            If InStr(A, "::=") < InStr(A, vbCrLf) Then
                Return True
            End If
            If FindMyGrammarName(Pop(A & " ", " ")) <> "" Then
                Return True
            End If

            Return False
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Test if imbedded mark is a start of a comment
        Public Shared Function IsThisAComment(CodeLine As String) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3027, 10, "IsThisAComment")
#End If
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxComments)) = MyUniverse.SysGen.Constants.SyntaxComments Then
                Return True
            End If
            If CodeLine = MyUniverse.ProgramOptions.FCCL_Comment Then
                Return True
            End If
            'If IsThISAMarker(CodeLine) <> "" Then Return False
            Return False
        End Function



        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Test if the string is all digits
        Public Shared Function IsThisANumber(CodeLine As String) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3028, 10, "IsThisANumber")
#End If
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxNumbers)) = MyUniverse.SysGen.Constants.SyntaxNumbers Then Return True
            If IsThISAMarker(CodeLine) <> "" Then Return False
            If MyLeft(CodeLine, 1) >= "0" And MyLeft(CodeLine, 1) <= "9" Then Return True
            Return False
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Test if the string is all alpha characters

        Public Shared Function IsThisAnAlphaNumeric(CodeLine As String) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3029, 10, "IsThisAnAlphaNumeric")
#End If
            If IsThisAnAlpha(CodeLine) = True Then Return True
            If IsThisANumber(CodeLine) = True Then Return True
            Return False
        End Function
        Public Shared Function IsThisAnAlpha(CodeLine As String) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3030, 11, "IsThisAnAlpha")
#End If
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxAlphas)) = MyUniverse.SysGen.Constants.SyntaxAlphas Then Return True
            If IsThISAMarker(CodeLine) <> "" Then Return False ' Any other marker
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxAlphas)) = MyUniverse.SysGen.Constants.SyntaxAlphas Then Return True
            If MyLeft(CodeLine, 1) >= "A" And MyLeft(CodeLine, 1) <= "Z" Then Return True
            If MyLeft(CodeLine, 1) >= "a" And MyLeft(CodeLine, 1) <= "z" Then Return True
            Return False
        End Function


        Public Shared Function IsThisAWhiteSpace(CodeLine As String) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3031, 10, "IsThisAWhiteSpace")
#End If
            If InStr(MyUniverse.SysGen.Constants.ConstantWhiteSpaces, MyLeft(CodeLine, 1)) > 0 Then
                Return True
            Else
                Return False
            End If
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Test if the string is special character mark
        Public Shared Function IsThisASpecalCharacter(CodeLine As String) As Boolean
            ' First test if it a marker
#If MINEDEBUG Then
  if mydebug(9) then follow(3032, 10, "IsThisASpecialCharacter")
#End If
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxSpecialCharacters)) = MyUniverse.SysGen.Constants.SyntaxSpecialCharacters Then Return True
            If IsThISAMarker(CodeLine) <> "" Then Return False
            If IsThisAVariableName(CodeLine) = True Then Return False ' if it is a variable name (including special characters for this language


            'todo need to go through all of the characters of CodeLine ?
            'todo make sure that special characters for this language for this variable is not included
            If InStr(MyUniverse.SysGen.Constants.ConstantSpecialCharacters, MyLeft(CodeLine, 1)) > 0 Then
                Return True
            Else
                Return False
            End If

        End Function


        Public Shared Function IsThisALetterRange(T As String) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3033, 10, "IsThisALetterRange")
#End If
            If MyDebug(9) Then follow(2380, T)
            If T = "-" Then Return False
            Select Case Len(T)
                Case 3
                    If Mid(T & " ", 2, 1) = "-" Then
                        If AscW(Mid(T, 1, 1)) < AscW(Mid(T, 3, 1)) Then
                            Return True
                        End If
                    End If
                Case 5
                    If Mid(T, 3, 1) = "-" Then
                        If MyLeft(T, 1) = "'" And MyRight(T, 1) = "'" Then
                            If InStr(T, "-") <> 0 Then
                                Return True
                            End If
                        ElseIf InStr(T, "-") <> 0 Then
                            If InStr(T, "-") > 1 Then
                                If InStr(T, "-") < Len(T) Then
                                    If MyDebug(9) Then follow(2381, AscW(T).ToString & vbTab & AscW(Mid(T, InStr(T, "-") + 1, 1)).ToString)
                                    Return True
                                End If
                            End If
                        Else
                            If InStr(T, "-") <> 0 Then
                                Return True
                            End If
                        End If
                    End If
                Case Else
                    If InStr(T, "-") <> 0 Then
                        If MyDebug(9) Then follow(2382, T)
                    End If
            End Select

            If T = ChrW(768) & ChrW(8211) & ChrW(879) Then Return True

            Return False
        End Function

        Public Shared Function NoBlock(Quoted As String) As String
            Dim RTN As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3034, 11, "NoBlock")
#End If
            'todo this needs to use the /block inputs
            RTN = Quoted
            If Len(RTN) = 1 Then Return RTN
            If MyLeft(RTN, 1) = "'" And InStr(2, "'", RTN) <> 0 And Len(RTN) > 2 Then RTN = Mid(RTN, 2, InStr(2, "'", RTN))
            If MyLeft(RTN, 1) = Chr(34) And MyRight(RTN, 1) = Chr(34) And Len(RTN) > 2 Then RTN = Mid(RTN, 2, Len(RTN) - 2)
            If MyLeft(RTN, 1) = "(" And MyRight(RTN, 1) = ")" And Len(RTN) > 2 Then RTN = Mid(RTN, 2, Len(RTN) - 2)
            If MyLeft(RTN, 1) = "[" And MyRight(RTN, 1) = "]" And Len(RTN) > 2 Then RTN = Mid(RTN, 2, Len(RTN) - 2)
            If MyLeft(RTN, 1) = "{" And MyRight(RTN, 1) = "}" And Len(RTN) > 2 Then RTN = Mid(RTN, 2, Len(RTN) - 2)
            If MyLeft(RTN, 1) = "<" And MyRight(RTN, 1) = ">" And Len(RTN) > 2 Then RTN = Mid(RTN, 2, Len(RTN) - 2)
            Return Trim(RTN)
        End Function

        Public Shared Function BlockBreak(ByRef CodeLine As String, StartEndBlock As String) As String
            Dim mystart, myend, Half As Int32
            Dim X As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3035, 10, "BlockBreak")
#End If
            Half = CInt(Len(StartEndBlock) / 2)

            mystart = InStr(CodeLine, Mid(StartEndBlock, 1, Half))
            myend = InStr(mystart + 1, CodeLine, Mid(StartEndBlock, 1 + Half, Half))

            If mystart <> 0 And myend <> 0 And myend > mystart Then
                X = Mid(CodeLine, mystart + 1, myend - mystart - Half)
                If X = "" Then Return "" 'todo fix this
                CodeLine.Replace(X, " ")
                If MyDebug(9) Then follow(2374, "Block = " & HighLight(X))
                Return X
            End If
            Return ""
        End Function

        Public Shared Sub DebugWrite(S As String)
            Debug.Write(S)
        End Sub

        Public Shared Sub DebugPrint(S As String)
            Debug.Print(S)
        End Sub


        Public Shared Sub FollowLog(BugNumber As Int32, DebugLevel As Int32, A As String)
#If minedebug Then
            Dim L, M, MAXLEN, MINLEN As Int32
#End If
            Dim CS As String
#If MINEDEBUG Then
              if mydebug(9) then follow(3037, 10, "FollowLog " & BugNumber)
#End If
            If BugNumber < 1000 Or BugNumber > 9999 Then
                DebugPrint("Fix Bug number " & BugNumber.ToString)
            End If
            If DebugLevel = 11 Then Return
            If MyDebug(DebugLevel) = False Then Return
            CS = CountStackS(DebugLevel)
#If minedebug Then
            MAXLEN = 256
            MINLEN = 64
            If Len(A) > MAXLEN Then
                L = Len(A)
                DebugPrint("217 ," & A)
                If InStr(A, "(ALSOBELOW") <> 0 Then MINLEN = 48
                DebugPrint("218 ," & L.ToString & FD & Mid(A, MINLEN, L - MINLEN))
                M = InStr(MAXLEN, A, " ") : If M <> 0 And M < L Then L = M
                DebugPrint("219 ," & L.ToString & FD & Mid(A, MINLEN, L - MINLEN))
                M = InStr(MINLEN, A, vbTab) : If M <> 0 And M < L Then L = M
                DebugPrint("220 ," & L.ToString & FD & Mid(A, MINLEN, L - MINLEN))
                M = InStr(MINLEN, A, FD) : If M <> 0 And M < L Then L = M
                DebugPrint("221 ," & L.ToString & FD & Mid(A, MINLEN, L - MINLEN))
                M = InStr(MINLEN, A, vbCr) : If M <> 0 And M < L Then L = M
                DebugPrint("222 ," & L.ToString & FD & Mid(A, MINLEN, L - MINLEN))
                M = InStr(MINLEN, A, "/") : If M <> 0 And M < L Then L = M - 1
                DebugPrint("223 ," & L.ToString & FD & Mid(A, MINLEN, L - MINLEN))
                M = InStr(MINLEN, A, "(END)") : If M <> 0 And M < L Then L = M - 1
                If L > MAXLEN Then L = MAXLEN
   if mydebug(9) then follow(BugNumber, DebugLevel, Len(A).ToString & "(ALSOBELOW) " & Mid(A, 1, MINLEN - L))
   if mydebug(9) then follow(BugNumber, DebugLevel, Len(A).ToString & "(END) " & Mid(A, (MINLEN - L) + 1))
                Return
            End If
#End If
            If Len(MyUniverse.MySystem.Dumps.OutputFileName3) > 1 Then
                System.IO.File.AppendAllText(MyUniverse.MySystem.Dumps.OutputFileName3, MyNoCR(" -->#" & BugNumber.ToString & FD & DebugLevel.ToString & ">" & MyUniverse.FCCLDebugLevel.ToString & FD & CS.ToString & ", " & HighLight(A)) & vbCrLf)
                DebugPrint("-->#" & BugNumber.ToString & FD & SHL(MyUniverse.FCCLDebugLevel.ToString & ">" & DebugLevel.ToString) & ", " & SHL(MyNoCR(A)))
                Return
            End If
            If MyDebug(DebugLevel) = False Then Return
            DebugPrint("208 ," & " -->#" & BugNumber.ToString & FD & SHL(MyUniverse.FCCLDebugLevel.ToString & "<=" & DebugLevel.ToString) & ", " & SHL(MyNoCR(A)))
            Return
        End Sub ' log if mydebug(9) then follow()


        Public Shared Function MyShowFormSize(A As Control) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3038, 10, "MyShowFormSize")
#End If
            Return "(" & A.Top.ToString & FD & A.Left.ToString & ")_(" & A.Size.Height.ToString & FD & A.Size.Width.ToString & ")"
        End Function



        Public Shared Function MyShowAForm(A As Form) As String
            Dim B As String
            Dim E As Control
#If MINEDEBUG Then
  if mydebug(9) then follow(3039, 11, "MyShowAForm")
#End If
            B = "--->" & A.Name & "<--- , " & MyShowLineXYXY(A.Left, A.Top, A.Left + A.Width, A.Top + A.Height)
            For Each E In A.Controls
                'if mydebug(9) then follow(2678, 8, "control Name " & E.Name & ", " & E.Text)
                B &= E.Name & ", " & E.Text & ", "
                If E.Name = "PictureBox1" Then
                    B &= " Picture size " & E.Name & ",top " & E.Top.ToString & ",left " & E.Left.ToString & ",height " & E.Size.Height.ToString & ",width " & E.Size.Width.ToString & ", " & MyShowFormSize(E)
                End If
            Next
            B &= " Number of Controls " & A.Controls.Count.ToString & " "
            B &= " Size of window " & MyShowPoints(A.Left, A.Top, A.Width, A.Height)
            Return B
        End Function


        Public Shared Sub MyBeep()
            FMB(5043)
            'System.Console.Beep()
        End Sub



        Public Shared Function MyDebug(DebugLevel As Int32) As Boolean
            If DebugLevel > 11 Then
                DebugPrint("209 ," & "ERROR Invalid debug level " & DebugLevel.ToString)
            End If
            If MyUniverse.FCCLDebugLevel = 0 Then Return False      'not set yet
            If MyUniverse.FCCLDebugLevel >= DebugLevel Then Return True
            Return False

        End Function

        Public Shared Sub Follow(BugNumber As Int32, Message As String)
            Dim CS As String
            CS = CountStackS(1)
            If Len(MyUniverse.MySystem.Dumps.OutputFileName3) > 1 Then
                System.IO.File.AppendAllText(MyUniverse.MySystem.Dumps.OutputFileName3, MyNoCR(" -->#" & BugNumber.ToString & FD & CS.ToString & FD & Message & vbCrLf))
            End If
            DebugPrint(MyNoCR(" -->#" & BugNumber.ToString & FD & CS.ToString & FD & Message))
        End Sub
        Public Shared Sub Follow(BugNumber As Int32, DebugLevel As Int32, Routine As String)
            Dim CS As String
            'DebugPrint("210 ," & MyUniverse.FCCL_DebugLevel.ToString & FD & DebugLevel.ToString & "Hiding? " & Routine)
            If IsNothing(MyUniverse.DebugCount) Then ReDim MyUniverse.DebugCount(1)
            If BugNumber >= UBound(MyUniverse.DebugCount) Then
                ReDim Preserve MyUniverse.DebugCount(BugNumber + 100)
                If MyDebug(6) = True Then If MyDebug(9) Then Follow(3436, 6, "***** highest debug " & BugNumber.ToString)
            End If
            MyUniverse.DebugCount(BugNumber) += 1
            If MyDebug(DebugLevel) = False Then Return
            CS = CountStackS(DebugLevel)
            FollowLog(BugNumber, DebugLevel, SHL(MyUniverse.MyProgramStatus) & FD & Routine & FD & SHL(Trim(CS.ToString)))

            If BugNumber > 9000 Then
                FollowLog(BugNumber, 1, ">9000| " & SHL(MyUniverse.MyProgramStatus) & "STOP AND FIX THIS BUG NUMBER " & BugNumber.ToString & FD & Routine & " , Stack=" & CS.ToString)
            End If
        End Sub 'Follow

        Public Shared Sub FlowChartDelete(IndexFlowChart As Int32)
            FlowChart_TableCode(IndexFlowChart, "/delete")
        End Sub
        Public Shared Function FlowChartRecordMatches(IndexFlowChart1 As Int32, IndexFlowChart2 As Int32) As Boolean
            If IndexFlowChart1 = IndexFlowChart2 Then Return False
            If InvalidIndex(IndexFlowChart1, FlowChart_FilePathSymbolName) Then Return False
            If InvalidIndex(IndexFlowChart2, FlowChart_FilePathSymbolName) Then Return False

            If FlowChart_FilePathSymbolName(IndexFlowChart1) <> FlowChart_FilePathSymbolName(IndexFlowChart2) Then
                Return False
            End If
            If FlowChart_FileCoded(IndexFlowChart1) <> FlowChart_FileCoded(IndexFlowChart2) Then
                Return False
            End If
            If FlowChart_FileX1(IndexFlowChart1) <> FlowChart_FileX1(IndexFlowChart2) Then
                Return False
            End If
            If FlowChart_FileY1(IndexFlowChart1) <> FlowChart_FileY1(IndexFlowChart2) Then
                Return False
            End If
            If FlowChart_File_X2_Rotation(IndexFlowChart1) <> FlowChart_File_X2_Rotation(IndexFlowChart2) Then
                Return False
            End If
            If FlowChart_File_Y2_Option(IndexFlowChart1) <> FlowChart_File_Y2_Option(IndexFlowChart2) Then
                Return False
            End If
            If FlowChart_File_DataType(IndexFlowChart1) <> "" And FlowChart_File_DataType(IndexFlowChart2) <> "" Then
                If FlowChart_File_DataType(IndexFlowChart1) <> FlowChart_File_DataType(IndexFlowChart2) Then
                    Return False
                End If
            End If

            Return True
        End Function

        Public Shared Function FMBs(Tstring As String) As Int32
            Dim T As String
            T = MyTrim(Tstring)
            If T = "STOP" Then Return 0
            If T = "CBool" Then Return 0
            If T = "Cstr" Then Return 0
            If T = "Cint" Then Return 0
            If T = "Cdbl" Then Return 0
            If IsThisAHexDigitRange(T) = True Then
                Return 0
            ElseIf IsThisAHexDigit(T) = True Then
                Return 0
            ElseIf IsThisA_KeyWord(T) = True Then
                Return 0
            ElseIf IsThisA_Operator(T) = True Then
                Return 0
            ElseIf IsThisALetterRange(T) Then
                Return 0
            ElseIf ItThisAUnicodeClass(T) = True Then
                Return 0
            ElseIf FindMyGrammarName(T) <> "" Then
                Return 0
            ElseIf FindMyKeyword(T) > 0 Then
                Return 0
            ElseIf FindMyOperator(T) > 0 Then
                Return 0
            ElseIf IsThisA_Function(NoBlock(T)) = True Then
                Return 0
            ElseIf IsThisALetterRange(T) = True Then
                Return 0
            ElseIf MyLeft(T, 1) = "'" Then 'bug for basic only
                Return 0
            ElseIf T = "''" Or T = "'" Or T = "|" Or T = "(" Or T = ")" Or T = "{" Or T = "}" Or T = "[" Or T = "]" Or T = "<" Or T = ">" Or T = "'<" Or T = ">'" Or T = "+" Or T = "-" Or T = "&" Or T = "-" Or T = "+" Or T = "*" Or T = "?" Then
                Return 0
            ElseIf Len(T) = 1 Then
                Return 0
            ElseIf T = ";" Then
                Return 0
            End If
            Return -1
        End Function

        Public Shared Function FMB(DebugNumber As Int32) As Boolean
            Dim I, J As Int32
#If MINEDEBUG Then
if mydebug(9) then follow(3042, 1, "FMB " & MyShowFlowChartRecord(True, 1) & vbTab & vbTab & MyShowFlowChartRecord(True, 2))
#End If

            For I = 1 To TopOfFile("FlowChart")
                For J = I + 1 To TopOfFile("FlowChart")
                    If DistanceBetweenTwoPaths(I, J) = 0 Then
                        DebugPrint(" paths connected " & vbCrLf & MyShowFlowChartRecord(False, I) & vbCrLf & MyShowFlowChartRecord(False, J))
                    End If
                Next
            Next


            I = TopOfFile("flowchart")
            If FlowChart_FileX1(I) = 2000 Then
                If FlowChart_FileY1(I) = 6000 Then
                    If MyDebug(1) Then
                        Follow(DebugNumber, 1, "Found Problem " & I.ToString & " =====>" & MyShowFlowChartRecord(False, I))
                    End If
                    Return True
                End If
            End If
            DebugWrite(".")
            Return False
        End Function

        'looking if inside the flow chart window
        Public Shared Function FMB(x As Int32, Y As Int32) As String
            If InSideMyWindow(FlowChartWindow.PictureBox1, MyPoint1XY(x, Y)) = True Then
                Return " INSIDE "
            End If
            Return " OUTSIDE "
        End Function

        Public Shared Function FMB(BugNumber As Int32, S As String) As Boolean
            If MyDebug(10) Then Follow(BugNumber, "FMB: following string " & SHL(S))
            Return FMB(BugNumber)
        End Function

        Private Shared Function FMB_IsXY(IndexFlowChart As Int32) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3043, 10, "FMB_IsXY")
#End If
            Return FMB_IsXY(FlowChart_FileX1(IndexFlowChart), FlowChart_FileY1(IndexFlowChart), FlowChart_File_X2_Rotation(IndexFlowChart), FlowChart_File_Y2_Option(IndexFlowChart))
        End Function



        Private Shared Function FMB_IsXY(x1 As Int32, y1 As Int32, x2 As Int32, y2 As Int32) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3044, 10, "FMB_IsXY:= " & MyShowPoints(x1, y1, x2, y2))
#End If
            If x1 = 2000 And y1 = 6000 Then Return True
            Return False
        End Function


        Public Shared Sub FMB(MyArray() As String, What As String)
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3045, 10, "FMB")
#End If
            For I = 0 To UBound(MyArray)
                If MyArray(I) = What Then
                    Return
                End If
            Next
        End Sub

        Public Shared Sub FindingMyBugsChangeOfWindows()
            Static Last(7) As Boolean
            Dim Flag As Boolean = False
            If DontFindMyBugs() = True Then Return
            If Last(0) <> FlowChartWindow.Visible Then Last(0) = FlowChartWindow.Visible : Flag = True
            If Last(1) <> SymbolWindow.Visible Then Last(1) = SymbolWindow.Visible : Flag = True
            If Last(2) <> FileInputOutputWindow.Visible Then Last(2) = FileInputOutputWindow.Visible : Flag = True
            If Last(3) <> OptionsWindow.Visible Then Last(3) = OptionsWindow.Visible : Flag = True
            If Last(4) <> SplashWindow.Visible Then Last(4) = SplashWindow.Visible : Flag = True
            If Flag = True Then
                If mydebug(9) Then follow(1013, 3, "Windows : " & ", " & FlowChartWindow.Visible & ", " & SymbolWindow.Visible & ", " & FileInputOutputWindow.Visible & ", " & OptionsWindow.Visible & ", " & SplashWindow.Visible)
                'Else
                'if mydebug(9) then follow(1015, 3, "No Change in Visible Windows")
            End If
        End Sub
        Public Shared Sub NoDups(A() As String)
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3046, 10, "NoDups")
#End If
            For I = 1 To UBound(A)
                If A(I - 1) = A(I) Then
                    If A(I) <> "" Then
                        A(I) = MyConstantIgnoreFunctionOperatorKeyWord & I.ToString & A(I)
                    End If
                End If
            Next
        End Sub


        Public Shared Sub FMB1(DeBugNumber As Int32) 'Find My Bugs
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3047, 10, "FMB1")
#End If
            For I = 1 To SymbolWindow.ComboBoxPointNameList.Items.Count - 1
                If SymbolWindow.ComboBoxPointNameList.Items(I - 1).ToString = SymbolWindow.ComboBoxPointNameList.Items(I).ToString Then
                    MSG_ABug(DeBugNumber, "Bug of two matching point names.", SymbolWindow.ComboBoxPointNameList.Items(I - 1).ToString, "")
                End If
            Next
        End Sub


        Public Shared Function Block(ByRef CL As String) As String

            Dim I, T1, T2 As Int32
            Dim A, B, C As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3048, 10, "Block")
#End If
            For I = 1 To UBound(Language_Blocks)
                If Len(Language_Blocks(I)) > 0 Then
                    A = MyTrim(CL)
                    B = Language_Blocks(I)
                    T1 = CInt(Len(B) / 2)
                    C = MyRight(B, T1)
                    B = MyLeft(B, T1)

                    If Len(B) <> T1 Then If MyDebug(3) Then follow(2387, "Problem " & T1.ToString & FD & B)
                    If Len(C) <> T1 Then If MyDebug(3) Then follow(2388, "Problem " & T1.ToString & FD & C)

                    If MyLeft(A, T1) = B Then
                        If InStr(T1 + 1, A, C) <> 0 Then
                            T2 = InStr(T1 + 1, A, C)
                            'todo need to remove from CL before returning
                            Return Mid(A, T1 + 1, InStr(T1 + 1, A, C) - 2)
                        End If
                    End If
                End If
            Next
            'find the first block
            ''< >'      ' '     ""   ( )   { }   ( )    < >
            Return "" 'todo
        End Function

        Public Shared Function IsThisAHexDigitRange(A As String) As Boolean
            Dim I, J As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3049, 10, "IsThisAHexDigitRange")
#End If
            'I = InStr(A, "0x027")
            I = InStr(A, "0x")
            If I = 0 Then Return False
            J = InStr(I + 1, A, "0x")
            If J = 0 Then Return False

            If IsThisAHexDigit(Mid(A, I + 2, 4)) = False Then Return False
            If IsThisAHexDigit(Mid(A, J + 2, 4)) = False Then Return False
            Return True

        End Function


        Public Shared Function IsThisAHexDigit(A As String) As Boolean
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3050, 10, "IsThisAHexDigit")
#End If
            For I = 1 To Len(A)
                Select Case Mid(A, I, 1)
                    Case "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "a", "b", "c", "d", "e", "f"
                        'DebugWrite(A)
                    Case Else
                        'if mydebug(9) then follow(2828,10,"")
                        Return False
                End Select
            Next I
            'if mydebug(9) then follow(2829,10,"")
            Return True
        End Function

        Public Shared Function ItThisAUnicodeClass(A As String) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3051, 10, "ItThisAUnicodeClass")
#End If
            If Len(A) <> 2 Then Return False
            Select Case A
                Case "Cc", "Cf", "Co", "Cs", "Ll", "Lm", "Lo", "Lt", "Lu", "Mc", "Me", "Mn", "Nd", "Nl", "No", "Pc", "Pd", "Pe", "Pf", "Pi", "Po", "Ps", "Sc", "Sk", "Sm", "So", "Zl", "Zp", "Zs"
                    Return True
                Case "Ws"
                    Return True
            End Select
            Return False
        End Function

        Public Shared Function TestUnicodeRange(Hex_0x As String, Letter As String) As Boolean
            Dim I, J, K, L As Int32
            Dim A, B, C As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3052, 10, "TestUnicodeRange")
#End If
            A = Hex_0x

            A = Trim(TrimOff(A, "'"))
            A = Trim(TrimOff(A, "<"))
            A = Trim(TrimOff(A, ">"))
            A = Trim(TrimOff(A, ","))
            A = Trim(A)

            If InStr(A, "0x") = 0 Then Return False
            If InStr(A, "-") = 0 Then
                If InStr(A, "0x") <> 0 Then
                    I = Hex2Bin(A)
                Else
                    I = AscW(A)
                End If
                If InStr(Letter, "0x") <> 0 Then
                    J = Hex2Bin(Letter)
                Else
                    J = AscW(Letter)
                End If
                If I = J Then Return True
                Return False
            End If

            'else hex a a range of characters
            I = InStr(A, "0x")
            J = InStr(I + 1, A, "0x")
            K = InStr(Letter, "0x")
            L = InStr(A, "-")
            B = Mid(A, 1, L - 1)
            C = Mid(A, L + 1)


            If I <> 0 Then
                I = Hex2Bin(B) 'i+2
            Else
                I = AscW(A)
            End If

            If J <> 0 Then
                J = Hex2Bin(C) 'j+2
            Else
                J = AscW(MyRight(A, 1))
            End If


            If K <> 0 Then
                K = Hex2Bin(Mid(Letter, 3))
            Else
                K = AscW(Letter)
            End If

            If MyDebug(4) Then follow(2384, I.ToString & " " & J.ToString & " " & K.ToString)

            If K >= I And K <= J Then
                Return True
            End If
            Return False
        End Function

        Public Shared Function Bin2Hex(N As Long) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3053, 10, "Bin2Hex")
#End If
            Return "0x" & Hex(N)
        End Function


        Public Shared Function Str2Hex(a As String) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3054, 10, "Str2Hex")
#End If
            If "0" & MyRight("0000" & Hex(AscW(a)), 4) <> MyRight("0000" & Hex(AscW(a)), 5) Then
                If mydebug(9) Then follow(2736, 1, "This must be a an unknown bug " & MyRight("0000" & Hex(AscW(a)), 4) & "   " & MyRight("0000" & Hex(AscW(a)), 5))
            End If
            Str2Hex = MyRight("0000" & Hex(AscW(a)), 4) 'add leading zeros
        End Function

        Public Shared Function Hex2Bin(HEX0x0000 As String) As Int32
            Dim A As String
            Static LastHex As String
            Static LastValue As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3055, 10, "Hex2Bin")
#End If
            If HEX0x0000 = LastHex Then Return LastValue
            If HEX0x0000 = "" Then Return -1
            A = MyTrim(HEX0x0000)
            A = TrimOff(A, "'")
            'todo this should also have an error message
            If A = "0x" Then Return &HFFFFF 'todo should not return everything
            If MyLeft(A, 2) = "0x" Then A = Mid(A, 3)
            A = Trim(A)
            If IsThisAHexDigit(A) = True Then
                LastHex = HEX0x0000
                LastValue = Convert.ToInt32(A, 16)
                Return Convert.ToInt32(A, 16)
                'Else
                'MSG_AInfo(2344, "@ HEX2BIN can not convert ", A, HEX0x0000)
            End If
            Return -1
        End Function


        Public Shared Function TrimOff(A As String, Remove As String) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3056, 10, "TrimOff")
#End If
            TrimOff = A
            While MyLeft(TrimOff, 1) = Remove
                TrimOff = Mid(TrimOff, 2)
            End While
            While MyRight(TrimOff, 1) = Remove
                TrimOff = MyLeft(TrimOff, Len(TrimOff) - 1)
            End While
        End Function

        'returns the unicode characters in this Class/category
        Public Shared Function UnicodeClass(A As String) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3057, 10, "UniCodeClass")
#End If
            Return MyUnicode.FindUnicodeClass(A)
        End Function



        Public Shared Function IsHex(A As String) As Boolean
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3058, 10, "IsHex")
#End If
            For I = 1 To Len(A)
                If Not IsThisAHexDigit(Mid(A, I, 1)) Then
                    Return False
                End If
            Next
            Return True
        End Function


        'this returns what this is
        'character '?'
        'character <unicode '0x####' >
        'letter (unicode) <unicode ...> )
        Public Shared Function GetHex(A As String) As String
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3059, 10, "GetHex")
#End If
            GetHex = ""
            If MyDebug(8) Then FMB(3535, A)
            I = InStr(A, "0x") + 2
            If I = 0 Then Return ""
            If I < 1 Or I > Len(A) Then I = 1
            While IsThisAHexDigit(Mid(A, I, 1)) = True
                GetHex &= Mid(A, I, 1)
                If I > Len(A) + 2 Then Return "0x" & GetHex
                I += 1
            End While
            Return "0x" & GetHex '"0x" & GetHex
        End Function


        Public Shared Function FixGrammar(Code_line As String) As String ' This will change '<0x????>' and '<0x????-0x????>' to characters
            Dim I As Int32
            Dim Temp As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3060, 10, "FixGrammar")
#End If
            'if mydebug(9) then follow(2830, 10, "Fix Grammar " & Code_line)
            FixGrammar = MyTrim(Code_line)
            FixGrammar = FixGrammar.Replace("&h", "0x") 'change from basic default to other HEX
            Temp = Trim(Code_line)
            Temp = Pop(Temp, " ")
            While InStr(FixGrammar, "0x") > 0
                Temp = GetHex(FixGrammar)
                'Temp = Mid(FixGrammar, InStr(FixGrammar, "0x"), 6) 'todo sometimes it is a bigger than 6 characters (16 bits)
                I = Hex2Bin(Temp)

                If I >= -32768 And I <= 65535 Then
                    FixGrammar = FixGrammar.Replace(Temp, ChrW(I))
                Else
                    'MSG_AInfo1(2345, "Hex is outside of character range -32768 65535 " & Temp & HighLight(Char.ConvertFromUtf32(I)), I.ToString, "")
                    FixGrammar = FixGrammar.Replace(Temp, Char.ConvertFromUtf32(I))
                End If
            End While
            Return FixGrammar
        End Function


        Public Shared Function WhatIsThisBlock(CodeLine As String) As String
            Dim I, J As Int32
            Dim T1, T2, T3 As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3061, 10, "WhatIsThisBlock")
#End If
            'todo this should see what this code line block does (assume that it is a unicode character for now, but add the others things later.
            WhatIsThisBlock = ""
            If Trim(CodeLine) = "" Then
                Return ""
            End If
            If Len(CodeLine) = 1 Then
                Return CodeLine
            End If
            If InStr(LCase(CodeLine), "0x") <> 0 And InStr(LCase(CodeLine), "unicode") <> 0 Then 'this has a unicode character defined maybe
                I = InStr(LCase(CodeLine), "0x")
                J = InStr(LCase(CodeLine), "unicode")
                If J > I Then Return "" 'error?
                'not used? WhatIsThisBlock = Mid(CodeLine, I + 2, 4) 'debug only
                If IsMyDigit(Mid(CodeLine, I + 2, 1)) = False Then
                    Return ""
                End If
                If IsMyDigit(Mid(CodeLine, I + 3, 1)) = False Then
                    Return ""
                End If
                If IsMyDigit(Mid(CodeLine, I + 4, 1)) = False Then
                    Return ""
                End If
                If IsMyDigit(Mid(CodeLine, I + 5, 1)) = False Then
                    Return ""
                End If
                WhatIsThisBlock = CodeLine.Replace(Mid(CodeLine, I, 6), ChrW(Hex2Bin(Mid(CodeLine, I + 2, 4))))
            ElseIf InStr(LCase(CodeLine), "unicode") <> 0 Then
                Return "X"
            ElseIf MyLeft(CodeLine, 1) = "'" And InStr(2, "'", CodeLine) <> 0 Then 'it is a Constant
                If InStr(CodeLine, " ") <> 0 Then
                    MSG_ABug(2199, "The Grammar can not have a Constant with a space in it", CodeLine, "")
                    Return ""
                Else

                    If Len(CodeLine) < 2 Then
                        Return Trim(CodeLine)
                    End If
                    Return Mid(CodeLine, 2, Len(CodeLine) - 2) 'keyword
                End If
            ElseIf MyLeft(CodeLine, 10) = "'<Unicode " Then
                ' removed not needed ?                T1 = Pop(CodeLine, " ") 'unicode
                T2 = Pop(CodeLine, " ") 'name of character
                Select Case LCase(T2)
                    Case "classes"
                        While Len(CodeLine) > 0
                            T3 = Pop(CodeLine, " |,>'")
                            Select Case T3
                                Case "Ll"
                                    WhatIsThisBlock &= " Ll "
                                Case "Cc"
                                    WhatIsThisBlock &= " ??? "
                                Case "Cf"
                                    WhatIsThisBlock &= " ??? "
                                Case "Co"
                                    WhatIsThisBlock &= " ??? "
                                Case "Cs"
                                    WhatIsThisBlock &= " ??? "
                                Case "Ll"
                                    WhatIsThisBlock &= " ??? "
                                Case "Lm"
                                    WhatIsThisBlock &= " Lm "
                                Case "Lo"
                                    WhatIsThisBlock &= " Lo "
                                Case "Lt"
                                    WhatIsThisBlock &= " Lt "
                                Case "Lu"
                                    WhatIsThisBlock &= " Lu "
                                Case "Mc"
                                    WhatIsThisBlock &= " ??? "
                                Case "Me"
                                    WhatIsThisBlock &= " ??? "
                                Case "Mn"
                                    WhatIsThisBlock &= " ??? "
                                Case "Nd"
                                    WhatIsThisBlock &= " ??? "
                                Case "Nl"
                                    WhatIsThisBlock &= " Nl "
                                Case "No"
                                    WhatIsThisBlock &= " ??? "
                                Case "Pc"
                                    WhatIsThisBlock &= " ??? "
                                Case "Pd"
                                    WhatIsThisBlock &= " ??? "
                                Case "Pe"
                                    WhatIsThisBlock &= " ??? "
                                Case "Pf"
                                    WhatIsThisBlock &= " ??? "
                                Case "Pi"
                                    WhatIsThisBlock &= " ??? "
                                Case "Po"
                                    WhatIsThisBlock &= " ??? "
                                Case "Ps"
                                    WhatIsThisBlock &= " ??? "
                                Case "Sc"
                                    WhatIsThisBlock &= " ??? "
                                Case "Sk"
                                    WhatIsThisBlock &= " ??? "
                                Case "Sm"
                                    WhatIsThisBlock &= " ??? "
                                Case "So"
                                    WhatIsThisBlock &= " ??? "
                                Case "Zl"
                                    WhatIsThisBlock &= " ??? "
                                Case "Zp"
                                    WhatIsThisBlock &= " ??? "
                                Case "Zs"
                                    WhatIsThisBlock &= " ??? "
                                Case Else
                                    WhatIsThisBlock &= " unknown "
                            End Select
                        End While
                        Return WhatIsThisBlock
                    Case Else
                End Select
                ' removed not needed ?J = InStr(I + 1, CodeLine, " ")
                If MyDebug(9) Then follow(2159, "What Is This Block ---> " & HighLight(CodeLine) & vbCrLf & SHL(WhatIsThisBlock))
            Else
                While Len(CodeLine) > 0
                    T1 = Pop(CodeLine, " ,|")
                    T2 = Pop(CodeLine, " ,|")
                    WhatIsThisBlock &= " " & T1 'WhatIsThisBlock(T1)
                    WhatIsThisBlock &= " " & T2 'WhatIsThisBlock(T2)
                End While
                Return Trim(WhatIsThisBlock)
            End If
        End Function

        Public Shared Function IsThisABlock(CodeLine As String) As Boolean ' returns is this is the start of a quote
#If MINEDEBUG Then
  if mydebug(9) then follow(3062, 10, "IsThisABlock")
#End If
            If Block(CodeLine) = "" Then Return False
            Return True
        End Function



        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Test if imbedded mark for a quote
        Public Shared Function IsThisAQuote(CodeLine As String) As Boolean ' returns is this is the start of a quote
#If MINEDEBUG Then
  if mydebug(9) then follow(3063, 10, "IsThisAQuote")
#End If
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxQuotes)) = MyUniverse.SysGen.Constants.SyntaxQuotes Then Return True
            If MyLeft(Trim(CodeLine), 1) = Trim(MyUniverse.SysGen.Constants.ConstantQuote) Then Return True
            If IsThISAMarker(CodeLine) <> "" Then Return False ' because its not quotes
            Return False
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' We are still not finding it in the list even tho it is there (Found with a loop through them all
        Public Shared Function IsThisA_KeyWord(CodeLine As String) As Boolean ' returns is this is in the keyword list (ignores markers)
            Dim I As Int32
            Dim A, B As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3064, 11, "IsThisA_KeyWord")
#End If


            If MyDebug(8) Then FMB(1120, CodeLine)
            A = NoBlock(CodeLine)
            B = A
            B = Trim(Pop1(B, MyUniverse.SysGen.Constants.ConstantWhiteSpaces))  ' Trim(Pop1(B, myuniverse.SysGen.Constants.ConstantDelimiters))
            If MyIsNothing(B) Or B = "" Then Return False
            If MyDebug(8) Then FMB1(8032)
            I = FindInSortedLanguageList(MyUniverse.SysGen.Constants.SyntaxKeyWords, B, Language_KeyWord)
            If I > UBound(Language_KeyWord) Then
                MSG_ABug(1264, "Index returned outside of array size " & I, UBound(Language_KeyWord).ToString, "")
            End If
            If I > ConstantMyErrorCode Then
                If Language_KeyWord(I) = B Then
                    Return True
                Else
                    'I = FindInSortedLanguageList(MyUniverse.SysGen.Constants.SyntaxKeyWords, B, Language_KeyWord) 'todo debug only remove
                    Return False
                End If
            End If

            ' Else we have to search it item by item (and resort it also
            For I = 1 To UBound(Language_KeyWord)
                If LCase(B) = LCase(Language_KeyWord(I)) Then
                    MSG_ABug(1265, "(This is a function(): find in sorted language list() failed to find an existing word", B, "Found at " & I)
                    Return True
                End If
            Next
            If MyDebug(8) Then FMB1(8032)
            Return False
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Test if this is in the inputed keyWord list
        Public Shared Function IsThisA_Function(CodeLine As String) As Boolean ' returns is this is in the keyword list (ignores markers)
            Dim I As Int32
            Dim A, B, D As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3065, 11, "IsThisA_Function")
#End If
            A = CodeLine
            B = A
            B = Trim(Pop1(B, MyUniverse.SysGen.Constants.ConstantWhiteSpaces)) ' to get just one word
            If MyIsNothing(B) Or B = "" Then Return False

            I = FindInSortedLanguageList(MyUniverse.SysGen.Constants.SyntaxFunctions, B, Language_Function)
            If I > ConstantMyErrorCode Then
                If Language_Function(I) = B And B <> "" Then
                    Return True
                Else
                    Return False
                End If
            End If

            'It say's it failed to find it, 
            If I >= LBound(Language_Function) And I <= UBound(Language_Function) Then 'hack
                MSG_ABug(1266, "binary search did not find keyword/operator/function- IsThisA_Fuunction() Searching for " & HighLight(B), " Found " & HighLight(Language_Function(I)), "") 'hack
            End If 'hack

            ' Else we have to search it item by item (and resort it also
            For I = 1 To UBound(Language_Function)
                If LCase(B) = LCase(Language_Function(I)) Then
                    ' This is hear because finInSortedLanguageList() failed.It is there, but did not return it correctly
                    MSG_ABug(1267, "Failed binary search - IsThisA_Fuunction() Searching for " & HighLight(B), " Found " & HighLight(Language_Function(I)), " looking at each item - At " & I.ToString)
                    'hack ************ follow this through if you get here
                    '?I =
                    FindInSortedLanguageList(MyUniverse.SysGen.Constants.SyntaxFunctions, B, Language_Function)
                    Return True
                End If
            Next
            ' no need to test if it is a marker.
            'If IsThISAMarker(CodeLine) <> "" Then Return False
            'todo test this seeing if this is a 'variablename followed by a ( ... )
            D = Pop(A, "(")
            If Len(D) > 1 Then If MyRight(D, 1) = "(" Then D = D.Substring(1, Len(D) - 1)
            If InStr(A, "(") > 1 And InStr(A, ")") > 1 And IsThisAVariableName(D) Then
                Return True
            End If
            Return False
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Test if this is in the inputed operator list
        Public Shared Function IsThisA_Operator(CodeLine As String) As Boolean ' returns is this is in the keyword list (ignores markers)
            Dim I, J As Int32
            Dim A, B As String
            Dim C As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3066, 11, "IsThisA_Operator")
#End If

            A = CodeLine
            B = A
            B = Trim(Pop1(B, MyUniverse.SysGen.Constants.ConstantWhiteSpaces)) ' to get just one word
            If MyIsNothing(B) Or B = "" Then Return False
            ' Hardcoded for now all keyWord I can think of untill I put it in a /Keyword,language,keyWord

            I = FindInSortedLanguageList(MyUniverse.SysGen.Constants.SyntaxOperators, B, Language_Operator)
            If I > ConstantMyErrorCode Then
                'A = Language_Operator(I)
                If Language_Operator(I) = B Then
                    Return True
                End If
            Else
                C = False
                For I = 1 To UBound(Language_Operator)
                    ReSortLanguagekeyWord("LanguageOperator", Language_Operator, I)
                    If LCase(B) = LCase(Language_Operator(I)) Then
                        MSG_ABug(1011, "(This is a Operator(): find in sorted language list() failed to find an existing word", B, "Found at " & I)
                        ReSortLanguagekeyWord("LanguageOperator", Language_Operator, I)
                        J = FindingMyBugsSorted()
                        C = True
                    End If
                    If A = Language_Operator(I) Then C = True
                Next
                If C = True Then Return C
            End If

            ' Else we have to search it item by item (and resort it also
            'todo need to remove this loop after debugging 
            C = False
            If Len(B) > 0 Then
                For I = 1 To UBound(Language_Operator)
                    If LCase(B) = LCase(Language_Operator(I)) Then
                        MSG_ABug(2371, "(This is a Operator(): find in sorted language list() failed to find an existing word", B, "Found at " & I)
                        ReSortLanguagekeyWord("LanguageOperator", Language_Operator, I)
                        C = True
                    End If
                Next
            Else
                Return False
            End If
            If IsThISAMarker(CodeLine) <> "" Then Return False
            Return C ' Not an operator
        End Function

        Public Shared Function EndOfVariableName(A As String) As Int32
            Dim rtn As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3067, 10, "EndOfVariableName")
#End If
            'todo tie all of the isthis... to the BNF input
            rtn = 1
            If Len(A) = 0 Then Return 0 'not the name of a variable
            If IsThisAnAlpha(A) Then
                While rtn < Len(A) And IsThisAnAlphaNumeric(Mid(A, rtn, 1))
                    rtn += 1
                End While
                If rtn = Len(A) Then
                    Return rtn
                Else
                    Return rtn - 1 'cause the last letter is not an alpha
                End If
            End If
            Return 0
        End Function
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Test if imbedded mark for a variable name
        Public Shared Function IsThisAVariableName(InputLine As String) As Boolean
            Dim TS, TE, CodeLine As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3068, 11, "IsThisAVariableName")
#End If
            TS = MyUniverse.SysGen.Constants.RMStart
            TE = MyUniverse.SysGen.Constants.RMEnd
            If Len(InputLine) = 0 Then
                Return False
            End If
            CodeLine = MyTrim(InputLine)

            If MyLeft(CodeLine, Len(TS)) = TS Then
                If MyRight(CodeLine, Len(TE)) = TE Then
                    If InStr(CodeLine, ".") <> 0 Then
                        Return True
                        'todo also check for a valid .pathname, and all of the other possibilities
                        ''SymbolName.name)]}
                        ''{[(SymbolName.name)]}
                        '{[(SymbolName.index)]}
                        '{[(SymbolName.x)]}
                        '{[(SymbolName.y)]}
                        '{[(SymbolName.Rotation)]}
                        '{[(SymbolName.DataType)]}
                        '{[(SymbolName.OpCode)]}
                        '{[(SymbolName.notes)]}
                        '{[(SymbolName.FileName)]}
                        '{[(SymbolName.Author)]}
                        '{[(SymbolName.Version)]}
                        '{[(SymbolName.Stroke)]}
                        '{[(SymbolName.Indexes)]}
                        '{[(SymbolName.name)]}
                        '{[(SymbolName.xa)]}
                        '{[(SymbolName.ya)]}
                        '{[(SymbolName.rotation)]}
                        '{[(SymbolName.code)]}
                        '{[(PointName.name)]}
                        '{[(PointName.index)]}
                        '{[(PointName.name)]}
                        '{[(PointName.x)]}
                        '{[(PointName.y)]}
                        '{[(PointName.IO)]}
                        '{[(PointName.Rotation)]}
                        '{[(PointName.DataType)]}
                        '{[(PointName.PathName)]}
                        '{[(PointName.Variable)]}
                        '{[(PointName.PathX)]}
                        '{[(PointName.pathY)]}
                        '{[(PointName.Distance)]}
                        '{[(PointName.DataTypeName)]}
                        '{[(PointName.DataTypeDescription)]}
                        '{[(PointName.Bytes)]}
                        '{[(PointName.DataTypeColor)]}
                        '{[(PointName.Width)]}
                    End If
                End If
            End If


            'If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxVariables)) = MyUniverse.SysGen.Constants.SyntaxVariables Then
            'Return True
            'End If
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.RMStart)) = MyUniverse.SysGen.Constants.RMStart Then
                If InStr(CodeLine, MyUniverse.SysGen.Constants.RMEnd) <> 0 Then
                    If InStr(CodeLine, ".") < InStr(CodeLine, MyUniverse.SysGen.Constants.RMEnd) Then
                        Return True 'format {[(???.????)]}
                    End If
                End If
            End If
            If IsThISAMarker(CodeLine) <> "" Then
                Return False
            End If

            If IsThisAnAlpha(CodeLine) Then
                Return True
            ElseIf IsThisANumber(CodeLine) Then
                Return True
            End If
            Return False
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'returns the length of the marker (if any)
        ' returns zero if not a marker
        '21/02/2021 changed to return then name instead of the length
        Public Shared Function IsThISAMarker(CodeLine As String) As String ' this returns the length of the marker (Which is always 3, except for one case, and if it changes in the future)
            Dim X As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3069, 11, "IsThISAMarker")
#End If
            If CodeLine = "" Then
                Return ""
            End If
            ' All markers must start with {[(
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.RMStart)) <> MyUniverse.SysGen.Constants.RMStart Then
                Return ""
            End If
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxQuotes)) = MyUniverse.SysGen.Constants.SyntaxQuotes Then Return MyUniverse.SysGen.Constants.SyntaxQuotes
            'todo need to make this also look for {[(name.PATH)]} (or what ever...)
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxNumbers)) = MyUniverse.SysGen.Constants.SyntaxNumbers Then Return MyUniverse.SysGen.Constants.SyntaxNumbers
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxAlphas)) = MyUniverse.SysGen.Constants.SyntaxAlphas Then Return MyUniverse.SysGen.Constants.SyntaxAlphas
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine)) = MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine Then Return MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxCameFromLine)) = MyUniverse.SysGen.Constants.SyntaxCameFromLine Then Return MyUniverse.SysGen.Constants.SyntaxCameFromLine
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxComments)) = MyUniverse.SysGen.Constants.SyntaxComments Then Return MyUniverse.SysGen.Constants.SyntaxComments
            X = MyUniverse.ProgramOptions.FCCL_MultiLine : If MyLeft(CodeLine, Len(X)) = X Then Return X
            X = MyUniverse.ProgramOptions.FCCL_Comment : If MyLeft(CodeLine, Len(X)) = X Then Return X
            X = MyUniverse.ProgramOptions.FCCL_Extensions : If MyLeft(CodeLine, Len(X)) = X Then Return X
            '''''''''''    If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxVariables)) = MyUniverse.SysGen.Constants.SyntaxVariables Then Return MyUniverse.SysGen.Constants.SyntaxVariables
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.RMStart)) = MyUniverse.SysGen.Constants.RMStart Then
                If InStr(CodeLine, MyUniverse.SysGen.Constants.RMEnd) <> 0 Then
                    If InStr(CodeLine, ".") < InStr(CodeLine, MyUniverse.SysGen.Constants.RMEnd) Then
                        Return MyLeft(CodeLine, InStr(CodeLine, MyUniverse.SysGen.Constants.RMEnd)) 'todo removed +2 here 
                    End If
                End If
            End If
            If IsThISAMarker2(CodeLine) <> "" Then Return IsThISAMarker2(CodeLine) ' Returns the length of this marker format Myfd(point.name )
            ' All special characters are after language special characters
            If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.SyntaxSpecialCharacters)) = MyUniverse.SysGen.Constants.SyntaxSpecialCharacters Then Return MyUniverse.SysGen.Constants.SyntaxSpecialCharacters

            Return IsThISAMarker2(CodeLine) ' Not a marker but might still be one of this kind
        End Function



        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This will return the variable if in the form variable.variable 
        'This has not be verified to work
        '02/21/2021 THis return s the marker now
        Public Shared Function IsThISAMarker2(CodeLine As String) As String ' this will return the variable if in formation [variable.option]
            Dim X, VariableName, PartName As String
            Dim M1, M2, M3, M4 As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3070, 10, "IsThISAMarker2")
#End If
            X = CodeLine
            If MyLeft(X, Len(MyUniverse.SysGen.Constants.RMStart)) = MyUniverse.SysGen.Constants.RMStart Then
                M1 = 1
                M2 = InStr(CodeLine, ".")
                M3 = InStr(CodeLine, MyUniverse.SysGen.Constants.RMEnd)
                M4 = Len(CodeLine)
                If M4 < M3 Then Return ""
                If M3 < M2 Then Return ""
                If M2 < M1 Then Return ""
                If M3 <> 0 And M2 - Len(MyUniverse.SysGen.Constants.RMStart) = 1 Then Return ""
                VariableName = Mid(CodeLine, 4, M2 - 4)
                PartName = Mid(CodeLine, M2 + 1, M3 - M2 - 1)

                If IsThisAVariableName(VariableName) Then
                    If IsThisAPointAttribute(PartName) <> "" Then
                        Return AddRM(VariableName & "." & PartName)
                    Else
                        If MyDebug(9) Then follow(2161, "xxx This is a variable name with not attribute name " & VariableName)
                    End If
                End If
                If Len(VariableName) = 0 Then
                    If Len(PartName) <> 0 Then
                        MSG_AInfo1(1269, "No Variable Name", Mid(X, 1, Len(PartName) + 7), " for attribute " & PartName)
                        Return "" 'Mid(X, 1, Len(PartName) + 7)' unknown marker with only part name 
                    End If
                End If
            Else 'it does not start with a RMStart
                Return ""
            End If
            MSG_ABug(1270, "This starts with a marker but NOT known", CodeLine, "")
            Return ""
        End Function

        Public Shared Function IsThisAPointAttribute(CodeLine As String) As String
            'todo need to document these {[(name.PointAttribute)]}
#If MINEDEBUG Then
  if mydebug(9) then follow(3071, 10, "IsThisAPointAttribute")
#End If
            Select Case LCase(CodeLine)
                Case "author"
                    Return CodeLine
                Case "bytes"
                    Return CodeLine
                Case "DataType"
                    Return CodeLine
                Case "DataTypename"
                    Return CodeLine
                Case "DataTypeDescription"
                    Return CodeLine
                Case "DataTypecolor"
                    Return CodeLine
                Case "distance"
                    Return CodeLine
                Case "filename"
                    Return CodeLine
                Case "index"
                    Return CodeLine
                Case "indexes"
                    Return CodeLine
                Case "io"
                    Return CodeLine
                Case "name", "variable"
                    Return CodeLine
                Case "notes"
                    Return CodeLine
                Case "opcode"
                    Return CodeLine
                Case "rotation"
                    Return CodeLine
                Case "stroke"
                    Return CodeLine
                Case "version"
                    Return CodeLine
                Case "xa"
                    Return CodeLine
                Case "x"
                    Return CodeLine
                Case "ya"
                    Return CodeLine
                Case "y"
                    Return CodeLine
                Case "pathname"
                    Return CodeLine
    'Case MyUniverse.SysGen.Constants.SyntaxVariables
    'Return CodeLine
                Case "path"
                    Return CodeLine
                Case "pathX"
                    Return CodeLine
                Case "pathY"
                    Return CodeLine
                Case "width"
                    Return CodeLine
                Case Else
                    Return ""
            End Select
            Return ""
        End Function


        Public Shared Function FindMyGrammarName(Grammar_Name As String) As String
            Dim IndexGrammar As Int32
            Dim s, t As String
            Static LastName As String = "??????" ' to make sure that it is not finding nothing
            Static LastIndex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3072, 10, "FindMyGrammarName " & Grammar_Name)
#End If
            'if mydebug(9) then follow(2831, 10, "Searching for Grammar " & HighLight(Grammar_Name))
            If Len(Grammar_Name) = 0 Then Return ""
            If Grammar_Name = LastName Then
                Return Language_Grammar(LastIndex)
            End If
            t = Grammar_Name
            If InStr(t, "::=") <> 0 Then
                t = Trim(Mid(t, 1, InStr(t & "::=", "::=") - 1))
            End If
            If MyRight(t, 1) = "?" Then t = Mid(t, 1, Len(t) - 1)
            If MyRight(t, 1) = "*" Then t = Mid(t, 1, Len(t) - 1)
            If MyRight(t, 1) = "+" Then t = Mid(t, 1, Len(t) - 1)
            If MyRight(t, 1) = "-" Then t = Mid(t, 1, Len(t) - 1)


            For IndexGrammar = LBound(Language_Grammar) To UBound(Language_Grammar)
                s = Language_Grammar(IndexGrammar)
                s = Pop(s, MyUniverse.SysGen.Constants.ConstantDelimiters)
                If s = t Then
                    LastName = Grammar_Name
                    LastIndex = IndexGrammar
                    Return Language_Grammar(IndexGrammar)
                End If
            Next
            Return ""
        End Function 'finding my Grammar



        'Routine This returns and removes till a carriage return or Line Feed
        Public Shared Function PopLine(ByRef A As String) As String ' Return up to the first CRLF, CR or LF
            Dim B As String
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3073, 10, "PopLine")
#End If
            While MyLeft(A, 1) = vbCrLf Or MyLeft(A, 1) = vbCr Or MyLeft(A, 1) = vbLf
                A = Mid(A, 2, Len(A))
            End While

            I = InStr(A, vbCrLf)
            If I > 3 Then
                PopLine = Mid(A, 1, I)
                A = Mid(A, I, Len(A))
                Return PopLine
            End If

            PopLine = MyLeft(A, 1)
            A = Mid(A, 2)
            B = MyLeft(A & Chr(10), 1)
            While Len(A) >= 1 And B <> vbCr And B <> vbCrLf And B <> vbLf 'B > Chr(16) And '
                PopLine &= MyLeft(A, 1)
                A = Mid(A, 2)
                B = MyLeft(A & Chr(10), 1)
            End While
        End Function

        Public Shared Function S2N(A As String) As Int32
            Dim X As String
            X = MyLeft(A, 1)
            Select Case A
                Case "0" : Return 0
                Case "1" : Return 1
                Case "2" : Return 2
                Case "3" : Return 3
                Case "4" : Return 4
                Case "5" : Return 5
                Case "6" : Return 6
                Case "7" : Return 7
                Case "8" : Return 8
                Case "9" : Return 9
                Case Else
                    MSG_ABug(1271, "Trying to make a number from :", X, A)
            End Select
            Return ConstantMyErrorCode
        End Function

        Public Shared Function My_INT(Text As String) As Int32 ' Cint() ignore all first ,'s.
            Dim Sign As Int32
            Dim Temp As String
            Temp = Text
            If MyLeft(Temp, Len(FD)) = FD Then
                Temp = Mid(Temp, Len(FD), Len(Temp))
            End If
            Sign = 1
            My_INT = 0
            While Len(Temp) > 0
                Select Case MyLeft(Temp, 1)
                    Case "-"
                        Sign = -1
                    Case "9"
                        My_INT = My_INT * 10 + 9
                    Case "8"
                        My_INT = My_INT * 10 + 8
                    Case "7"
                        My_INT = My_INT * 10 + 7
                    Case "6"
                        My_INT = My_INT * 10 + 6
                    Case "5"
                        My_INT = My_INT * 10 + 5
                    Case "4"
                        My_INT = My_INT * 10 + 4
                    Case "3"
                        My_INT = My_INT * 10 + 3
                    Case "2"
                        My_INT = My_INT * 10 + 2
                    Case "1"
                        My_INT = My_INT * 10 + 1
                    Case "0"
                        My_INT = My_INT * 10 + 0
                    Case FD
                        Exit Function
                    Case Else
                        MSG_ABug(1272, "never happen ", CStr(My_INT), Text)
                        My_INT = My_INT 'This should never happen 
                End Select
                Temp = Mid(Temp, 2, Len(Temp))
            End While
            My_INT *= Sign
        End Function


        Public Shared Function PopNonZeroValue(ByRef B As String) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3074, 10, "PopNonZeroValue")
#End If
            PopNonZeroValue = 0
            While Len(B) > 0 And PopNonZeroValue = 0
                PopNonZeroValue = PopValue(B)
            End While
        End Function


        Public Shared Function MyPathTextValues2Line(IndexFlowChart As Int32, ByRef S As String) As MyLineStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3075, 10, "MyPathTextValues2Line")
#End If
            MyPathTextValues2Line = Nothing
            MyPathTextValues2Line.a.Named.PathName = FlowChart_Table_Path_SymbolName(IndexFlowChart)
            MyPathTextValues2Line.a.x = PopValue(S)
            MyPathTextValues2Line.a.y = PopValue(S)
            MyPathTextValues2Line.b.x = PopValue(S)
            MyPathTextValues2Line.b.y = PopValue(S)
            MyPathSnap(MyPathTextValues2Line, MyPathTextValues2Line)
            FlowChart_TableX1(IndexFlowChart, MyPathTextValues2Line.a.x)
            FlowChart_TableY1(IndexFlowChart, MyPathTextValues2Line.a.y)
            FlowChart_TableX2(IndexFlowChart, MyPathTextValues2Line.b.x)
            FlowChart_TableY2(IndexFlowChart, MyPathTextValues2Line.b.y)

            FMB_IsXY(FlowChart_FileX1(IndexFlowChart), FlowChart_FileY1(IndexFlowChart), FlowChart_File_X2_Rotation(IndexFlowChart), FlowChart_File_Y2_Option(IndexFlowChart))

        End Function



        Public Shared Function MyUseTextValues2Line(IndexFlowChart As Int32, ByRef S As String) As MyLineStructure
            MyUseTextValues2Line = Nothing
            MyUseTextValues2Line.a = Nothing
            MyUseTextValues2Line.a.x = PopValue(S)
            MyUseTextValues2Line.a.y = PopValue(S)
            MyUseTextValues2Line.a = MySymbolSnap(MyUseTextValues2Line.a)
            FlowChart_TableX1(IndexFlowChart, MyUseTextValues2Line.a.x)
            FlowChart_TableY1(IndexFlowChart, MyUseTextValues2Line.a.y)
        End Function



        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Routine This returns and removes all numbers before 'white' space
        Public Shared Function PopValueY(ByRef NumberAsString As String) As Int32 ' Returns a number from the string My_Int() & Value()
            Dim Xstring As String
            Dim Ystring As String
            Dim Sign, Multiplyer As Integer
#If MINEDEBUG Then
  if mydebug(9) then follow(3076, 10, "PopValueY")
#End If
            Sign = 1 ' final sign of the number
            Multiplyer = 10 ' stops when there is a period .
            PopValueY = 0
            NumberAsString = MyTrim(NumberAsString)
            Xstring = ""
            Ystring = " "
            ' This needs to be changed so that we find where the trim is, and then move the string only once, because this way is VERY slow.
            While (Ystring >= "0" And Ystring <= "9") Or Ystring = " " Or Ystring = "-"
                Xstring &= Ystring
                Select Case Ystring
                    Case "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"
                        PopValueY = PopValueY * Multiplyer + S2N(Ystring)
                    Case "."
                        Multiplyer = 1
                    Case "-"
                        Sign = -1
                End Select
                Ystring = MyLeft(NumberAsString, 1)
                If Len(NumberAsString) > 0 Then NumberAsString = Mid(NumberAsString, 2, Len(NumberAsString))
            End While
            'flow10'Change to get the value character by character 
            PopValueY *= Sign ' My_Int(Trim(Xstring) & ".0")
            Return PopValueY
        End Function



        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Routine This returns and removes all numbers before 'white' space
        Public Shared Function PopValue(ByRef NumberAsString As String) As Int32 ' Returns a number from the string My_Int() & Value()
            Dim Xstring As String
            Dim Ystring As String
            Dim Sign, Multiplyer As Integer
#If MINEDEBUG Then
  if mydebug(9) then follow(3077, 10, "PopValue")
#End If
            Sign = 1 ' final sign of the number
            Multiplyer = 10 ' stops when there is a period .
            PopValue = 0
            NumberAsString = MyTrim(NumberAsString)
            Xstring = ""
            Ystring = " "
            ' This needs to be changed so that we find where the trim is, and then move the string only once, because this way is VERY slow.
            While (Ystring >= "0" And Ystring <= "9") Or Ystring = " " Or Ystring = "-"
                Xstring &= Ystring
                Select Case Ystring
                    Case "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"
                        PopValue = PopValue * Multiplyer + S2N(Ystring)
                    Case "."
                        Multiplyer = 1
                    Case "-"
                        Sign = -1
                End Select
                Ystring = MyLeft(NumberAsString, 1)
                If Len(NumberAsString) > 0 Then NumberAsString = Mid(NumberAsString, 2, Len(NumberAsString))
            End While
            'flow10'Change to get the value character by character 
            PopValue *= Sign ' My_Int(Trim(Xstring) & ".0")
        End Function

        Public Shared Function MyFormName(Formed As String) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3078, 10, "MyFormName")
#End If
            Select Case LCase(Formed)
    ' If a Window name Then Window name Return the Window form name
                Case "FlowChartwindow"
                    Return FlowChartWindow.Name
                Case "Symbolwindow", "toolstripSymboltop", "toolstripSymbolbottom"
                    Return SymbolWindow.Name
                Case "optionswindow"
                    Return OptionsWindow.Name
                Case ""
                    Return FileInputOutputWindow.Name
    'If a tool strip then return the form that owns this tool strip (Yes, I should pass the control, and then return the parent of the parent, but it never worked.
                Case "toolstripFlowChart"
                    'todo return the name of the owner Also rename one of the too
                    'todo rename all of the toolstrips 1-
                    Return FlowChartWindow.Name
                Case "toolstripoption"
                    Return OptionsWindow.Name
                Case Else
                    Return ""
            End Select
            Return "" ' does not ever get here.
        End Function


        Public Shared Function FindInDropDownButton(ItemName As String, TSDD As ToolStripDropDownButton) As Int32
            Dim I As Int32
            Dim Temp As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3079, 10, "FindInDropDownButton")
#End If
            If MyDebug(10) Then follow(2832, 10, "seach for  " & ItemName & " in " & TSDD.Name)
            For I = 0 To TSDD.DropDownItems.Count - 1
                Temp = TSDD.DropDownItems(I).Text
                If ItemName = Pop(Temp, FD) Then Return I
            Next
            Return ConstantMyErrorCode
        End Function



        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Returns the whole list of this record
        Public Shared Function MyUnEnum(Number As Int32, MyComboBox As ToolStripDropDownButton, ItemNumberOffset As Int32) As String
            Dim I As Int32, Temp As String
            Dim Count As Int32
            ReDim Preserve MyUniverse.MyStaticData.MyUnEnum.LastResults(20)
            Dim PaRnt As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3080, 10, "MyUnEnum")
#End If
            Count = MyComboBox.DropDownItems.Count
            MyUnEnum = ""

            PaRnt = MyComboBox.GetCurrentParent.Name
            PaRnt = MyFormName(PaRnt)
            If Number = ConstantMyErrorCode Then
                MSG_ABug(1277, PaRnt & " : " & " index is invalid index into the ComboBox" & MyComboBox.Name, " #" & Number, "look for #" & ItemNumberOffset)
                MyUnEnum = ""
                Exit Function
            End If
            ' Test if this is a number and not a Indexes to the ComboBox
            If Number > Count - 1 Then
                MSG_AInfo(1278, "The index is bigger than the ComboBox list in " & MyComboBox.Name & " at " & Number, " number in the ComboBox " & MyComboBox.DropDownItems.Count, " Get number " & Number & vbTab & "So this be an X value")
                MyUnEnum = CStr(Number)
                Exit Function
            End If
            Temp = MyComboBox.DropDownItems.Item(MyMinMax(Number, 0, Count - 1)).ToString ' Should this allow ComboBox.items(0)?

            If MyComboBox.Name = MyUniverse.MyStaticData.MyUnEnum.LastComboBox Then
                If Temp = MyUniverse.MyStaticData.MyUnEnum.LastUnEnum Then
                    If MyUniverse.MyStaticData.MyUnEnum.LastResults(ItemNumberOffset) <> Nothing Then
                        MyUnEnum = MyUniverse.MyStaticData.MyUnEnum.LastResults(ItemNumberOffset)
                        Exit Function
                    End If
                End If
            Else
                ReDim MyUniverse.MyStaticData.MyUnEnum.LastResults(20) ' get rid of everything
            End If

            MyUniverse.MyStaticData.MyUnEnum.LastComboBox = MyComboBox.Name
            MyUniverse.MyStaticData.MyUnEnum.LastUnEnum = Temp
            For I = 0 To ItemNumberOffset
                Temp = Trim(Temp)
                MyUnEnum = Pop(Temp, FD)
                MyUniverse.MyStaticData.MyUnEnum.LastResults(I) = MyUnEnum
            Next I
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'converts from a number into the cap start/end type
        'This is erroring out, and not reutnr a valid type of data for this
        Public Shared Function MyCapCode(ANumber As Int32) As Drawing2D.LineCap
            Select Case ANumber
                Case 1
                    Return Drawing2D.LineCap.AnchorMask
                Case 2
                    Return Drawing2D.LineCap.ArrowAnchor
                Case 3
                    Return Drawing2D.LineCap.DiamondAnchor
                Case 4
                    Return Drawing2D.LineCap.Flat
                Case 5
                    Return Drawing2D.LineCap.NoAnchor
                Case 6
                    Return Drawing2D.LineCap.Round
                Case 7
                    Return Drawing2D.LineCap.RoundAnchor
                Case 8
                    Return Drawing2D.LineCap.Square
                Case 9
                    Return Drawing2D.LineCap.SquareAnchor
                Case 10
                    Return Drawing2D.LineCap.Triangle
                Case Else
                    Return Drawing2D.LineCap.AnchorMask 'if cant / DoNot know what it is 
            End Select
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Returns the number of the first item in this number

        Public Shared Function MyEnumValue(Whatstring As String, MyComboBox As ToolStripDropDownButton) As Int32
            Dim I As Int32, Low, LocalIndex, Jdex, Kdex, ErrorKounter As Int32
            Dim SearchingFor As String
            Dim Count As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3081, 10, "MyEnumValue")
#End If
            If MyDebug(11) Then follow(2655, 11, " Searching for " & SHL(Whatstring) & vbTab & vbTab & " In " & MyComboBox.Name & FD & MyComboBox.GetCurrentParent.Name)
            If MyUniverse.MyStaticData.MyEnum.LastComboBox = MyComboBox.Name Then ' same as last 
                If MyUniverse.MyStaticData.MyEnum.LastWhatString = Whatstring Then
                    Return MyUniverse.MyStaticData.MyEnum.Last_Enum ' return shortcut
                End If
            End If


            Count = MyComboBox.DropDownItems.Count
            If Count < 1 Then Return 0
            Low = 0
            SearchingFor = MyTrim(Whatstring)
            If Len(SearchingFor) < 1 Then
                'MSG_ABug(1281, "MyEnumValue():" & HighLight(MyComboBox.Name), ":Can not find an empty String in the list ","")
                MyUniverse.MyStaticData.MyEnum.LastComboBox = MyComboBox.Name
                MyUniverse.MyStaticData.MyEnum.LastWhatString = Whatstring
                MyUniverse.MyStaticData.MyEnum.Last_Enum = ConstantMyErrorCode
                MyEnumValue = ConstantMyErrorCode
                Exit Function
            End If

            'Lets try a binary search first
            Kdex = Count - 1
            LocalIndex = MyMinMax(CInt(Kdex / 2), Low, Kdex)
            Jdex = MyMinMax(CInt(LocalIndex / 2), Low, Kdex)
            ErrorKounter = -(Count + 8) ' Try to find it eight times to many
            'Temp = MyComboBox.Items.Item(LocalIndex).ToString 'hack
            'Temp = Trim(Pop(MyComboBox.Items.Item(LocalIndex).ToString, myuniverse.SysGen.Constants.ConstantDelimiters)) 'hack
            I = MyCompared1_a(SearchingFor, Trim(Pop(MyComboBox.DropDownItems.Item(LocalIndex).Text, MyUniverse.SysGen.Constants.ConstantDelimiters)))

            If MyDebug(11) Then follow(2656, 11, I.ToString & FD & " Searching for " & SearchingFor & FD & " at " & LocalIndex.ToString & MyComboBox.DropDownItems.Item(LocalIndex).Text & vbTab & MyComboBox.DropDownItems.Item(LocalIndex).ToString)
            While I <> 0
                ErrorKounter += 1
                If ErrorKounter + 2 > Count Then
                    ' Not found and searched almost for ever.
                    MyUniverse.MyStaticData.MyEnum.LastComboBox = MyComboBox.Name
                    MyUniverse.MyStaticData.MyEnum.LastWhatString = Whatstring
                    MyUniverse.MyStaticData.MyEnum.Last_Enum = Nothing
                    'MyEnumValue = Nothing
                    GoTo FailedBinarySearch
                End If
                'if mydebug(9) then follow(2657, 9, I.ToString & FD & " Searching for " & SearchingFor & FD & " at " & LocalIndex.ToString & FD & MyComboBox.DropDownItems.Item(LocalIndex).Text & vbTab & MyComboBox.DropDownItems.Item(LocalIndex).ToString)
                If I < 0 Then
                    LocalIndex = MyMinMax(LocalIndex - Jdex, Low, Kdex)
                Else
                    LocalIndex = MyMinMax(LocalIndex + Jdex, Low, Kdex)
                End If
                Jdex = MyMinMax(CInt(Jdex / 2), 1, Kdex)

                'if mydebug(9) then follow(2660, 0, "A" & MyComboBox.Name & vbCrLf & "  " & LocalIndex.ToString & FD & MyComboBox.DropDownItems(LocalIndex).Text & vbCrLf) 'todo remove this
                'if mydebug(9) then follow(2659, 0, "b " & Jdex.ToString & FD & Trim(Pop(MyTrim(MyComboBox.DropDownItems(Jdex).Text), MyUniverse.SysGen.Constants.ConstantDelimiters)) & vbCrLf) 'todo remove this and debug1
                'if mydebug(9) then follow(2658, 0, "c " & LocalIndex.ToString & FD & Trim(Pop(MyTrim(MyComboBox.DropDownItems(LocalIndex).Text), MyUniverse.SysGen.Constants.ConstantDelimiters)) & vbCrLf)
                I = MyCompared1_a(SearchingFor, Pop(Trim(MyComboBox.DropDownItems.Item(LocalIndex).ToString), MyUniverse.SysGen.Constants.ConstantDelimiters))
                'if mydebug(9) then follow(2661, 9, I.ToString & FD & " Searching for " & SearchingFor & FD & " at " & LocalIndex.ToString & MyComboBox.DropDownItems.Item(LocalIndex).Text & vbTab & MyComboBox.DropDownItems.Item(LocalIndex).ToString)

            End While
            If MyDebug(11) Then follow(2662, 11, " LastComboBox name = " & MyUniverse.MyStaticData.MyEnum.LastComboBox & "  Current Combo Box name = " & MyComboBox.Name)
            MyUniverse.MyStaticData.MyEnum.LastComboBox = MyComboBox.Name
            MyUniverse.MyStaticData.MyEnum.LastWhatString = Whatstring
            MyUniverse.MyStaticData.MyEnum.Last_Enum = LocalIndex
            MyEnumValue = LocalIndex
            Exit Function
            ' The above should replace the below, but should add an escape incase it's not in the List to avoid a forever loop
FailedBinarySearch:
            SearchingFor = MyTrim(Whatstring)
            If SearchingFor = "" Or SearchingFor = MyUniverse.ProgramOptions.FCCL_WhiteSpace Then
                'MSG_ABug(1282, "MyEnumValue", 0, 2)
                MyUniverse.MyStaticData.MyEnum.LastComboBox = MyComboBox.Name
                MyUniverse.MyStaticData.MyEnum.LastWhatString = Whatstring
                MyUniverse.MyStaticData.MyEnum.Last_Enum = ConstantMyErrorCode
                MyEnumValue = ConstantMyErrorCode
                Exit Function
            End If
            MyUniverse.MyStaticData.MyEnum.LastComboBox = MyComboBox.Name
            MyUniverse.MyStaticData.MyEnum.LastWhatString = Whatstring
            MyUniverse.MyStaticData.MyEnum.Last_Enum = Nothing
            MyEnumValue = Nothing
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'swaps the array (assumed no key
        Public Shared Sub MySwap(MyTable As String, MyArray() As Int32, A As Int32, B As Int32) ' Swap the two numbers
            Dim Temp As Int32
#If MINEDEBUG Then
            if mydebug(10) then  follow(2385, MyTable & " Swap = " & MyArray(A) & FD & MyArray(B))
#End If
            Temp = MyArray(A)
            MyArray(A) = MyArray(B)
            MyArray(B) = Temp
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'swap the two numbers 
        ' It looks lik it does not return the swapped values?
        ' Why is A & B not by REF ?
        '        Public Shared Sub MySwap_NotUsed(MyTable As String, A As Int32, B As Int32) ' Swap the two numbers
        'todo is this nessary '''    Dim Temp As Int32
        'todo is this nessary '''    Temp = A
        'todo is this nessary '''A = B
        'todo is this nessary '''B = Temp
        '    End Sub



        'Routine  changes places between two string locations in an MyArray
        Public Shared Sub MySwap(MyTable As String, ByRef MyArray() As String, A As Int32, B As Int32) ' Swap the two items in the myArray
            Dim TempA As String
#If MINEDEBUG Then
            if mydebug(5) then  follow(2386, MyTable & " Swap = " & MyArray(A) & FD & MyArray(B))
#End If
            TempA = MyArray(A)
            MyArray(A) = MyArray(B)
            MyArray(B) = TempA
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' Swaps the two places of the keyWord array (Sorting them to keep them in order, should look into an insert sort method)
        Public Shared Sub MySwapLanguagekeyWord(MyTable As String, ByRef MyArray() As String, A As Int32, B As Int32)
            Dim T As String

            If A < 0 Then Return
            If B < 0 Then Return
            If A > UBound(MyArray) Then Return
            If B > UBound(MyArray) Then Return
            If MyDebug(9) Then follow(2387, MyTable & " Swapped = " & MyArray(A) & FD & MyArray(B))
            If MyArray(A) = MyArray(B) Then
                If MyDebug(7) Then follow(2164, "duplicate keywords " & MyArray(A) & FD & MyArray(B))
            End If
            'if mydebug(9) then follow(2164, "swap keyword " & MyArray(A) & "    WITH    " & MyArray(B))

            T = MyArray(A)
            MyArray(A) = MyArray(B)
            MyArray(B) = T
            If MyArray(A) = MyArray(B) Then
                If MyDebug(10) Then follow(2164, "duplicate keywords " & MyArray(A) & FD & MyArray(B))
                MyArray(B) = MyConstantIgnoreFunctionOperatorKeyWord & MyRnd()
            End If
#If MINEDEBUG Then
  if mydebug(9) then follow(3082, 10, "MySwapLanguageKeyWord" & vbTab & MyArray(A) & vbTab & MyArray(B))
#End If
        End Sub

        Public Shared Sub MySwapBytes(MyTable As String, MyArray() As Byte, A As Int32, B As Int32)
            Dim TempA As Byte
            Dim TempB As Byte
#If MINEDEBUG Then
  if mydebug(9) then follow(3083, 10, "MySwapBytes")
#End If
            'Should have an error message out here.and not swap anything (better yet, test it before it gets here)
            If MyMinMax(A, 1, UBound(MyArray) - 1) <> A Then Return 'todo need to add ABug 
            If MyMinMax(B, 1, UBound(MyArray) - 1) <> B Then Return
            If MyDebug(7) Then Follow(2388, "Table = " & MyTable & " #'s" & A.ToString & FD & B.ToString & " Swapping = " & MyArray(A) & " with " & MyArray(B))
            TempB = MyArray(B)
            TempA = MyArray(A)
            MyArray(A) = TempB
            MyArray(B) = TempA
        End Sub

        Public Shared Sub MySwapNn(MyTable As String, MyArrayLong() As Int32, ISAM() As Int32, A As Int32, B As Int32)
            Dim TempA As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3084, 10, "MySwapNn")
#End If
            If ISAM(A) = 0 Or ISAM(B) = 0 Then
                If MyDebug(9) Then follow(2389, "Error in swapping index " & A.ToString & FD & ISAM(A) & " <-->  " & B.ToString & FD & ISAM(B).ToString)
                Return
            End If
            If MyDebug(7) Then follow(2390, MyTable & " Swap = " & MyArrayLong(A).ToString & FD & MyArrayLong(B).ToString & ":::")
            TempA = ISAM(A)
            ISAM(A) = ISAM(B)
            ISAM(B) = TempA
        End Sub

        'Routine changes places between two number locations in a number MyArray
        Public Shared Sub MySwapN(MyTable As String, ByRef MyArray() As String, ByRef ISAM() As Int32, A As Int32, B As Int32)
            Dim TempA As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3085, 10, "MySwapN")
#End If
            ' Just to make sure that it is always valid
            If MyMinMax(A, 1, UBound(ISAM) - 1) <> A Then
                MSG_ABug(1289, "Index outside of array 1,", A.ToString, (UBound(ISAM) - 1).ToString)
                Return
            End If
            If MyMinMax(B, 1, UBound(ISAM) - 1) <> B Then
                MSG_ABug(1290, "Index outside of array 1,", B.ToString, (UBound(ISAM) - 1).ToString)
                Return
            End If
            If MyDebug(9) Then Follow(2391, MyTable & " Swap = " & MyArray(A) & FD & MyArray(B))
            TempA = ISAM(A)
            ISAM(A) = ISAM(B)
            ISAM(B) = TempA
        End Sub

        Public Shared Sub ReSortSymbolList() ' Used only in DeCompileLine
            Dim I, IndexSymbol As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3086, 10, "ReSortSymbolList")
#End If
            FMB(5044)
            For IndexSymbol = 2 To TopOfFile("Symbol")
                I = IndexSymbol
                While Symbol_FileCoded(I) = MyKeyword_2_Byte("/name") ' Moving /name to the top of the list
                    While Symbol_FileSymbolName(I - 1) = Symbol_FileSymbolName(I) ' A point name is before the Symbol name
                        ' Should never get here, if we do its a program bug
                        MySwapSymbolList(IndexSymbol, IndexSymbol + 1)
                        'FindingMyBugs(100) 'hack Least amount of checking here 'hack 2020 08 04
                        I -= 1
                    End While
                    I -= 1
                End While
                I = IndexSymbol
                While Symbol_FileCoded(I) = MyKeyword_2_Byte("/name") And Symbol_FileCoded(I - 1) = MyKeyword_2_Byte("/name") And Symbol_FileSymbolName(I - 1) = Symbol_FileSymbolName(I)
                    MySwapSymbolList(IndexSymbol, IndexSymbol + 1)
                    FindingMyBugs(100) 'hack Least amount of checking here 'hack 2020 08 04
                    I -= 1
                End While
                'FindingMyBugs(10) 'hack Least amount of checking here 'hack 2020 08 04
            Next
            'FindingMyBugs(10) 'hack Least amount of checking here 'hack 2020 08 04
            FMB(5045)
        End Sub



        'Routine swaps in all Symbol MyArrays two locations
        Public Shared Sub MySwapSymbolList(A As Int32, B As Int32) ' With one higher ' inserting records in a non-index-file
            Dim Temp As MyNumberOrString
#If MINEDEBUG Then
  if mydebug(9) then follow(3087, 10, "MySwapSymbolList")
#End If
            Const MyTable As String = "Symbol"
            If MyDebug(11) Then follow(2834, 11, "Swap Symbol " & A.ToString & " with " & B.ToString)
            MyMakeArraySizesBigger()
            FMB(5046)
            If InvalidIndex(A, Symbol_FileSymbolName) Or InvalidIndex(B, Symbol_FileSymbolName) Then
                Return
            End If
            If Symbol_TableCoded_String(A) = "/unknown" And Symbol_TableCoded_String(B) = "/unknown" Then
                'DoNot bother to swap two invalid
                'todo need to make this an info() or IGNORE
                'MSG_MyTrace1(1294, "An error?  ====> it is not swapping two unknown Symbol graphic records." & vbCrLf & MyShowSymbolRecords(True, A) & vbCrLf & MyShowSymbolRecords(True, B))
                Return
            End If
#If MINEDEBUG Then
            if mydebug(8) then  follow(2400, 8, MyTable & "Swaping =" & A.ToString & FD & Symbol_FileCoded(A).ToString & FD & B.ToString & Symbol_FileCoded(B).ToString)
            if mydebug(8) then  follow(2401,  MyTable & " Swaping =" & Symbol_File_NameOfPoint(A) & FD & Symbol_File_NameOfPoint(B))
            if mydebug(8) then  follow(2402,  MyTable & " Swaping =" & Symbol_FileX1(A).ToString & FD & Symbol_FileX1(B).ToString)
            if mydebug(8) then  follow(2403,  MyTable & " Swaping =" & Symbol_FileX2_io(A).MyNumber.ToString & FD & Symbol_FileX2_io(B).MyNumber.ToString)
            if mydebug(8) then  follow(2404,  MyTable & " Swaping =" & Symbol_FileX2_io(A).MyString & FD & Symbol_FileX2_io(B).MyString)
            if mydebug(8) then  follow(2405,  MyTable & " Swaping =" & Symbol_FileY1(A).ToString & FD & Symbol_FileY1(B).ToString)
            if mydebug(8) then  follow(2406,  MyTable & " Swaping =" & Symbol_FileY2_dt(A).MyNumber.ToString & FD & Symbol_FileY2_dt(B).MyNumber.ToString)
            if mydebug(8) then  follow(2407,  MyTable & " Swaping =" & Symbol_FileY2_dt(A).MyString & FD & Symbol_FileY2_dt(B).MyString)
            FMB(5047)
#End If
            MySwapBytes(MyTable & " Symbol", Symbol_FileCoded, A, B)
            MySwap(MyTable & " Symbol", Symbol_File_NameOfPoint, A, B)
            MySwap(MyTable & " Symbol", Symbol_FileSymbolName, A, B)
            MySwap(MyTable & " Symbol", Symbol_FileX1, A, B)
            MySwap(MyTable & " Symbol", Symbol_FileY1, A, B)
            FMB(5048)


            Temp = Symbol_FileX2_io(A)
            Symbol_FileX2_io(A) = Symbol_FileX2_io(B)
            Symbol_FileX2_io(B) = Temp
            Temp = Symbol_FileY2_dt(A)
            Symbol_FileY2_dt(A) = Symbol_FileY2_dt(B)
            Symbol_FileY2_dt(B) = Temp
            'MySwap("Symbol", Symbol_FileX2_io, A, B)
            'MySwap("Symbol", Symbol_FileY2_dt, A, B)
            'FindingMyBugs(20) 'hack Least amount of checking here 'hack
        End Sub



        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Routine returns from 'real' world to Window scale
        Public Shared Function ScaledSize(MyNumber As Int32) As Int32 'single
            LimitScale()
            ScaledSize = CInt(MyNumber * MyUniverse.SysGen.MyFlowChartScale)
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'invalid use point/path/Symbol snap
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Move the point to the grid
        Public Shared Function MyLineSnap(XY As Int32) As Int32
            If mydebug(9) Then follow(2835, 10, "Snap line " & XY.ToString)
            Return CInt(XY / MyUniverse.SysGen.Snaps.MySnap) * MyUniverse.SysGen.Snaps.MySnap
        End Function

        Public Shared Function MyLineXY(A As MyPointStructure, B As MyPointStructure) As MyLineStructure
            MyLineXY = Nothing
            MyLineXY.a.x = A.x
            MyLineXY.a.y = A.y
            MyLineXY.b.x = B.x
            MyLineXY.b.y = B.y
        End Function


        Public Shared Sub MyPathSnap(ByRef ReturnedXY As MyLineStructure, XY As MyLineStructure) 'As MyLineStructure
            'todo XY.a.Named.PathName = XY.a.Named.PathName
            If MyUniverse.SysGen.Snaps.MyPointSnap = 0 Then
                ReturnedXY = XY
                Return
            End If
            ReturnedXY.a.x = CInt(XY.a.x / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
            ReturnedXY.a.y = CInt(XY.a.y / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
            ReturnedXY.b.x = CInt(XY.b.x / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
            ReturnedXY.b.y = CInt(XY.b.y / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
        End Sub



        Public Shared Function MyPointSnap(XY As MyPointStructure) As MyPointStructure
            MyPointSnap = Nothing
            XY.Named.PointName = XY.Named.PointName 'incase it is a path, or a point get them both, and leave the symb name null
            XY.Named.PathName = XY.Named.PathName
            MyPointSnap.x = CInt(XY.x / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
            MyPointSnap.y = CInt(XY.y / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
        End Function
        Public Shared Function MySymbolSnap(XY As MyPointStructure) As MyPointStructure
            MySymbolSnap = Nothing
            MySymbolSnap.x = CInt(XY.x / MyUniverse.SysGen.Snaps.MySymbolSnap) * MyUniverse.SysGen.Snaps.MySymbolSnap
            MySymbolSnap.y = CInt(XY.y / MyUniverse.SysGen.Snaps.MySymbolSnap) * MyUniverse.SysGen.Snaps.MySymbolSnap
        End Function

        Public Shared Function MakePathOrthogonal(IndexFlowChart As Int32) As Boolean ' returns if changed the line
            Dim DX, DY, IndexFlowChart1 As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3088, 10, "MakePathOrthogonal")
#End If
            If mydebug(9) Then follow(2836, 10, "Make Path Orthogonal at " & IndexFlowChart.ToString)
            MakePathOrthogonal = False ' Didn't change anything
            If MyOptionTest(14) = False Then Exit Function 'Orthogonal paths
            ' Need to make sure this is a path first
            If FlowChart_TableCode(IndexFlowChart) <> "/path" Then
                Exit Function ' this is not a path to be able to change
            End If

            'It's check so make this rect Orthogonal 
            ' Get the distances between the two points on the line
            DX = MyABS(FlowChart_TableX1(IndexFlowChart) - FlowChart_TableX2(IndexFlowChart))
            DY = MyABS(FlowChart_TableY1(IndexFlowChart) - FlowChart_TableY2(IndexFlowChart))
            If DX = 0 Or DY = 0 Then Exit Function ' The X or Y is already stright up/down OR level right/left
            IndexFlowChart1 = InsertFlowChartRecord(FlowChart_TablePath_Name(IndexFlowChart), "/path", MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), MyPoint2XY(FlowChart_TableX2(IndexFlowChart), FlowChart_TableY2(IndexFlowChart)), FlowChart_Table_DataType(IndexFlowChart))
            MyMakeArraySizesBigger()
            PaintAll(FlowChartWindow.PictureBox1, IndexFlowChart, IndexFlowChart)
            PaintAll(FlowChartWindow.PictureBox1, IndexFlowChart1, IndexFlowChart1)
            If DX >= DY Then
                DX = FlowChart_TableX1(IndexFlowChart)
                DY = FlowChart_TableY2(IndexFlowChart)
                FlowChart_TableX1(IndexFlowChart1, DX)
                FlowChart_TableY1(IndexFlowChart1, DY)
                FlowChart_TableX2(IndexFlowChart, DX)
                FlowChart_TableY2(IndexFlowChart, DY)
                PaintAll(FlowChartWindow.PictureBox1, IndexFlowChart, IndexFlowChart)
                PaintAll(FlowChartWindow.PictureBox1, IndexFlowChart1, IndexFlowChart1)
            Else
                DX = FlowChart_TableX2(IndexFlowChart)
                DY = FlowChart_TableY1(IndexFlowChart)
                FlowChart_TableX1(IndexFlowChart1, DX)
                FlowChart_TableY1(IndexFlowChart1, DY)
                FlowChart_TableX2(IndexFlowChart, DX)
                FlowChart_TableY2(IndexFlowChart, DY)
                PaintAll(FlowChartWindow.PictureBox1, IndexFlowChart, IndexFlowChart)
                PaintAll(FlowChartWindow.PictureBox1, IndexFlowChart1, IndexFlowChart1)
                '2020 07 20 changed to also add a record ThisArea.MyWorldXY.a.x = ThisArea.MyWorldXY.b.x
            End If
        End Function

        Public Shared Sub SetMyLimitWindow(FromXY As MyPointStructure)
            'todo put a follow here
#If MINEDEBUG Then
  if mydebug(9) then follow(3089, 10, "SetMyLimitWindow")
#End If
            If MyUniverse.MyStaticData.MinXY.x > FromXY.x Then
                MyUniverse.MyStaticData.MinXY.x = FromXY.x - 1000
                If MyDebug(6) = True Then If mydebug(9) Then follow(2687, 6, "Sizes [X1=" & FromXY.x.ToString & " --> " & MyUniverse.MyStaticData.MinXY.x.ToString & "], [Y=" & FromXY.y.ToString & " --> " & MyUniverse.MyStaticData.MinXY.y.ToString & "]")
            End If
            If MyUniverse.MyStaticData.MinXY.y > FromXY.y Then
                If MyDebug(6) = True Then If mydebug(9) Then follow(2688, 6, "Sizes [Y1=" & FromXY.x.ToString & " --> " & MyUniverse.MyStaticData.MinXY.x.ToString & "], [Y=" & FromXY.y.ToString & " --> " & MyUniverse.MyStaticData.MinXY.y.ToString & "]")
                MyUniverse.MyStaticData.MinXY.y = FromXY.y - 1000
            End If
            If MyUniverse.MyStaticData.MaxXY.x < FromXY.x Then
                If MyDebug(6) = True Then If mydebug(9) Then follow(2689, 6, "Sizes [X2=" & FromXY.x.ToString & " --> " & MyUniverse.MyStaticData.MinXY.x.ToString & "], [Y=" & FromXY.y.ToString & " --> " & MyUniverse.MyStaticData.MinXY.y.ToString & "]")
                MyUniverse.MyStaticData.MaxXY.x = FromXY.x + 1000
            End If
            If MyUniverse.MyStaticData.MaxXY.y < FromXY.y Then
                If MyDebug(6) = True Then If mydebug(9) Then follow(2690, 6, "Sizes [Y2=" & FromXY.x.ToString & " --> " & MyUniverse.MyStaticData.MinXY.x.ToString & "], [Y=" & FromXY.y.ToString & " --> " & MyUniverse.MyStaticData.MinXY.y.ToString & "]")
                MyUniverse.MyStaticData.MaxXY.y = FromXY.y + 1000
            End If
            If MyDebug(11) = True Then If mydebug(9) Then follow(2883, 11, "New size AddressOf work area" & MyShowPoint(MyUniverse.MyStaticData.MinXY) & "Data Point" & MyShowPoint(FromXY))
        End Sub


        Public Shared Function FixSymbolLimits2Window(XY1 As MyPointStructure) As MyPointStructure
            FixSymbolLimits2Window = XY1
            FixSymbolLimits2Window.x = MyMinMax(FixSymbolLimits2Window.x, 0, SymbolWindow.PictureBox1.Width - 2)
            FixSymbolLimits2Window.y = MyMinMax(FixSymbolLimits2Window.y, 0, SymbolWindow.PictureBox1.Height - 2)
            If FixSymbolLimits2Window.x <> XY1.x Or FixSymbolLimits2Window.y <> XY1.y Then
                MSG_AInfo(1303, "Change to the bounds of Window", MyShowPoint(FixSymbolLimits2Window), MyShowPoint(XY1))
            End If
        End Function



        'Routine returns from 'real' world to Window scale
        Public Shared Function Copy2WindowXY(Where As PictureBox, FromXY As MyPointStructure) As MyPointStructure
            Dim TempH, TempV As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3080, 10, "Copy2WindowXY " & FromXY.x.ToString & FD & FromXY.y.ToString & FD & MyShowWindowSizes())
#End If
            Copy2WindowXY = Nothing
            'if mydebug(9) then follow(2765, 10, "To Window offset: " & MyShowPoint(MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.x, MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.y) & " From World: " & MyShowPoint(FromXY))

            LimitScale()
            Select Case LCase(Where.Parent.Name)
                Case "FlowChartwindow"
                    SetMyLimitWindow(FromXY)
                    If MyOptionTest(23) = True Then ' the origin is set by either CmdMoveHand or by scroll bars.
                        TempH = MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.x
                        TempV = MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.y
                    Else
                        TempH = CInt((MyUniverse.MyMouseAndDrawing.MyWindow.b.x + MyUniverse.MyMouseAndDrawing.MyWindow.a.x) * FlowChartWindow.HScrollBar1.Value / FlowChartWindow.HScrollBar1.Maximum)
                        TempV = CInt((MyUniverse.MyMouseAndDrawing.MyWindow.b.y - MyUniverse.MyMouseAndDrawing.MyWindow.a.y) * FlowChartWindow.VScrollBar1.Value / FlowChartWindow.VScrollBar1.Maximum)
                    End If
                    Copy2WindowXY.x = CInt((FromXY.x - TempH) * MyUniverse.SysGen.MyFlowChartScale)
                    Copy2WindowXY.y = CInt((FromXY.y - TempV) * MyUniverse.SysGen.MyFlowChartScale)
                Case "Symbolwindow"
                    'hack debugging

                    Copy2WindowXY.x = CInt((FromXY.x + MyUniverse.SysGen.Constants.ConstantSymbolCenter) * MyUniverse.SysGen.MySymbolScale)
                    Copy2WindowXY.y = CInt((FromXY.y + MyUniverse.SysGen.Constants.ConstantSymbolCenter) * MyUniverse.SysGen.MySymbolScale)

                    Copy2WindowXY = FixSymbolLimits2Window(Copy2WindowXY)


                    'I think this should be 0?
                    If Copy2WindowXY.x < 0 Then
                        MSG_ABug(1305, "2Window " & "The X1 is under of the Symbol graphics area " & " From " & MyShowPoint(FromXY) & " to " & MyShowPoint(Copy2WindowXY) & "Sized for Symbol" & MyShowPoint(MyPoint1XY(-MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)), "Sized for image " & MyShowPoint(MyUniverse.MyStaticData.ZeroZero), "")
                    End If
                    'I think this should be picture width?
                    If Copy2WindowXY.x > SymbolWindow.PictureBox1.Width Then
                        MSG_ABug(1306, "2Window " & "The is X over the Symbol graphics area " & " From " & MyShowPoint(FromXY) & " to " & MyShowPoint(Copy2WindowXY) & "Sized for Symbol" & MyShowPoint(MyPoint1XY(-MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)), "Sized for image " & MyShowPoint(MyPoint1XY(SymbolWindow.PictureBox1.Width, SymbolWindow.PictureBox1.Height)), "")
                    End If
                    'I think this should be 0?
                    If Copy2WindowXY.y < 0 Then
                        MSG_ABug(1307, "2Window " & "The Y is under of the Symbol graphics area " & " From " & MyShowPoint(FromXY) & " to " & MyShowPoint(Copy2WindowXY) & "Sized for Symbol" & MyShowPoint(MyPoint1XY(-MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)), "Sized for image " & MyShowPoint(MyPoint1XY(SymbolWindow.PictureBox1.Width, SymbolWindow.PictureBox1.Height)), "")
                    End If
                    'I think this should be picture height?
                    If Copy2WindowXY.y > SymbolWindow.PictureBox1.Height Then
                        MSG_ABug(1308, "2Window " & "The Y is over the Symbol graphics area " & " From " & MyShowPoint(FromXY) & " to " & MyShowPoint(Copy2WindowXY) & "Sized for Symbol" & MyShowPoint(MyPoint1XY(-MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)), "Sized for image " & MyShowPoint(MyPoint1XY(SymbolWindow.PictureBox1.Width, SymbolWindow.PictureBox1.Height)), "")
                    End If
                Case Else
                    Copy2WindowXY.x = -1
                    Copy2WindowXY.y = -1
                    MSG_ABug(1309, " unable to convert from world to Window because this is not a graphics Window ", Where.Parent.Name, Where.Name)
            End Select
            'if mydebug(9) then follow(2766, 1, "To Window orgin= " & MyShowPoint(MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.x, MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.y) & " from=" & MyShowPoint(FromXY) & " to " & MyShowPoint(Copy2WindowXY))
            'if mydebug(9) then follow(2681, 7, " 2_Window " & MyShowPoint(Copy2WindowXY) & vbTab & " from World " & MyShowPoint(FromXY))
        End Function


        'Routine copies from Window scale to 'real' world scale

        'todo rename the X in the x( routine(s) and remove the debug test this string parametrer
        Public Shared Function Copy2WorldXY(CodeString As String, Where As PictureBox, FromXY As MyPointStructure) As MyPointStructure
            Dim TempH, TempV As Single
#If MINEDEBUG Then
  if mydebug(9) then follow(3081, 10, "Copy2WorldXY")
#End If
            Copy2WorldXY = Nothing
            LimitScale()
            Select Case LCase(Where.Parent.Name)
                Case "FlowChartwindow"
                    'todo need to hide scroll bars if the hand option is used.
                    If MyOptionTest(23) = True Then ' the origin is set by either CmdMoveHand or by scroll bars.
                        TempH = MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.x
                        TempV = MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.y
                    Else
                        TempH = CInt((MyUniverse.MyMouseAndDrawing.MyWindow.b.x + MyUniverse.MyMouseAndDrawing.MyWindow.a.x) * FlowChartWindow.HScrollBar1.Value / FlowChartWindow.HScrollBar1.Maximum)
                        TempV = CInt((MyUniverse.MyMouseAndDrawing.MyWindow.b.y - MyUniverse.MyMouseAndDrawing.MyWindow.a.y) * FlowChartWindow.VScrollBar1.Value / FlowChartWindow.VScrollBar1.Maximum)
                    End If

                    Select Case LCase(CodeString)
                        Case My_keyWord(My_KeyConstUse) 'Symbolgrid snap
                            MyUniverse.Area.MyWorldXY.a = MySymbolSnap(MyUniverse.Area.MyWorldXY.a)
                            Copy2WorldXY = MySymbolSnap(MyPoint1XY(CInt(FromXY.x + TempH), CInt(FromXY.y + TempV)))
                        Case "/Constant" 'Point / Path grid snap
                            MyUniverse.Area.MyWorldXY.a = MyPointSnap(MyUniverse.Area.MyWorldXY.a)
                            Copy2WorldXY = MySymbolSnap(MyPoint1XY(CInt(FromXY.x + TempH), CInt(FromXY.y + TempV)))
                        Case "/path" 'point/path grid snap
                            MyPathSnap(MyUniverse.Area.MyWorldXY, MyUniverse.Area.MyWorldXY)
                            Copy2WorldXY = MySymbolSnap(MyPoint1XY(CInt(FromXY.x + TempH), CInt(FromXY.y + TempV)))
                        Case "/", Nothing
                            Copy2WorldXY.x = CInt((FromXY.x / MyUniverse.SysGen.MyFlowChartScale) + TempH)
                            Copy2WorldXY.y = CInt((FromXY.y / MyUniverse.SysGen.MyFlowChartScale) + TempV)
                        Case Else
                            MSG_ABug(1311, "how do I know if this is a Symbol or a path?", CodeString, "unable to snap to grid")
                            Copy2WorldXY.x = CInt((FromXY.x / MyUniverse.SysGen.MyFlowChartScale) + TempH)
                            Copy2WorldXY.y = CInt((FromXY.y / MyUniverse.SysGen.MyFlowChartScale) + TempV)
                    End Select
                Case "Symbolwindow"
                    Select Case LCase(CodeString)
                        Case "/point"
                            Copy2WorldXY.x = CInt(FromXY.x / MyUniverse.SysGen.MySymbolScale) - MyUniverse.SysGen.Constants.ConstantSymbolCenter
                            Copy2WorldXY.y = CInt(FromXY.y / MyUniverse.SysGen.MySymbolScale) - MyUniverse.SysGen.Constants.ConstantSymbolCenter
                            Copy2WorldXY = MyPointSnap(Copy2WorldXY)
                        Case "/line" ' no snapping of lines.
                            Copy2WorldXY.x = CInt(FromXY.x / MyUniverse.SysGen.MySymbolScale) - MyUniverse.SysGen.Constants.ConstantSymbolCenter
                            Copy2WorldXY.y = CInt(FromXY.y / MyUniverse.SysGen.MySymbolScale) - MyUniverse.SysGen.Constants.ConstantSymbolCenter
                        Case "/", "", Nothing
                            Copy2WorldXY.x = CInt(CSng(FromXY.x - MyUniverse.SysGen.Constants.ConstantSymbolCenter) * MyUniverse.SysGen.MySymbolScale - MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                            Copy2WorldXY.y = CInt(CSng(FromXY.y - MyUniverse.SysGen.Constants.ConstantSymbolCenter) * MyUniverse.SysGen.MySymbolScale - MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                        Case "?"
                            Copy2WorldXY.x = CInt(FromXY.x / MyUniverse.SysGen.MySymbolScale) - MyUniverse.SysGen.Constants.ConstantSymbolCenter
                            Copy2WorldXY.y = CInt(FromXY.y / MyUniverse.SysGen.MySymbolScale) - MyUniverse.SysGen.Constants.ConstantSymbolCenter
                        Case Else
                            MSG_ABug(1312, "Can not use a ", CodeString.ToString, " in the  " & Where.Parent.Name)
                            Copy2WorldXY.x = CInt(CSng(FromXY.x - MyUniverse.SysGen.Constants.ConstantSymbolCenter) * MyUniverse.SysGen.MySymbolScale + MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                            Copy2WorldXY.y = CInt(CSng(FromXY.y - MyUniverse.SysGen.Constants.ConstantSymbolCenter) * MyUniverse.SysGen.MySymbolScale + MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                    End Select '/point/line/
                    'todo This is for debugging only.
                    If Copy2WorldXY.x < -MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                        MSG_ABug(1313, "The X is under the Symbol drawing area", MyShowPoint(Copy2WorldXY), MyShowPoint(FromXY) & " : " & MyShowPoint(MyPoint1XY(0, 2 * MyUniverse.SysGen.Constants.ConstantSymbolCenter)))
                        Copy2WorldXY.x = -MyUniverse.SysGen.Constants.ConstantSymbolCenter + 10
                    End If
                    If Copy2WorldXY.x > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                        MSG_ABug(1314, "The X is over the Symbol drawing area", MyShowPoint(Copy2WorldXY), MyShowPoint(FromXY) & MyShowPoint(MyPoint1XY(0, 2 * MyUniverse.SysGen.Constants.ConstantSymbolCenter)))
                        Copy2WorldXY.x = MyUniverse.SysGen.Constants.ConstantSymbolCenter - 10
                    End If
                    If Copy2WorldXY.y < -MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                        MSG_ABug(1315, "The Y is under the Symbol drawing area", MyShowPoint(Copy2WorldXY), MyShowPoint(FromXY))
                        Copy2WorldXY.y = -MyUniverse.SysGen.Constants.ConstantSymbolCenter + 10
                    End If
                    If Copy2WorldXY.y > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                        MSG_ABug(1316, "The Y is over Symbol drawing area", MyShowPoint(Copy2WorldXY), MyShowPoint(FromXY))
                        Copy2WorldXY.y = MyUniverse.SysGen.Constants.ConstantSymbolCenter - 10
                    End If
                Case Else
                    MSG_ABug(1317, "Trying to scale on something that is not a FlowChart or Symbol", Where.Parent.Name, "")
                    Copy2WorldXY.x = -1
                    Copy2WorldXY.y = -1
                    MSG_ABug(1318, "Myscale the program does Not understand trying to convert the XY on " & Where.Parent.Name, "", "")
            End Select

            If MyDebug(10) = True Then If mydebug(9) Then follow(2767, 10, SHL(MyNoCR("World offset: " & MyShowPoint(MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.x, MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.y) & " From Win:" & MyShowPoint(FromXY) & " to World: " & MyShowPoint(Copy2WorldXY))))
            If MyDebug(6) = True Then If mydebug(9) Then follow(2682, 6, SHL(MyNoCR(" 2_World " & MyShowPoint(Copy2WorldXY) & vbTab & " from Window " & MyShowPoint(FromXY))))
        End Function





        Public Shared Function ThisExtension(extensions As String, whichone As Int32) As String
            Dim j As Int32
            Dim Z, A As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3081, 10, "ThisExtension")
#End If
            If MyDebug(10) = True Then If mydebug(9) Then follow(2837, 11, "Extensions " & extensions & " at " & whichone.ToString)
            A = extensions
            Z = extensions
            For j = 1 To whichone
                A = Pop(Z, FD)
            Next j
            If A <> "" Then
                If MyLeft(A, 1) <> "." Then
                    A = "." & A
                End If
            End If
            Return A
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This is where all file openings take place
        'ReadOrWrite is a string of "read" for input of a FlowChart
        '       "write" for output of a FlowChart
        '       "decompile" for input from source code
        '       "compile" for output to source code
        ' All of them open a dialog box to get the file name (SaveAs, there is no save (yet))

        'Routine Returns the file name opened.(Does not change the input file name
        Public Shared Function XOpenFile(ReadOrWrite As String, MyTitle As String) As String ' , My_FileName As String) As String 'Opens the standard selection box'2020 08 10
            Dim My_FileName, MyFilter, X, Y, Z As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3082, 10, "XOpenFile")
#End If
            If MyDebug(10) = True Then If mydebug(9) Then follow(2838, 10, "XOpen " & ReadOrWrite & FD & MyTitle)
            My_FileName = Nothing
            MyFilter = Nothing
            'OpenFileDialog 
            Select Case LCase(ReadOrWrite)
                Case "read"
                    Dim openFileDialog1 As New OpenFileDialog()
                    'If MyFileName = Nothing Then 2020 08 10
                    X = MyUniverse.ProgramOptions.FCCL_Extension
                    Z = ""
                    While X <> ""
                        Y = ThisExtension(Pop(X, FD), 1)
                        My_FileName &= Z & MyUniverse.SysGen.Constants.DrillDown_FileName & Y
                        Z = ";"
                    End While

                    X = MyUniverse.ProgramOptions.FCCL_Extension
                    While X <> ""
                        Y = ThisExtension(Pop(X, FD), 1)
                        MyFilter &= MyUniverse.SysGen.Constants.DrillDown_FileName & Y & "|" & MyUniverse.SysGen.Constants.DrillDown_FileName & Y & "|"
                    End While
                    openFileDialog1.Title = MyTitle
                    openFileDialog1.FileName = My_FileName
                    openFileDialog1.InitialDirectory = "c:    \\"
                    openFileDialog1.Filter = MyFilter & "Flow Chart Computer Language files (*.FlowChart)|*.FlowChart|Symbol files (*.Symbol)|*.Symbol|TextFile (*.txt)|*.txt|All Files (*.*)|*.*"
                    openFileDialog1.RestoreDirectory = True
                    openFileDialog1.AddExtension = True
                    openFileDialog1.DefaultExt = ".FlowChart"
                    openFileDialog1.Multiselect = False
                    If openFileDialog1.ShowDialog() = DialogResult.OK Then
                        My_FileName = openFileDialog1.FileName
                    Else
                        My_FileName = Nothing
                    End If
                    XOpenFile = My_FileName
                    openFileDialog1.Dispose()

                Case "decompile"
                    Dim openFileDialog1 As New OpenFileDialog()
                    'If My_FileName = Nothing Then 
                    My_FileName = MyUniverse.SysGen.Constants.DrillDown_FileName & ThisExtension(MyUniverse.ProgramOptions.FCCL_Extension, 1)
                    openFileDialog1.Title = MyTitle
                    openFileDialog1.FileName = My_FileName
                    openFileDialog1.InitialDirectory = "c:\\"
                    openFileDialog1.Filter = MyUniverse.ProgramOptions.FCCL_LanguageClassName & MyUniverse.ProgramOptions.FCCL_WhiteSpace & ComputerFileNamesAre()
                    openFileDialog1.RestoreDirectory = True
                    openFileDialog1.AddExtension = True
                    openFileDialog1.DefaultExt = ComputerFileNamesAre()
                    openFileDialog1.Multiselect = False
                    If openFileDialog1.ShowDialog() = DialogResult.OK Then
                        My_FileName = openFileDialog1.FileName
                    Else
                        My_FileName = Nothing
                    End If
                    XOpenFile = My_FileName
                    openFileDialog1.Dispose()

                Case "write"
                    Dim SaveFileDialog1 As New SaveFileDialog()
                    If My_FileName = Nothing Then My_FileName = "Start" & ThisExtension(MyUniverse.ProgramOptions.FCCL_Extension, 1)
                    SaveFileDialog1.Title = MyTitle
                    SaveFileDialog1.FileName = My_FileName
                    SaveFileDialog1.InitialDirectory = "c:\\"
                    SaveFileDialog1.Filter = "Software Schematic files (*.FlowChart)|*.FlowChart|Symbol files (*.Symbol)|*.Symbol|TextFile (*.txt)|*.txt|All Files (*.*)|*.*"
                    SaveFileDialog1.RestoreDirectory = True
                    SaveFileDialog1.AddExtension = True
                    SaveFileDialog1.DefaultExt = ".FlowChart"
                    SaveFileDialog1.CheckFileExists = False
                    SaveFileDialog1.CheckPathExists = True
                    If SaveFileDialog1.ShowDialog() = DialogResult.OK Then
                        My_FileName = SaveFileDialog1.FileName
                    Else
                        My_FileName = Nothing
                    End If
                    XOpenFile = My_FileName
                    SaveFileDialog1.Dispose()
                Case "compile"
                    Dim SaveFileDialog1 As New SaveFileDialog()
                    If My_FileName = Nothing Then My_FileName = MyUniverse.SysGen.Constants.DrillDown_FileName & ThisExtension(MyUniverse.ProgramOptions.FCCL_Extension, 1)
                    SaveFileDialog1.Title = MyTitle
                    SaveFileDialog1.FileName = My_FileName
                    SaveFileDialog1.InitialDirectory = "c:\\"

                    SaveFileDialog1.Filter = MyUniverse.ProgramOptions.FCCL_LanguageClassName & MyUniverse.ProgramOptions.FCCL_WhiteSpace & ComputerFileNamesAre()

                    SaveFileDialog1.RestoreDirectory = True
                    SaveFileDialog1.AddExtension = True
                    SaveFileDialog1.DefaultExt = ComputerFileNamesAre()
                    SaveFileDialog1.CheckFileExists = False
                    SaveFileDialog1.CheckPathExists = True
                    If SaveFileDialog1.ShowDialog() = DialogResult.OK Then
                        My_FileName = SaveFileDialog1.FileName
                    Else
                        My_FileName = Nothing
                    End If
                    XOpenFile = My_FileName
                    SaveFileDialog1.Dispose()
                Case Else
                    XOpenFile = Nothing
            End Select
        End Function




        Public Shared Function Point2MyPointStruct(xy As Point) As MyPointStructure
            Point2MyPointStruct.Named.PathName = ""
            Point2MyPointStruct.Named.PointName = ""
            Point2MyPointStruct.Named.SymbolName = ""
            Point2MyPointStruct.x = xy.X
            Point2MyPointStruct.y = xy.Y
            Return Point2MyPointStruct
        End Function


        Public Shared Function MyPointStruct2Point(xy As MyPointStructure) As Point
            MyPointStruct2Point.X = xy.x
            MyPointStruct2Point.Y = xy.y
        End Function


        'Routine This will write out one line of text to the file stream I/O
        Public Shared Sub MyWriteLine1(Writer As StreamWriter, OutPutString As String)
            If InStr(OutPutString, vbCrLf) <> 0 Then
                If InStr(OutPutString, vbCrLf & "/") = 0 Then
                    Writer.WriteLine(OutPutString.Replace(vbCrLf, ""))
                Else
                    Writer.WriteLine(OutPutString)
                End If
            Else
                Writer.WriteLine(OutPutString)
            End If
        End Sub


        Public Shared Function NoComments(MyCodeLine As String) As String
            Dim TempComment As String
            NoComments = MyCodeLine
            TempComment = MyUniverse.ProgramOptions.FCCL_Comment
            If InStr(MyCodeLine, TempComment) > 0 Then
                NoComments = Mid(MyCodeLine, 1, InStr(MyCodeLine, TempComment) - 1)
                Exit Function
            End If
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is parsing the inport file from the format /keyword=options....
        Public Shared Function TrimEqual(InputString As String) As String
            If MyLeft(InputString, 1) = "=" Then ' change in the delimiters 2020 08 13
                TrimEqual = Trim(Mid(InputString, 2, Len(InputString)))
            Else
                TrimEqual = InputString
            End If
        End Function


        Public Shared Function XTrim(StringtoTrim As String) As String
            XTrim = Trim(StringtoTrim)
            While MyLeft(XTrim, 1) = FD
                XTrim = Mid(XTrim, 2, Len(XTrim))
            End While
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Routine This will trim a string from all spaces, carriage returns, and Linefeeds
        ' This needs to be changed so that we find where the trim is, and then move the string only once, because this way is VERY slow.
        Public Shared Function My2Trim(StringToTrim As String, what As String) As String
            If MyDebug(7) Then FMB(1128, what)
            My2Trim = StringToTrim
            While MyLeft(My2Trim, Len(what)) = what
                My2Trim = Mid(My2Trim, Len(what) + 1, Len(My2Trim))
            End While

            While MyRight(My2Trim, Len(what)) = what
                My2Trim = Mid(My2Trim, 1, Len(My2Trim) - Len(what))
            End While
        End Function 'my2trim


        Public Shared Function MyTrim(StringToTrim As String) As String
            'if mydebug(9) then follow(2436, 7, "MyTrim")
            MyTrim = Trim(StringToTrim)
            MyTrim = My2Trim(MyTrim, vbCrLf)
            MyTrim = My2Trim(MyTrim, vbLf)
            MyTrim = My2Trim(MyTrim, vbCr)
            MyTrim = My2Trim(MyTrim, vbTab)
            If StringToTrim <> "," Then MyTrim = My2Trim(MyTrim, FD)
            MyTrim = Trim(MyTrim) 'doing it again just to make sure
        End Function 'MyTrim()


        'Routine This writes out all of the data in the MyArrays to a file (Has error, not able to create a new file yet)

        'todo needs to redo this and all of the MyShowFlowChart(), MyShowSymbol() and so on so that it ONLY returns the export (Which will then appear everywhere else yI need to show a record, (and not all of the internal junk)
        Public Shared Sub Export(expanded As Boolean, MyOutputFileName As String)
            Dim OutPutLine As String
            Dim I, IndexFlowChart, IndexISAM, IndexSymbol, IndexNamed As Int32
            Dim LineCount As Int32
            LineCount = 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3083, 10, "Export")
#End If
            If mydebug(9) Then follow(2839, 1, " Export " & MyOutputFileName)
            If Dir(MyOutputFileName) = "" Then ' need to create the file if it does not exist then you can ...
                Using Writer As System.IO.StreamWriter = System.IO.File.CreateText(MyOutputFileName)
                End Using
            Else
                'System.IO.File.Create(OutputFileName)
                Kill(MyOutputFileName)
                Using Writer As System.IO.StreamWriter = System.IO.File.CreateText(MyOutputFileName)
                End Using
            End If



            If MyOptionTest(22) = True Then
                If MyDebug(8) Then FMB1(8034)
                For IndexFlowChart = LBound(Language_KeyWord) + 1 To UBound(Language_KeyWord)
                    ReSortLanguagekeyWord("LanguagekeyWord", Language_KeyWord, IndexFlowChart)
                Next
                For IndexFlowChart = LBound(Language_Function) + 1 To UBound(Language_Function)
                    ReSortLanguagekeyWord("LanguageFunction", Language_Function, IndexFlowChart)
                Next
                For IndexFlowChart = LBound(Language_Operator) + 1 To UBound(Language_Operator)
                    ReSortLanguagekeyWord("LanguageOperator", Language_Operator, IndexFlowChart)
                Next
                For IndexFlowChart = LBound(Language_Grammar) + 1 To UBound(Language_Grammar)
                    ReSortLanguagekeyWord("LanguageGrammar", Language_Grammar, IndexFlowChart)
                Next

            End If

            'Make sure everything is in sorted order, cause Ima putting it out in sorted order, so it will be easier to re-input (except for FlowChart_Table...)

            SortColors()
            SortDataType()
            SortNamed()
            SortFlowChart()

            ' Now open it for output
            'Using MyWriter As System.IO.StreamWriter = System.IO.File.OpenText(OutputFileName)
            Using MyWriter As New StreamWriter(MyOutputFileName)
                'MyWriter = FreeFile()
                'FileOpen(MyWriter, OutputFileName, OpenMode.Output, OpenAccess.Write, OpenShare.Default, -1)
                LineCount += 1 : DisplayMyStatus(7, LineCount.ToString)

                If MyOptionTest(22) = True Or expanded = True Then
                    MyWriteLine1(MyWriter, "/ignore= formats" & vbCrLf)
                    DisplayMyStatus(7, "Exporting Language Key Words")
                    DoThisEvent(157)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatColor & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatDataType & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatSymbolName & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatPoint & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatLine & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatNameOfFile & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatLanguage & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatStroke & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatNotes & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatOrder & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatVersion & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatAuthor & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatOpcode & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatPath & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatUse & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatConstant & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatMacroText & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatOption & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatError & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatDelete & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    '    MyWriteLine1(MyWriter, "/Ignore= Format= " & formatThisCode)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatLanguage_KeyWord & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatLanguage_Operator & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatLanguage_Function & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatLanguage_Grammar & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatSyntax & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)

                End If

                ' Write out all of the options that are turned OFF

                OutPutLine = "/Language=" & MyUniverse.ProgramOptions.FCCL_LanguageClassName & vbCrLf : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                OutPutLine &= "/FCCL_DialectName=" & MyUniverse.ProgramOptions.FCCL_DialectName & vbCrLf : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                OutPutLine &= "/FCCL_Case=" & MyUniverse.ProgramOptions.FCCL_Case & vbCrLf : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                OutPutLine &= "/FCCL_Comment= " & MyUniverse.ProgramOptions.FCCL_Comment & vbCrLf : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                OutPutLine &= "/FCCL_Extension=" & MyUniverse.ProgramOptions.FCCL_Extension & vbCrLf : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                OutPutLine &= "/FCCL_MultiLine=" & MyUniverse.ProgramOptions.FCCL_MultiLine & vbCrLf : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                OutPutLine &= "/FCCL_Process=" & MyUniverse.ProgramOptions.FCCL_Process & vbCrLf : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                OutPutLine &= "/FCCL_VarChars=" & Bin2HEX(MyUniverse.ProgramOptions.FCCL_VarChars) & vbCrLf : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)

                MyWriteLine1(MyWriter, OutPutLine)

                MyWriteLine1(MyWriter, "/ignore= options" & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)

                If MyOptionTest(22) = True Or expanded = True Then
                    For IndexFlowChart = 0 To UBound(MyMessageBits) * 8
                        If IsBitSet(IndexFlowChart) = True Then
                            'MyWriteLine1(mywriter, "/Option=" & Index & FD & "on")
                        Else
                            MyWriteLine1(MyWriter, "/Option=" & IndexFlowChart & FD & "off" & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                        End If
                    Next

                    'write out all of the message options options that are turned off (Escape on the message box)
                    MyWriteLine1(MyWriter, "/ignore= messages" & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    For IndexFlowChart = 0 To UBound(MyTraceBits) * 8
                        If IsBitSet1(IndexFlowChart) Then
                            'MyWriteLine1(MyWriter, "/trace=" & IndexFlowChart & FD & "on")
                        Else
                            MyWriteLine1(MyWriter, "/trace=" & IndexFlowChart & FD & "off" & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                        End If
                    Next

                    'Write out all of the key words
                    'TempFormat = FormatLanguage_KeyWord
                    MyWriteLine1(MyWriter, "/ignore= Keywords again?" & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)

                    For IndexFlowChart = LBound(Language_Grammar) To UBound(Language_Grammar)
                        If Language_Grammar(IndexFlowChart) <> "" And MyLeft(Language_Grammar(IndexFlowChart), Len(Language_Grammar(IndexFlowChart))) <> MyConstantIgnoreFunctionOperatorKeyWord Then
                            OutPutLine = "/Grammar = " & Language_Grammar(IndexFlowChart) & vbCrLf
                            MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                        Else
                            OutPutLine = Language_Grammar(IndexFlowChart) & MyConstantIgnoreFunctionOperatorKeyWord
                        End If
                    Next IndexFlowChart

                    For IndexFlowChart = LBound(Language_KeyWord) To UBound(Language_KeyWord)
                        If Language_KeyWord(IndexFlowChart) <> "" And
        MyLeft(Language_KeyWord(IndexFlowChart), Len(Language_KeyWord(IndexFlowChart))) <> MyConstantIgnoreFunctionOperatorKeyWord Then
                            OutPutLine = MyShowkeyWord("/keyword", Language_KeyWord(IndexFlowChart) & vbCrLf)
                            MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1 ': 'DisplayMyStatus(7, LineCount.ToString)
                        Else
                            OutPutLine = Language_KeyWord(IndexFlowChart) & MyConstantIgnoreFunctionOperatorKeyWord
                        End If
                    Next IndexFlowChart

                    'TempFormat = FormatLanguage_operator
                    MyWriteLine1(MyWriter, "/ignore= operators" & vbCrLf)
                    For IndexFlowChart = LBound(Language_Operator) To UBound(Language_Operator)
                        If Language_Operator(IndexFlowChart) <> "" Then
                            OutPutLine = MyShowkeyWord("/operator", Language_Operator(IndexFlowChart) & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                            MyWriteLine1(MyWriter, OutPutLine)
                        Else
                            OutPutLine = Language_Operator(IndexFlowChart) & MyConstantIgnoreFunctionOperatorKeyWord & vbCrLf
                        End If
                    Next IndexFlowChart

                    'TempFormat = FormatLanguage_Function
                    MyWriteLine1(MyWriter, "/ignore= Functions" & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    For IndexFlowChart = LBound(Language_Function) To UBound(Language_Function)
                        If Language_Function(IndexFlowChart) <> "" Then
                            OutPutLine = MyShowkeyWord("/Function", Language_Function(IndexFlowChart) & vbCrLf)
                            MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                        Else
                            OutPutLine = Language_Function(IndexFlowChart) & MyConstantIgnoreFunctionOperatorKeyWord & vbCrLf
                        End If
                    Next IndexFlowChart

                    'Write out all of the color information (Including all of those that are not used here
                    DisplayMyStatus(7, "Exporting Colors")
                    'TempFormat = formatColor
                    MyWriteLine1(MyWriter, "/ignore= colors" & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    For IndexISAM = 1 To TopOfFile("Color") - 1
                        I = Color_Name_ISAM(IndexISAM)
                        OutPutLine = MyShowColor(False, I) & vbCrLf
                        MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    Next
                End If





                DisplayMyStatus(7, "Exporting Data Types")
                'TempFormat = formatDataType
                'DataTypes are not getting sorted before export

                MyWriteLine1(MyWriter, "/ignore= DataTypes" & vbCrLf)
                For IndexISAM = 1 To TopOfFile("DataType")
                    I = DataType_Name_ISAM(IndexISAM)
                    OutPutLine = MyShowDataTypeTable(False, I) & vbCrLf
                    MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                Next
                OutPutLine = Nothing


                ' We have to output it in the order of the file.
                DisplayMyStatus(7, "Exporting Symbols") : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                FindingMyBugs(10) 'hack Least amount of checking here 'hack
                MyWriteLine1(MyWriter, "/ignore= Symbol Names" & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                For IndexNamed = 1 To TopOfFile("Named")
                    IndexSymbol = GetSelfCorrectingIndexes(Named_TableSymbolName(IndexNamed))
                    OutPutLine = MyShowNamedRecords(False, IndexSymbol)
                    MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                    OutPutLine = MyShowSymbolRecords(False, IndexSymbol)
                    MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                Next


                DisplayMyStatus(3, "Exporting FlowChart Details")

                'todo need to change all of this to use myshowFlowChart()

                MyWriteLine1(MyWriter, "/ignore= FlowChart" & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)

                For IndexFlowChart = 1 To TopOfFile("FlowChart")
                    I = FlowChart_ISAM_Name(IndexFlowChart)
                    Select Case LCase(FlowChart_TableCode(I))
                        Case My_keyWord(My_KeyConstUse)
                            ' Error here X3 should never be Null (-1)
                            DisplayMyStatus(7, "Exporting Call " & FlowChart_TableSymbol_Name(I))
                            OutPutLine = MyShowFlowChartRecord(False, I) & vbCrLf & "/ignore=" & formatUse & vbCrLf
                            MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                        Case "/path"
                            DisplayMyStatus(7, "Exporting Path " & FlowChart_TablePathName(I))
                            OutPutLine = MyShowPath(False, I) & vbCrLf
                            ' removed         DisplayMyStatus(7,FlowChart_TableCompiledMacroCodeText(I))

                            'OutPutLine &= ", \ i =" & PrintAbleNull( i ) ' print out but ignored on input.
                            'OutPutLine &= ", \linkd=" & PrintAbleNull(FlowChart_TableLinks( i )) ' print out but ignored on input.
                            'TempFormat = formatPath
                            MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1 ' 'DisplayMyStatus(7, LineCount.ToString)
                        Case "/Constant"
                            OutPutLine = "/Constant" & "="
                            OutPutLine &= FD & PrintAbleNull(FindInSymbolList(FlowChart_TableOther_Name(I)).ToString)
                            OutPutLine &= FD & FlowChart_TableX1(I)
                            OutPutLine &= FD & FlowChart_TableY1(I)
                            OutPutLine &= FD & FlowChart_Table_DataType(I) & vbCrLf
                            'TempFormat = formatConstant
                            MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                        Case "/delete"
                            If MyOptionTest(22) = True Then
                                OutPutLine = vbCrLf & "/delete" & " = "
                                OutPutLine &= FD & PrintAbleNull(FindInSymbolList(FlowChart_TableOther_Name(I)).ToString)
                                OutPutLine &= FD & FlowChart_TableX1(I)
                                OutPutLine &= FD & FlowChart_TableY1(I)
                                OutPutLine &= FD & FlowChart_TableX2(I)
                                OutPutLine &= FD & FlowChart_TableY2(I)
                                OutPutLine &= FD & PrintAbleNull(FlowChart_Table_DataType(I)) & vbCrLf
                                'OutPutLine &= ", \ i =" & PrintAbleNull( i ) ' print out but ignored on input.
                                'OutPutLine &= ", \linkd=" & PrintAbleNull(FlowChart_TableLinks( i )) ' print out but ignored on input.
                                'TempFormat = FormatDelete
                                MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                            End If
                        Case "/error"
                            If MyOptionTest(22) = True Then
                                'TempFormat = FormatError
                                OutPutLine = "/error" & " = " & FlowChart_TableCode(I)
                                OutPutLine &= FD & PrintAbleNull(FindInSymbolList(FlowChart_TableOther_Name(I)).ToString)
                                OutPutLine &= FD & FlowChart_TableX1(I)
                                OutPutLine &= FD & FlowChart_TableY1(I)
                                OutPutLine &= FD & FlowChart_TableX2(I)
                                OutPutLine &= FD & FlowChart_TableY2(I)
                                OutPutLine &= FD & FlowChart_Table_DataType(I) & vbCrLf ' DataType is not required (ignored) on Import and should be '_' Null
                                'OutPutLine &= ", \ i =" & PrintAbleNull( i ) ' print out but ignored on input.
                                'OutPutLine &= ", \linkd=" & PrintAbleNull(FlowChart_TableLinks( i )) ' print out but ignored on input.
                                'TempFormat = FormatError
                                MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                            End If
                        Case Else
                            If MyOptionTest(22) = True Then
                                OutPutLine = "/Error=Export FlowChart unknown /"
                                OutPutLine &= FlowChart_TableCode(I)
                                OutPutLine &= ",\Code= " & FlowChart_TableCode(I)
                                OutPutLine &= ",\Named= " & FindInSymbolList(FlowChart_TableOther_Name(I))
                                OutPutLine &= ",\Number= " & FlowChart_TablePathName(I)
                                OutPutLine &= ",\X1 = " & FlowChart_TableX1(I)
                                OutPutLine &= ",\Y1 = " & FlowChart_TableY1(I)
                                OutPutLine &= ",\X2 = " & FlowChart_TableX2(I)
                                OutPutLine &= ",\Y2 = " & FlowChart_TableY2(I)
                                OutPutLine &= ",\DataType = " & PrintAbleNull(FlowChart_Table_DataType(I))
                                OutPutLine &= ",\ i  =" & PrintAbleNull(I.ToString) & vbCrLf ' print out but ignored on input.
                                ' removed         OutPutLine &= ",\linkd =" & PrintAbleNull(FlowChart_TableCompiledMacroCodeText(I)) ' print out but ignored on input.
                                MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                            End If
                    End Select
                Next
                MyWriteLine1(MyWriter, "/ignore= Finished" & vbCrLf) : LineCount += 1  'DisplayMyStatus(7, LineCount.ToString)
                MyWriter.Close() 'FileClose(MyWriter)
            End Using
            'End Using 'writer1
            ShowAllForms(ShowWindow, HideWindow, HideWindow, ShowWindow)
            DisplayMyStatus(7, "Export Finished.")
        End Sub

        Public Shared Sub ImportDataTypes(Key_line As String)
            Dim IndexDataType As Int32
            Dim Inputline As String
            Dim DataTypeName As String
            Dim LostColorName As String
            Dim LostColorIndex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3084, 10, "ImportDataTypes")
#End If
            Inputline = TrimEqual(Key_line)
            DataTypeName = MyTrim(Pop(Inputline, vbLf & vbCr & FD & ",=/\" & vbCrLf))
            If MyDebug(11) Then follow(2840, 11, "Import " & Key_line)

            If PrintAbleNull(DataTypeName) = "_" Then
                'MyMsgCtr(1413, "ImportDataTypes", DataTypeName, "15", "", "", "", "", "", "", "")
                Return
            End If
            'CheckForAnySortNeeded("Import Data Types", 205)
            DataType_FileColorIndex(NewTopOfFile("DataType")) = FindColor("Errored") '20200628'to fool FindingMyBugs for now
            IndexDataType = FindIndexInISAMTable("DataType", "add", DataType_FileName, DataType_Name_ISAM, DataTypeName)
            ' ****** incase we added then it is out of order
            'ShowSorts("DataType", SortDataType())
            'CheckForAnySortNeeded("Import Data Types", 206)
            'IndexDataType = MyMinMax(TopOfFile("DataType"), IndexDataType, TopOfFile("DataType"))
            '*******
            'DataType_TableName(Index) = Pop(KeyLine)
            DataType_TableNumberOfBytes(IndexDataType, PopValue(Inputline))
            Inputline = MyTrim(Inputline)
            LostColorName = Pop(Inputline, MyUniverse.SysGen.Constants.ConstantDelimiters)
            Inputline = MyTrim(Inputline)
            LostColorName = MyTrim(LostColorName)
            Inputline = MyTrim(Inputline)
            LostColorIndex = FindColor(LostColorName)
            Inputline = MyTrim(Inputline)
            If LostColorIndex = ConstantMyErrorCode Then
                MSG_ABug(1326, "Failed finding the color " & LostColorName, " For DataType " & DataTypeName, "From Line " & Key_line)
                ShowSorts("color", SortColors())
            End If
            DataType_TableColorIndex(IndexDataType, FindColor(LostColorName))
            If DataType_TableColorIndex(IndexDataType) < 1 Then
                DataType_TableColorIndex(IndexDataType, FindColor("RED"))
            End If
            If DataType_TableColorIndex(IndexDataType) = ConstantMyErrorCode Then
                FindingMyBugs(10) 'hack Least amount of checking here
                'MyMsgCtr(1048, "ImportDataTypes", LostColorName, DataType_TableName(IndexDataType), IndexDataType.ToString, LineNumber.ToString, MyUniverse.ProgramOptions.SelectedColor, "", "", "", "")
                DataType_TableColorIndex(IndexDataType, FindColor(MyUniverse.ProgramOptions.SelectedColor))
            End If
            DataType_TableWidth(IndexDataType, CByte(MyABS(PopValue(Inputline))))

            DataType_TableDescription(IndexDataType, Pop(Inputline, FD & vbCr & vbLf & vbCrLf))
            'CheckForAnySortNeeded("Import Data Types", 207) 'hack
            ShowSorts("DataType", MyReSort("DataType", DataType_FileName, DataType_Name_ISAM, IndexDataType)) '03/12/19 Only resort the top item
            'FindingMyBugs(10) 'hack Least amount of checking here 'hack
            SortDataType()
            'FindingMyBugs(10) 'hack Least amount of checking here 'hack
            CheckForAnySortNeeded(208) 'hack
            MyMakeArraySizesBigger()
            'FindingMyBugs(10) 'hack Least amount of checking here 'hack
            SymbolWindow.ToolStripDropDownDataType.DropDownItems.Add(DataType_TableName(IndexDataType))
            FindingMyBugsDropDowns()
        End Sub


        Public Shared Sub SetOptions(ImportLine As String)
            Dim X0, X1, X2, X3, X4 As String ' DUMP FILE NAMES
            Dim I, I1, I2, I3 As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3085, 10, "SetOption")
#End If
            X0 = ImportLine
            X1 = Pop(X0, FD) 'What
            Select Case LCase(X1)    ' format /language=(name of language) then all of the options
                Case "points" ' Location of the points (first to last point) 1-121??
                    'The first two points are the CameFromLine and Go_To (1 and 2)
                    I1 = MyMinMax(My_INT(Pop(X0, FD)), 0, UBound(MyUniverse.MySymbolPoints))
                    I2 = MyMinMax(My_INT(Pop(X0, FD)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                    I3 = MyMinMax(My_INT(Pop(X0, FD)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                    MyUniverse.MySymbolPoints(I1).x = I2
                    MyUniverse.MySymbolPoints(I1).y = I3
                Case "text" ' Location of the options to display 
                    'The first two points are the CameFromLine and Go_To (1 and 2)
                    I1 = MyMinMax(My_INT(Pop(X0, FD)), 0, UBound(MyUniverse.OptionDisplay))
                    I2 = MyMinMax(My_INT(Pop(X0, FD)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                    I3 = MyMinMax(My_INT(Pop(X0, FD)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                    MyUniverse.OptionDisplay(I1).x = I2
                    MyUniverse.OptionDisplay(I1).y = I3
                    MyUniverse.OptionDisplay(I1).Textwidth = MyMinMax(PopValue(X0), 50, MyUniverse.SysGen.Constants.ConstantSymbolCenter * 2)
                    MyUniverse.OptionDisplay(I1).Textheight = MyMinMax(PopValue(X0), 50, MyUniverse.SysGen.Constants.ConstantSymbolCenter * 16)
                Case "delimiters"
                    MyUniverse.SysGen.Constants.RMStart = Pop(X0, FD)
                    MyUniverse.SysGen.Constants.RMEnd = Pop(X0, FD)
                Case "language" ' Set a new language parameter (for any new language)
                    'hack, need to also see if this language is already there and replace it.
                    OptionsWindow.ListBoxLanguage.Items.Add(X0)
    'todo Also Select this as the default language now
                Case "options"
                    'Force it to only change the available list
                    X2 = Pop(X0, FD)
                    I = MyMinMax(My_INT(X2), 0, OptionsWindow.CheckedListBoxOptionSelection.Items.Count - 1)
                    OptionsWindow.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Checked)
                Case "scale"
                    X2 = Pop(X0, FD)
                    MyUniverse.SysGen.MyFlowChartScale = CSng(CInt(X2) / 1000.0)
                    LimitScale()
                Case "Grids"
                    'Done Add /set=grids=
                    '   Symbol grid(default 250), 
                    '   Point and path Grid(default 50),
                    '   Line grid(default 1)
                    MyUniverse.SysGen.Snaps.MySnap = MyMinMax(My_INT(Pop(X0, FD)), 1, 10)
                    MyUniverse.SysGen.Snaps.MyPointSnap = MyMinMax(My_INT(Pop(X0, FD)), 1, 250)
                    MyUniverse.SysGen.Snaps.MySymbolSnap = MyMinMax(My_INT(Pop(X0, FD)), 1, 10000)
                    ''''''MyUniverse.SysGen.Snaps.MaxSymbolInYSpacing = MyMinMax(My_INT(Pop(X0, FD)), MyUniverse.SysGen.Constants.ConstantSymbolCenter * 2, MyUniverse.SysGen.Constants.ConstantSymbolCenter * 10)
                Case "dump"
                    MyDoEvents(158)
                    X2 = Pop(X0, FD)
                    MyDoEvents(159)
                    X3 = Pop(X0, FD)
                    X4 = Pop(X0, FD)
                    MyInfo(626, "Dump Files Set to", vbTab & X2 & vbTab & X3 & vbTab & X4, "")
                    MyUniverse.MySystem.Dumps.OutputFileName1 = X2
                    MyUniverse.MySystem.Dumps.OutputFileName2 = X3
                    MyUniverse.MySystem.Dumps.OutputFileName3 = X4
                    'todo kill all dump file when you start and also when you import another dump file (delete the old, and also the new)
                    If Dir(MyUniverse.MySystem.Dumps.OutputFileName1) <> "" Then Kill(MyUniverse.MySystem.Dumps.OutputFileName1)
                    If Dir(MyUniverse.MySystem.Dumps.OutputFileName2) <> "" Then Kill(MyUniverse.MySystem.Dumps.OutputFileName2)
                Case Else
                    MSG_ABug(1332, "unknown set command ", ImportLine, HighLight(X0) & HighLight(X1))
            End Select
        End Sub


        Public Shared Sub DoOption(WhichOne As Int32, HowMuch As String, OtherOptions As String)
            Dim I As Int32
            Dim X As String
            Dim Level As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3086, 10, "DoOption")
#End If

            Select Case WhichOne
                Case 51
                    For I = LBound(MyMessageBits) To UBound(MyMessageBits)
                        MyMessageBits(I) = 255 ' Turn "on" all message and debug bits
                    Next I
                    For I = LBound(MyTraceBits) To UBound(MyTraceBits)
                        MyTraceBits(I) = 255 ' Turn "on" all message and debug bits
                    Next I
                Case 53 '    Turn off information messages
                    For I = 0 To OptionsWindow.ComboBoxDebug.Items.Count - 1
                        X = OptionsWindow.ComboBoxDebug.Items.Item(I).ToString
                        Level = PopValue(X)
                        If LCase(Trim(Pop(X, MyUniverse.SysGen.Constants.ConstantDelimiters))) = "information" Then
                            BitSet(Level, "off") ' turn on or off all information that can show up
                        End If
                    Next
                Case 54 '    Turn off warning messages
                    For I = 0 To OptionsWindow.ComboBoxDebug.Items.Count - 1
                        X = OptionsWindow.ComboBoxDebug.Items.Item(I).ToString
                        Level = PopValue(X)
                        If LCase(Trim(Pop(X, MyUniverse.SysGen.Constants.ConstantDelimiters))) = "warning" Then
                            BitSet(Level, "off") ' turn on or off all information that can show up
                        End If
                    Next
                Case 55 '    Turn off wrong messages
                    For I = 0 To OptionsWindow.ComboBoxDebug.Items.Count - 1
                        X = OptionsWindow.ComboBoxDebug.Items.Item(I).ToString
                        Level = PopValue(X)
                        If LCase(Trim(Pop(X, MyUniverse.SysGen.Constants.ConstantDelimiters))) = "wrong" Then
                            BitSet(Level, "off") ' turn on or off all information that can show up
                        End If
                    Next
                Case Else
                    If WhichOne >= 998 And WhichOne < 10000 Then
                        BitSet(WhichOne, HowMuch)
                    End If
            End Select
        End Sub


        Public Shared Sub ImportColors(Key_Line As String)
            Dim Temp As String
            Dim Temp2 As Int32
            Dim IndexColor As Int32
            Dim Inputline As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3087, 10, "ImportColors")
#End If
            Inputline = TrimEqual(Key_Line)
            If MyDebug(11) Then follow(2841, 11, "Import colors " & Key_Line)
            MyMakeArraySizesBigger()
            Temp = Pop(Inputline, MyUniverse.SysGen.Constants.ConstantDelimiters)
            If Temp = "=" Then ' this is added because of the change in delimiters 2020 08 13
                Temp = Pop(Inputline, MyUniverse.SysGen.Constants.ConstantDelimiters)
            End If
            Temp = MyTrim(NoFD(Temp)) ' re-moved any commas
            'should never return a -1
            If PrintAbleNull(Temp) = "_" Then
                'MyMsgCtr(1413, "ImportColors", Temp, "16", "", "", "", "", "", "", "")
                Return
            End If
            CheckForAnySortNeeded(209)
            'ShowSorts("Color", MyReSort("Color", Color_FileName, Color_Name_ISAM, IndexColor)) '3/13/19 incase of a color being added to the end
            IndexColor = FindIndexInISAMTable("Color", "add", Color_FileName, Color_Name_ISAM, Temp) 'hack
            'ShowSorts("Color", MyReSort("Color", Color_FileName, Color_Name_ISAM, IndexColor)) '3/13/19 incase of a color being added to the end
            'IndexColor = FindIndexInISAMTable("Color", "add", Color_FileName, Color_Name_ISAM, Temp) 'hack
            If IndexColor < 0 Then 'This is if the color is not found and can not be added.
                CheckForAnySortNeeded(215)
                IndexColor = FindIndexInISAMTable("Color", "add", Color_FileName, Color_Name_ISAM, Temp) 'hack
                If IndexColor = ConstantMyErrorCode Then
                    IndexColor = NewTopOfFile("Color")
                End If
            Else
                Temp2 = MyMinMax(IndexColor, 1, TopOfFile("Color"))
                If Temp2 <> IndexColor Then
                    MSG_ABug(1335, "ImportColors():", Temp2.ToString, IndexColor.ToString)
                End If
            End If
            ' Not in the table, so search for the closest name to this and make that the default color's

            If Color_Name_ISAM(IndexColor) = 0 Then
                Color_Name_ISAM(IndexColor) = IndexColor ' Add a missing ISAM pointer
            End If


            'Color_TableName(Index) = Pop(KeyLine)
            Color_TableAlpha(IndexColor, PopValue(Inputline)) ' Alpha
            Color_TableRed(IndexColor, PopValue(Inputline)) 'Red
            Color_TableGreen(IndexColor, PopValue(Inputline)) 'Green
            Color_TableBlue(IndexColor, PopValue(Inputline)) 'Blue
            '****** This is wrong, because all of the options are not available for all of the CAP styles, need to fix this later
            Color_TableStyle(IndexColor, Pop(Inputline, MyUniverse.SysGen.Constants.ConstantDelimiters)) ' ConstantEnumStyle, Inputline)
            Color_TableStartCap(IndexColor, MyEnumValue(Pop(Inputline, MyUniverse.SysGen.Constants.ConstantDelimiters), SymbolWindow.ToolStripDropDownPathStart))
            Color_TableEndCap(IndexColor, MyEnumValue(Pop(Inputline, MyUniverse.SysGen.Constants.ConstantDelimiters), SymbolWindow.ToolStripDropDownPathEnd))
            CheckForAnySortNeeded(217) 'hack


            ShowSorts("Color", MyReSort("Color", Color_FileName, Color_Name_ISAM, IndexColor)) '03/12/19 only resort top item if changed
            CheckForAnySortNeeded(218) 'hack
            'DisplayMyStatus(7," Added Color " & Temp)
            TopOfFile("color") ' This is to update the top of file, and make the array bigger
            'TestIfColorStandardMicroSoftColorName(IndexColor)
            SymbolWindow.ToolStripDropDownButtonColor.DropDownItems.Add(Color_TableName(IndexColor))
        End Sub


        Public Shared Sub ImportSymbolPointPreference()
#If MINEDEBUG Then
  if mydebug(9) then follow(3088, 10, "ImportSymbolPointPreference")
#End If
            MyUniverse.MySymbolPoints(0).x = -250 : MyUniverse.MySymbolPoints(0).y = -250
            MyUniverse.MySymbolPoints(1).x = 0 : MyUniverse.MySymbolPoints(1).y = -250
            MyUniverse.MySymbolPoints(2).x = 0 : MyUniverse.MySymbolPoints(2).y = 250
            MyUniverse.MySymbolPoints(3).x = 250 : MyUniverse.MySymbolPoints(3).y = 0
            MyUniverse.MySymbolPoints(4).x = -250 : MyUniverse.MySymbolPoints(4).y = 0
            MyUniverse.MySymbolPoints(5).x = -150 : MyUniverse.MySymbolPoints(5).y = -250
            MyUniverse.MySymbolPoints(6).x = 150 : MyUniverse.MySymbolPoints(6).y = -250
            MyUniverse.MySymbolPoints(7).x = 150 : MyUniverse.MySymbolPoints(7).y = 250
            MyUniverse.MySymbolPoints(8).x = -150 : MyUniverse.MySymbolPoints(8).y = 250
            MyUniverse.MySymbolPoints(9).x = -250 : MyUniverse.MySymbolPoints(9).y = -250
            MyUniverse.MySymbolPoints(10).x = 250 : MyUniverse.MySymbolPoints(10).y = -250
            MyUniverse.MySymbolPoints(11).x = 250 : MyUniverse.MySymbolPoints(11).y = 250
            MyUniverse.MySymbolPoints(12).x = -250 : MyUniverse.MySymbolPoints(12).y = 250
            MyUniverse.MySymbolPoints(13).x = -250 : MyUniverse.MySymbolPoints(13).y = -150
            MyUniverse.MySymbolPoints(14).x = 250 : MyUniverse.MySymbolPoints(14).y = -150
            MyUniverse.MySymbolPoints(15).x = 250 : MyUniverse.MySymbolPoints(15).y = 150
            MyUniverse.MySymbolPoints(16).x = -250 : MyUniverse.MySymbolPoints(16).y = 150
            MyUniverse.MySymbolPoints(17).x = -150 : MyUniverse.MySymbolPoints(17).y = -150
            MyUniverse.MySymbolPoints(18).x = 150 : MyUniverse.MySymbolPoints(18).y = -150
            MyUniverse.MySymbolPoints(19).x = 150 : MyUniverse.MySymbolPoints(19).y = 150
            MyUniverse.MySymbolPoints(20).x = -150 : MyUniverse.MySymbolPoints(20).y = 150
            MyUniverse.MySymbolPoints(21).x = -50 : MyUniverse.MySymbolPoints(21).y = -50
            MyUniverse.MySymbolPoints(22).x = 50 : MyUniverse.MySymbolPoints(22).y = -50
            MyUniverse.MySymbolPoints(23).x = 50 : MyUniverse.MySymbolPoints(23).y = 50
            MyUniverse.MySymbolPoints(24).x = -50 : MyUniverse.MySymbolPoints(24).y = 50
            MyUniverse.MySymbolPoints(25).x = -50 : MyUniverse.MySymbolPoints(25).y = 0
            MyUniverse.MySymbolPoints(26).x = 50 : MyUniverse.MySymbolPoints(26).y = 0
            MyUniverse.MySymbolPoints(27).x = 0 : MyUniverse.MySymbolPoints(27).y = -50
            MyUniverse.MySymbolPoints(28).x = 0 : MyUniverse.MySymbolPoints(28).y = 50
            MyUniverse.MySymbolPoints(29).x = -100 : MyUniverse.MySymbolPoints(29).y = 100
            MyUniverse.MySymbolPoints(30).x = 100 : MyUniverse.MySymbolPoints(30).y = 100
            MyUniverse.MySymbolPoints(31).x = 100 : MyUniverse.MySymbolPoints(31).y = -100
            MyUniverse.MySymbolPoints(32).x = -100 : MyUniverse.MySymbolPoints(32).y = -100
            MyUniverse.MySymbolPoints(33).x = -100 : MyUniverse.MySymbolPoints(33).y = 0
            MyUniverse.MySymbolPoints(34).x = 0 : MyUniverse.MySymbolPoints(34).y = 100
            MyUniverse.MySymbolPoints(35).x = 100 : MyUniverse.MySymbolPoints(35).y = 0
            MyUniverse.MySymbolPoints(36).x = 0 : MyUniverse.MySymbolPoints(36).y = -100
            MyUniverse.MySymbolPoints(37).x = -150 : MyUniverse.MySymbolPoints(37).y = -100
            MyUniverse.MySymbolPoints(38).x = 150 : MyUniverse.MySymbolPoints(38).y = 100
            MyUniverse.MySymbolPoints(39).x = 150 : MyUniverse.MySymbolPoints(39).y = -100
            MyUniverse.MySymbolPoints(40).x = -150 : MyUniverse.MySymbolPoints(40).y = 100
            MyUniverse.MySymbolPoints(41).x = -150 : MyUniverse.MySymbolPoints(41).y = 0
            MyUniverse.MySymbolPoints(42).x = 150 : MyUniverse.MySymbolPoints(42).y = 0
            MyUniverse.MySymbolPoints(43).x = 0 : MyUniverse.MySymbolPoints(43).y = -150
            MyUniverse.MySymbolPoints(44).x = 0 : MyUniverse.MySymbolPoints(44).y = 150
            MyUniverse.MySymbolPoints(45).x = -200 : MyUniverse.MySymbolPoints(45).y = 0
            MyUniverse.MySymbolPoints(46).x = 0 : MyUniverse.MySymbolPoints(46).y = -200
            MyUniverse.MySymbolPoints(47).x = 0 : MyUniverse.MySymbolPoints(47).y = 200
            MyUniverse.MySymbolPoints(48).x = 200 : MyUniverse.MySymbolPoints(48).y = 0
            MyUniverse.MySymbolPoints(49).x = -200 : MyUniverse.MySymbolPoints(49).y = -150
            MyUniverse.MySymbolPoints(50).x = -200 : MyUniverse.MySymbolPoints(50).y = -100
            MyUniverse.MySymbolPoints(51).x = -200 : MyUniverse.MySymbolPoints(51).y = 100
            MyUniverse.MySymbolPoints(52).x = -200 : MyUniverse.MySymbolPoints(52).y = 150
            MyUniverse.MySymbolPoints(53).x = 200 : MyUniverse.MySymbolPoints(53).y = 150
            MyUniverse.MySymbolPoints(54).x = 200 : MyUniverse.MySymbolPoints(54).y = 100
            MyUniverse.MySymbolPoints(55).x = 200 : MyUniverse.MySymbolPoints(55).y = -100
            MyUniverse.MySymbolPoints(56).x = 200 : MyUniverse.MySymbolPoints(56).y = -150
            MyUniverse.MySymbolPoints(57).x = -100 : MyUniverse.MySymbolPoints(57).y = -150
            MyUniverse.MySymbolPoints(58).x = -100 : MyUniverse.MySymbolPoints(58).y = 150
            MyUniverse.MySymbolPoints(59).x = 100 : MyUniverse.MySymbolPoints(59).y = 150
            MyUniverse.MySymbolPoints(60).x = 100 : MyUniverse.MySymbolPoints(60).y = -150
            MyUniverse.MySymbolPoints(61).x = -50 : MyUniverse.MySymbolPoints(61).y = -100
            MyUniverse.MySymbolPoints(62).x = -50 : MyUniverse.MySymbolPoints(62).y = 100
            MyUniverse.MySymbolPoints(63).x = 50 : MyUniverse.MySymbolPoints(63).y = 100
            MyUniverse.MySymbolPoints(64).x = 50 : MyUniverse.MySymbolPoints(64).y = -100
            MyUniverse.MySymbolPoints(65).x = -50 : MyUniverse.MySymbolPoints(65).y = -150
            MyUniverse.MySymbolPoints(66).x = 50 : MyUniverse.MySymbolPoints(66).y = -150
            MyUniverse.MySymbolPoints(67).x = 50 : MyUniverse.MySymbolPoints(67).y = 150
            MyUniverse.MySymbolPoints(68).x = -50 : MyUniverse.MySymbolPoints(68).y = 150
            MyUniverse.MySymbolPoints(69).x = -100 : MyUniverse.MySymbolPoints(69).y = 50
            MyUniverse.MySymbolPoints(70).x = -100 : MyUniverse.MySymbolPoints(70).y = -50
            MyUniverse.MySymbolPoints(71).x = 100 : MyUniverse.MySymbolPoints(71).y = -50
            MyUniverse.MySymbolPoints(72).x = 100 : MyUniverse.MySymbolPoints(72).y = 50
            MyUniverse.MySymbolPoints(73).x = -150 : MyUniverse.MySymbolPoints(73).y = -200
            MyUniverse.MySymbolPoints(74).x = 150 : MyUniverse.MySymbolPoints(74).y = -200
            MyUniverse.MySymbolPoints(75).x = 150 : MyUniverse.MySymbolPoints(75).y = -50
            MyUniverse.MySymbolPoints(76).x = 150 : MyUniverse.MySymbolPoints(76).y = 50
            MyUniverse.MySymbolPoints(77).x = -150 : MyUniverse.MySymbolPoints(77).y = 50
            MyUniverse.MySymbolPoints(78).x = -150 : MyUniverse.MySymbolPoints(78).y = -50
            MyUniverse.MySymbolPoints(79).x = -200 : MyUniverse.MySymbolPoints(79).y = -200
            MyUniverse.MySymbolPoints(80).x = -100 : MyUniverse.MySymbolPoints(80).y = -200
            MyUniverse.MySymbolPoints(81).x = -50 : MyUniverse.MySymbolPoints(81).y = -200
            MyUniverse.MySymbolPoints(82).x = 50 : MyUniverse.MySymbolPoints(82).y = -200
            MyUniverse.MySymbolPoints(83).x = 100 : MyUniverse.MySymbolPoints(83).y = -200
            MyUniverse.MySymbolPoints(84).x = 200 : MyUniverse.MySymbolPoints(84).y = -200
            MyUniverse.MySymbolPoints(85).x = 200 : MyUniverse.MySymbolPoints(85).y = -50
            MyUniverse.MySymbolPoints(86).x = 200 : MyUniverse.MySymbolPoints(86).y = 50
            MyUniverse.MySymbolPoints(87).x = 200 : MyUniverse.MySymbolPoints(87).y = 200
            MyUniverse.MySymbolPoints(88).x = 150 : MyUniverse.MySymbolPoints(88).y = 200
            MyUniverse.MySymbolPoints(89).x = 100 : MyUniverse.MySymbolPoints(89).y = 200
            MyUniverse.MySymbolPoints(90).x = 50 : MyUniverse.MySymbolPoints(90).y = 200
            MyUniverse.MySymbolPoints(91).x = -50 : MyUniverse.MySymbolPoints(91).y = 200
            MyUniverse.MySymbolPoints(92).x = -100 : MyUniverse.MySymbolPoints(92).y = 200
            MyUniverse.MySymbolPoints(93).x = -150 : MyUniverse.MySymbolPoints(93).y = 200
            MyUniverse.MySymbolPoints(94).x = -200 : MyUniverse.MySymbolPoints(94).y = 200
            MyUniverse.MySymbolPoints(95).x = -200 : MyUniverse.MySymbolPoints(95).y = 50
            MyUniverse.MySymbolPoints(96).x = -200 : MyUniverse.MySymbolPoints(96).y = -50
            MyUniverse.MySymbolPoints(97).x = -200 : MyUniverse.MySymbolPoints(97).y = -250
            MyUniverse.MySymbolPoints(98).x = -100 : MyUniverse.MySymbolPoints(98).y = -250
            MyUniverse.MySymbolPoints(99).x = -50 : MyUniverse.MySymbolPoints(99).y = -250
            MyUniverse.MySymbolPoints(100).x = 50 : MyUniverse.MySymbolPoints(100).y = -250
            MyUniverse.MySymbolPoints(101).x = 100 : MyUniverse.MySymbolPoints(101).y = -250
            MyUniverse.MySymbolPoints(102).x = 200 : MyUniverse.MySymbolPoints(102).y = -250
            MyUniverse.MySymbolPoints(103).x = 250 : MyUniverse.MySymbolPoints(103).y = -200
            MyUniverse.MySymbolPoints(104).x = 250 : MyUniverse.MySymbolPoints(104).y = -100
            MyUniverse.MySymbolPoints(105).x = 250 : MyUniverse.MySymbolPoints(105).y = -50
            MyUniverse.MySymbolPoints(106).x = 250 : MyUniverse.MySymbolPoints(106).y = 50
            MyUniverse.MySymbolPoints(107).x = 250 : MyUniverse.MySymbolPoints(107).y = 100
            MyUniverse.MySymbolPoints(108).x = 250 : MyUniverse.MySymbolPoints(108).y = 200
            MyUniverse.MySymbolPoints(109).x = 200 : MyUniverse.MySymbolPoints(109).y = 250
            MyUniverse.MySymbolPoints(110).x = 100 : MyUniverse.MySymbolPoints(110).y = 250
            MyUniverse.MySymbolPoints(111).x = 50 : MyUniverse.MySymbolPoints(111).y = 250
            MyUniverse.MySymbolPoints(112).x = -50 : MyUniverse.MySymbolPoints(112).y = 250
            MyUniverse.MySymbolPoints(113).x = -100 : MyUniverse.MySymbolPoints(113).y = 250
            MyUniverse.MySymbolPoints(114).x = -200 : MyUniverse.MySymbolPoints(114).y = 250
            MyUniverse.MySymbolPoints(115).x = -250 : MyUniverse.MySymbolPoints(115).y = 200
            MyUniverse.MySymbolPoints(116).x = -250 : MyUniverse.MySymbolPoints(116).y = 100
            MyUniverse.MySymbolPoints(117).x = -250 : MyUniverse.MySymbolPoints(117).y = 50
            MyUniverse.MySymbolPoints(118).x = -250 : MyUniverse.MySymbolPoints(118).y = -50
            MyUniverse.MySymbolPoints(119).x = -250 : MyUniverse.MySymbolPoints(119).y = -100
            MyUniverse.MySymbolPoints(120).x = -250 : MyUniverse.MySymbolPoints(120).y = -200
            MyUniverse.MySymbolPoints(121).x = 0 : MyUniverse.MySymbolPoints(121).y = 0


        End Sub


        Public Shared Function FillImportLine() As ImportLineStruct
#If MINEDEBUG Then
  if mydebug(9) then follow(3089, 10, "FillImportLine")
#End If

            FillImportLine = Nothing
            FillImportLine.LastName = ""
            FillImportLine.IndexName = -1
            FillImportLine.IndexSymbol = -1
            FillImportLine.TopMost = -1

            FillImportLine.Inputs.AllText = "?"
            FillImportLine.Inputs.KPar = "?"
            FillImportLine.Inputs.KWord = "?"
            FillImportLine.Inputs.LineNumberIn = 1

            FillImportLine.Temps.TempInteger1 = -1
            FillImportLine.Temps.TempString2 = "off"
            FillImportLine.Temps.TempFormat = "?"
            FillImportLine.Temps.TempRecord = -1

            FillImportLine.MyRecord.Coded = 0
            FillImportLine.MyRecord.X1 = -1
            FillImportLine.MyRecord.Y1 = -1
            FillImportLine.MyRecord.X2.MyString = ""
            FillImportLine.MyRecord.Y2.MyString = ""
            FillImportLine.MyRecord.X2.MyNumber = 0
            FillImportLine.MyRecord.Y2.MyNumber = 0
            FillImportLine.MyRecord.NameOfPoint = "?"

        End Function


        Public Shared Function ImportLineOrFile(TAll As String) As String
            Dim I As Int32
            Dim TKey, TPar As String 'todo these should have been for debug only, but make sure that are 'really' used before deleting.
#If MINEDEBUG Then
  if mydebug(9) then follow(3090, 10, "ImportLineOrFile")
#End If
            If TAll = "" Then Return ""

            I = InStr(TAll & vbCrLf, vbCrLf) - 1
            If MyDebug(5) Then Follow(2437, "ImportLineFile = " & MyLeft(TAll, I))

            MyMakeArraySizesBigger()
            'process all 
            'make sure that i include anything left over not done.

            'tall = InputLine_or_File
            TPar = ""
            While Len(TAll) > 0 Or Len(TPar) > 0
                ' removed Mydoevents(160)
                TAll = MyTrim(TAll)
                TPar = PopLine(TAll)
                TAll = MyTrim(TAll)               ' Mid(TAll, 1 + Len(TPar), Len(TAll))
                'Temp1 = Tpar
                TKey = MyTrim(MyReplace(Pop(TPar, "="), "=", ""))
                TPar = MyTrim(TPar)
                'TAll = TAll
                If MyUniverse.MySS.Inputs.LineNumberIn <> 0 And Int(MyUniverse.MySS.Inputs.LineNumberIn / 100) * 100 = MyUniverse.MySS.Inputs.LineNumberIn Then
                    DisplayMyStatus(7, "At Line " & MyUniverse.MySS.Inputs.LineNumberIn & MyUniverse.ProgramOptions.FCCL_WhiteSpace & TKey & "=" & TPar)
                End If
                If (InStr(TKey, "::=") <> 0) And (MyLeft(TKey, 1) <> "/") Then
                    If mydebug(9) Then follow(2727, 1, MyNoCR(SHL(TKey) & " : " & Mid(TAll, 1, MyMinMax(Len(TAll), 32, 128))))
                    If mydebug(9) Then follow(2901, 1, "A) Decompile " & Len(TAll) & "=" & TKey & FD & TPar)
                End If
                If MyDebug(11) Then follow(2901, 11, "A) Decompile " & Len(TAll) & "=" & TKey & FD & TPar)
                Select Case LCase(MyTrim(TKey))
                    Case "/Grammar"
                        'MyInfo(990, "Grammar", tkey, Tpar)
                        MyUniverse.Grammar = True 'This is to tell that a Grammar has been entered.
                        TPar = FixGrammar(TPar)
                        TPar = MyTrim(TPar)
                        If InStr(TPar, "::=") <> 0 Then
                            AddSortedList(MyUniverse.SysGen.Constants.SyntaxGrammar, TPar, Language_Grammar)
                        Else
                            MSG_ABug(2346, "a /Grammar is missing ::=  in the definition", TPar, "")
                        End If
                    Case "/debug"
                        MyUniverse.FCCLDebugLevel = PopValue(TPar)
                        If MyUniverse.FCCLDebugLevel < 1 Then MyUniverse.FCCLDebugLevel = DefaultDebugLevel
                        If MyUniverse.FCCLDebugLevel > 11 Then MyUniverse.FCCLDebugLevel = 11
                        MSG_AInfo(2728, "/De Bug set to ", MyUniverse.FCCLDebugLevel.ToString, "")
                    Case "/import"
                    Case "/export"
                    Case "/login"
                    Case "/drilldown"
                        MyDeCompile(FlowChartWindow.PictureBox1, TPar)
                    Case "/dump"
                        Dump2()
                    Case "/ConstantQuote"
                        MyUniverse.SysGen.Constants.ConstantQuote = TPar
                    Case "/SyntaxQuotes"
                        MyUniverse.SysGen.Constants.SyntaxQuotes = TPar
                    Case "/SyntaxNumber"
                        MyUniverse.SysGen.Constants.SyntaxNumbers = TPar
                    Case "/SyntaxAlpha"
                        MyUniverse.SysGen.Constants.SyntaxAlphas = TPar
                    Case "/SyntaxSpecialCharacters"
                        MyUniverse.SysGen.Constants.SyntaxSpecialCharacters = TPar
                    Case "/SyntaxComment"
                        MyUniverse.SysGen.Constants.SyntaxComments = TPar
                    Case "/ConstantSymbolCenter"
                        MyUniverse.SysGen.Constants.ConstantSymbolCenter = PopValue(TPar)
                    Case "/ConstantSpacingFactor"
                        MyUniverse.SysGen.Constants.ConstantSpacingFactor = PopValue(TPar)
                    Case "/ConstantMinPenSize"
                        MyUniverse.SysGen.Constants.ConstantMinPenSize = PopValue(TPar)
                    Case "/ConstantMaxPenSize"
                        MyUniverse.SysGen.Constants.ConstantMaxPenSize = PopValue(TPar)
                    Case "/ConstantMinBoxSize"
                        MyUniverse.SysGen.Constants.ConstantMinBoxSize = PopValue(TPar)
                    Case "/ConstantFirstLineTextOffset"
                        MyUniverse.SysGen.Constants.ConstantFirstLineTextOffset = PopValue(TPar)
                    Case "/ConstantSecondLineTextOffset"
                        MyUniverse.SysGen.Constants.ConstantSecondLineTextOffset = PopValue(TPar)
                    Case "/ConstantDistanceBetweenControls"
                        MyUniverse.SysGen.Constants.ConstantDistanceBetweenControls = PopValue(TPar)
                    Case "/ConstantRecordsBeforeSaveIsAllowed"
                        MyUniverse.SysGen.Constants.ConstantRecordsBeforeSaveIsAllowed = PopValue(TPar)
                    Case "/ConstantDistanceToMovePaths"
                        MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths = PopValue(TPar)
                    Case "/ConstantSpecialCharacters"
                        MyUniverse.SysGen.Constants.ConstantSpecialCharacters = TPar
                    Case "/ConstantWhiteSpace"
                        MyUniverse.SysGen.Constants.ConstantWhiteSpaces = ""
                        TPar = TPar
                        While Len(TPar) > 0
                            I = PopValue(TPar)
                            If I > 0 Then
                                MyUniverse.SysGen.Constants.ConstantWhiteSpaces &= Chr(I)
                            End If
                        End While
                    Case "/ConstantDelimiters"
                        MyUniverse.SysGen.Constants.ConstantDelimiters = ""
                        While Len(TPar) <> 0
                            MyUniverse.SysGen.Constants.ConstantDelimiters &= Chr(PopValue(TPar)).ToString
                        End While
                    Case "/SyntaxCameFromLine"
                        MyUniverse.SysGen.Constants.SyntaxCameFromLine = TPar
                    Case "/ConstantGo_Tonextlin"
                        MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine = TPar
                    Case "/route"
                        For I = 1 To UBound(Net_FileLinks)
                            RouterTicked()
                            MyROUTERnetIndex(I)
                        Next I
                    Case "/ignore"
                        TPar = "" ' Ignore everything on this
                    Case "/set"
                        SetOptions(TPar)
                    Case "/option"
                        MyUniverse.MySS.Temps.TempFormat = FormatOption
                        If IsThisANumber(TPar) Then
                            MyUniverse.MySS.Temps.TempInteger1 = PopValue(TPar)
                            MyUniverse.MySS.Temps.TempInt32 = PopValue(TPar)
                            If MyUniverse.MySS.Temps.TempInt32 = 0 Then
                                MyUniverse.MySS.Temps.TempString2 = "off"
                            Else
                                MyUniverse.MySS.Temps.TempString2 = "on"
                            End If
                            BitSet(MyMinMax(MyUniverse.MySS.Temps.TempInteger1, 1, 10000 - 1), MyUniverse.MySS.Temps.TempString2)
                        End If
                    Case "/FCCL_case"
                        If MyTrim(TPar) <> "" Then
                            MyUniverse.ProgramOptions.FCCL_Case = MyTrim(TPar)
                        Else
                        End If
                    Case "/FCCL_multiline"
                        If MyTrim(TPar) <> "" Then
                            MyUniverse.ProgramOptions.FCCL_MultiLine = MyTrim(TPar)
                        End If
                        MyUniverse.ProgramOptions.FCCL_MultiLine = ReplaceWithactualControlCharacter(MyUniverse.ProgramOptions.FCCL_MultiLine)
                    Case "/FCCL_comment"
                        If MyTrim(TPar) <> "" Then MyUniverse.ProgramOptions.FCCL_Comment = MyTrim(TPar)
                    Case "/FCCL_Extension"
                        TPar = TPar
                        MyUniverse.ProgramOptions.FCCL_Extension = ""
                        While Len(TPar) > 0
                            TKey = Pop(TPar, FD)
                            If Len(TKey) > 0 Then
                                If MyLeft(TKey, 1) <> "." Then
                                    MyUniverse.ProgramOptions.FCCL_Extension &= "." & TKey & FD
                                Else
                                    MyUniverse.ProgramOptions.FCCL_Extension &= TKey & FD
                                End If
                            End If
                        End While
                    Case "/FCCL_varchars"
                        If MyTrim(TPar) <> "" Then MyUniverse.ProgramOptions.FCCL_VarChars = MyTrim(TPar)
                    Case "/FCCL_DialectName"
                        If MyTrim(TPar) <> "" Then MyUniverse.ProgramOptions.FCCL_DialectName = MyTrim(TPar)
                    Case "/syntaxGo_Tonextline"
                        If MyTrim(TPar) <> "" Then MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine = MyTrim(TPar)
                    Case "/syntaxCameFromline"
                        If MyTrim(TPar) <> "" Then MyUniverse.SysGen.Constants.SyntaxCameFromLine = MyTrim(TPar)
                    Case "/FCCL_process"
                        If MyTrim(TPar) <> "" Then MyUniverse.ProgramOptions.FCCL_Process = MyTrim(TPar)
                    Case "/color"
                        MyUniverse.MySS.Temps.TempFormat = formatColor
                        ImportColors(TPar)
                        ShowSorts("Color", SortColors())'20200702
                    Case "/DataType"
                        MyUniverse.MySS.Temps.TempFormat = formatDataType
                        ImportDataTypes(TPar)
                        SortDataType()
                    Case "/name"
                        MyUniverse.MySS.Temps.TempFormat = formatSymbolName
                        ShowSorts("Named", MyReSort("Named", Named_FileSyntax, Named_FileSyntax_ISAM, TopOfFile("named")))
                        ShowSorts("Named", MyReSort("Named", Named_FileSymbolName, Named_FileSymbolName_ISAM, TopOfFile("named")))
                        MyUniverse.MySS.LastName = Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)
                        CheckForAnySortNeeded(219)
                        ' @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                        ' is returning the wrong should be 1 and returns 0
                        MyUniverse.MySS.IndexName = FindIndexInISAMTable("Named", "add", Named_FileSymbolName, Named_FileSymbolName_ISAM, MyUniverse.MySS.LastName)
                        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                        If MyUniverse.MySS.IndexName = ConstantMyErrorCode Then
                            MSG_ABug(1375, TAll, "The index for the Symbol is not found.", MyUniverse.MySS.LastName)
                            MyUniverse.MySS.IndexName = AddNewNamedRecord(MyUniverse.MySS.LastName, "?", "?", "?", "?", "?", "?", "?", "?") ', "?"
                            MyUniverse.MySS.IndexName = TopOfFile("named")
                            MyUniverse.MySS.IndexName = FindIndexInISAMTable("Named", "Don Add Find Again after Sort", Named_FileSymbolName, Named_FileSymbolName_ISAM, MyUniverse.MySS.LastName)
                            CheckForAnySortNeeded(223)
                        End If
                        If MyUniverse.MySS.IndexName = ConstantMyErrorCode Then
                            'MSG_ABug(1376, tall, 0,"") ' We should find it after adding it
                            'MyMsgCtr(1100, "Import", MyUniverse.MySS.LastName, tall, MyUniverse.MySS.Inputs.LineNumberIn.ToString, "", "", "", "", "", "")
                        Else
                            ' Get the Direct Array Indexes
                            If Named_TableSymbolName(MyUniverse.MySS.IndexName) <> MyUniverse.MySS.LastName Then
                                MSG_ABug(1377, TAll, "3", "3") ' we should always have the name after we have just found it'
                            End If
                            'Named_TableSymbolName(MyUniverse.MySS.indexname, MyUniverse.MySS.lastname) ' why are we replacing it when we just found it?
                            MyMakeArraySizesBigger()
                            If PrintAbleNull(TPar) = "_" Then ' This is testing for all options that should be in this Symbol
                                TPar = "?" & MyUniverse.MySS.LastName
                            End If
                            MyUniverse.MySS.IndexSymbol = FindInSymbolList(MyUniverse.MySS.LastName)
                            If MyUniverse.MySS.IndexSymbol = ConstantMyErrorCode Then
                                AddNEWSymbolpointRecord(MyUniverse.MySS.LastName, "/name", 0, 0, MyUniverse.ProgramOptions.SelectedInputOutput, MyUniverse.ProgramOptions.SelectedDataType, TPar)
                                MyUniverse.MySS.IndexSymbol = TopOfFile("Symbol")
                            End If
                            If MyUniverse.MySS.IndexSymbol > ConstantMyErrorCode Then ' replace any information that is already there (If added, then is always something there
                                'Debug, check if this is updating the table after finding it above
                                Symbol_FileCoded(MyUniverse.MySS.IndexSymbol) = MyKeyword_2_Byte("/name") ' KeyConstName '"/name"
                                'Symbol_TableSymbolName(MyUniverse.MySS.indexSymbol, MyUniverse.MySS.lastname)' Did not need to do it again!!!!!
                                Symbol_Table_NameOfPoint(MyUniverse.MySS.IndexSymbol, TPar)
                                Symbol_TableX1(MyUniverse.MySS.IndexSymbol, 1)
                                Symbol_TableY1(MyUniverse.MySS.IndexSymbol, 1)
                                Symbol_Table_X2(MyUniverse.MySS.IndexSymbol, 1)
                                Symbol_Table_Y2(MyUniverse.MySS.IndexSymbol, 1)
                                Symbol_TableX1(MyUniverse.MySS.IndexSymbol, 1)
                            Else
                                MyMsgCtr(1411, "Import", MyUniverse.MySS.IndexSymbol.ToString, TopOfFile("Symbol").ToString, TKey, TAll, MyUniverse.MySS.Inputs.LineNumberIn.ToString, "", "", "", "")
                            End If
                        End If
                    Case "/point"
                        MyUniverse.MySS.Temps.TempFormat = formatPoint
                        TPar = XTrim(TPar)
                        MyUniverse.MySS.MyRecord.a.x = PopValue(TPar)
                        TPar = XTrim(TPar)
                        MyUniverse.MySS.MyRecord.a.y = PopValue(TPar)
                        MyUniverse.MySS.MyRecord.a = MyPointSnap(MyUniverse.MySS.MyRecord.a)
                        TPar = XTrim(TPar)
                        MyUniverse.MySS.MyRecord.X2.MyString = Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)
                        TPar = XTrim(TPar)
                        MyUniverse.MySS.MyRecord.Y2.MyString = Trim(Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters))
                        TPar = XTrim(TPar)
                        MyUniverse.MySS.MyRecord.NameOfPoint = TPar
                        TPar = XTrim(TPar)

                        ' This will inser them backwards, but who cares? (It should not make a difference because each record should be independant.
                        AddNEWSymbolpointRecord(MyUniverse.MySS.LastName, "/point", MyUniverse.MySS.MyRecord.X1, MyUniverse.MySS.MyRecord.Y1, MyUniverse.MySS.MyRecord.X2.MyString, MyUniverse.MySS.MyRecord.Y2.MyString, MyUniverse.MySS.MyRecord.NameOfPoint)
                        CheckForAnySortNeeded(230)

                        Symbol_Table_NameOfPoint(TopOfFile("Symbol"), TPar) ' For A point
                        ShowSorts("DataType", MyReSort("DataType", DataType_FileName, DataType_Name_ISAM, TopOfFile("Symbol"))) '3/12/19 only sort added 
                    Case "/line"
                        MyUniverse.MySS.Temps.TempFormat = formatLine
                        MyUniverse.MySS.TopMost = NewTopOfFile("Symbol")
                        Symbol_FileSymbolName(MyUniverse.MySS.TopMost) = "L_" & MyUniverse.MySS.TopMost ' No lines have input names, only color, so this is to allow other sorts to work
                        Symbol_TableCode(MyUniverse.MySS.TopMost, MyKeyword_2_Byte(TKey))
                        Symbol_TableX1(MyUniverse.MySS.TopMost, MyMinMax(MyLineSnap(PopValue(TPar)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter))
                        Symbol_TableY1(MyUniverse.MySS.TopMost, MyMinMax(MyLineSnap(PopValue(TPar)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter))
                        Symbol_Table_X2(MyUniverse.MySS.TopMost, MyMinMax(MyLineSnap(PopValue(TPar)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter))
                        Symbol_Table_Y2(MyUniverse.MySS.TopMost, MyMinMax(MyLineSnap(PopValue(TPar)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter))
                        Symbol_Table_NameOfPoint(MyUniverse.MySS.TopMost, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)) ' Color
                        If TPar = "" Then
                            Symbol_TableSymbolName(MyUniverse.MySS.TopMost, "Line" & TopOfFile("Symbol"))
                        Else
                            Symbol_TableSymbolName(MyUniverse.MySS.TopMost, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)) ' Optional, but should never be a named line, Only Paths
                        End If
                        MyMakeArraySizesBigger()
                    Case "/path"
                        MyUniverse.MySS.Temps.TempFormat = formatPath
                        MyUniverse.MySS.Temps.TempRecord = NewFlowChartRecord()
                        FlowChart_TableCode(MyUniverse.MySS.Temps.TempRecord, "/path") 'KeyConstPath)
                        FlowChart_TablePathSymbolName(MyUniverse.MySS.Temps.TempRecord, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)) 'name last
                        MyPathTextValues2Line(MyUniverse.MySS.Temps.TempRecord, TAll)


                        FlowChart_Table_DataType(MyUniverse.MySS.Temps.TempRecord, Trim(Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters))) ' DataType
                        ShowSorts("FlowChart", ReSortFlowChart(MyUniverse.MySS.Temps.TempRecord))
                        '20200709        PaintAll(Where, myy.temps.temprecord, myy.temps.temprecord)
                        MyMakeArraySizesBigger()
                        PaintAll(FlowChartWindow.PictureBox1, MyUniverse.MySS.Temps.TempRecord, MyUniverse.MySS.Temps.TempRecord)
                    Case My_keyWord(My_KeyConstUse)
                        MyUniverse.MySS.Temps.TempFormat = formatUse 'hack
                        MyUniverse.MySS.Temps.TempRecord = NewFlowChartRecord()
                        FlowChart_TableCode(MyUniverse.MySS.Temps.TempRecord, My_keyWord(My_KeyConstUse))
                        FlowChart_TablePathSymbolName(MyUniverse.MySS.Temps.TempRecord, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)) 'Name First
                        MyUseTextValues2Line(MyUniverse.MySS.Temps.TempRecord, TPar)
                        'FlowChart_TableX1(MyUniverse.MySS.Temps.TempRecord, MySymbolSnap(PopValue(tpar)))
                        'FlowChart_TableY1(MyUniverse.MySS.Temps.TempRecord, MySymbolSnap(PopValue(tpar)))
                        FlowChart_Table_Rotation(MyUniverse.MySS.Temps.TempRecord, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters))
                        FlowChart_Table_DataType(MyUniverse.MySS.Temps.TempRecord, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)) ' later for dynamic Symbols
                        ShowSorts("FlowChart", ReSortFlowChart(MyUniverse.MySS.Temps.TempRecord))
                        PaintAll(FlowChartWindow.PictureBox1, MyUniverse.MySS.Temps.TempRecord, MyUniverse.MySS.Temps.TempRecord)

                    Case "/MicroCodeText"
                        MyUniverse.MySS.Temps.TempFormat = FormatMacroText
                        If MyUniverse.MySS.IndexName > 0 Then
                            Named_TableMicroCodeText(MyUniverse.MySS.IndexName, Named_TableMicroCodeText(MyUniverse.MySS.IndexName) & vbCrLf & TPar & MyUniverse.ProgramOptions.FCCL_MultiLine)
                        Else
                            MyMsgCtr(1403, "Import", "/MicroCodeText", TKey & "=" & TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName, "", "", "", "", "")
                        End If
                    Case "/syntax"
                        MyUniverse.MySS.Temps.TempFormat = FormatSyntax
                        If MyUniverse.MySS.IndexName > 0 Then
                            Named_TableSyntax(MyUniverse.MySS.IndexName, Named_TableSyntax(MyUniverse.MySS.IndexName) & vbCr & TPar)
                        Else
                            MyMsgCtr(1403, "Import", "/Syntax", TKey & "=" & TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName, "", "", "", "", "")
                        End If

                    Case "/order"
                        MyUniverse.MySS.Temps.TempFormat = FormatOrder
                        MyUniverse.SysGen.Order = PopLine(TPar)
                    Case "/filename"
                        MyUniverse.MySS.Temps.TempFormat = formatNameOfFile
                        If MyUniverse.MySS.IndexName > 0 Then
                            Named_TableNameOfFile(MyUniverse.MySS.IndexName, TPar)
                        Else
                            MyMsgCtr(1404, "Import", "/filename", TKey & "=" & TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName, "", "", "", "", "")
                        End If
            ' Needdc To change the options if it is already there 
                    Case "/language"
                        MyUniverse.MySS.Temps.TempFormat = formatLanguage
                        MyDoEvents(161)
                        MyUniverse.ProgramOptions.FCCL_LanguageClassName = TPar
                        MyButtonsEnableRules()
                    Case "/stroke"
                        MyUniverse.MySS.Temps.TempFormat = formatStroke
                        If MyUniverse.MySS.IndexName > 0 Then
                            Named_TableStroke(MyUniverse.MySS.IndexName, TPar)
                        Else
                            MyMsgCtr(1406, "Import", "/stroke" & " : ", TKey & "=" & TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName, "", "", "", "", "")
                        End If
                    Case "/notes"
                        MyUniverse.MySS.Temps.TempFormat = formatNotes
                        If MyUniverse.MySS.IndexName > 0 Then
                            Named_TableNotes(MyUniverse.MySS.IndexName, Named_TableNotes(MyUniverse.MySS.IndexName) & vbCr & PopLine(TPar))
                        Else
                            MyMsgCtr(1407, "Import", "/notes" & " : ", TKey & "=" & TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName, "", "", "", "", "")
                        End If
                    Case "/version"
                        MyUniverse.MySS.Temps.TempFormat = formatVersion
                        If MyUniverse.MySS.IndexName > 0 Then
                            Named_TableVersion(MyUniverse.MySS.IndexName, TPar)
                        Else
                            MyMsgCtr(1408, "Import", "/version" & " : ", TKey & "=" & TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName, "", "", "", "", "")
                        End If
                    Case "/author"
                        MyUniverse.MySS.Temps.TempFormat = formatAuthor
                        If MyUniverse.MySS.IndexName > 0 Then
                            Named_TableAuthor(MyUniverse.MySS.IndexName, TPar)
                        Else
                            MyMsgCtr(1409, "Import", "/author" & " : ", TKey & "=" & TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName, "", "", "", "", "")
                        End If
                    Case "/opcode"
                        MyUniverse.MySS.Temps.TempFormat = formatOpcode
                        If MyUniverse.MySS.IndexName > 0 Then
                            If Len(Named_TableOpCode(MyUniverse.MySS.IndexName)) > 0 Then
                                Named_TableOpCode(MyUniverse.MySS.IndexName, Named_TableOpCode(MyUniverse.MySS.IndexName) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.ProgramOptions.FCCL_MultiLine & MyUniverse.ProgramOptions.FCCL_WhiteSpace & TPar)
                            Else
                                Named_TableOpCode(MyUniverse.MySS.IndexName, TPar)
                            End If
                        Else
                            MyMsgCtr(1410, "Import", "/opcode" & " : ", TKey & "=" & TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName, "", "", "", "", "")
                        End If
                    Case "/Constant"
                        MyUniverse.MySS.Temps.TempFormat = formatConstant
                        MyUniverse.MySS.Temps.TempRecord = TopOfFile("FlowChart")
                        FlowChart_TableCode(MyUniverse.MySS.Temps.TempRecord, TKey)
                        MyUseTextValues2Line(MyUniverse.MySS.Temps.TempRecord, TPar)
                        FlowChart_Table_DataType(MyUniverse.MySS.Temps.TempRecord, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters))
                        FlowChart_TablePathSymbolName(MyUniverse.MySS.Temps.TempRecord, TPar)
                        ShowSorts("FlowChart", ReSortFlowChart(MyUniverse.MySS.Temps.TempRecord))
                        CheckForAnySortNeeded(231)
                        ReSetScrollBars(MyUniverse.MySS.Temps.TempRecord)
                    Case "/error"
                        MyUniverse.MySS.Temps.TempFormat = FormatError
        'ignore error imports
                    Case "/delete"
                        MyUniverse.MySS.Temps.TempFormat = FormatDelete
        ' ignore deleted stuff also
                    Case "/keyword"
                        AddSortedList(MyUniverse.SysGen.Constants.SyntaxKeyWords, TPar, Language_KeyWord)

                    Case "/operator"
                        'FindingMyBugs(10) 'hack Least amount of checking here
                        FindingMyBugsSorted()
                        ReSortLanguagekeyWord("operator", Language_Operator, TopOfFile("Operator"))
                        FindingMyBugsSorted()
                        AddSortedList(MyUniverse.SysGen.Constants.SyntaxOperators, TPar, Language_Operator) ' Get rid of the '=' sign
                        FindingMyBugsSorted()
                    Case "/function"
                        'FindingMyBugs(10) 'hack Least amount of checking here
                        AddSortedList(MyUniverse.SysGen.Constants.SyntaxFunctions, Trim(TPar), Language_Function) ' get rid of the equal sign and any white space
                    Case "/Grammar"
                        FindingMyBugs(10)
                        AddSortedList(MyUniverse.SysGen.Constants.SyntaxGrammar, TPar, Language_Grammar)
                    Case "/blocks"
                        If Len(Language_Blocks(UBound(Language_Blocks))) > 1 Then ReDim Preserve Language_Blocks(UBound(Language_Blocks) + 1)
                        Language_Blocks(UBound(Language_Blocks)) = MyTrim(TPar)
                    Case "/finish", "", Nothing ' do nothing
                    Case Else
                        'not a FCCL '/' command 
                        SortALLISAM() 'todo need to see how many times this  actually does sort.
                        TKey = TKey
                        If MyLeft(TKey, 1) <> "/" Then
                            If Len(TKey) > 0 Then
                                TPar = TPar '                                TPar = TKey & " = " & TPar
                            ElseIf IsThisABlock(TKey) = True Then
                                TPar = TKey
                            Else
                                TPar = Mid(TKey, 1, InStr(TKey & " ", " "))
                            End If
                            MyDeCompileLine(TKey)
                            'todo this needs to remove all of the myMsgBox stuff below the exit select
                            Exit Select
                        Else
                            FindGrammarFromCode(TKey, 1)
                            Exit Select
                        End If
                        'todo should never get to 1211
                        Select Case MyMsgCtr(1211, "Import", MyUniverse.MySS.Inputs.LineNumberIn.ToString, TKey, TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, "Not known command", "", "", "", "")
                            Case vbNo

                            Case vbOK, vbYes
                                MyMakeArraySizesBigger()
                                FlowChart_TableCode(TopOfFile("FlowChart"), "/error")
                                FlowChart_Table_DataType(TopOfFile("FlowChart"), TAll)
                                SortALLISAM()
                            Case vbCancel
                                Init()
                                Return ""
                                '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                            Case Else
                                MSG_ABug(1385, "Invalid inputs to program", TKey, TKey)
                        End Select
                        FindingMyBugs(10) 'hack Least amount of checking here 'hack
                End Select
            End While
            If MyDebug(6) Then follow(2759, 6, "Completed Conversion.")
            FMB(5049)
            Return "" 'nothing

        End Function 'End Of import line Or file


        'This is to add keywords from the Grammar's
        Public Shared Sub CheckGrammar()
            Const DISPLAYER As Int32 = 25
            Dim I, J As Int32
            Dim S As String = ""
            Dim T As String = ""
            Dim t1, t2, t3 As Int32
            Dim MyEquals As Int32

#If MINEDEBUG Then
  if mydebug(9) then follow(3091, 10, "CheckGrammar")
#End If
            If MyOptionTest(61) Then
                Exit Sub
            End If

            DisplayStatus(FlowChartWindow.LabelProgramStatus, "Checking Grammar") : DoThisEvent(2907)

            If MyUniverse.Grammar = True Then Return
            For I = 0 To UBound(Language_Grammar)
                If CInt(I / DISPLAYER) * DISPLAYER = I Then DisplayMyStatus(7, "Checking Grammar Pass 1 @" & I.ToString)
                If Len(Language_Grammar(I)) > 1 Then
                    If MyDebug(10) Then follow(2439, 10, "Grammar available " & SHL(MyNoCR(Language_Grammar(I))))
                    S = Language_Grammar(I)
                    'Add Grammar Check that /Grammar has a ::= after the bnf word ie /Grammar= This ::= 'This'
                    'todo why am I looking at this column only?
                    MyEquals = InStr(S, "::=")
                    'make sure that we can at least try to parse it
                    If MyEquals <> 0 Then                    '  Mid(S, 3, 4) = " ::=" Then
                        'if MyDebug(10 ) then follow(2445, 10, "has ::= " & shl(S))
                        S = Trim(Mid(S, MyEquals + 3))
                        'if MyDebug(6 ) then follow(2446, 6, "Less variable name " & shl(S))
                        While Len(S) > 0
                            If MyDebug(9) Then Follow(2447, 9, "03" & S & " .")
                            'todo replace any tabs with a space
                            If InStr(S, "'" & vbTab & "'") > 0 Then
                                If MyDebug(10) Then follow(2448, 5, "Has 'tab' " & SHL(S) & vbTab & vbTab & vbTab & SHL(T))
                            End If

                            T = Trim(Block(S))
                            'todo need to fix bug when T set to nothing
                            If T = "" And Len(S) <> 0 Then
                                T = Pop(S, MyUniverse.SysGen.Constants.ConstantDelimiters)
                            Else
                                S = S.Substring(Len(T) + 2)
                                'if MyDebug(10 ) then follow(2449, 10, "(B) Popped off " & shl(T) & vbTab & vbTab & vbTab & shl(S))
                            End If
                        End While
                    Else ' this is an error because the /Grammar=bnfName ::= 'literals'
                        If T <> "" Then
                            If InStr(T, "::=") = 0 Then
                                If MyDebug(4) Then follow(2390, "error here? " & SHL(S))
                            Else
                                If MyDebug(4) Then follow(2391, "Check this " & SHL(S))
                            End If
                        End If
                    End If
                End If
            Next

            For I = 0 To UBound(Language_Grammar)
                S = Language_Grammar(I)
                'if MyDebug(10 ) then follow(2450, 7, "working on " & shl(S))
                If CInt(I / DISPLAYER) * DISPLAYER = I Then DisplayMyStatus(7, "Checking Grammar Pass 2 @" & I.ToString)
                If MyDebug(10) Then follow(2905, 10, "===========>> " & MyNoCR(S))
                J = InStr(S, "::=")
                If MyDebug(8) Then FMB(1122, S)
                If J <> 0 Then
                    'if MyDebug(9 ) then follow(2451, 9, "has ::= " & shl(S))
                    T = Trim(Mid(S, 1, J - 1))
                    'if MyDebug(10 ) then follow(2452, 8, "Popped off variable " & T & " and ::= ")
                    If MyDebug(8) Then FMB(1125, T)
                    S = MyTrim(Mid(S, J + 3))
                    While Len(MyTrim(S)) > 0
                        '                        if MyDebug(9 ) then follow(2453, 9, "still working on " & shl(T) & vbTab & vbTab & vbTab & S)
                        If MyLeft(S, 3) = "'''" Then
                            T = "'"
                            S = Mid(S, 3, Len(S))
                        Else
                            'if MyDebug(9 ) then follow(2454, 9, "08" & shl(S))
                            If S = "'" Then
                                'if MyDebug(9 ) then follow(2455, 9, "30 " & shl(T) & vbTab & vbTab & vbTab & shl(S))
                                T = "'"
                                S = ""
                            Else
                                'if MyDebug(9 ) then follow(2456, 9, "31 " & shl(T) & vbTab & vbTab & vbTab & shl(S))
                                T = MyTrim(PopGrammar(S))
                            End If
                            'if MyDebug(9 ) then follow(2457, 9, "20 " & shl(T) & vbTab & vbTab & vbTab & shl(S))
                        End If
                        '************** anything with a ' must also have a ending ' because its the end of the line
                        'if MyDebug(9 ) then follow(2458, 10, "32 " & shl(T) & vbTab & vbTab & vbTab & shl(S))
                        T = MyTrim(T)
                        'todo this needs to also do block list of 
                        If Len(T) > 2 And MyLeft(T, 1) = "'" And MyRight(T, 1) = "'" Then
                            '   if MyDebug(9 ) then follow(2459, 9, "09" & shl(T) & vbTab & vbTab & vbTab & S)
                            T = Mid(T, 2)
                            If MyDebug(8) Then FMB(1118, T)
                            T = Mid(T, 1, Len(T) - 1)
                            T = MyTrim(T)
                            t1 = AscW(Mid(T & "   ", 1, 1))
                            t2 = AscW(Mid(T & "   ", 2, 1))
                            t3 = AscW(Mid(T & "   ", 3, 1))
                            'if MyDebug(6 ) then follow(2460, 6, "1 keyword  " & shl(T) & vbTab & " from " & vbTab & shl(S))
                            If IsThisAHexDigitRange(T) = True Then
                                If MyDebug(10) Then follow(2460, 1, "1 character range " & SHL(T) & vbTab & " from " & vbTab & SHL(S))
                                Continue While
                            ElseIf IsThisAHexDigit(T) = True Then
                                If MyDebug(8) Then FMB(1129, T)
                                Continue While
                            ElseIf IsThisA_KeyWord(T) = True Then
                                If MyDebug(8) Then FMB(1130, T)
                                Continue While
                            ElseIf IsThisA_Operator(T) = True Then
                                If MyDebug(8) Then FMB(1136, T)
                                Continue While
                            ElseIf IsThisAGrammar(T) = True Then
                                Continue While
                            ElseIf IsThisALetterRange(T) Then
                                If MyDebug(8) Then FMB(1137, T)
                                Continue While
                            ElseIf Len(T) = 1 Then
                                If MyDebug(8) Then FMB(1140, T)
                                If MyDebug(10) Then follow(2462, 7, "12a single character " & SHL(T) & " " & vbTab & vbTab & vbTab & SHL(S))
                                Continue While
                            Else
                                If MyDebug(10) Then follow(2461, 8, "11" & SHL(T) & " " & Len(T))
                                If MyDebug(8) Then FMB(1144, Len(T).ToString & " " & AscW(Mid(T & " ", 1, 1)) & " " & AscW(Mid(T & "  ", 2, 1)) & " " & AscW(Mid(T & "  ", 3, 1)))
                                If MyDebug(8) Then FMB(1146, T)
                                If MyDebug(8) Then follow(2462, "12b " & SHL(T) & " " & vbTab & vbTab & vbTab & SHL(S))
                                GoTo hit
                            End If
                        ElseIf ItThisAUnicodeClass(T) = True Then
                            If MyDebug(8) Then follow(2463, "21 it is a unicode class " & SHL(T) & vbTab & vbTab & vbTab & SHL(S))
                            If MyDebug(6) Then follow(2391, "Unicode Class " & T)
                            Continue While
                        ElseIf IsThisA_Operator(T) = True Then
                            Continue While
                        ElseIf FindMyGrammarName(T) <> "" Then
                            If MyDebug(7) Then follow(2466, "Grammar name --> " & T & vbTab & FD & vbTab & S & vbTab)
                            Continue While
                        ElseIf FindMyKeyword(T) > 0 Then
                            If MyDebug(8) Then follow(2467, "25" & T)
                            Continue While
                        ElseIf FindMyOperator(T) > 0 Then
                            If MyDebug(8) Then follow(2468, "26" & T)
                            Continue While
                        ElseIf IsThisA_Function(NoBlock(T)) = True Then
                            If MyDebug(10) Then follow(2469, 8, "27" & T)
                            Continue While
                        ElseIf IsThisALetterRange(T) = True Then
                            If MyDebug(10) Then follow(2470, 8, "28" & T)
                        ElseIf MyLeft(T, 1) = "'" Then 'bug for basic only
                            Continue While
                        ElseIf Len(T) = 0 And Len(S) <> 0 Then 'todo this should never hapen, but does it there is an error in the /Grammar
                            T = MyLeft(S, 1)
                            S = Mid(S, 2)
                        ElseIf T = "''" Or T = "'" Or T = "|" Or T = "(" Or T = ")" Or T = "{" Or T = "}" Or T = "[" Or T = "]" Or T = "<" Or T = ">" Or T = "'<" Or T = ">'" Or T = "+" Or T = "-" Or T = "&" Or T = "-" Or T = "+" Or T = "*" Or T = "?" Then
                            If MyDebug(10) Then follow(2464, 7, "22 name = " & T)
                            Continue While
                        ElseIf T = ";" Then
                            If MyDebug(10) Then follow(2465, 7, "23 semicolon " & SHL(T))
                            S = ""
                        Else
hit:
                            If S = "" Then Exit While
                            FMBs(T)
                            MSG_ABug(2473, "Check Grammar: not sure what this is : " & SHL(T), AscW(Mid(T & "    ", 1, 1)) & " " & AscW(Mid(T & "    ", 2, 1)) & " " & AscW(Mid(T & "    ", 3, 1)) & " " & AscW(Mid(T & "    ", 4, 1)) & " " & AscW(Mid(T & "    ", 5, 1)), Language_Grammar(I))
                            MyBeep()
                            Select Case MsgBox(T & " " & AscW(T).ToString & vbCrLf & Language_Grammar(I), MsgBoxStyle.YesNo, "1001 Should this be added as a keyword?")
                                Case MsgBoxResult.Yes
                                    If Len(T) > 1 Then
                                        AddSortedList(AddRM("KeyWord"), Mid(T, 2, Len(T) - 2), Language_KeyWord)
                                    End If
                                Case MsgBoxResult.No
                            End Select
                        End If
                        'All else fails so this might be a problem
                    End While
                Else
                    If S = "" Then
                        DisplayMyStatus(3, " select options computer language class then it's dialect") 'nothing left to test
                    Else
                        If Language_Grammar(I) = MyConstantIgnoreFunctionOperatorKeyWord & "Grammar ::= ' '" Then
                        Else
                            If MyDebug(9) Then follow(2357, "not a valid Grammar, missing ::= " & vbCrLf & Language_Grammar(I))
                        End If
                    End If
                End If
            Next
            If IsNothing(FlowChartWindow.LabelProgramStatus) Then
                DisplayStatus(FlowChartWindow.LabelProgramStatus, "Checking Grammar Done") : DoThisEvent(2908)
            Else
                DisplayStatus(FlowChartWindow.LabelProgramStatus, "Checking Grammar Done") : DoThisEvent(2908) : DoThisEvent(2908) : DoThisEvent(2908)
            End If
            If MyDebug(2) Then follow(2392, "Check Grammar Complete" & SHL(T))
            DoThisEvent(3518)
        End Sub


        'Routine This reads in an file with all of the information for a FlowChart & Symbol.
        Public Shared Sub Import(InputFileName As String)
            Dim MyCompleteFileText As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3092, 10, "Import")
#End If
            If MyDebug(1) = True Then follow(2842, "Import " & InputFileName)
            MyUniverse.SysGen.DoNotAskToAdd = True
            ' Start off with junk
            MyUniverse.MySS = FillImportLine()

            ShowAllForms(LeaveWindow, LeaveWindow, LeaveWindow, ShowWindow)
            If Dir(InputFileName) = "" Then
                MSG_ABug(1387, "The file name ", InputFileName, "Could not be found")
            End If
            Using reader As System.IO.TextReader = System.IO.File.OpenText(InputFileName)

                MyCompleteFileText = "" ' Used to get through the first time only
                Do
                    If Len(MyCompleteFileText) < 100 Then
                        MyCompleteFileText &= reader.ReadToEnd() ' add to this text if less than 100 characters long
                    End If
                    MyMakeArraySizesBigger()
                    DisplayMyStatus(7, "Importing:line # " & MyUniverse.MySS.Inputs.LineNumberIn & " : " & Len(InputFileName) & FD & Len(MyCompleteFileText) & " : " & MyUniverse.MySS.Inputs.KPar)
                    DoThisEvent(3434)
                    MyCompleteFileText = ImportLineOrFile(MyCompleteFileText)
                Loop While Len(MyCompleteFileText) > 0
            End Using
            DoThisEvent(1902)
            SortALLISAM()
            ShowAllForms(LeaveWindow, HideWindow, HideWindow, ShowWindow)
            MyUniverse.SysGen.DoNotAskToAdd = False
            'FindingMyBugs(10) 'hack Least amount of checking here
            ShowAllForms(LeaveWindow, LeaveWindow, LeaveWindow, LeaveWindow)
            PaintAll(FlowChartWindow.PictureBox1, TopOfFile("FlowChart") - 1, TopOfFile("FlowChart")) '20200709
            DisplayMyStatus(7, "Finished Importing.Number of lines =" & MyUniverse.MySS.Inputs.LineNumberIn)
            If MyDebug(5) Then follow(2474, 5, "Import")
            'FindingMyBugs(10) 'hack Least amount of checking here 'hack
            MyUniverse.Grammar = False
            If MyDebug(5) Then follow(2475, 5, "Import")
            DisplayStatus(FlowChartWindow.LabelProgramStatus, "Checking Grammar") : DoThisEvent(2909)
            FMB(5050)
            SortAllList()
            FMB(5051)
            CheckGrammar()
            FMB(5052)
            SortAllList()
            FMB(5053)
            DisplayStatus(FlowChartWindow.LabelProgramStatus, "Done")
            DoThisEvent(2910)
        End Sub

        Public Shared Function PopGrammar(ByRef CodeLine As String) As String
            Dim I As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3093, 10, "PopGrammar")
#End If
            CodeLine = MyTrim(CodeLine)
            If MyLeft(CodeLine, 3) = "'''" Then
                If MyDebug(4) Then follow(2393, CodeLine)
                CodeLine = Mid(CodeLine, 3)
                Return "'" 'special case 'todo 
            End If
            ' get the first one.
            'if this is a '?' literial then return it
            If MyLeft(CodeLine, 1) = "'" Then 'return this string 
                I = InStr(2, CodeLine, "'")
                PopGrammar = Mid(CodeLine, 1, I)
                CodeLine = Mid(CodeLine, I + 1, Len(CodeLine))
                Return PopGrammar
            End If
            CodeLine = MyTrim(CodeLine)
            'if this is a Grammar name then return it.
            CodeLine = MyTrim(CodeLine)
            PopGrammar = Pop(CodeLine, MyUniverse.SysGen.Constants.ConstantDelimiters)
            If Len(PopGrammar) = 1 Then Return PopGrammar
            Select Case MyRight(PopGrammar, 1)
                Case "-", "+", "?", "*"
                    'need to find Grammar???
                    Return MyLeft(PopGrammar, Len(PopGrammar) - 1)
                Case Else
            End Select
            Return PopGrammar
        End Function

        Public Shared Function MyFlowChartPathLine(IndexFlowChart As Int32) As MyLineStructure
            MyFlowChartPathLine = Nothing
            MyFlowChartPathLine.a.Named.PathName = FlowChart_TablePathName(IndexFlowChart)
            MyFlowChartPathLine.b.Named.PathName = FlowChart_TablePathName(IndexFlowChart)
            MyFlowChartPathLine.a.x = FlowChart_TableX1(IndexFlowChart)
            MyFlowChartPathLine.a.y = FlowChart_TableY1(IndexFlowChart)
            MyFlowChartPathLine.b.x = FlowChart_TableX2(IndexFlowChart)
            MyFlowChartPathLine.b.y = FlowChart_TableY2(IndexFlowChart)
        End Function

        ' A line (distance) between two record points
        '    Public Shared Function MyLineFlowChart(IndexFlowChart1   As Int32, IndexFlowChart2   As Int32) As MyLineStructure
        '    MyLine2 = Nothing
        '    MyLine2.a.x = FlowChart_TableX1(IndexFlowChart1  )
        '    MyLine2.a.y = FlowChart_TableY1(IndexFlowChart1  )
        '    MyLine2.b.x = FlowChart_TableX1(IndexFlowChart2  )
        '    MyLine2.b.y = FlowChart_TableY1(IndexFlowChart2  )
        '    End Function


        ' A line (distance) between two record points
        Public Shared Function MyLine1(aXY As MyPointStructure, bXY As MyPointStructure) As MyLineStructure
            MyLine1 = Nothing
            MyLine1.a.x = aXY.x
            MyLine1.a.y = aXY.y
            MyLine1.b.x = bXY.x
            MyLine1.b.y = bXY.y
            Return MyLine1
        End Function

        Public Shared Function MyLine1(X1 As Int32, Y1 As Int32, X2 As Int32, Y2 As Int32) As MyLineStructure
            MyLine1 = Nothing
            MyLine1.a.x = X1
            MyLine1.a.y = Y1
            MyLine1.b.x = X2
            MyLine1.b.y = Y2
        End Function


        ' a line in one record
        Public Shared Function MyLine1(IndexFlowChart As Int32) As MyLineStructure
            MyLine1 = Nothing
            MyLine1.a.x = FlowChart_TableX1(IndexFlowChart)
            MyLine1.a.y = FlowChart_TableY1(IndexFlowChart)
            MyLine1.b.x = FlowChart_TableX2(IndexFlowChart)
            MyLine1.b.y = FlowChart_TableY2(IndexFlowChart)
        End Function
        Public Shared Function MyLine2(IndexFlowChart As Int32) As MyLineStructure
            MyLine2 = Nothing
            MyLine2.a.x = FlowChart_TableX1(IndexFlowChart)
            MyLine2.a.y = FlowChart_TableY1(IndexFlowChart)
            MyLine2.b.x = FlowChart_TableX2(IndexFlowChart)
            MyLine2.b.y = FlowChart_TableY2(IndexFlowChart)
        End Function
        Public Shared Function MyLineS(IndexFlowChart1 As Int32, IndexFlowChart2 As Int32, WhichOne As Int32) As MyLineStructure
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3094, 10, "MyLineS")
#End If
            MyLineS = Nothing
            Select Case WhichOne
                Case 1
                    MyLineS.a.x = FlowChart_TableX1(IndexFlowChart1) : MyLineS.a.y = FlowChart_TableY1(IndexFlowChart1)
                    MyLineS.b.x = FlowChart_TableX1(IndexFlowChart2) : MyLineS.b.y = FlowChart_TableY1(IndexFlowChart2)
                Case 2
                    MyLineS.a.x = FlowChart_TableX1(IndexFlowChart1) + 10 : MyLineS.a.y = FlowChart_TableY1(IndexFlowChart1) + 10
                    MyLineS.b.x = FlowChart_TableX1(IndexFlowChart2) + 10 : MyLineS.b.y = FlowChart_TableY1(IndexFlowChart2) + 10
                Case 3
                    MyLineS.a.x = FlowChart_TableX1(IndexFlowChart1) + 20 : MyLineS.a.y = FlowChart_TableY1(IndexFlowChart1) - 20
                    MyLineS.b.x = FlowChart_TableX1(IndexFlowChart2) + 20 : MyLineS.b.y = FlowChart_TableY1(IndexFlowChart2) - 20
                Case 4
                    MyLineS.a.x = FlowChart_TableX1(IndexFlowChart1) - 20 : MyLineS.a.y = FlowChart_TableY1(IndexFlowChart1) + 20
                    MyLineS.b.x = FlowChart_TableX1(IndexFlowChart2) - 20 : MyLineS.b.y = FlowChart_TableY1(IndexFlowChart2) + 20
                Case Else 'might as well find the closest
                    MyLineS.a.x = FlowChart_TableX1(IndexFlowChart1) : MyLineS.a.y = FlowChart_TableY1(IndexFlowChart1) - 80
                    MyLineS.b.x = FlowChart_TableX1(IndexFlowChart2) : MyLineS.b.y = FlowChart_TableY1(IndexFlowChart2) - 80
            End Select
        End Function


        'Routine converts from two numbers (x, y) to structure xy
        Public Shared Function MyPoint1XY(X As Int32, Y As Int32) As MyPointStructure
            MyPoint1XY = Nothing
            MyPoint1XY.x = X
            MyPoint1XY.y = Y
        End Function

        Public Shared Function MyPoint1XY(IndexFlowChart As Int32) As MyPointStructure
            Dim XYZ As MyLineStructure
            'todo is this nessary '''XYZ = Nothing
            XYZ = MySnapindex(IndexFlowChart) ', FlowChart_TableX1(IndexFlowChart))
            'MyPoint1XY.y = MySnap(IndexFlowChart, FlowChart_TableY1(IndexFlowChart))
            Return XYZ.a
        End Function

        Public Shared Function MyPoint1_1XY(IndexFlowChart As Int32) As MyPointStructure
            Dim XYZ As MyLineStructure
            XYZ = MySnapindex(IndexFlowChart)
            Return XYZ.a
        End Function

        Public Shared Function MyPoint2XY(X As Int32, Y As Int32) As MyPointStructure
            Dim XYZ As MyLineStructure
            XYZ = MySnapXYXY("/path", X, Y, X, Y)
            Return XYZ.a
        End Function

        Public Shared Function MyPoint2_1XY(IndexFlowChart As Int32) As MyPointStructure
            Dim XYZ As MyLineStructure
            XYZ = MySnapindex(IndexFlowChart)
            Return XYZ.a
        End Function

        Public Shared Function MyPoint2_2XY(IndexFlowChart As Int32) As MyPointStructure
            Dim XYZ As MyLineStructure
            XYZ = MySnapindex(IndexFlowChart)
            Return XYZ.a
            'MyPoint2_2XY = Nothing
            'MyPoint2_2XY.x = MySnap(IndexFlowChart, FlowChart_TableX2(IndexFlowChart))
            'MyPoint2_2XY.y = MySnap(IndexFlowChart, FlowChart_TableY2(IndexFlowChart))
        End Function

        'Routine 
        Public Shared Function MyFixLine(AString As String) As String
            Dim Index As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3095, 10, "MyFixLine")
#End If
            MyFixLine = AString
            For Index = 1 To Len(MyFixLine) - 1
                If Mid(MyFixLine, Index, 1) = FD Or Mid(MyFixLine, Index, 1) = FD Then
                    If Mid(MyFixLine, Index + 1, 1) = FD Or Mid(MyFixLine, Index + 1, 1) = FD Then
                        MyFixLine = MyLeft(MyFixLine, Index) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & Mid(MyFixLine, Index + 1, Len(MyFixLine))
                    End If
                End If

                If Mid(MyFixLine, Index, 1) = FD Or Mid(MyFixLine, Index, 1) = FD Then
                    If Mid(MyFixLine, Index + 1, 1) = vbCr Then
                        MyFixLine = MyLeft(MyFixLine, Index) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & Mid(MyFixLine, Index + 1, Len(MyFixLine))
                    End If
                End If

                If Mid(MyFixLine, Index, 1) = FD Or Mid(MyFixLine, Index, 1) = FD Then
                    If Mid(MyFixLine, Index + 1, 1) = vbLf Then
                        MyFixLine = MyLeft(MyFixLine, Index) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & Mid(MyFixLine, Index + 1, Len(MyFixLine))
                    End If
                End If

                If Mid(MyFixLine, Index, 1) = FD Or Mid(MyFixLine, Index, 1) = FD Then
                    If Mid(MyFixLine, Index + 1, 1) = "/" Then
                        MyFixLine = MyLeft(MyFixLine, Index) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & Mid(MyFixLine, Index + 1, Len(MyFixLine))
                    End If
                End If


            Next
        End Function




        'This is used to fill/refill the list of currently available lib Symbols 
        Public Shared Sub FillAllDropdowns(SelectedSymbolName As String)
            Dim Index As Int32
            Dim IndexDropDown As Integer
            Dim IndexColor As Int32
            Dim ColorName As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3096, 10, "FillAllDropDowns")
#End If
            ColorName = "Errored" ' only to avoid a warning message.
            If MyDebug(8) = True Then If mydebug(9) Then follow(2683, 8, SHL(MyNoCR(MyShowDropDownItems(SymbolWindow.ToolStripDropDownSelectSymbol))))
            If MyDebug(6) = True Then If mydebug(9) Then follow(2684, 6, SHL(MyNoCR(MyShowDropDownItems(FlowChartWindow.ToolStripDropDownSelectSymbol))))
            SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Clear()
            FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Clear()

            '  Adding all Symbol names to the Symbol select list(S).(only button that should be on two Windows)
            For Index = 1 To TopOfFile("named")
                If MyIsNothing(Named_TableSymbolName(Index)) Then
                Else
                    AddSymbolToDropDown(Named_TableSymbolName(Index))
                End If
            Next


            '    For IndexDropDown = 0 To SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count - 1
            '   If SelectedSymbolName = SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text Then
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName)
            SelectInToolStripDropDownButton(FlowChartWindow.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName)
            '      FindingMyBugs(100)
            '     Exit For
            '    End If
            '   Next

            ' need to make the DataType selected from something
            SymbolWindow.ToolStripDropDownDataType.DropDownItems.Clear()
            If MyDebug(10) = True Then If mydebug(9) Then follow(2843, 10, "Adding colors to drop down ")
            For Index = 1 To TopOfFile("DataType")
                If MyIsNothing(DataType_TableName(Index)) Then
                    MSG_ABug(1396, "No Color Name at " & Index, "", "")
                Else
                    If MyDebug(10) = True Then If mydebug(9) Then follow(2844, 10, DataType_TableName(Index) & FD)
                    SymbolWindow.ToolStripDropDownDataType.DropDownItems.Add(DataType_TableName(Index))
                End If
            Next


            SymbolWindow.ToolStripDropDownButtonColor.DropDown.Items.Clear()
            For Index = 1 To TopOfFile("Color")
                IndexColor = Color_Name_ISAM(Index)
                If IndexColor > ConstantMyErrorCode Then
                    If MyIsNothing(Color_TableName(IndexColor)) Or Color_TableName(IndexColor) = "" Then
                        MSG_ABug(1397, "GetAllSymbolNames() This is an empty color name", Index.ToString, IndexColor.ToString)
                    Else
                        If MyUniverse.MyProgramStatus <> "Begin" Then If MyDebug(10) = True Then If mydebug(9) Then follow(2845, 10, "Fill Color DropDowns " & Color_TableName(IndexColor))
                        SymbolWindow.ToolStripDropDownButtonColor.DropDown.Items.Add(Color_TableName(IndexColor))
                    End If
                Else
                    MSG_ABug(1398, "Color not found ", Color_TableName(IndexColor), "While using the color table to find the color table")
                End If
            Next

            For IndexDropDown = 0 To SymbolWindow.ToolStripDropDownButtonColor.DropDownItems.Count - 1
                If LCase(Trim(SymbolWindow.ToolStripDropDownButtonColor.DropDownItems.Item(IndexDropDown).Text)) = LCase(Trim(ColorName)) Then
                    SymbolWindow.ToolStripDropDownButtonColor.Text = ColorName
                    MyUniverse.ProgramOptions.SelectedColor = ColorName
                    Exit For
                End If
            Next IndexDropDown
            If MyDebug(7) = True Then
                If mydebug(9) Then follow(2685, 7, SHL(MyNoCR("Symbol: " & MyShowDropDownItems(SymbolWindow.ToolStripDropDownSelectSymbol))))
                If mydebug(9) Then follow(2686, 7, SHL(MyNoCR("FlowChart: " & MyShowDropDownItems(FlowChartWindow.ToolStripDropDownSelectSymbol))))
            End If
        End Sub


        Public Shared Sub YouHaveAnErrorMessage(WhichOne As Int32, WhatIsIt As String)
            DisplayMyStatus(7, "You have an error message " & WhatIsIt & WhichOne.ToString)
            DoThisEvent(2911)
        End Sub



        Public Shared Sub MoveAllPaths(Where As PictureBox, AtX1Y1 As MyPointStructure, MoveOverXY As MyPointStructure)
            Dim AtXY As MyLineStructure
            Dim Index As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3097, 10, "MoveAllPaths")
#End If
            AtXY.a.x = AtX1Y1.x
            AtXY.a.y = AtX1Y1.y
            For Index = 1 To TopOfFile("FlowChart")
                Select Case LCase(FlowChart_TableCode(Index))
                    Case "/path"
                        'Try One End 
                        ' Comparing the same code type snap ' this really is a hack, but it works
                        If DoesPointMatch(MySnapindex(Index).a, MySnapXYXY("/path", AtXY.a.x, AtXY.a.y, AtXY.b.x, AtXY.b.y).a) = True Then
                            PaintErase(Where, Index)
                            FlowChart_TableX1(Index, FlowChart_TableX1(Index) + MoveOverXY.x)
                            FlowChart_TableY1(Index, FlowChart_TableY1(Index) + MoveOverXY.y)
                            PaintAll(Where, Index, Index)
                        End If
                        'Try the other end
                        If DoesPointMatch(MySnapindex(Index).b, MySnapXYXY("/path", AtXY.a.x, AtXY.a.y, AtXY.b.x, AtXY.b.y).a) = True Then
                            PaintErase(Where, Index)
                            FlowChart_TableX2(Index, FlowChart_TableX2(Index) + MoveOverXY.x)
                            FlowChart_TableY2(Index, FlowChart_TableY2(Index) + MoveOverXY.y)
                            PaintAll(Where, Index, Index)
                        End If
                End Select
            Next
        End Sub



        Public Shared Sub MoveSymbolAndAllPaths(Where As PictureBox, IndexFlowChart As Int32, MyDistanceXY As MyPointStructure)
            ' Need to change this to also move any connected paths before moving the Symbol
            Dim IndexPoint As Int32
            Dim XY As MyPointStructure
            Dim XDistance As Int32
            Dim YDistance As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3098, 10, "MoveSymbolAndAllPaths")
#End If
            XDistance = MyDistanceXY.x
            YDistance = MyDistanceXY.y

            IndexPoint = FindInSymbolList(FlowChart_TablePath_Name(IndexFlowChart))

            If IndexPoint > ConstantMyErrorCode Then
                IndexPoint += 1 ' Skip over the name
                While IndexPoint <= TopOfFile("Symbol") And Symbol_TableCoded_String(IndexPoint) <> "/name"
                    Select Case LCase(Symbol_TableCoded_String(IndexPoint))
                        Case "/point"
                            XY = MyRotated(IndexPoint, IndexFlowChart)
                            MoveAllPaths(Where, XY, MyDistanceXY)
                        Case "/line"
                        Case Else
                    End Select

                    IndexPoint += 1 ' Skip over the name
                End While
            End If

            MSG_AInfo1(1402, "Moving Symbol " & IndexFlowChart, MyShowFlowChartRecord(False, IndexFlowChart), "To " & MyPoint1XY(FlowChart_TableX1(IndexFlowChart) + XDistance, FlowChart_TableY1(IndexFlowChart) + YDistance).ToString)
            PaintErase(Where, IndexFlowChart)
            FlowChart_TableX1(IndexFlowChart, FlowChart_TableX1(IndexFlowChart) + XDistance)
            FlowChart_TableY1(IndexFlowChart, FlowChart_TableY1(IndexFlowChart) + YDistance)
            PaintAll(Where, IndexFlowChart, IndexFlowChart)

        End Sub


        Public Shared Function BlockedRectAt(xy1 As MyLineStructure, xy2 As MyLineStructure) As MyLineStructure
            Dim A, B As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3099, 10, "BlockedRectAt")
#End If
            BlockedRectAt = Nothing
            A = MyMax(xy1.a.x, xy1.b.x)
            B = MyMax(xy2.a.x, xy2.b.x)
            BlockedRectAt.a.x = MyMin(A, B)

            A = MyMax(xy1.a.y, xy1.b.y)
            B = MyMax(xy2.a.y, xy2.b.y)
            BlockedRectAt.a.x = MyMin(A, B)

            A = MyMin(xy1.a.x, xy1.b.x)
            B = MyMin(xy2.a.x, xy2.b.x)
            BlockedRectAt.a.x = MyMax(A, B)

            A = MyMin(xy1.a.x, xy1.b.x)
            B = MyMin(xy2.a.x, xy2.b.x)
            BlockedRectAt.a.x = MyMax(A, B)
        End Function



        Public Shared Function SymbolOnTopOfSymbol(A As Int32, B As Int32) As Boolean
            Dim T2 As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3100, 10, "SymbolOnTopOfSymbol")
#End If
            If A = B Then Return False 'you can not be ontop of yourself 
            If FlowChart_TableCode(A) <> My_keyWord(My_KeyConstUse) Then Return False
            If FlowChart_TableCode(B) <> My_keyWord(My_KeyConstUse) Then Return False
            'check that they are both Symbols, and not a path, because the path might be connected to it.
            T2 = MyDistance(MyPoint1XY(A), MyPoint1_1XY(B))
            'MyDoEvents(162)
            If MyDebug(6) Then follow(2741, 6, "Distance between two Symbols in the Flow Chart " & T2.ToString & " for " & A.ToString & FD & B.ToString & vbCrLf & vbTab & MyShowFlowChartRecord(False, A) & vbCrLf & vbTab & MyShowFlowChartRecord(False, B))
            'todo  the * 4 should be set to the spacing factor in placement
            If T2 < MyUniverse.SysGen.Constants.ConstantSymbolCenter * 5 Then ' Not close to each other either
                MSG_AInfo(1405, "DIstance of " & T2.ToString & " between Symbol centers", MyShowFlowChartRecord(False, A), MyShowFlowChartRecord(False, B))
                SymbolOnTopOfSymbol = True
            Else
                SymbolOnTopOfSymbol = False
            End If

        End Function

        Public Shared Function PathAboveOrBelow(aY As Int32, bY1 As Int32, bY2 As Int32) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3101, 10, "PathAboveOrBelow")
#End If
            If aY > bY1 And aY > bY2 Then 'Ignore it its all above the line
                PathAboveOrBelow = False
            ElseIf aY < bY1 And aY < bY2 Then     'ignore it is below the other
                PathAboveOrBelow = False
            Else 'they are on top of each other
                PathAboveOrBelow = True
            End If
        End Function

        Public Shared Function DoesFlowChartPathMatch(IndexFlowChart1 As Int32, IndexFlowChart2 As Int32) As Boolean
            Return DoesPathMeet(MyLine1(IndexFlowChart1), MyLine2(IndexFlowChart2))
        End Function


        Public Shared Function DoesPointMatch(A As MyPointStructure, B As MyPointStructure) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3102, 10, "DoesPointsMatch")
#End If
            If A.x = B.x And A.y = B.y Then Return True
            Return False
        End Function

        Public Shared Function DoesPathMeet(A As MyLineStructure, B As MyLineStructure) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3103, 10, "DoesPathMeet")
#End If
            If DoesPointMatch(A.a, B.a) = True Then Return True
            If DoesPointMatch(A.a, B.b) = True Then Return True
            If DoesPointMatch(A.b, B.a) = True Then Return True
            If DoesPointMatch(A.b, B.b) = True Then Return True
            Return False
        End Function



        Public Shared Function PathOnTop(A As MyLineStructure, B As MyLineStructure) As Boolean ' Is the Path on top of each other
            ' I am only checking if the distance is close to each other, not if they lines are on top of each other.
            ' On top of each other is only if theyt are up/down and/or right/left - angle lines should be change 
            '(if the option is checked) other wise no checking
            Dim T1, T2, T3, T4, Temp As Int32
            'If this option is chosen
#If MINEDEBUG Then
  if mydebug(9) then follow(3104, 10, "PathOnTop")
#End If
            If MyOptionTest(14) = True Then ' Orthogonal paths
                If DoesPathMeet(A, B) = True Then
                    If PathAboveOrBelow(A.a.x, B.a.x, B.b.x) = True Then PathOnTop = True : Exit Function
                    If PathAboveOrBelow(A.a.y, B.a.y, B.b.y) = True Then PathOnTop = True : Exit Function
                    If PathAboveOrBelow(A.b.x, B.a.x, B.b.x) = True Then PathOnTop = True : Exit Function
                    If PathAboveOrBelow(A.b.y, B.a.y, B.b.y) = True Then PathOnTop = True : Exit Function
                End If

            Else ' If the option is not chosen
                T1 = MyDistance(MyPoint1XY(A.a.x, A.a.y), MyPoint2XY(B.a.x, B.a.y)) ' a1-b1
                T2 = MyDistance(MyPoint1XY(A.a.x, A.a.y), MyPoint2XY(B.b.x, B.b.y)) ' a1-b2
                T3 = MyDistance(MyPoint1XY(A.b.x, A.b.y), MyPoint2XY(B.a.x, B.a.y)) ' a2-b1
                T4 = MyDistance(MyPoint1XY(A.b.x, A.b.y), MyPoint2XY(B.b.x, B.b.y)) ' a2-b2
                Temp = T1
                If Temp < T2 Then Temp = T2
                If Temp < T3 Then Temp = T3
                If Temp < T4 Then Temp = T4
                If Temp < MyUniverse.SysGen.Constants.ConstantDistanceBetweenControls Then
                    PathOnTop = True : Exit Function
                End If
            End If
            PathOnTop = False
        End Function



        Public Shared Sub CheckColorTable()
            Dim IndexColor As Int32
            Dim JdexColor As Int32
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3105, 10, "CheckColorTable")
#End If
            For I = 1 To TopOfFile("Color") - 1
                MyDoEvents(163)
                IndexColor = Color_Name_ISAM(I)
                JdexColor = Color_Name_ISAM(I + 1)
                If LCase(Trim(Color_TableName(IndexColor))) = LCase(Trim(Color_TableName(JdexColor))) Then
                    YouHaveAnErrorMessage(1, "duplicate color named " & LCase(Color_TableName(IndexColor)) & " and " & LCase(Color_TableName(JdexColor)))
                    Color_TableName(IndexColor, Color_TableName(IndexColor) & "_CopyA" & I)
                End If
            Next
        End Sub

        Public Shared Sub CheckDataType_Table()
            Dim Index As Int32
            Dim jdex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3106, 10, "CheckDataType_Table")
#End If
            For Index = 1 To TopOfFile("DataType")
                MyDoEvents(164)
                For jdex = Index + 1 To TopOfFile("DataType")
                    MyDoEvents(165)
                    If LCase(DataType_TableName(Index)) = LCase(DataType_TableName(jdex)) Then
                        YouHaveAnErrorMessage(1, "duplicate data type named " & LCase(DataType_TableName(Index)) & " and " & LCase(DataType_TableName(jdex)))
                        DataType_TableName(Index, DataType_TableName(Index) & "_CopyB")
                    End If
                Next
            Next
        End Sub



        Public Shared Sub CheckNamed_Table()
            Dim ISAMIndex As Int32
            Dim jdex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3107, 10, "CheckNamed_Table")
#End If
            For ISAMIndex = 1 To TopOfFile("named")
                MyDoEvents(166)
                jdex = ISAMIndex + 1
                MyDoEvents(167)
                If LCase(Named_TableSymbolName(Named_FileSymbolName_ISAM(ISAMIndex))) = LCase(Named_TableSymbolName(Named_FileSymbolName_ISAM(jdex))) Then
                    YouHaveAnErrorMessage(1, "duplicate Symbol named " & LCase(Named_TableSymbolName(Named_FileSymbolName_ISAM(ISAMIndex))) & " and " & LCase(Named_TableSymbolName(Named_FileSymbolName_ISAM(jdex))))
                    Named_TableSymbolName(jdex, Named_TableSymbolName(Named_FileSymbolName_ISAM(jdex)) & "_CopyC")
                End If
            Next
        End Sub


        Public Shared Sub MyCheckForMovingPathEnds(Where As PictureBox, index As Int32, xy As MyPointStructure)
            Dim XY1XY As MyPointStructure = Nothing
#If MINEDEBUG Then
  if mydebug(9) then follow(3108, 10, "MyCheckForMovingPathEnds")
#End If
            If LCase(FlowChart_TableCode(index)) <> "/path" Then Return ' not a path to modify, program should never reach here
            XY1XY.x = FlowChart_TableX1(index)
            XY1XY.y = FlowChart_TableY1(index)
            If MyDistance(XY1XY, xy) <= MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths Then
                'MyStatus("Changing " & FlowChart_TableX1(index) & " To " & XY.x & " and also " & FlowChart_TableY1(index) & " To " & xy.Y)
                PaintErase(Where, index) ' get rid of where it was and
                FlowChart_TableX1(index, xy.x)
                FlowChart_TableY1(index, xy.y)
                PaintAll(Where, index, index) 'repaint it where its going to
                'MyStatus("")
            End If


            XY1XY.x = FlowChart_TableX2(index)
            XY1XY.y = FlowChart_TableY2(index)
            If MyDistance(XY1XY, xy) <= MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths Then
                '    MyStatus("Changing " & FlowChart_TableX2_Rotation(index) & " To " & XY.x & " and also " & FlowChart_TableY2_Option(index) & " To " & xy.y)
                PaintErase(Where, index) ' get rid of where it was and
                FlowChart_TableX2(index, xy.x)
                FlowChart_TableY2(index, xy.y)
                PaintAll(Where, index, index) 'repaint it where its going to
                '   MyStatus("")
            End If
        End Sub


        Public Shared Sub CheckAllPaths(Where As PictureBox)
            Dim Flag As Boolean
            Dim MyXY1 As MyRECTStructure
            Dim MyXY2 As MyPointStructure
            Dim FlowChartUseIndex, FlowChartPathIndex, FlowChartCheckingPathIndex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3109, 10, "CheckAllPaths")
#End If

            MyXY1 = Nothing
            'todo is this nessary '''MyXY2 = Nothing


            For FlowChartUseIndex = 1 To TopOfFile("FlowChart")
                MyDoEvents(168)
                Flag = False
                MyXY1.MyWorldXY.a.x = FlowChart_TableX1(FlowChartUseIndex)
                MyXY1.MyWorldXY.a.y = FlowChart_TableY1(FlowChartUseIndex)
                MyXY1.MyWorldXY.b.x = FlowChart_TableX2(FlowChartUseIndex)
                MyXY1.MyWorldXY.b.y = FlowChart_TableY2(FlowChartUseIndex)
                MyDoEvents(169)
                'MyMsgCtr(1015, "CheckAllPaths", FlowChartUseIndex.ToString, MyXY1.MyWorldXY.a.x.ToString, MyXY1.MyWorldXY.a.y.ToString, MyXY1.MyWorldXY.b.x.ToString, MyXY1.MyWorldXY.b.y.ToString, FlowChart_TablePathName(FlowChartUseIndex), "", "", "")
                Select Case LCase(FlowChart_TableCode(FlowChartUseIndex))
                    Case "" ' ignore if nothing also
        '?Flag = True
                    Case "/path", My_keyWord(My_KeyConstUse)
                        ' We are looking at a Symbol points connecting
                        For FlowChartPathIndex = FlowChartUseIndex + 1 To TopOfFile("FlowChart") ' Looking only for /use statements
                            MyDoEvents(170)
                            PaintErase(Where, FlowChartPathIndex)
                            Select Case LCase(FlowChart_TableCode(FlowChartPathIndex))
                                Case My_keyWord(My_KeyConstUse)
                                    FlowChartCheckingPathIndex = FindInSymbolList(FlowChart_TableSymbol_Name(FlowChartPathIndex))
                                    If FlowChartCheckingPathIndex = ConstantMyErrorCode Then
                                        MSG_ABug(1409, FlowChart_TableSymbol_Name(FlowChartPathIndex), "", "")
                                        MakeErrorAt(Where, MyXY1.MyInputWindowXY.a, "There is no Symbol defined in the libaray with the name >" & FlowChart_TableSymbol_Name(FlowChartPathIndex) & "< ")
                                        MakeErrorAt(Where, MyXY1.MyInputWindowXY.b, "There is no Symbol defined in the libaray with the name >" & FlowChart_TableSymbol_Name(FlowChartPathIndex) & "< ")
                                    Else
                                        FlowChartCheckingPathIndex += 1 ' skip over the name of the Symbol
                                        'MyStatus("Comparing " & Index & " : " & FlowChartPathIndex & " : " & FlowChartCheckingPathIndex)
                                        While FlowChartCheckingPathIndex <= TopOfFile("Symbol")  ' Till the next name
                                            MyDoEvents(171)
                                            '    MyStatus("Comparing index " & Index & " with index " & FlowChartPathIndex & " with index  " & FlowChartCheckingPathIndex)
                                            Select Case LCase(Symbol_TableCoded_String(FlowChartCheckingPathIndex))
                                                Case "/name"
                                                    Exit While ' End of the Symbol (starting of the next Symbol)
                                                Case "/line" 'Line Start so ignore - cause lines have no meaning
                                                Case "/point" ' See if the path matches the point
                                                    MyXY2 = MyRotated(FlowChartPathIndex, FlowChartCheckingPathIndex)
                                                    ' Checking of point points to here.
                                                    If MyDistance(MyXY2, MyXY1.MyWorldXY.a) < MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths Then
                                                        MSG_ABug(1410, Symbol_FileSymbolName(FlowChartCheckingPathIndex), "", MyDistance(MyXY2, MyXY1.MyWorldXY.a).ToString)
                                                        MyCheckForMovingPathEnds(Where, FlowChartPathIndex, MyXY2)
                                                        '?Flag = True
                                                        Exit For
                                                    End If
                                                    If MyDistance(MyXY2, MyXY1.MyWorldXY.b) < MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths Then
                                                        MSG_ABug(1411, Symbol_FileSymbolName(FlowChartCheckingPathIndex), "", MyDistance(MyXY2, MyXY1.MyWorldXY.b).ToString)
                                                        MyCheckForMovingPathEnds(Where, FlowChartPathIndex, MyXY2)
                                                        '?Flag = True
                                                        Exit For
                                                    End If
                                                Case "/delete"
                                                Case "/error"
                                                Case Else
                                            End Select ' end of the Symbols
                                            FlowChartCheckingPathIndex += 1 ' Should I ?
                                            ' MyStatus("Comparing " & Index & " : " & FlowChartPathIndex & " : " & FlowChartCheckingPathIndex)
                                        End While ' next record in the Symbols
                                    End If ' Testing if this is a /use
                                Case "/path"
                                    ' check if two paths are connected
                                    'FlowChartPathIndex = Index
                                    If LCase(FlowChart_TableCode(FlowChartUseIndex)) = "/path" Then
                                        For FlowChartCheckingPathIndex = FlowChartPathIndex To TopOfFile("FlowChart")
                                            MyDoEvents(172)
                                            If FlowChartCheckingPathIndex <> FlowChartUseIndex Then ' DoNot compare the same path
                                                If LCase(FlowChart_TableCode(FlowChartCheckingPathIndex)) = "/path" Then ' only compart paths to other paths
                                                    'xy1 to xy2
                                                    If MyDistance(MyPoint1_1XY(FlowChartUseIndex), MyPoint2_2XY(FlowChartCheckingPathIndex)) = 0 Then
                                                        MSG_ABug(1412, "CheckAllPaths():", FlowChartUseIndex.ToString, FlowChartCheckingPathIndex.ToString)
                                                        ' We are matching two paths together so Ignore ifit goes to another.
                                                        '**** We need to check that the names (name of the variable) are the same for the two paths (or can make them the same)
                                                        MyCheckForMovingPathEnds(Where, FlowChartUseIndex, MyPoint2_2XY(FlowChartCheckingPathIndex))
                                                        Flag = True
                                                        ' DoNot exit, check all other paths also 'Exit For
                                                    End If
                                                    ' xy2 to xy1
                                                    If MyDistance(MyPoint2_1XY(FlowChartUseIndex), MyPoint1XY(FlowChartCheckingPathIndex)) = 0 Then
                                                        MSG_ABug(1413, "CheckAllPaths", FlowChartUseIndex.ToString, FlowChartCheckingPathIndex.ToString)
                                                        MyCheckForMovingPathEnds(Where, FlowChartUseIndex, MyPoint1XY(FlowChartCheckingPathIndex))
                                                        Flag = True
                                                        ' DoNot exit, check all other paths also 'Exit For
                                                    End If

                                                    If MyDistance(MyPoint2_1XY(FlowChartUseIndex), MyPoint2_2XY(FlowChartCheckingPathIndex)) = 0 Then
                                                        MSG_ABug(1414, "CheckAllPaths():", MyShowFlowChartRecord(True, FlowChartUseIndex), MyShowFlowChartRecord(True, FlowChartCheckingPathIndex))
                                                        MyCheckForMovingPathEnds(Where, FlowChartUseIndex, MyPoint2_2XY(FlowChartCheckingPathIndex))
                                                        Flag = True
                                                        ' DoNot exit, check all other paths also 'Exit For
                                                    End If
                                                    If MyDistance(MyPoint2_1XY(FlowChartUseIndex), MyPoint2_2XY(FlowChartCheckingPathIndex)) = 0 Then
                                                        MSG_ABug(1415, "CheckAllPaths():", MyShowFlowChartRecord(True, FlowChartUseIndex), MyShowFlowChartRecord(True, FlowChartCheckingPathIndex))
                                                        MyCheckForMovingPathEnds(Where, FlowChartUseIndex, MyPoint2_2XY(FlowChartCheckingPathIndex))
                                                        Flag = True
                                                        ' DoNot exit, check all other paths also 'Exit For
                                                    End If
                                                End If
                                            End If
                                        Next
                                    End If
                                Case "/Constant"
                                    Flag = True
                                Case "/delete"
                                    Flag = True
                                Case "/error"
                                    Flag = True
                                Case Else
                            End Select
                            If Flag = False Then 'hack
                                MSG_ABug(1416, "Path Goes Nowhere", MyShowFlowChartRecord(True, FlowChartUseIndex), MyShowFlowChartRecord(True, FlowChartCheckingPathIndex)) 'hack
                                MakeErrorAt(Where, MyPoint1_1XY(FlowChartUseIndex), "Path goes no where")
                            End If
                        Next
                End Select

            Next ' Index

        End Sub





        Public Shared Function CheckAllSymbolsOnFlowChart(Where As PictureBox) As Int32
            Dim IndexFlowChart, Jdex As Int32
            Dim MyXY As MyPointStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3110, 10, "CheckAllSymbolsOnFlowChart")
#End If
            MyXY = Nothing
            CheckAllSymbolsOnFlowChart = 0
            FindingMyBugsSymbol()
            For IndexFlowChart = 1 To TopOfFile("FlowChart")
                ' removed   Mydoevents(173)
                For Jdex = IndexFlowChart + 1 To TopOfFile("FlowChart")
                    If MyDebug(8) Then follow(1418, 8, "Check All Symbols On Flow Chart : " + vbCrLf + MyShowFlowChartRecord(True, IndexFlowChart) + vbCrLf + vbTab + " against " + vbCrLf + MyShowFlowChartRecord(True, Jdex))
                    MyDoEvents(174)
                    If LCase(FlowChart_TableCode(Jdex)) = My_keyWord(My_KeyConstUse) Then
                        If MyOptionTest(15) = True Then ' Auto Move Symbols ontop of each other
                            While SymbolOnTopOfSymbol(IndexFlowChart, Jdex) = True
                                MyDoEvents(175)
                                MoveSymbolAndAllPaths(Where, Jdex, MyPoint1XY(MyUniverse.SysGen.Snaps.MySymbolSnap, 0))
                                MyDoEvents(176)
                                'PaintEach(Where, MyPoint1XY(FlowChart_TableX1(IndexFlowChart ), FlowChart_TableY1(IndexFlowChart )), FlowChart_TablePathSymbol_Name(Index))
                                MyDrawLineXY_XY(Where, MyLineS(IndexFlowChart, Jdex, 1), "red")
                                MyDrawLineXY_XY(Where, MyLineS(IndexFlowChart, Jdex, 2), "red")
                                MyDrawLineXY_XY(Where, MyLineS(IndexFlowChart, Jdex, 3), "red")
                                MyDrawLineXY_XY(Where, MyLineS(IndexFlowChart, Jdex, 4), "red")
                            End While
                        Else
                            If SymbolOnTopOfSymbol(IndexFlowChart, Jdex) = True Then
                                MyXY.x = FlowChart_TableX1(IndexFlowChart)
                                MyXY.y = FlowChart_TableY1(IndexFlowChart)
                                CheckAllSymbolsOnFlowChart += 1
                                MakeErrorAt(Where, MyXY, "Symbol Overlaps " & MyShowFlowChartRecord(True, IndexFlowChart) & " with " & MyShowFlowChartRecord(True, Jdex))
                            End If
                        End If
                    End If

                    If LCase(FlowChart_TableCode(IndexFlowChart)) = My_keyWord(My_KeyConstUse) Then
                        CheckAllSymbolsOnFlowChart += CheckSymbolByNamedIndex(IndexFlowChart)
                    End If
                Next
            Next
        End Function


        Public Shared Function CheckSymbolByNamedIndex(IndexNamed As Int32) As Int32
            Dim IndexSymbol As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3111, 10, "CheckSymbolByNamedIndex")
#End If
            CheckSymbolByNamedIndex = ConstantMyErrorCode

            'IndexNamed = FindIndexInISAMTable("Named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, FlowChart_TablePathSymbol_Name(IndexFlowChart ))
            If IndexNamed = ConstantMyErrorCode Then Return ConstantMyErrorCode

            IndexSymbol = GetSelfCorrectingIndexes(Named_TableSymbolName(IndexNamed))

            If IndexSymbol > ConstantMyErrorCode Then
                IndexSymbol += 1 ' go past the name 
                While IndexSymbol <= TopOfFile("named")
                    ' First check that the name of the point is in the program text (with " & Myfd("
                    Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                        Case "/name"
                            Return CheckSymbolByNamedIndex 'hack Least amount of checking here 'hack
                        Case "/line" 'ignore all lines
                        Case "/error" 'ignore all errors in the Symbol (for now)
                            MSG_AInfo(1420, "Ignore /error ", "", "")
                        Case "/point" ' Check points

                            'hack Is this instr right?  or should it be the other way around?

                            If InStr(Named_TableSyntax(IndexNamed), NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol))) = 0 Then
                                CheckSymbolByNamedIndex += 1
                                MSG_AInfo1(1421, "A Point name " & HighLight(Symbol_Table_NameOfPoint(IndexSymbol)) & " is not in the syntax", MyShowSymbolGraphic(True, IndexSymbol), MyShowNamedRecords(True, IndexNamed))
                                MSG_ABug(1422, "A See error 729 also : Index = " & IndexNamed.ToString & ":" & IndexSymbol.ToString, MyShowSymbolGraphic(True, IndexSymbol), MyShowNamedRecords(True, IndexNamed))
                                MSG_ABug(1423, "A Point name does not syntax code text ", HighLight(Named_TableSyntax(IndexNamed)), HighLight(Symbol_Table_NameOfPoint(IndexSymbol)))
                            End If

                            If InStr(Named_TableMicroCodeText(IndexNamed), NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol))) = 0 Then
                                CheckSymbolByNamedIndex += 1
                                MSG_AInfo1(1424, "B Point name " & HighLight(Symbol_Table_NameOfPoint(IndexSymbol)) & " is not in the micro text ", MyShowSymbolGraphic(True, IndexSymbol), MyShowNamedRecords(True, IndexNamed))
                                MSG_ABug(1425, "B See error 729B also : Index = " & IndexNamed.ToString & ":" & IndexSymbol.ToString, MyShowSymbolGraphic(True, IndexSymbol), MyShowNamedRecords(True, IndexNamed))
                                MSG_ABug(1426, "B Point name does not match micro code ", HighLight(Named_TableSyntax(IndexNamed)), HighLight(Symbol_Table_NameOfPoint(IndexSymbol)))
                            End If
                        Case "/unknown"
                            MSG_AInfo1(1427, "Ignoreing unknown code", MyShowSymbolGraphic(True, IndexSymbol), Symbol_TableCoded_String(IndexSymbol))
                            Dump3(2311, "Unknown code in the Symbol graphics " & Symbol_TableCoded_String(IndexSymbol))
                        Case Else
                            CheckSymbolByNamedIndex += 1
                            MyBeep()
                            MsgBox(MyShowSymbolGraphic(True, IndexSymbol), MsgBoxStyle.Information, "Error in Symbolo construction unknown code")
                    End Select
                    IndexSymbol += 1
                End While
            End If
            Return CheckSymbolByNamedIndex 'hack Least amount of checking here 'hack
        End Function


        Public Shared Sub CheckThisLong(BugNumber As Int32, MyArrayLong() As Int32, ByRef ISAM() As Int32, Index As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3112, 10, "CheckThisLong")
#End If
            '    CheckThisLong = false
            If Index <= 0 Then
                MyMsgCtr(1390, "CheckThisLong", "", "", "", "", "", "", "", "", BugNumber.ToString)
                Return
            End If
            If Index > UBound(MyArrayLong) - 1 Then
                MyMsgCtr(1391, "CheckThisLong", "", "", "", "", "", "", "", "", BugNumber.ToString)
                Return
            End If
            If Index > UBound(ISAM) - 1 Then
                MyMsgCtr(1392, "CheckThisLong", "", "", "", "", "", "", "", "", BugNumber.ToString)
                Return
            End If
            ' Need to check if at the end of the MyArray here (as in the string MyArray check
            If ISAM(Index) < 1 Then
                MyMsgCtr(1380, "CheckThisLong", "", ISAM(Index).ToString, Index.ToString, "", "", "", "", "".ToString, BugNumber.ToString)
                Return
            End If
            If ISAM(Index) >= UBound(MyArrayLong) - 1 Then
                'MyMsgCtr(1387, "CheckThisLong", "", ISAM(Index).ToString, Index.ToString, "", "", "", "", "", BugNumber.ToString)
                Return
            End If
            ' No errors detected if here
            '    CheckThisLong = true
        End Sub


        Public Shared Sub CheckThisStringArray(BugNumber As Int32, ByRef MyArray() As String, ByRef ISAM() As Int32, Index As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3113, 10, "CheckThisStringArray")
#End If
            '    CheckThis = false
            If Index <= 0 Then
                MyMsgCtr(1390, "CheckThis", "", "", "", "", "", "", "", "", BugNumber.ToString)
                Return
            End If
            If Index > UBound(MyArray) - 1 Then
                'MyMsgCtr(1393, "CheckThis", "", "", "", "", "", "", "", "", BugNumber.ToString)
                Return
            End If
            If Index > UBound(ISAM) - 1 Then
                'MSG_ABug(1430, "CheckThis", 0, 1394)
                'MyMsgCtr(1394, "CheckThis", "", "", "", "", "", "", "", "", BugNumber.ToString)
                Return
            End If

            'This check is no longer valid, because I split the Symbol name and path name into two arrays (uses only one or the other now.
            If MyIsNothing(MyArray(Index)) Then
                Return 'Because ISAM checks are meaningless after
            End If
            If ISAM(Index) < 1 Then
                Return
            End If
            If ISAM(Index) >= UBound(MyArray) - 1 Then
                'MSG_ABug(1431, "CheckThis", 0, 1389)
                'MyMsgCtr(1389, "CheckThis", "", ISAM(Index).ToString, Index.ToString, "", "", "", "CheckThis", "", BugNumber.ToString)
                Return
            End If
            ' No errors detected if here
        End Sub


        ' This is to check everything (It should be a thread that is always running on new/moved/delete)
        Public Shared Sub CheckAll()
#If MINEDEBUG Then
  if mydebug(9) then follow(3114, 10, "CheckAll")
#End If
            MyDoEvents(180)
            'First check for two named Symbols in the named/DataType/COlor table
            CheckColorTable()
            MyDoEvents(181)
            CheckDataType_Table()
            MyDoEvents(182)
            CheckNamed_Table()
            MyDoEvents(183)
            CheckAllPaths(FlowChartWindow.PictureBox1)
            MyDoEvents(184)
            CheckAllSymbolsOnFlowChart(FlowChartWindow.PictureBox1)
            MyDoEvents(185)
        End Sub

        Public Shared Sub MyRemoveAllUnusedSymbols()
            Dim Index As Int32
            Dim Jdex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3115, 10, "MyRemoveAllUnusedSymbols")
#End If
            'Need to Add to make sure that every /name in Symbols has a name in Named_Table also
            ShowSorts("Named", MySortStringArray("Named", Named_FileSyntax, Named_FileSyntax_ISAM))
            ShowSorts("Named", MySortStringArray("Named", Named_FileSymbolName, Named_FileSymbolName_ISAM)) ' make sure that the named Symbol table is in order for this to work.
            For Index = 1 To TopOfFile("named")
                If LCase(Named_TableSymbolName(Index)) = LCase(Named_TableSymbolName(Index + 1)) Then
                    If Named_TableSymbolName(Index) <> "" Then
                        MyReMoveSymbol(Named_TableSymbolName(Index)) ' From both named and Symbol
                        MyReMoveNamed(Index)
                    End If
                End If
            Next

            For Index = 1 To TopOfFile("named")
                If Len(Named_TableSymbolName(Index)) = 0 Then
                    MSG_ABug(1434, "MyRemoveAllUnusedSymbols():Null Symbol Name", "", "")
                    ' Need to see if there is anything I need to add here later
                Else
                    CheckForAnySortNeeded(244)
                    Jdex = FindIndexInISAMTable("FlowChart", "DoNotAdd", FlowChart_FilePathSymbolName, FlowChart_ISAM_Name, Named_TableSymbolName(Index))
                    CheckForAnySortNeeded(245)
                    'If Jdex > 1 Then
                    'MyMsgCtr(1366, "MyRemoveAllUnusedSymbols",
                    '     "39 Names : ",
                    '     Named_TableSymbolName(Index),
                    '     Named_TableSymbolName(Named_FileSymbolName_ISAM(Jdex - 1)),
                    '     Named_TableSymbolName(Named_FileSymbolName_ISAM(Jdex)),
                    '     Named_TableSymbolName(Named_FileSymbolName_ISAM(Jdex + 1)), "", "", "", "")
                    'End If
                    If Jdex = ConstantMyErrorCode Then
                        MyReMoveSymbol(Named_TableSymbolName(Index)) ' From both named and Symbol
                        MyReMoveNamed(Index)
                    End If
                End If
            Next
            ShowSorts("Named", MySortStringArray("Named", Named_FileSyntax, Named_FileSyntax_ISAM)) ' make sure that the named Symbol table is in order for this to work.
            ShowSorts("Named", MySortStringArray("Named", Named_FileSymbolName, Named_FileSymbolName_ISAM))

        End Sub

        Public Shared Sub MyReMoveNamed(IndexNamed As Int32) ' completed destroy it (for now)
#If MINEDEBUG Then
  if mydebug(9) then follow(3116, 10, "MyReMoveNamed")
#End If
            Named_TableSymbolName(IndexNamed, Nothing)
            Named_TableMicroCodeText(IndexNamed, Nothing)
            '    Named_TableLanguage(IndexNamed, Nothing)
            Named_TableNotes(IndexNamed, Nothing)
            Named_TableOpCode(IndexNamed, Nothing)
            Named_TableSymbolIndexes(IndexNamed, Nothing)
            Named_TableNameOfFile(IndexNamed, Nothing)
            Named_TableStroke(IndexNamed, Nothing)
        End Sub

        Public Shared Sub MyReMoveSymbol(SymbolName As String)
            Dim Index As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3117, 10, "MyReMoveSymbol")
#End If
            Index = FindInSymbolList(SymbolName)

            If Index = ConstantMyErrorCode Then
                MSG_ABug(1437, "This Symbol name is not found in the Symbol name table", SymbolName, "")
            Else
                If LCase(Symbol_TableSymbolName(Index)) = LCase(SymbolName) Then
                    Symbol_TableCode(Index, "/delete")
                    While Symbol_TableCoded_String(Index) <> "/name" And Index <= TopOfFile("Symbol")
                        Symbol_TableCode(Index, "/delete") ' consider making it nothing.
                        Index += 1
                    End While
                Else
                    ' We have some kind of internal error here.
                End If
            End If
        End Sub

        'Need to make sure that we Sort after at least one of these (and reset the kounter)
        Public Shared Sub MyDeleteDataType_Table(Index As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3118, 10, "MyDeleteDataType_Table")
#End If
            DataType_TableName(Index, Nothing)
            DataType_TableColorIndex(Index, 0L)
            DataType_TableDescription(Index, Nothing)
            DataType_TableNumberOfBytes(Index, Nothing)
            DataType_TableWidth(Index, Nothing)
            'now we should move everything up (reverse insert sort)
        End Sub


        Public Shared Sub DeleteAllErrorMessages()
            Dim Index As Int32
            Dim Jdex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3119, 10, "DeleteAllErrorMessages")
#End If
            Jdex = 0 ' one before the usable records
            For Index = 1 To TopOfFile("Symbol")
                If Symbol_TableCoded_String(Index) = "/error" Or Symbol_TableCoded_String(Index) = "/delete" Then
                Else
                    Jdex += 1
                End If
                If Index <> Jdex Then
                    FindingMyBugs(10) 'hack Least amount of checking here 'hack 2020 08 04
                    MySwapSymbolList(Index, Jdex) ' Move the records forward over the bad record to compress
                    FindingMyBugs(10) 'hack Least amount of checking here 'hack 2020 08 04
                End If
            Next

            Jdex = 0
            For Index = 1 To TopOfFile("FlowChart")
                If FlowChart_TableCode(Index) = "/error" Or FlowChart_TableCode(Index) = "/delete" Then
                Else
                    Jdex += 1
                End If
                If Index <> Jdex Then
                    FindingMyBugs(10) 'hack Least amount of checking here 'hack 2020 08 04
                    MySwapSymbolList(Index, Jdex) ' Move the records forward over the bad record to compress
                    FindingMyBugs(10) 'hack Least amount of checking here 'hack 2020 08 04
                End If
            Next
            SortALLISAM()
            FindingMyBugs(10) 'hack Least amount of checking here 'hack
        End Sub


        Public Shared Function MyIsNothing(AString As String) As Boolean
            If IsNothing(AString) Then Return True
            If AString.ToString = "" Then Return True
            Return False
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This makes sure that something is printable (make it an underline instead of nothing)
        Public Shared Function PrintAbleNull(A As String) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3120, 11, "PrintAbleNull")
#End If
            If IsNothing(A) Then Return "_"
            If Len(A.ToString) = 0 Or MyIsNothing(A.ToString) Then
                Return "_"
            Else
                Return A
            End If
        End Function


        Public Shared Function MyOffset(XY As MyPointStructure, X As String, Y As String) As MyPointStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3121, 10, "MyOffSet")
#End If
            MyOffset = Nothing
            MyOffset.x = XY.x + My_INT(X)
            MyOffset.y = XY.y + My_INT(Y)
        End Function



        Public Shared Function FindPathNameAtLine() As String
            Dim S1, S2 As String
            Dim LocalIndex, Jdex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3122, 10, "FindPathNameAtLine")
#End If
            'todo is this nessary '''S1 = ""
            'todo is this nessary '''S2 = ""
            LocalIndex = FindPathNameAt(MyUniverse.Area.MyWorldXY.b)
            Jdex = FindPathNameAt(MyUniverse.Area.MyWorldXY.a)
            S1 = FlowChart_TablePathName(LocalIndex)
            S2 = FlowChart_TablePathName(Jdex)
            If S1 = S2 Then Return S1
            If Len(S1) = 0 Then
                If Len(S2) = 0 Then
                    Return Nothing
                Else
                    Return S2
                End If
            Else
                If Len(S2) = 0 Then
                    Return S1
                Else
                    Return Nothing
                End If
            End If
            Return MakePathName("Path")
        End Function


        ' This routine returns the name of (any-First) path that it finds closest to this location
        Public Shared Function FindPathNameAt(XY As MyPointStructure) As Int32 ' index of path
            Dim D1, D2 As Int32
            Dim IndexFound, IndexFound2 As Int32 ' First Found One
            Dim Index As Int32
            Dim D3, D4 As Int32 'hack
#If MINEDEBUG Then
  if mydebug(9) then follow(3123, 10, "FindPathNameAt")
#End If
            IndexFound = 0
            IndexFound2 = 0
            For Index = 1 To TopOfFile("FlowChart") ' this should use the ISAM to go from a littlt below to a littlew above ...
                Select Case LCase(FlowChart_TableCode(Index))
                    Case "/use"
                    Case "/error"
                    Case "/Constant"
                    Case "/path"
                        If IndexFound = 0 Then
                            'MyInfo(691, "setting to find shorter distance to :", MyShowFlowChartRecord(False, Index), "")
                            XY.Named.PathName = FlowChart_TablePathName(Index) & "_A"
                            IndexFound = Index ' i IndexFound the first one available (It might even be itself.
                        End If
                        D1 = MyDistance(XY, MyPoint1XY(Index))
                        D2 = MyDistance(XY, MyPoint1XY(IndexFound))

                        If D1 < D2 Then
                            IndexFound = Index
                            XY.Named.PathName = FlowChart_TablePathName(Index) & "_B"
                        End If
                    Case Else
                        If IndexFound2 = 0 Then
                            IndexFound2 = Index
                            XY.Named.SymbolName = FlowChart_TableSymbol_Name(Index) & "_C"
                            If IndexFound <> 0 And IndexFound2 <> 0 Then
                                MSG_AInfo(1443, "Searching for path to " & MyShowPoint(XY), "Distances" & D1 & ":" & D2 & ":" & D3 & ":" & D4 & " Indexes " & ":" & Index & ":" & IndexFound & ":" & IndexFound2, " IndexFound something else" & vbCrLf & MyShowFlowChartRecord(True, Index) & vbCrLf & MyShowFlowChartRecord(True, IndexFound) & vbCrLf & MyShowFlowChartRecord(True, IndexFound2))
                            End If
                        End If
                        D3 = MyDistance(XY, MyPoint1XY(Index))
                        D4 = MyDistance(XY, MyPoint1XY(IndexFound))

                        If D3 < D4 Then
                            IndexFound2 = Index
                            XY.Named.SymbolName = FlowChart_TableSymbol_Name(Index) & "_D"
                            MSG_AInfo(1444, "Searching for path to " & MyShowPoint(XY), "Distances" & D1 & ":" & D2 & ":" & D3 & ":" & D4 & " Indexes " & ":" & Index & ":" & IndexFound & ":" & IndexFound2, " Found something else" & vbCrLf & MyShowFlowChartRecord(True, Index) & vbCrLf & MyShowFlowChartRecord(True, IndexFound) & vbCrLf & MyShowFlowChartRecord(True, IndexFound2))
                        End If
                End Select

            Next

            If IndexFound > 0 Then
                Return IndexFound
            Else
                MSG_AInfo(1446, "Searching for path to " & MyShowPoint(XY), "Distances" & D1 & ":" & D2 & ":" & D3 & ":" & D4 & " Indexes " & ":" & Index & ":" & IndexFound & ":" & IndexFound2, " Found something else" & vbCrLf & MyShowFlowChartRecord(True, Index) & vbCrLf & MyShowFlowChartRecord(True, IndexFound) & vbCrLf & MyShowFlowChartRecord(True, IndexFound2))
                If IndexFound2 > 0 Then
                    If FlowChart_TableCode(IndexFound2) <> My_keyWord(My_KeyConstUse) Then
                        MSG_ABug(1447, "Did Find at " & MyShowPoint(XY), "Distances =" & MyShowPoint(MyPoint1XY(D3, D4)), " found at " & MyShowFlowChartRecord(True, IndexFound2) & vbCrLf & "But it is not a path")
                    End If
                End If
                MSG_AInfo(1448, "Searching for path to " & MyShowPoint(XY), "Distances" & D1 & ":" & D2 & ":" & D3 & ":" & D4 & " Indexes " & ":" & Index & ":" & IndexFound & ":" & IndexFound2, " Found something else" & MyShowFlowChartRecord(True, Index))
                Return ConstantMyErrorCode
            End If
            'should never get to this point!!!!
            MSG_ABug(1449, "Searching for path to " & MyShowPoint(XY), "Distances" & D1 & ":" & D2 & ":" & D3 & ":" & D4 & " Indexes " & ":" & Index & ":" & IndexFound & ":" & IndexFound2, " Found something else" & MyShowFlowChartRecord(True, Index))
        End Function

        'RECURSIVE routine to find all of the paths connected together to XY.
        Public Shared Function FindAllPaths(IndexFlowChart As Int32, XY As MyPointStructure, Pathname As String) As Boolean
            '@@@@@@@@@@@@@@@@@ Yes I know that it causes recursion loop that will never stop, I'll fix it later - Really I will
            ' Find all of the points to this location and return as a string of the index to that path
            Dim I As Int32
            Dim IndexFlowChartX1 As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3124, 10, "FindAllPaths")
#End If
            Pathname = CheckThisPathName(Pathname, IndexFlowChart)
            'MSG_AInfo(1451, "FindAllPaths " & MyShowPoint(XY), Pathname, MyShowFlowChartRecord(true , IndexFlowChart))
            If IndexFlowChart < 1 Then
                MSG_ABug(1452, XY.x.ToString, XY.y.ToString, IndexFlowChart.ToString)
                Return False
            End If
            If IndexFlowChart > TopOfFile("FlowChart") Then Return False
            If LCase(FlowChart_TableCode(IndexFlowChart)) <> "/path" Then Return False

            If MyInListOfNumbers(IndexFlowChart) = False Then
                MSG_AInfo1(1453, "The path number " & IndexFlowChart & " is NOT in the pathlinks", MyShowFlowChartRecord(True, IndexFlowChart), "")
                Return False
            End If

            CheckForAnySortNeeded(248)
            '@@@@@@@@@@@@@@@@@@@@ Error this is not returning the index of a found item
            IndexFlowChartX1 = FindIndexInISAMTable("FlowChart", "DoNotAdd", FlowChart_FileX1, FlowChart_ISAM_X1, FlowChart_TableX1(IndexFlowChart))

            '?I = MyUniverse.MyCheatSheet.LastISAMNumberIndex

            CheckForAnySortNeeded(248)
            If MyCheckIndex_long("FlowChart", IndexFlowChartX1, FlowChart_File_X2_Rotation, FlowChart_ISAM_X1) = False Then
                Return False
            End If
            IndexFlowChartX1 = MyMinMax(IndexFlowChartX1, 1, UBound(FlowChart_ISAM_X1))

            'Why does the following line error out? It works the first few times
            '?
            'Lets make sure we are at the geggining of the first ISAM(index)
            If InvalidIndex(IndexFlowChart, FlowChart_FileX1, FlowChart_ISAM_X1) Then Return False
            While FlowChart_TableX1(FlowChart_ISAM_X1(IndexFlowChartX1 - 1)) < FlowChart_TableX1(IndexFlowChart)
                IndexFlowChartX1 += 1
                If IndexFlowChartX1 >= TopOfFile("FlowChart") Then Exit While
            End While

            While FlowChart_TableX1(FlowChart_ISAM_X1(IndexFlowChartX1 - 1)) = FlowChart_TableX1(IndexFlowChart)
                IndexFlowChartX1 -= 1
            End While

            '    If FindIndex_In_TableNetLinks(IndexFlowChart ) > 0 Then Return False ' already in a net
            ' Already in a net 
            While InvalidIndex(IndexFlowChartX1, FlowChart_FilePathSymbolName) = False And FlowChart_TableX1(FlowChart_ISAM_X1(IndexFlowChartX1)) <=
                FlowChart_TableX1(IndexFlowChart)
                I = FlowChart_ISAM_X1(IndexFlowChartX1)
                If IndexFlowChart <> IndexFlowChartX1 Then
                    Select Case LCase(FlowChart_TableCode(I))
                        Case "/path"
                            If IndexFlowChart <> I Then
                                CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart))
                                If MyInListOfNumbers(IndexFlowChart) = True Then
                                    'MSG_AInfo(1454, "Already in the path links", MyShowFlowChartRecord(true , IndexFlowChart), MyShowNetLnks(FindIndex_In_TableNetLinks(IndexFlowChart)))
                                Else
                                    'Check The first point
                                    If XY.x = FlowChart_TableX1(I) Then
                                        If XY.y = FlowChart_TableY1(I) Then
                                            CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart))
                                            ' Start new tree search
                                            If FindAllPaths(I, MyPoint1XY(FlowChart_TableX1(I), FlowChart_TableY1(I)), Pathname) = True Then
                                                If FindAllPaths(I, MyPoint2XY(FlowChart_TableX2(I), FlowChart_TableY2(I)), Pathname) = True Then
                                                    Return True
                                                End If
                                            End If
                                        End If
                                    End If
                                    'Check The Second point
                                    If XY.x = FlowChart_TableX2(I) Then
                                        If XY.y = FlowChart_TableY2(I) Then
                                            CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart))
                                            ConnectPaths(I, IndexFlowChart, Pathname)
                                            ' Start new tree search
                                            If FindAllPaths(I, MyPoint1XY(FlowChart_TableX1(I), FlowChart_TableY1(I)), Pathname) = True Then
                                                If FindAllPaths(I, MyPoint2XY(FlowChart_TableX2(I), FlowChart_TableY2(I)), Pathname) = True Then
                                                    Return True
                                                End If
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        Case My_keyWord(My_KeyConstUse)'ignore
                        Case "/error" 'ignore
                        Case "/origin" 'ignore
                        Case "/Constant" 'ignore
                        Case Else
                            MSG_AInfo(1455, "not a /path", MyShowFlowChartRecord(True, I), MyShowFlowChartRecord(True, IndexFlowChart))
                    End Select
                End If
                ''    FlowChart_TableCompiledMacroCodeText(IndexFlowChart , CleanListOfNets(IndexFlowChart ))
                CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart))
                'MyMsgCtr(1247, "FindAllPaths", IndexFlowChart .ToString, FlowChart_TableCompiledMacroCodeText(IndexFlowChart ), Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart )), "", "", "", "", "", "")
                IndexFlowChartX1 += 1
                If IndexFlowChartX1 <> MyMinMax(IndexFlowChartX1, 1, TopOfFile("FlowChart")) Then
                    Exit While
                End If

                IndexFlowChartX1 = MyMinMax(IndexFlowChartX1, 1, TopOfFile("FlowChart"))
                While InvalidIndex(IndexFlowChartX1, FlowChart_FileX1, FlowChart_ISAM_X1)
                    MSG_ABug(1456, "FindAllPaths() invalid index:", IndexFlowChartX1.ToString, MyShowFlowChartRecord(True, IndexFlowChartX1))
                    IndexFlowChartX1 += 1
                    If IndexFlowChartX1 > TopOfFile("FlowChart") Then Exit While
                    If IndexFlowChartX1 <> MyMinMax(IndexFlowChartX1, 1, TopOfFile("FlowChart")) Then
                        IndexFlowChartX1 = MyMinMax(IndexFlowChartX1, 1, TopOfFile("FlowChart"))
                    End If
                End While
                If IndexFlowChartX1 <> MyMinMax(IndexFlowChartX1, 1, TopOfFile("FlowChart")) Then
                    IndexFlowChartX1 = MyMinMax(IndexFlowChartX1, 1, TopOfFile("FlowChart"))
                End If
            End While
            ' Got here cause this XY is not anywhere else 
            ''    FlowChart_TableCompiledMacroCodeText(IndexFlowChart , CleanListOfNets(IndexFlowChart ))
            CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart))
            'MSG_AInfo(1457, "FindAllPaths", MyShowFlowChartRecord(true , IndexFlowChart), Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart))) ', "", "", "", "", "", "", "")
            Return True
        End Function




        Public Shared Sub FindAllPaths_2(IndexFlowChart As Int32) ', PathName As String) ' This does findallpaths()  but by name
            '@@@@@@@@@@@@@@@@@ Yes I know that it causes recursion loop that will never stop, I'll fix it later - Really I will
            ' Find all of the points to this location and return as a string of the index to that path
            Dim Index As Int32
            Dim Jdex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3125, 10, "FindAllPaths_2")
#End If
            'todo is this nessary '''PathName = CheckThisPathName(PathName, IndexFlowChart)
            If IndexFlowChart < 1 Then
                Return
            End If
            If IndexFlowChart > TopOfFile("FlowChart") Then Return
            If LCase(FlowChart_TableCode(IndexFlowChart)) <> "/path" Then Return

            '@@@@@@@@@@@@@@@@@@@@@@@@ I can speed it up later
            CheckForAnySortNeeded(249)
            Jdex = FindISAM_IN_Table("FlowChart", "DoNotAdd", FlowChart_FilePathSymbolName, FlowChart_ISAM_Name, FlowChart_TablePath_Name(IndexFlowChart))
            CheckForAnySortNeeded(249)
            If MyCheckIndex_String("FlowChart", Jdex, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) = False Then Return
            ' above is all extra and dow not work MyRight( I used it wrongly)


            'Get the index in the ISAM of the start
            Jdex = FindIndexInISAMTable("FlowChart", "DoNotAdd", FlowChart_FilePathSymbolName, FlowChart_ISAM_Name, FlowChart_TablePath_Name(IndexFlowChart))

            'todo is this nessary '''Index = MyUniverse.MyCheatSheet.LastISAMNumberIndex ' Is this what I want? and not jdex (ie set jdex to this )


            'hack to add Z when it returns nothing
            While FlowChart_TablePathName(FlowChart_ISAM_Name(Jdex)) & "z" < FlowChart_TablePathName(IndexFlowChart) And Jdex < UBound(FlowChart_ISAM_Name)
                Jdex += 1
            End While

            While FlowChart_TablePathName(FlowChart_ISAM_Name(Jdex - 1)) = FlowChart_TablePathName(IndexFlowChart) And Jdex > 1
                Jdex -= 1
            End While

            While FlowChart_TablePathName(FlowChart_ISAM_Name(Jdex)) <= FlowChart_TablePathName(IndexFlowChart)
                Index = FlowChart_ISAM_Name(Jdex)
                If InvalidIndex(Index, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then
                    'MSG_AInfo1(1459, "The index for the FlowChart is invalid ", Index, Jdex)
                    Exit While
                End If
                Select Case LCase(FlowChart_TableCode(Index))
                    Case "/path"
                        If IndexFlowChart <> Index Then
                            CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart))
                            If MyInListOfNumbers(IndexFlowChart) = True Then
                                'MyMsgCtr(1246, MyShowFlowChartRecord(true , IndexFlowChart), "", "", "", "", "", "", "", "", "")
                            Else
                                'Check The first point
                                If FlowChart_TablePathName(IndexFlowChart) = FlowChart_TablePathName(Index) Then
                                    CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart))
                                    '' FlowChart_TableCompiledMacroCodeText(IndexFlowChart , CleanListOfNets(IndexFlowChart ))
                                    ' This name is not in the list of path links , so lets connect them together
                                    MakePaths(IndexFlowChart, Index) ')
                                    'FLOW10' Causes recursion never ending 'MyShowAndUpDateProperties(Index)
                                    PaintAll(FlowChartWindow.PictureBox1, IndexFlowChart, IndexFlowChart)
                                    PaintAll(FlowChartWindow.PictureBox1, Index, Index)
                                End If
                            End If
                        End If
                        CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart))
                        ''        FlowChart_TableCompiledMacroCodeText(IndexFlowChart , CleanListOfNets(IndexFlowChart ))
                End Select
                Jdex += 1

                If InvalidIndex(Index, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then
                    MSG_ABug(1460, "The index for the FlowChart is invalid ", Index.ToString, "")
                    Exit While
                End If

            End While
            ' Got here cause this XY is not anywhere else 
            'MyMsgCtr(1248, "FindAllPaths_2", MyShowFlowChartRecord(true , IndexFlowChart), "", "", "", "", "", "", "", "")
        End Sub





        Public Shared Function NewFlowChartRecord() As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3126, 10, "NewFlowChartRecord")
#End If
            NewFlowChartRecord = NewTopOfFile("FlowChart")
            FlowChart_FilePathSymbolName(NewFlowChartRecord) = "?" ' just to make no errors 
            FlowChart_ISAM_Name(NewFlowChartRecord) = NewFlowChartRecord
            FlowChart_ISAM_X1(NewFlowChartRecord) = NewFlowChartRecord
            FlowChart_ISAM_Y1(NewFlowChartRecord) = NewFlowChartRecord
            FlowChart_ISAM_X2(NewFlowChartRecord) = NewFlowChartRecord
            FlowChart_ISAM_Y2(NewFlowChartRecord) = NewFlowChartRecord
        End Function



        ' returns true if the IndexFlowChart  is in the list of number in Symbol table data
        ' returns false if not, or issue
        Public Shared Function MyInListOfNumbers(IndexFlowChart As Int32) As Boolean
            Dim Temp, Numbers As String
            Dim IndexNetLinks As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3127, 10, "MyInListOfNumbers")
#End If
            Numbers = ""
            Temp = FD & IndexFlowChart & FD 'create a string to search for - Make sure the comma before and after so that it only find the complete number
            'hack I think that this is not used this way anymore, but that it should be getting the net_links of a pointer from ?????
            'stop here, somehow it is return an index beyond the end of the _fileLinks 
            IndexNetLinks = FindIndex_In_TableNetLinks(IndexFlowChart)
            'Check that the index is inside the netLinks bounds (If not then it is to be add as the next one.
            If IndexNetLinks > LBound(Net_FileLinks) Then
                If IndexNetLinks <= UBound(Net_FileLinks) Then
                    Numbers = Net_TableLinks(IndexNetLinks) ' indexnetlinks is a valid pointer to get the netlink information
                Else
                    MSG_ABug(1463, "Should never happen here ", IndexNetLinks.ToString, UBound(Net_FileLinks).ToString)
                    MakeNew_NetLinks(IndexFlowChart, FlowChart_TablePathName(IndexFlowChart))
                End If
            ElseIf IndexNetLinks < UBound(Net_FileLinks) Then
                Numbers = Net_TableLinks(IndexNetLinks)
            Else
                MSG_ABug(1464, "Should never happen here ", IndexNetLinks.ToString, UBound(Net_FileLinks).ToString)
                Numbers = Net_TableLinks(IndexNetLinks)
            End If

            If InStr(Numbers, Temp) > 0 Then Return True

            ' We should never get here 
            'todo al of the above to get to here to  see if the IndexFlowChart  already exist in a net
            Temp = Numbers
            While Len(Temp) > 0
                If PopValue(Temp) = IndexFlowChart Then
                    Return True
                End If
            End While
            Return False
        End Function



        ' This will return the index in netlink() of this index
        Public Shared Function CleanListOfNet_TableLinks(IndexNetLinks As Int32) As Int32 ' always return index to netlinks
            Dim I, K As Int32
            Dim CleanList As String
            Dim MyList(1) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3128, 10, "CleanListOfNet_TableLinks")
#End If
            If IndexNetLinks < 1 Then Return ConstantMyErrorCode
            If IndexNetLinks > UBound(Net_FileLinks) Then
                ReDim Preserve Net_FileLinks(IndexNetLinks + 1)
                ReDim Preserve Net_FileNames(IndexNetLinks + 1)
            End If

            CleanList = Net_TableLinks(IndexNetLinks)

            MyList(1) = 0
            While Len(CleanList) > 0
                ReDim Preserve MyList(UBound(MyList) + 1)
                K = PopValue(CleanList)
                If K <> 0 Then
                    MyList(UBound(MyList) - 1) = K
                End If
            End While
            For I = 1 To UBound(MyList)
                If MyList(I) <> 0 Then ' Do not check not used /deleted numbers
                    For K = I + 1 To UBound(MyList)
                        If MyList(I) = MyList(K) Then
                            MyList(I) = 0 ' Delete the duplicate
                        End If
                    Next K
                End If
            Next I

            For I = 1 To UBound(MyList) - 1
                If MyList(I) <> 0 Then
                    If CleanList = "" Then CleanList = FD 'changes to only have it if there is going to be something.
                    CleanList = CleanList & MyList(I) & FD
                End If
            Next I
            If CleanList = "" Then
                MSG_AInfo(1466, " Cleaned up the list and it is now nothing ", "Was ->" & Net_TableLinks(IndexNetLinks) & "<-", "")
            End If
            Net_TableLinks(IndexNetLinks, CleanList) 'Update this path List
            Return IndexNetLinks
        End Function

        Public Shared Sub ChangeOptionsWindowSelectedIndex(MyTable As String, T As ToolStripDropDownButton, WhatToSelect As String)
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3129, 10, "ChangeOptionsWindowSelectedIndex")
#End If
            CheckForAnySortNeeded(250)
            I = FindIndexInISAMTable("Color", "DoNotAdd", Color_FileName, Color_Name_ISAM, MyUniverse.ProgramOptions.SelectedColor)
            CheckForAnySortNeeded(251)
            If I = ConstantMyErrorCode Then
                MSG_ABug(1468, "The selected color is not found in the color table ", I.ToString, MyUniverse.ProgramOptions.SelectedColor)
                Return
            End If
            'MyUnEnum(Color_TableStyle(I), OptionsWindow.ComboBoxLineStyle, 2)

            'Error needs To be fixed
            'Temp = Color_TableStyle(I)

            SymbolWindow.ToolStripDropDownPathLineStyle.Text = I.ToString 'Color_TableStyle(I)
            SymbolWindow.ToolStripDropDownPathStart.Text = MyUnEnum(Color_TableStartCap(I), SymbolWindow.ToolStripDropDownPathStart, 0)
            SymbolWindow.ToolStripDropDownPathEnd.Text = MyUnEnum(Color_TableEndCap(I), SymbolWindow.ToolStripDropDownPathEnd, 1)

        End Sub



        'The following is to preview and print pages
        'Dim objCallback As System.Drawing.Image.GetThumbnailImageAbort = New System.Drawing.Image.GetThumbnailImageAbort(AddressOf ThumbnailCallback)
        'Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button1.Click
        'Dim printer As PrintDocument = New PrintDocument
        ' AddHandler() printer.PrintPage, AddressOf PrintImage
        'printer.Print()
        'End Sub
        'Private Sub PrintImage(ByVal sender As Object, ByVal e As PrintPageEventArgs)
        'Dim img As Image = PictureBox1.Image
        'img = img.GetThumbnailImage(300, 300, objCallback, IntPtr.Zero)
        'e.Graphics.DrawImage(img, 0, 0)
        'End Sub
        'Function ThumbnailCallback() As Boolean
        'Return false
        'End Function
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Another Example to print @@@@@@@@@@@@@@@@@@@@@@@
        'Public Sub printImage()
        'Dim objPrint As New PrintDocument
        ' AddHandler() objPrint.PrintPage, AddressOf PrintImage_PrintPage
        '    objPrint.Print()
        'End Sub
        'Private Sub PrintImage_PrintPage(ByVal sender As Object, ByVal e As PrintPageEvent A r g s )
        '    e.Graphics.DrawImage(PictureBox1.Image, 0, 0, PictureBox1.Width, PictureBox1.Height)
        'End Sub



        Public Shared Sub RouterTicked()
#If MINEDEBUG Then
  if mydebug(9) then follow(3130, 10, "RouterTicked")
#End If
            'DoEvents(186) ' required always
            Timer_MoveNextSymbol(TimerIndexFlowChartCounter)
            'DoEvents(187)
            If Timer_MoveNextPath(TimerIndexFlowChartCounter) = True Then
                'DoEvents(188)
                Timer_ReROUTERNextPath(TimerIndexFlowChartCounter)
            End If
            'DoEvents(189)
            TimerIndexFlowChartCounter += 1
            If TimerIndexFlowChartCounter > TopOfFile("FlowChart") Then
                TimerIndexFlowChartCounter = 1
            End If
        End Sub



        Public Shared Sub TimerTicked(sender As Object, e As EventArgs)
#If MINEDEBUG Then
  if mydebug(9) then follow(3131, 10, "TimerTicked")
#End If
            MyDoEvents(190) ' required always
            Timer_MoveNextSymbol(TimerIndexFlowChartCounter)
            MyDoEvents(191)
            If Timer_MoveNextPath(TimerIndexFlowChartCounter) = True Then
                MyDoEvents(192)
                Timer_ReROUTERNextPath(TimerIndexFlowChartCounter)
            End If
            MyDoEvents(193)
            TimerIndexFlowChartCounter += 1
            If TimerIndexFlowChartCounter > TopOfFile("FlowChart") Then
                TimerIndexFlowChartCounter = 0
            End If
        End Sub

        Public Shared Sub Timer_MoveNextSymbol(LocalIndex As Int32) ' always get the next to work on
            Dim Jdex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3132, 10, "Timer_MoveNextSymbol")
#End If
            LocalIndex = MyMinMax(LocalIndex, 1, TopOfFile("FlowChart"))
            If FlowChart_TableCode(LocalIndex) <> My_keyWord(My_KeyConstUse) Then Return ' cause we only want to work on Symbol right now.
            For Jdex = LocalIndex + 1 To TopOfFile("FlowChart")
                If FlowChart_TableCode(LocalIndex) = My_keyWord(My_KeyConstUse) Then
                    If SymbolOnTopOfSymbol(LocalIndex, Jdex) = True Then
                        'move one of the Symbols
                        MoveSymbolAndAllPaths(FlowChartWindow.PictureBox1, LocalIndex, MyPoint1XY(MyUniverse.SysGen.Constants.ConstantSymbolCenter + MyUniverse.SysGen.Constants.ConstantSymbolCenter, 0)) ' move over in the X the distance of this
                        ' Of course it will make it land on another one, but 
                    End If
                End If
            Next Jdex
        End Sub
        Public Shared Function Timer_MoveNextPath(LocalIndex As Int32) As Boolean
            Dim Jdex As Int32
            Dim Line1, Line2 As MyLineStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3135, 10, "Timer_MovwNextPath")
#End If
            Timer_MoveNextPath = False
            LocalIndex = MyMinMax(LocalIndex, 1, TopOfFile("FlowChart"))
            'DoEvents(194)
            If FlowChart_TableCode(LocalIndex) <> "/path" Then Exit Function ' cause we only want to work on paths right now
            'DoEvents(195)
            For Jdex = LocalIndex + 1 To TopOfFile("FlowChart")
                'DoEvents(196)
                If FlowChart_TableCode(LocalIndex) = "/path" Then
                    Line1 = MyLine1(LocalIndex)
                    Line2 = MyLine2(Jdex)
                    If PathOnTop(Line1, Line2) = True Then
                        'move one of the Symbols
                        Timer_MoveNextPath = True
                        ' Move it nex if true
                        'MoveSymbolAndAllPaths(FlowChartWindow.PictureBox1, LocalIndex, MyPoint1XY(myuniverse.SysGen.Constants.ConstantSymbolCenter + myuniverse.SysGen.Constants.ConstantSymbolCenter / 2, 0)) ' move over in the X the distance of this
                        ' Of course it will make it land on another one, but 
                    End If
                    'DoEvents(197)
                End If
            Next Jdex
            'DoEvents(198)
        End Function


        Public Shared Sub Timer_ReROUTERNextPath(LocalIndex As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3136, 10, "Timer_ReROUTERNextPath")
#End If
            LocalIndex = MyMinMax(LocalIndex, 1, TopOfFile("FlowChart"))
            MyDoEvents(200)
            If FlowChart_TableCode(LocalIndex) = "/path" Then Return ' cause we only want to work on paths right now
            MyDoEvents(201)
            MoveSymbolAndAllPaths(FlowChartWindow.PictureBox1, LocalIndex, MyPoint1XY(MyUniverse.SysGen.Constants.ConstantSymbolCenter, 0)) ' move over in the X the distance of this
            DoEvents(202)
        End Sub



        Public Shared Function Net_TableNames(IndexNet As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3137, 10, "Net_TableNames(A)")
#End If
            If IndexNet < LBound(Net_FileNames) Or IndexNet > UBound(Net_FileNames) Then Return Nothing 'Need to show an error 
            Return Net_FileNames(IndexNet)
        End Function
        Public Shared Sub Net_TableNameS(IndexNet As Int32, Value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3138, 10, "Net_TableNameS(B)")
#End If
            If IndexNet < 0 Or IndexNet > UBound(Net_FileNames) Then Return 'Need to show an error 
            Net_FileNames(IndexNet) = Value
            'FindingMyBugsNets()
        End Sub


        Public Shared Function Net_TableLinks(Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3145, 10, "Net_TableLinks(A)")
#End If
            If Index < 1 Or Index > UBound(Net_FileLinks) Then Return Nothing 'Need to show an error 
            Return Net_FileLinks(Index)
        End Function
        Public Shared Sub Net_TableLinks(Index As Int32, Value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3146, 10, "Net_TableLinks(B)")
#End If
            If Index < 1 Or Index > UBound(Net_FileLinks) Then Return 'Need to show an error 
            Net_FileLinks(Index) = Value
        End Sub





        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Named_TableSymbolName(Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3147, 10, "Named_TableSymbolName")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Named_TableSymbolName = Nothing
                Exit Function
            End If
            Named_TableSymbolName = Named_FileSymbolName(Index)
        End Function

        Public Shared Sub Named_TableSymbolName(Index As Int32, Value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3148, 10, "Named_TableSymbolName(B)")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then Return
            Named_FileSymbolName(Index) = Value
            MyUniverse.MyCheatSheet.NamedSorted += 1
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Named_TableMicroCodeText(Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3149, 10, "Named_TableMicroCodeText(B)")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Named_TableMicroCodeText = Nothing
                Exit Function
            End If
            Named_TableMicroCodeText = Named_FileMicroCodeText(Index)
        End Function

        Public Shared Sub Named_TableMicroCodeText(Index As Int32, Value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3150, 10, "Named_TableMicroCodeText")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Return
            End If
            Named_FileMicroCodeText(Index) = Value
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Named_TableOpCode(Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3151, 10, "Named_TableOpCOde(A)")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Named_TableOpCode = Nothing
                Exit Function
            End If
            Named_TableOpCode = Named_FileOpCode(Index)
        End Function

        Public Shared Sub Named_TableOpCode(Index As Int32, Value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3152, 10, "Named_TableOpCode(B)")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Return
            End If
            Named_FileOpCode(Index) = Value
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Named_TableSymbolIndexes(Index As Int32) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3153, 10, "Named_TableSymbolIndexes(A)")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Named_TableSymbolIndexes = Nothing
                Exit Function
            End If
            Named_TableSymbolIndexes = Named_FileSymbolIndexes(Index)
        End Function



        Public Shared Sub Named_TableSymbolIndexes(Index As Int32, value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3154, 10, "Named_TableSymbolIndexes(B)")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Return
            End If
            If MyDebug(5) Then follow(2763, 5, " pointer changed from " & Named_FileSymbolIndexes(Index).ToString & " to " & value)
            Named_FileSymbolIndexes(Index) = value
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Named_TableStroke(Index As Int32) As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3155, 10, "Named_TableStroke(A)")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Named_TableStroke = Nothing
                Exit Function
            End If
            Named_TableStroke = Named_FileStroke(Index)
        End Function



        Public Shared Sub Named_TableStroke(Index As Int32, Value As String)
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3156, 10, "Named_TableStroke(B)")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Return
            End If
            Named_FileStroke(Index) = Value
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Named_TableNameofFile(Index As Int32) As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3157, 10, "Named_TableNameOfFile(A)")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Named_TableNameofFile = Nothing
                Exit Function
            End If
            Named_TableNameofFile = Named_FileNameOfFile(Index)
        End Function


        Public Shared Sub Named_TableNameOfFile(Index As Int32, Value As String)
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3158, 10, "Named_TableNameOfFile(B)")
#End If
            If InvalidIndex(Index, Named_FileNameOfFile, Named_FileSymbolName_ISAM) Then
                Return
            End If
            Named_FileNameOfFile(Index) = Value
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Named_TableNotes(Index As Int32) As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3159, 10, "Named_TableNotes")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Named_TableNotes = Nothing
                Exit Function
            End If
            Named_TableNotes = Named_FileNotes(Index)
        End Function

        Public Shared Sub Named_TableNotes(Index As Int32, Value As String)
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3160, 10, "Named_TableNotes")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Return
            End If
            Named_FileNotes(Index) = Value
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Named_TableAuthor(Index As Int32) As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3161, 10, "Named_TableAuthor(A)")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Named_TableAuthor = Nothing
                Exit Function
            End If
            Named_TableAuthor = Named_FileAuthor(Index)
        End Function


        Public Shared Sub Named_TableAuthor(Index As Int32, Value As String)
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3162, 10, "Named_TableAuthor(B)")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Return
            End If
            Named_FileAuthor(Index) = Value
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Named_TableVersion(Index As Int32) As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3163, 10, "Named_TableVersion(A)")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Named_TableVersion = Nothing
                Exit Function
            End If
            Named_TableVersion = Named_FileVersion(Index)
        End Function


        Public Shared Sub Named_TableVersion(Index As Int32, Value As String)
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3164, 10, "Named_TableVersion(B)")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Return
            End If
            Named_FileVersion(Index) = Value
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Named_TableSyntax(Index As Int32) As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3165, 10, "Named_TableSyntax(B)")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Named_TableSyntax = Nothing
                Exit Function
            End If
            Named_TableSyntax = Named_FileSyntax(Index)
        End Function


        Public Shared Sub Named_TableSyntax(Index As Int32, Value As String)
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3166, 10, "Syntax")
#End If
            If InvalidIndex(Index, Named_FileSymbolName, Named_FileSymbolName_ISAM) Then
                Return
            End If

            Named_FileSyntax(Index) = Value
        End Sub

        Public Shared Function FindInputOutputIndex(InputOutputName As String) As Int32
            Dim I As Int32
            Dim Temp As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3167, 10, "FindInputOutputIndex")
#End If
            For I = 0 To SymbolWindow.ToolStripDropDownInputOutput.DropDownItems.Count - 1
                Temp = SymbolWindow.ToolStripDropDownInputOutput.DropDownItems(I).Text
                If MyTrim(LCase(InputOutputName)) = LCase(MyTrim(Pop(Temp, MyUniverse.SysGen.Constants.ConstantDelimiters))) Then
                    Return I
                End If
            Next
            Return ConstantMyErrorCode
        End Function

        Public Shared Function FindDataTypeIndex(DataTypeName As String) As Int32
            Dim I As Int32
            I = FindIndexInISAMTable("DataType", "DoNotAdd", DataType_FileName, DataType_Name_ISAM, DataTypeName)
            If I = ConstantMyErrorCode Then
#If MINEDEBUG Then
                if MyDebug(10 ) then follow((3168, 10, "FindDataTypeIndex not in list " & HighLight(DataTypeName))
#End If
                Return ConstantMyErrorCode
            End If
            Return I
        End Function

        Public Shared Function FindColorIndexFromName(ColorName As String) As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3169, 10, "FindColorIndexFromName")
#End If
            Return FindIndexInISAMTable("Color", "DoNotAdd", Color_FileName, Color_Name_ISAM, ColorName)
        End Function

        Public Shared Function FindColorFromDataType(DataTypeName As String) As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3170, 10, "FindColorFromDataType " & HighLight(DataTypeName))
#End If
            If Len(DataTypeName) = 0 Then
                Return Nothing
            End If
            Return Color_TableName(DataType_TableColorIndex(FindDataTypeIndex(DataTypeName)))
        End Function


        Public Shared Function FindWidthFromDataType(DataTypeName As String) As Int32
            Dim I2 As Int32
            Dim LocalIndex, Kdex, Jdex As Int32
            Dim ErrorCount As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3171, 10, "FindWidthFromDataType")
#End If
            Kdex = TopOfFile("DataType")
            LocalIndex = CInt(Kdex / 2)
            Jdex = CInt((LocalIndex - 4) / 2)
            ErrorCount = 2048
            FindWidthFromDataType = 0
            While ErrorCount > 0
                ErrorCount -= 1
                Select Case MyCompared3(DataType_TableName(DataType_Name_ISAM(LocalIndex)), DataTypeName, DataType_TableName(DataType_Name_ISAM(LocalIndex + 1)))
                    Case -5 ' Test 9 A > C unsorted list error
                        MSG_ABug(1503, DataType_TableName(DataType_Name_ISAM(LocalIndex)), DataTypeName, DataType_TableName(DataType_Name_ISAM(LocalIndex + 1)))
                        FindWidthFromDataType = 1 'default min DataType/line width
                        LocalIndex -= Jdex
                    Case -4 'Test 5 & 7  both A=nothing and b = c then only A=nothing
                        FindWidthFromDataType = 0
                        'todo should this one be + or -?
                        LocalIndex += 1
                    Case -3 'test 11 A is higher than B  and C = nothing
                        FindWidthFromDataType = 1 'default min DataType/line width
                        LocalIndex -= Jdex
                    Case -2 'test 12  b>C
                        FindWidthFromDataType = 1 'default min DataType/line width
                        LocalIndex += Jdex
                    Case -1 'Test 3 -> A = b
                        Return DataType_TableWidth(LocalIndex)
                    Case 0 'Test 2 & 10 A and C are both null or nothing then A<b<C not in list
                        FindWidthFromDataType = 0
                        Exit While
                    Case 1 'Test 4 -> b=C so move forward just one.
                        FindWidthFromDataType = DataType_TableWidth(LocalIndex)
                        LocalIndex += 1
                    Case 2 'test 14 A<b
                        FindWidthFromDataType = DataType_TableWidth(LocalIndex)
                        LocalIndex += Jdex
                    Case 3 'test 13 b < C
                        FindWidthFromDataType = DataType_TableWidth(LocalIndex)
                        LocalIndex += Jdex
                    Case 4 'test 6 & 8 ->>> C is nothing and b > A then C=nothing
                        FindWidthFromDataType = 0
                        Exit While
                    Case 5 'Test 1 & 15 -> b=nothing then no other test works (Error)
                        MSG_ABug(1504, DataType_TableName(DataType_Name_ISAM(LocalIndex)), "searching for" & HighLight(DataTypeName), DataType_TableName(DataType_Name_ISAM(LocalIndex + 1)))
                        Return 1
                End Select
                If LocalIndex = 0 And Jdex = 1 Then Exit While
                LocalIndex = MyMinMax(LocalIndex, 1, Kdex)
                Jdex = MyMinMax(CInt(Jdex / 2), 1, Kdex)
            End While
            For I2 = 1 To TopOfFile("DataType")
                If LCase(Trim(DataTypeName)) = LCase(Trim(DataType_TableName(I2))) Then
                    MSG_ABug(1505, "Failed binary search for width", DataTypeName, "")
                    Return DataType_TableWidth(I2)
                End If
            Next
        End Function


        'returns if the colors have changed.

        'todo this routine needs to NOT use getpen() but instead just the ARGB value to compare
        Public Shared Function TestIfColorStandardMicroSoftColorName(IndexColor As Int32) As Int32
            Dim I As Int32
            Dim R1, R2, G1, G2, B1, B2, A1, A2, LastIndex As Int32
            Dim LastDistance, Distance As Int64
            Dim ThisPen, ThatPen As Pen
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3172, 10, "TestIfColorStandardMicroSoftColorName")
#End If
            If Len(Color_TableName(IndexColor)) = 0 Then Return ConstantMyErrorCode
            '?LastIndex = LBound(Color_FileName)
            ThisPen = MyGetPen(Color_TableName(IndexColor), "")

            If ThisPen.Color.Name = Color_TableName(IndexColor) Then Return IndexColor
            ThatPen = MyGetPen(Color_TableName(IndexColor), "")
            'todo if this color matches then we do not need to find the closest
            '  if mydebug(9) then follow(1507, 1, "Color Name Error?: " & HighLight(ThisPen.Color.Name) & "<>" & HighLight(ThatPen.Color.Name) & " Index= " & IndexColor & vbTab & Color_TableName(IndexColor) & vbTab & ThisPen.Color.Name.ToString)

            R1 = ThisPen.Color.R
            G1 = ThisPen.Color.G
            B1 = ThisPen.Color.B
            A1 = ThisPen.Color.A
            ' go through all of the pens to see if this one is there.

            LastDistance = 32000
            LastIndex = 1

            For I = 1 To UBound(Color_FileName)
                If Len(Color_FileName(I)) <> 0 Then
                    ThatPen = MyGetPen(Color_TableName(I), "")
                    'Th color is unknown so find the closest
                    ' go through all of the pens to see if this one is there.
                    R2 = ThatPen.Color.R
                    G2 = ThatPen.Color.G
                    B2 = ThatPen.Color.B
                    A2 = ThatPen.Color.A
                    Distance = MyABS64(R1 - R2)
                    Distance += MyABS64(G1 - G2)
                    Distance += MyABS64(B1 - B2)
                    Distance += MyABS64(A1 - A2)
                    If Distance < LastDistance Then
                        LastIndex = I
                        LastDistance = Distance
                    End If
                    If ThatPen.Color.Name = ThisPen.Color.Name Then
                        ThatPen.Dispose()
                        ThisPen.Dispose()
                        Return I ' names match
                    End If
                    ThatPen.Dispose()
                End If
            Next
            'This is the closest they come
            ThatPen.Dispose()
            ThisPen.Dispose()
            Return LastIndex
        End Function




        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'returns the index of the name of the color
        Public Shared Function FindColor(Clr As String) As Int32
            Dim I As Int32
            Dim LocalIndex, Kdex, Jdex As Int32
            Static LastString As String
            Static lastIndex As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow((3173, 10, "FindColor")
#End If
            If Clr = LastString Then Return lastIndex
            If MyIsNothing(Clr) Then Return ConstantMyErrorCode
            If Trim(Clr) = "" Then Return ConstantMyErrorCode



            Kdex = TopOfFile("Color")
            LocalIndex = CInt(Kdex / 2)
            Jdex = CInt((LocalIndex - 4) / 2)
            While 1 = 1
                Select Case MyCompared3(Color_TableName(Color_Name_ISAM(LocalIndex)), Clr, Color_TableName(Color_Name_ISAM(LocalIndex + 1)))
                    Case -5 ' Test 9 A > C unsorted list error
                        MSG_ABug(1509, Color_TableName(Color_Name_ISAM(LocalIndex)), Clr, Color_TableName(Color_Name_ISAM(LocalIndex + 1)))
                        LocalIndex -= Jdex
                    Case -4 'Test 5 & 7  both A=nothing and b = c then only A=nothing
                        FindColor = 1
                        lastIndex = FindColor : LastString = Clr
                        '      if MyDebug(10 ) then follow((2846,10," Closest Color " & Clr & " " &  TestIfColorStandardMicroSoftColorName(LocalIndex).ToString)
                        Exit Function
                    Case -3 'A is higher than B  and C = nothing
                        LocalIndex -= Jdex
                    Case -2 'test 12  b>C
                        LocalIndex += Jdex
                    Case -1 'Test 3 -> A = b
                        FindColor = LocalIndex
                        lastIndex = FindColor : LastString = Clr
                        '      if MyDebug(10 ) then follow((2847,10," Closest Color " & Clr & " " &  TestIfColorStandardMicroSoftColorName(LocalIndex).ToString)
                        Exit Function
                    Case 0 'Test 2 & 10 A and C are both null or nothing then A<b<C not in list
                        If MyDebug(10) Then follow(2848, 10, "10005 finding color = " & Clr)
                        FindColor = ConstantMyErrorCode
                        lastIndex = FindColor : LastString = Clr
                        '  if mydebug(9) then follow(2849,10," Closest Color " & Clr & " " &  TestIfColorStandardMicroSoftColorName(LocalIndex).ToString)
                        Exit Function
                    Case 1 'Test 4 -> b=C so move forward just one.
                        LocalIndex += 1
                    Case 2 'test 14 A<b
                        LocalIndex += Jdex
                    Case 3 'test 13 b < C
                        LocalIndex += Jdex
                    Case 4 'test 6 & 8 ->>> C is nothing and b > A then C=nothing
                        FindColor = LocalIndex 'end of the file
                        lastIndex = FindColor : LastString = Clr
                        '  if mydebug(9) then follow(2850,10," Closest Color " & Clr & " " &  TestIfColorStandardMicroSoftColorName(LocalIndex).ToString)
                        Exit Function
                    Case 5 'Test 1 & 15 -> b=nothing then no other test works (Error)
                        If MyIsNothing(Clr) Then Exit While
                        If Trim(Clr) = "" Then Exit While
                        If Clr = FD Then Exit While
                        MSG_ABug(1510, "Finding Color returns 5, meaning out of order", Color_TableName(Color_Name_ISAM(LocalIndex)) & " : " & Clr & " : " & Color_TableName(Color_Name_ISAM(LocalIndex + 1)), "")
                        FindColor = ConstantMyErrorCode
                        '  if mydebug(9) then follow(2851,10," Closest Color " & Clr & " " &  TestIfColorStandardMicroSoftColorName(LocalIndex).ToString)
                        Exit Function
                End Select
                If LocalIndex = 0 And Jdex = 1 Then Exit While
                LocalIndex = MyMinMax(LocalIndex, 1, Kdex)
                Jdex = MyMinMax(CInt(Jdex / 2), 1, Kdex)
            End While
            'FindColor = -1
            'Exit Function

            'failed so try everything loop

            For I = 1 To UBound(Color_FileName)
                If LCase(Trim(Clr)) = LCase(Trim(Color_TableName(I))) Then
                    MSG_ABug(1511, "FindColor() Failed to find it but a search of each and every one turned it up", I.ToString, Clr)
                    FindColor = I
                    lastIndex = FindColor : LastString = Clr
                    '  if mydebug(9) then follow(2852,10," Closest Color " & Clr & " " &  TestIfColorStandardMicroSoftColorName(LocalIndex).ToString)
                    Exit Function
                End If
            Next
            MSG_AInfo(1512, "FindColor():", Clr, 0)
            FindColor = ConstantMyErrorCode
            '  if mydebug(9) then follow(2853,10," Closest Color " & Clr & " " &  TestIfColorStandardMicroSoftColorName(LocalIndex).ToString)
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Color_TableName(Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3174, 10, "Color_TableName(A)")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then Return ""
            Color_TableName = Color_FileName(Index)
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Color_TableName(Index As Int32, Value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3175, 10, "Color_TableName(B)")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then
                Return
            End If
            Color_FileName(Index) = Value
            MyUniverse.MyCheatSheet.ColorsSorted += 1
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Color_TableStartCap(Index As Int32) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3176, 10, "Color_TableStartCap")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then Return ConstantMyErrorCode
            Color_TableStartCap = Color_FileStartCap(Index)
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Color_TableEndCap(Index As Int32) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3177, 10, "Color_TableEndCap(A)")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then Return ConstantMyErrorCode
            Color_TableEndCap = Color_FileEndCap(Index)
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'this returns the line style from the line number type
        Public Shared Function Color_TableStyle(Index As Int32) As Drawing2D.DashStyle
#If MINEDEBUG Then
  if mydebug(9) then follow(3178, 10, "Color_TableStyle")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then Return Nothing
            Select Case My_INT(MyUnEnum(Color_FileStyle(Index), SymbolWindow.ToolStripDropDownPathLineStyle, 1))
                Case 0
                    Return Drawing2D.DashStyle.Solid
                Case 1
                    Return Drawing2D.DashStyle.Dash
                Case 2
                    Return Drawing2D.DashStyle.DashDot
                Case 3
                    Return Drawing2D.DashStyle.DashDotDot
                Case 4
                    Return Drawing2D.DashStyle.Dot
                Case Else
                    Return Drawing2D.DashStyle.Solid
            End Select
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Color_TableAlpha(Index As Int32) As Byte
#If MINEDEBUG Then
  if mydebug(9) then follow(3179, 10, "Color_TableAlpha")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then
                Color_TableAlpha = Nothing
                Exit Function
            End If
            Color_TableAlpha = Color_FileAlpha(Index)
        End Function
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Color_TableRed(Index As Int32) As Byte
#If MINEDEBUG Then
  if mydebug(9) then follow(3180, 10, "Color_TableRed(A)")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then
                Color_TableRed = Nothing
                Exit Function
            End If
            Color_TableRed = Color_FileRed(Index)
        End Function
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Color_TableGreen(Index As Int32) As Byte
#If MINEDEBUG Then
  if mydebug(9) then follow(3181, 10, "Color_TableGreen(A)")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then
                Color_TableGreen = Nothing
                Exit Function
            End If
            Color_TableGreen = Color_FileGreen(Index)
        End Function
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Color_TableBlue(Index As Int32) As Byte
#If MINEDEBUG Then
  if mydebug(9) then follow(3182, 10, "Color_TableBlue(A)")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then
                Color_TableBlue = Nothing
                Exit Function
            End If
            Color_TableBlue = Color_FileBlue(Index)
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Color_TableStartCap(Index As Int32, value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3183, 10, "Color_TableStartCap")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then
                Return
            End If
            Color_FileStartCap(Index) = CByte(MyMinMax(value, 0, 255))
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Color_TableEndCap(Index As Int32, value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3184, 10, "Color_TableEndCap")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then
                Return
            End If
            Color_FileEndCap(Index) = CByte(MyMinMax(value, 0, 255))
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This saves the style of color index in the drop down 
        ' one for string input 
        Public Shared Sub Color_TableStyle(Index As Int32, value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3185, 10, "Color_TableStyle(A)")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then
                Return
            End If
            Color_FileStyle(Index) = CByte(MyMinMax(MyEnumValue(Trim(value), SymbolWindow.ToolStripDropDownPathLineStyle), 0, 255))
        End Sub
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        'one for DataType_FileNumberOfBytes input
        Public Shared Sub Color_TableStyle(Index As Int32, value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3186, 10, "Color_TableStyle(B)")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then
                Return
            End If
            Color_FileStyle(Index) = CByte(MyMinMax(value, 0, 255))
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Color_TableAlpha(Index As Int32, Value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3187, 10, "Color_TableAlpha")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then
                Return
            End If
            Color_FileAlpha(Index) = CByte(MyMinMax(Value, 0, 255))
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Color_TableRed(Index As Int32, Value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3188, 10, "Color_TableRed")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then
                Return
            End If
            Color_FileRed(Index) = CByte(MyMinMax(Value, 0, 255))
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Color_TableGreen(Index As Int32, Value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3189, 10, "Color_TableGreen")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then
                Return
            End If
            Color_FileGreen(Index) = CByte(MyMinMax(Value, 0, 255))
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Color_TableBlue(Index As Int32, Value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3190, 10, "Color_TableBlue(B)")
#End If
            If InvalidIndex(Index, Color_FileName, Color_Name_ISAM) Then
                Return
            End If
            Color_FileBlue(Index) = CByte(MyMinMax(Value, 0, 255))
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Symbol_TableCode(Index As Int32, value As Byte)
#If MINEDEBUG Then
  if mydebug(9) then follow(3191, 10, "Symbol_TableCode(A)")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Return
            End If
            Symbol_FileCoded(Index) = value
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Symbol_TableCode(Index As Int32, value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3192, 10, "Symbol_TableCode(B)")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Return
            End If
            Symbol_FileCoded(Index) = MyKeyword_2_Byte(value)
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Symbol_TableSymbolName(Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3193, 10, "Symbol_TableSymbolName")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Symbol_TableSymbolName = ConstantMyErrorCode.ToString
                Exit Function
            End If
            If MyDebug(7) Then FMB(5054)
            Symbol_TableSymbolName = Symbol_FileSymbolName(Index)
        End Function



        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Symbol_TableSymbolName(Index As Int32, value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3194, 10, "Symbol_TableSymbolName")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Return
            End If
            Symbol_FileSymbolName(Index) = value
            FMB(5055)
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Symbol_TableCoded_String(Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3196, 10, "Symbol_TableCoded_String")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Symbol_TableCoded_String = ""
                Exit Function
            End If
            Symbol_TableCoded_String = MyKeyword2String(Symbol_FileCoded(Index))
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Symbol_TableCoded_Byte(Index As Int32) As Byte
#If MINEDEBUG Then
  if mydebug(9) then follow(3197, 10, "Symbol_TableCoded_Byte")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Symbol_TableCoded_Byte = Nothing
                Exit Function
            End If
            Symbol_TableCoded_Byte = Symbol_FileCoded(Index)
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Symbol_TableX1(Index As Int32) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3198, 10, "Symbol_TableX1(A)")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Symbol_TableX1 = Nothing
                Exit Function
            End If
            Symbol_TableX1 = Symbol_FileX1(Index)
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Symbol_TableX1(Index As Int32, value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3199, 10, "Symbol_TableX1(B)")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Return
            End If
            Symbol_FileX1(Index) = value
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Symbol_TableY1(Index As Int32) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3200, 10, "Symbol_TableY1(A)")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Symbol_TableY1 = Nothing
                Exit Function
            End If
            Symbol_TableY1 = Symbol_FileY1(Index)
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Symbol_TableY1(Index As Int32, value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3201, 10, "Symbol_TableY1(B)")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Return
            End If
            Symbol_FileY1(Index) = value
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Symbol_Table_X2(Index As Int32) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3202, 10, "Symbol_Table_X2(C)")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Symbol_Table_X2 = ConstantMyErrorCode
                Exit Function
            End If
            If Symbol_FileX2_io(Index).MyNumber = -1 And Symbol_FileX2_io(Index).MyString = "" Then
                Return -1 'todo debug this is to catch the problem
            End If
            Symbol_Table_X2 = Symbol_FileX2_io(Index).MyNumber
        End Function


        Public Shared Function Symbol_Table_InputOutput(Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3203, 10, "Symbol_Table_InputOutput")
#End If

            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Return Nothing
            End If
            'Temp = SymbolWindow.ToolStripDropDownInputOutput.DropDownItems(Symbol_FileX2_io(Index)).Text
            If MyIsNothing(Symbol_FileX2_io(Index).MyString) = True Then
                If Symbol_FileX2_io(Index).MyNumber >= 0 Then
                    If Symbol_FileX2_io(Index).MyNumber < SymbolWindow.ToolStripDropDownInputOutput.DropDownItems.Count Then
                        Return Pop(SymbolWindow.ToolStripDropDownInputOutput.DropDownItems(Symbol_FileX2_io(Index).MyNumber).Text, FD)
                    Else
                        Return "Both" 'todo there are errors all over the place with this routine.  
                    End If
                Else
                    Return "Both" 'default
                End If
            Else
                Return Symbol_FileX2_io(Index).MyString
            End If
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Symbol_Table_X2(Index As Int32, value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3204, 10, "Symbol_Table_X2")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then Return
            If Index = 8 Then
                value = value ' todo remove this debug 
            End If
            Symbol_FileX2_io(Index).MyNumber = value
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Symbol_Table_InputOutput(Index As Int32, value As String)
            'Dim jdex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3205, 10, "Symbol_Table_InputOutput")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then Return
            'jdex = FindInputOutputIndex(value)
            Symbol_FileX2_io(Index).MyString = value
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Symbol_Table_Y2(Index As Int32) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3206, 10, "Symbol_Table_Y2(A)")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                'todo then return if it is a unenum.
                MSG_ABug(1547, "This should not happen, invalid index on Y2/DataType=", Index.ToString, "")
                Return ConstantMyErrorCode
            End If
            'todo, should return a string of the DataType if less than ?
            Return Symbol_FileY2_dt(Index).MyNumber
        End Function

        Public Shared Function Symbol_Table_DataType(Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3207, 10, "Symbol_Table_DataType")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                MSG_ABug(1548, "This should not happen, invalid index on Y2/DataType=", Index.ToString, "")
                Return Nothing
            End If
            If Symbol_TableCoded_String(Index) = "/Line" Then 'lines do not have DataTypes
                Return ""
            End If
            If MyIsNothing(Symbol_FileY2_dt(Index).MyString) = True Then
                If Symbol_FileY2_dt(Index).MyNumber >= 0 Then
                    If Symbol_FileY2_dt(Index).MyNumber = 0 Then
                        Return "" 'todo check this no string, and zero index (which is invalid?)
                    ElseIf Symbol_FileY2_dt(Index).MyNumber < 0 Then
                        Return Symbol_FileY2_dt(Index).MyNumber.ToString
                    ElseIf Symbol_FileY2_dt(Index).MyNumber <= SymbolWindow.ToolStripDropDownDataType.DropDownItems.Count Then
                        Symbol_Table_DataType(Symbol_FileY2_dt(Index).MyNumber, DataType_TableName(Symbol_FileY2_dt(Index).MyNumber)) 'todo fix the data type to 
                        Return DataType_TableName(Symbol_FileY2_dt(Index).MyNumber)
                    ElseIf Symbol_FileY2_dt(Index).MyNumber < SymbolWindow.ToolStripDropDownDataType.DropDownItems.Count Then
                        If MyDebug(4) Then follow(2175, SymbolWindow.ToolStripDropDownDataType.DropDownItems(Symbol_FileY2_dt(Index).MyNumber).Text)
                        If MyDebug(4) Then follow(2176, Pop(SymbolWindow.ToolStripDropDownDataType.DropDownItems(Symbol_FileY2_dt(Index).MyNumber).Text, FD))
                        Return Pop(SymbolWindow.ToolStripDropDownDataType.DropDownItems(Symbol_FileY2_dt(Index).MyNumber).Text, FD)
                    Else
                        If MyDebug(1) Then follow(2177, "******  error here some how")
                        Return ""
                    End If
                Else
                    Return "Logic" 'default
                End If
            Else
                Return Symbol_FileY2_dt(Index).MyString
            End If
        End Function




        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Symbol_Table_Y2(Index As Int32, value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3208, 10, "Symbol_Table_Y2(B)")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Return
            End If
            Symbol_FileY2_dt(Index).MyNumber = value
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

        Public Shared Function Symbol_Table_LineColor(Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3209, 10, "Symbol_Table_LineColor")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Return ""
            End If
            Return Symbol_File_NameOfPoint(Index)
        End Function


        Public Shared Sub Symbol_Table_LineColor(Index As Int32, Value As String)
            Dim LocalIndex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3210, 10, "Symbol_Table_LineColor")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Return
            End If
            If Symbol_TableCoded_String(Index) <> "/Line" Then
                MSG_ABug(2723, "can not make a line a data type ", "Program possible bug", "")
                Return
            End If
            LocalIndex = FindIndexInISAMTable("Color", "DoNotAdd", Color_FileName, Color_Name_ISAM, Value)
            If LocalIndex < 0 Then
                If Len(Value) = 0 Then
                    LocalIndex = 0
                Else
                    LocalIndex = FindIndexInISAMTable("color", "DoNotAdd", Color_FileName, Color_Name_ISAM, "errored")
                    If LocalIndex < 0 Then
                        LocalIndex = 0
                    End If
                    MSG_ABug(1551, "Unable to find the color or data type " & HighLight(Value), "Forced to be Black", "")
                    If MyOptionTest(25) = True Then
                        LocalIndex = FindIndexInISAMTable("Color", "add", Color_FileName, Color_Name_ISAM, Value)
                    Else
                        LocalIndex = FindIndexInISAMTable("color", "DoNotAdd", Color_FileName, Color_Name_ISAM, "black")
                    End If
                End If
            End If
            Symbol_Table_NameOfPoint(Index, Value) 'Save the number of the index into the Y of this Symbol record (/point)
        End Sub




        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Symbol_Table_DataType(Index As Int32, Value As String) ' Assumed DataType if passing a string
            Dim LocalIndex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3211, 10, "Symbol_Table_DataType")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Return
            End If
            If Symbol_TableCoded_String(Index) = "/Line" Then
                MSG_ABug(2720, "can not make a line a data type ", "Program possible bug", "")
                Return
            End If
            LocalIndex = FindIndexInISAMTable("DataType", "DoNotAdd", DataType_FileName, DataType_Name_ISAM, Value)
            If LocalIndex < 0 Then
                If Len(Value) = 0 Then
                    LocalIndex = 0
                Else
                    LocalIndex = FindIndexInISAMTable("DataType", "DoNotAdd", DataType_FileName, DataType_Name_ISAM, "errored")
                    If LocalIndex < 0 Then
                        LocalIndex = 0
                    End If
                    MSG_ABug(1551, "Unable to find the color or data type " & HighLight(Value), "Forced to be Black", "")
                    If MyOptionTest(25) = True Then
                        LocalIndex = FindIndexInISAMTable("DataType", "add", DataType_FileName, DataType_Name_ISAM, Value)
                    Else
                        LocalIndex = FindIndexInISAMTable("color", "DoNotAdd", Color_FileName, Color_Name_ISAM, "errored")
                    End If
                End If
            End If
            Symbol_Table_Y2(Index, LocalIndex) 'Save the number of the index into the Y of this Symbol record (/point)
        End Sub






        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function Symbol_Table_NameOfPoint(Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3212, 10, "FlowChart_Table_NameOfPoint")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Symbol_Table_NameOfPoint = Nothing
                Exit Function
            End If
            Symbol_Table_NameOfPoint = Symbol_File_NameOfPoint(Index)
        End Function



        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub Symbol_Table_NameOfPoint(Index As Int32, value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3214, 10, "FlowChart_Table_NameOfPoint")
#End If
            If InvalidIndex(Index, Symbol_FileSymbolName) Then
                Return
            End If
            Symbol_File_NameOfPoint(Index) = value
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function FlowChart_TableCode(IndexFlowChart As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3215, 10, "FlowChart_TableCode")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName) Then
                ' A I N F O 2  ( 9  96)
                FlowChart_TableCode = Nothing
                Exit Function
            End If
            FlowChart_TableCode = MyKeyword2String(FlowChart_FileCoded(IndexFlowChart))
        End Function 'FlowChart_TableCode


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        'converts it from a string (name or number passed as a styring) to save.
        Public Shared Sub FlowChart_TableCode(IndexFlowChart As Int32, Value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3216, 10, "FlowChart_TableCode")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then
                Return
            End If
            FMB_IsXY(FlowChart_FileX1(IndexFlowChart), FlowChart_FileY1(IndexFlowChart), FlowChart_File_X2_Rotation(IndexFlowChart), FlowChart_File_Y2_Option(IndexFlowChart))
            Select Case LCase(Value)
                Case "/use", "5"
                    FlowChart_FileCoded(IndexFlowChart) = 5
                Case "/path", "6"
                    FlowChart_FileCoded(IndexFlowChart) = 6
                Case "/delete", "14"
                    FlowChart_FileCoded(IndexFlowChart) = 14
                Case "/Constant", "15"
                    FlowChart_FileCoded(IndexFlowChart) = 15
                Case "/error", "13"
                    FlowChart_FileCoded(IndexFlowChart) = 13
                Case Else
                    FlowChart_FileCoded(IndexFlowChart) = 0 'unknown
                    MSG_ABug(1556, "FlowChart_TableCode():", "Unknown code ", Value)
            End Select
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function FlowChart_TableSymbol_Name(IndexFlowChart As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3217, 10, "FlowChart_TableSymbol_Name")
#End If
            If FlowChart_TableCode(IndexFlowChart) = "/delete" Then Return ""
            If mydebug(9) Then follow(2854, 10, "FC Symbol name = " & FlowChart_Table_Path_SymbolName(IndexFlowChart))
            Return FlowChart_Table_Path_SymbolName(IndexFlowChart)
        End Function 'FlowChart_TableSymbol_Name
        Public Shared Function FlowChart_TableOther_Name(IndexFlowChart As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3218, 10, "FlowChart_TableCode")
#End If
            Select Case FlowChart_TableCode(IndexFlowChart)
                Case "/path"
                    MSG_ABug(1561, "", "using a /other for a " & MyShowFlowChartRecord(True, IndexFlowChart), "")
                Case My_keyWord(My_KeyConstUse)
                    MSG_ABug(1562, "using a /use= for a /other= ", IndexFlowChart.ToString, "")
                Case Else
                    If MyDebug(10) Then follow(2855, 10, "FC Other name = " & FlowChart_Table_Path_SymbolName(IndexFlowChart)) '& MyShowFlowChartRecord(True, IndexFlowChart))
            End Select
            Return FlowChart_Table_Path_SymbolName(IndexFlowChart)
        End Function

        Public Shared Function FlowChart_Table_Path_SymbolName(IndexFlowChart As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3219, 10, "FlowChart_Table_Path_SymbolName")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then
                FlowChart_Table_Path_SymbolName = Nothing
                Exit Function
            End If

            FlowChart_Table_Path_SymbolName = FlowChart_FilePathSymbolName(IndexFlowChart)
            'if mydebug(9) then follow(2856, 10, "FC ???? name = " & FlowChart_FilePathSymbolName(IndexFlowChart)) ' FlowChart_Table_Path_SymbolName(IndexFlowChart))
        End Function 'FlowChart_Table_Path_SymbolName


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub FlowChart_TablePathSymbolName(IndexFlowChart As Int32, Value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3220, 10, "FlowChart_TablePathSymbolName(A)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then
                Return
            End If
            FMB_IsXY(FlowChart_FileX1(IndexFlowChart), FlowChart_FileY1(IndexFlowChart), FlowChart_File_X2_Rotation(IndexFlowChart), FlowChart_File_Y2_Option(IndexFlowChart))

            If InStr(Value, MyUniverse.SysGen.Constants.RMStart) <> 0 Then
                MSG_ABug(1564, "Path and Symbol names should not have a ", MyUniverse.SysGen.Constants.RMStart, Value)
                Value = NameOfPointOnly(Value)
            End If
            If FlowChart_FilePathSymbolName(IndexFlowChart) <> "" And FlowChart_FilePathSymbolName(IndexFlowChart) <> Value Then
                If MyDebug(9) Then follow(2180, "flow chart name changed " & HighLight(FlowChart_FilePathSymbolName(IndexFlowChart)) & vbTab & HighLight(Value) & vbCrLf)
            End If
            FlowChart_FilePathSymbolName(IndexFlowChart) = Value
            If MyDebug(9) Then follow(2857, "FC Symbol name set = " & FlowChart_Table_Path_SymbolName(IndexFlowChart))
            MyUniverse.MyCheatSheet.FlowChartSorted += 1
        End Sub



        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function FlowChart_TablePathNumber(IndexFlowChart As Int32) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3221, 10, "FlowChart_TablePathNumber(A)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then Return Nothing
            If FlowChart_TableCode(IndexFlowChart) <> "/path" Then Return Nothing
            FlowChart_TablePathNumber = UseNetLinksNumber(IndexFlowChart)
        End Function


        'this will simply return what ever is in the Symbol name table/cell/field
        Public Shared Function FlowChart_TablePath_Name(IndexFlowChart As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3222, 10, "FlowChart_TablePath_Name(A)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then Return Nothing
            Return FlowChart_Table_Path_SymbolName(IndexFlowChart)
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'cross between _pathnumber and net_names)
        Public Shared Function FlowChart_TablePathName(IndexFlowChart As Int32) As String
            Dim IndexNet As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3223, 1, "FlowChart_TablePathName " & IndexFlowChart.ToString)
#End If
            If IndexFlowChart = MyUniverse.MyStaticData.FlowChart_FilePathName.LastIndexFlowChart Then
                Return MyUniverse.MyStaticData.FlowChart_FilePathName.LastFlowChart_FilePathName
            End If
            'if mydebug(9) then follow(1567, 10, MyShowFlowChartRecord(True, IndexFlowChart))
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then Return Nothing
            If FlowChart_TableCode(IndexFlowChart) = "/path" Then
                IndexNet = FindIndex_In_TableNetLinks(IndexFlowChart)
                If IndexNet <> 0 Then
                    If FlowChart_FilePathSymbolName(IndexFlowChart) <> Net_TableNames(IndexNet) Then
                        'MSG_ABug(1568, "The name of the path is not the name of the linked path", MyShowFlowChartRecord(False, IndexFlowChart), MyShowNetLnks(FindIndex_In_TableNetLinks(IndexFlowChart)))
                        'FindingMyBugsFlowChart()
                        Return "NOT_" & IndexNet.ToString & FlowChart_FilePathSymbolName(IndexFlowChart)
                    Else
                        FlowChart_TablePathName = FlowChart_FilePathSymbolName(IndexFlowChart)
                        MyUniverse.MyStaticData.FlowChart_FilePathName.LastFlowChart_FilePathName = FlowChart_FilePathSymbolName(IndexFlowChart)
                        MyUniverse.MyStaticData.FlowChart_FilePathName.LastIndexFlowChart = IndexFlowChart
                        Exit Function
                    End If
                ElseIf FlowChart_TableCode(IndexFlowChart) = "/path" Then
                    MSG_ABug(2729, "Trying to fine that path name of a /use Symbol", MyShowFlowChartRecord(True, IndexFlowChart), "")
                Else
                    If MyDebug(4) Then follow(2181, "?:?:?:?:?: net number is zero for " & FlowChart_TableSymbol_Name(IndexFlowChart) & vbCrLf)
                    MSG_ABug(2182, "?*?*?*?* not a path for ", MyShowFlowChartRecord(True, IndexFlowChart), "")
                    Return Nothing
                End If
            End If
            IndexNet = FindIndex_In_TableNetLinks(IndexFlowChart)
            If IndexNet = 0 Then ' add this to the net links
                MakeNew_NetLinks(IndexFlowChart, FlowChart_FilePathSymbolName(IndexFlowChart))
            End If
            FlowChart_TablePathName = FlowChart_FilePathSymbolName(IndexFlowChart)
            MyUniverse.MyStaticData.FlowChart_FilePathName.LastFlowChart_FilePathName = FlowChart_FilePathSymbolName(IndexFlowChart)
            MyUniverse.MyStaticData.FlowChart_FilePathName.LastIndexFlowChart = IndexFlowChart
        End Function 'FlowChart_TablePathName



        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function FlowChart_TableX1(IndexFlowChart As Int32) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3224, 11, "FlowChart_TableX1(A)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then
                FlowChart_TableX1 = Nothing
                Exit Function
            End If
            FlowChart_TableX1 = FlowChart_FileX1(IndexFlowChart)
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub FlowChart_TableX1(IndexFlowChart As Int32, Value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3225, 10, "FlowChart_TableX1(B)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then
                Return
            End If
            FMB_IsXY(FlowChart_FileX1(IndexFlowChart), FlowChart_FileY1(IndexFlowChart), FlowChart_File_X2_Rotation(IndexFlowChart), FlowChart_File_Y2_Option(IndexFlowChart))
            FlowChart_FileX1(IndexFlowChart) = Value
            MyUniverse.MyCheatSheet.FlowChartSorted += 1
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function FlowChart_TableY1(IndexFlowChart As Int32) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3226, 11, "FlowChart_TableY1(A)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then
                FlowChart_TableY1 = Nothing
                Exit Function
            End If
            FlowChart_TableY1 = FlowChart_FileY1(IndexFlowChart)
        End Function



        Public Shared Sub FlowChart_TableY1(IndexFlowChart As Int32, Value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3227, 10, "FlowChart_TableY1(B)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then Return
            FlowChart_FileY1(IndexFlowChart) = Value
            FMB_IsXY(FlowChart_FileX1(IndexFlowChart), FlowChart_FileY1(IndexFlowChart), FlowChart_File_X2_Rotation(IndexFlowChart), FlowChart_File_Y2_Option(IndexFlowChart))
            MyUniverse.MyCheatSheet.FlowChartSorted += 1
        End Sub



        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function FlowChart_Table_Rotation(IndexFlowChart As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3228, 10, "FlowChart_Table_Rotation(C)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then Return Nothing
            FlowChart_Table_Rotation = MyUnEnum(FlowChart_TableX2(IndexFlowChart), SymbolWindow.ToolStripDropDownRotation, 0)
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function FlowChart_TableX2(IndexFlowChart As Int32) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3229, 11, "FlowChart_TableX2(A)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then Return Nothing
            FlowChart_TableX2 = FlowChart_File_X2_Rotation(IndexFlowChart)
            FMB_IsXY(FlowChart_FileX1(IndexFlowChart), FlowChart_FileY1(IndexFlowChart), FlowChart_File_X2_Rotation(IndexFlowChart), FlowChart_File_Y2_Option(IndexFlowChart))
        End Function
        Public Shared Sub FlowChart_TableX2(IndexFlowChart As Int32, Value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3230, 10, "FlowChart_TableX2(B)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then Return
            FlowChart_File_X2_Rotation(IndexFlowChart) = Value
            MyUniverse.MyCheatSheet.FlowChartSorted += 1
            FMB_IsXY(FlowChart_FileX1(IndexFlowChart), FlowChart_FileY1(IndexFlowChart), FlowChart_File_X2_Rotation(IndexFlowChart), FlowChart_File_Y2_Option(IndexFlowChart))

        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub FlowChart_Table_Rotation(IndexFlowChart As Int32, Value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3231, 10, "FlowChart_Table_Rotation(B)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then Return
            FlowChart_File_X2_Rotation(IndexFlowChart) = FindInDropDownButton(Value, SymbolWindow.ToolStripDropDownRotation)
            FMB_IsXY(FlowChart_FileX1(IndexFlowChart), FlowChart_FileY1(IndexFlowChart), FlowChart_File_X2_Rotation(IndexFlowChart), FlowChart_File_Y2_Option(IndexFlowChart))
            MyUniverse.MyCheatSheet.FlowChartSorted += 1
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function FlowChart_TableY2(IndexFlowChart As Int32) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3232, 11, "FlowChart_TableY2(A)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then Return Nothing
            FlowChart_TableY2 = FlowChart_File_Y2_Option(IndexFlowChart)
            '
            FMB_IsXY(FlowChart_FileX1(IndexFlowChart), FlowChart_FileY1(IndexFlowChart), FlowChart_File_X2_Rotation(IndexFlowChart), FlowChart_File_Y2_Option(IndexFlowChart))
        End Function


        Public Shared Function FlowChart_TableOption(IndexFlowChart As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3233, 10, "FlowChart_TableOption(A)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then Return Nothing
            If FlowChart_File_Y2_Option(IndexFlowChart) > MyUniverse.MySystem.FlowChartOptions.Length Then Return Nothing
            If FlowChart_File_Y2_Option(IndexFlowChart) < 0 Then Return Nothing
            FlowChart_TableOption = MyUniverse.MySystem.FlowChartOptions(FlowChart_File_Y2_Option(IndexFlowChart)).OptionNames
            FMB_IsXY(FlowChart_FileX1(IndexFlowChart), FlowChart_FileY1(IndexFlowChart), FlowChart_File_X2_Rotation(IndexFlowChart), FlowChart_File_Y2_Option(IndexFlowChart))

        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub FlowChart_TableY2(IndexFlowChart As Int32, Value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3234, 10, "FlowChart_TableY2(B)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then
                '    FlowChart_TableY2_Option = Nothing
                Return
            End If
            FlowChart_File_Y2_Option(IndexFlowChart) = Value
            MyUniverse.MyCheatSheet.FlowChartSorted += 1
            FMB_IsXY(FlowChart_FileX1(IndexFlowChart), FlowChart_FileY1(IndexFlowChart), FlowChart_File_X2_Rotation(IndexFlowChart), FlowChart_File_Y2_Option(IndexFlowChart))

        End Sub
        Public Shared Sub FlowChart_TableOption(IndexFlowChart As Int32, Value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3235, 10, "FlowChart_TableOption(B)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then
                Return
            End If
            FMB_IsXY(FlowChart_FileX1(IndexFlowChart), FlowChart_FileY1(IndexFlowChart), FlowChart_File_X2_Rotation(IndexFlowChart), FlowChart_File_Y2_Option(IndexFlowChart))


            FlowChart_File_Y2_Option(IndexFlowChart) = FindInDropDownButton(Value, FlowChartWindow.ToolStripDropDownSelectSymbol)
            MyUniverse.MyCheatSheet.FlowChartSorted += 1
        End Sub
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function FlowChart_Table_DataType(IndexFlowChart As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3236, 11, "FlowChart_Table_DataType(A)")
#End If
            'check if we are inside the limits of the table
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then Return Nothing
            FlowChart_Table_DataType = FlowChart_File_DataType(IndexFlowChart)
        End Function
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub FlowChart_Table_DataType(IndexFlowChart As Int32, Value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3237, 10, "FlowChart_Table_DataType(B)")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) Then
                'FlowChart_Table_DataType = Nothing
                Return
            End If
            FlowChart_File_DataType(IndexFlowChart) = Value
            FMB_IsXY(FlowChart_FileX1(IndexFlowChart), FlowChart_FileY1(IndexFlowChart), FlowChart_File_X2_Rotation(IndexFlowChart), FlowChart_File_Y2_Option(IndexFlowChart))
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function DataType_TableName(Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3238, 10, "DataType_TableName(A)")
#End If
            If InvalidIndex(Index, DataType_FileName, DataType_Name_ISAM) Then
                DataType_TableName = Nothing
                Exit Function
            End If
            DataType_TableName = DataType_FileName(Index)
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub DataType_TableName(Index As Int32, Value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3239, 10, "DataType_TableName(B)")
#End If
            If InvalidIndex(Index, DataType_FileName, DataType_Name_ISAM) Then
                Return
            End If
            DataType_FileName(Index) = Value
            MyUniverse.MyCheatSheet.DataTypeSorted += 1
        End Sub
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function DataType_Color(Index As Int32) As String ' returns the name of this color number in the color table
#If MINEDEBUG Then
  if mydebug(9) then follow(3240, 10, "DataType_TableColor")
#End If
            If InvalidIndex(Index, DataType_FileName, DataType_Name_ISAM) Then
                DataType_Color = Nothing
                Exit Function
            End If
            DataType_Color = Color_FileName(Index)
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function DataType_TableColorIndex(Index As Int32) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3241, 10, "DataType_TableColorIndex")
#End If
            If InvalidIndex(Index, DataType_FileName, DataType_Name_ISAM) Then Return -1
            DataType_TableColorIndex = DataType_FileColorIndex(Index)
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub DataType_TableColorIndex(Index As Int32, Value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3242, 10, "DataType_TableColorIndex")
#End If
            If InvalidIndex(Index, DataType_FileName, DataType_Name_ISAM) Then Return
            If Value < 1 Then MSG_ABug(1590, "This DataType does not have a valid color set ", Value.ToString, Index.ToString)
            DataType_FileColorIndex(Index) = Value
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function DataType_TableDescription(Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3243, 10, "DataType_TableDescription(A)")
#End If
            If InvalidIndex(Index, DataType_FileName, DataType_Name_ISAM) Then
                DataType_TableDescription = Nothing
                Exit Function
            End If
            DataType_TableDescription = DataType_FileDescription(Index)
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub DataType_TableDescription(Index As Int32, Value As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3244, 10, "DataType_TableDescription(B)")
#End If
            If InvalidIndex(Index, DataType_FileName, DataType_Name_ISAM) Then Return
            DataType_FileDescription(Index) = Value
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function DataType_TableWidth(Index As Int32) As Byte
#If MINEDEBUG Then
  if mydebug(9) then follow(3245, 10, "DataType_TableWidth(A)")
#End If
            If InvalidIndex(Index, DataType_FileName, DataType_Name_ISAM) Then
                DataType_TableWidth = Nothing
                Exit Function
            End If
            DataType_TableWidth = DataType_FileWidth(Index)
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub DataType_TableWidth(Index As Int32, Value As Byte)
#If MINEDEBUG Then
  if mydebug(9) then follow(3246, 10, "DataType_TableWidth(B)")
#End If
            If InvalidIndex(Index, DataType_FileName, DataType_Name_ISAM) Then Return
            DataType_FileWidth(Index) = Value
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Function DataType_TableNumberOfBytes(Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3247, 10, "DataType_TableNumberOfBytes(A)")
#End If
            If InvalidIndex(Index, DataType_FileName, DataType_Name_ISAM) Then
                DataType_TableNumberOfBytes = Nothing
                Exit Function
            End If
            DataType_TableNumberOfBytes = CStr(DataType_FileNumberOfBytes(Index))
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to isolate the actual data from the program (So that it can be converted later versions)
        Public Shared Sub DataType_TableNumberOfBytes(Index As Int32, Value As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3248, 10, "DataType_TableNumberOfBytes(B)")
#End If
            If InvalidIndex(Index, DataType_FileName, DataType_Name_ISAM) Then Return
            DataType_FileNumberOfBytes(Index) = Value
        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' checks that everything sorted correctly 
        'hack
        'can delete when it no longer finds issues
        Public Shared Function MyIsValidCheckSortAll_String(MyTable As String, ByRef MyArray() As String, ByRef ISAM() As Int32) As Boolean
            Dim LocalIndex, Topmost As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3249, 10, "MyIsValidCheckSortAll_String " & MyTable)
#End If
            Topmost = TopOfFile(MyTable) 'UBound(MyArray) ' Changed 04/09/19 to get a lower number checking
            MyIsValidCheckSortAll_String = True

            For LocalIndex = Topmost To 2 Step -1
                If MyIsNothing(MyArray(LocalIndex)) And ISAM(LocalIndex) <> 0 Then
                    MyMsgCtr(1385, "MyIsValidCheckSortAll_String", LocalIndex.ToString, ISAM(LocalIndex).ToString, "Data Set to Nothing", "", "", "", "", "", "" & vbCrLf)
                    MyIsValidCheckSortAll_String = False ' Can not index nothing?
                End If
                If ISAM(LocalIndex) <= 0 Or ISAM(LocalIndex) > UBound(MyArray) Then
                    MyIsValidCheckSortAll_String = False
                    Exit For
                End If

                ' If two ISAMs equal each other then we have major issues with the ISAM
                If ISAM(LocalIndex) <> 0 And ISAM(LocalIndex - 1) = ISAM(LocalIndex) Then
                    'MyMsgCtr(1017, "MyIsValidCheckSortAll_String", LocalIndex - 1, ISAM(LocalIndex - 1).ToString, LocalIndex, ISAM(LocalIndex).ToString, "", "", "", "", "" & vbcrlf)
                    MyIsValidCheckSortAll_String = False
                    Exit For
                End If
                If ISAM(LocalIndex - 1) = ISAM(LocalIndex) Then
                    MyMsgCtr(1003, "MyIsValidCheckSortAll_String", (LocalIndex - 1).ToString, LocalIndex.ToString, MyCompared1_a(MyArray(ISAM(LocalIndex - 1)).ToString, MyArray(ISAM(LocalIndex))).ToString, MyArray(ISAM(LocalIndex - 1)).ToString, MyArray(ISAM(LocalIndex)).ToString, "", "", "", "2") ' EXTRA so I can see why it's here
                    MyIsValidCheckSortAll_String = False
                    FindingMyBugs(10) 'hack Least amount of checking here
                    Exit For
                End If
                ' Is Array Is out of order (returns 0 if equal, -1 if A < B, 1 if A > B which is an error
                If MyCompared2(MyArray, ISAM, LocalIndex - 1, LocalIndex) = 1 Then 'MyCompared(MyArray(ISAM(LocalIndex - 1)), MyArray(ISAM(LocalIndex))) = 1 Then
                    MyIsValidCheckSortAll_String = False
                    Select Case LCase(MyTable)
                        Case "FlowChart"
                            MyUniverse.MyCheatSheet.FlowChartSorted += 1
                        Case "DataType"
                            MyUniverse.MyCheatSheet.DataTypeSorted += 1
                        Case "color"
                            MyUniverse.MyCheatSheet.ColorsSorted += 1
                        Case "named"
                            MyUniverse.MyCheatSheet.NamedSorted += 1
                        Case Else ' sort every thing
                            MyUniverse.MyCheatSheet.FlowChartSorted += 1
                            MyUniverse.MyCheatSheet.DataTypeSorted += 1
                            MyUniverse.MyCheatSheet.ColorsSorted += 1
                            MyUniverse.MyCheatSheet.NamedSorted += 1
                    End Select
                    Exit For
                End If
            Next
        End Function
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' This is to make sure that all array referances are inside the array
        Public Shared Function InvalidIndex(Index As Int32, MyArray() As String) As Boolean
            '#If MINEDEBUG Then
            'if mydebug(9) then follow(3250, 10, "InvalidIndex_C")
            '#End If
            'if mydebug(9) then follow(2784, 10, "*" & Index.ToString & FD & MyArray.Length.ToString & vbTab)
            If Index < 1 Then
                Return True ' I DoNot use array zero
            End If
            If Index > UBound(MyArray) Then
                Return True
            End If
            Return False
        End Function


        'change to be fewer test 2020 09 02
        '    '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Checking if the index to the array is inside the bounds or not.
        'It should never be outside, or else there is a programming bug again
        Public Shared Function InvalidIndex(Index As Int32, ByRef MyArray() As String, ByRef ISAM() As Int32) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3251, 11, "InvalidIndex_B")
#End If
            If Index < 1 Then
                '   if mydebug(9) then follow(2785, 10, "A)#" & Index.ToString & FD & MyArray.Length.ToString & vbTab)
                Return True 'Index has not been set yet
            End If
            If Index > UBound(ISAM) - 1 Then
                If mydebug(9) Then follow(2785, 10, "B)#" & Index.ToString & FD & MyArray.Length.ToString & vbTab)
                Return True
            End If
            If ISAM(Index) < 1 Then
                '  if mydebug(9) then follow(2785, 10, "C)#" & Index.ToString & FD & MyArray.Length.ToString & vbTab)
                Return True ' ISAM index has not been set
            End If

            If UBound(MyArray) <> UBound(ISAM) Then
                MSG_AInfo1(1601, "D)Invalid index program error the array is not the same size as the index ISAM", Index.ToString, "")
                Return True
            End If
            If Index < 1 Or Index > UBound(MyArray) Then
                MSG_AInfo1(1602, "E)Invalid index is not between ", Index.ToString, "Low=1,High=" & UBound(MyArray).ToString)
                Return True
            End If
            If ISAM(Index) <> MyMinMax(ISAM(Index), 1, UBound(ISAM)) Then
                MSG_AInfo1(1603, "F)Invalid ISAM index is not between ", Index.ToString, "Low=1,High=" & UBound(ISAM).ToString)
                Return True
            End If
            'if mydebug(9) then follow(2881, 1, "G)#Index Good = 1 < " & Index.ToString & " < " & MyArray.Length.ToString & vbTab)
            Return False
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Checks to see if it is a valid index for this array
        Public Shared Function InvalidIndex(Index As Int32, MyArrayLong() As Int32, ByRef ISAM() As Int32) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3252, 10, "InvalidIndex_A")
#End If
            If Index < 1 Then
                If MyDebug(10) Then follow(2859, 10, "Invalid Index Pointer A) at " & Index.ToString & " Array.size = " & MyArrayLong.Length.ToString & vbTab)
                Return True
            End If
            If Index > UBound(ISAM) Then
                If MyDebug(10) Then follow(2859, 10, "Invalid Index Pointer B) at " & Index.ToString & " Array.size = " & MyArrayLong.Length.ToString & vbTab)
                Return True
            End If
            If ISAM(Index) < 1 Then
                If MyDebug(10) Then follow(2859, 10, "Invalid Index Pointer C) ISAM(" & Index.ToString & ") = " & ISAM(Index).ToString & "  Array.size = " & MyArrayLong.Length.ToString & vbTab)
                Return True
            End If

            'If MyArrayLong(Index) = Nothing Then
            'Return True
            'End If


            If UBound(MyArrayLong) <> UBound(ISAM) Then
                MSG_AInfo1(1605, "Number array and ISAM is not the same size ", UBound(MyArrayLong).ToString, UBound(ISAM).ToString)
                Return True
            End If
            If Index <> MyMinMax(Index, 1, UBound(MyArrayLong)) Then
                MSG_AInfo1(1606, "Index for number is invalid ", Index.ToString, "low=1,High=" & UBound(MyArrayLong).ToString)
                Return True
            End If
            If ISAM(Index) <> MyMinMax(ISAM(Index), 1, UBound(ISAM)) Then
                MSG_AInfo1(1607, "ISAM Index for number is invalid ", ISAM(Index).ToString, "low=1,High=" & UBound(ISAM).ToString)
                Return True
            End If
            'If ISAM(Index) <> 0 And MyArrayLong(Index) = Nothing Then
            'MSG_AInfo(1608, vbCrLf & "ISAM Index in number Array is not set ", ISAM(Index).ToString, MyArrayLong(Index).ToString)
            'Return True
            'End If
            Return False
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This will replace the string with it replacement 

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This sets, or unsets a bit option
        ' Level is the number 1-1000, and passed on/off , yes/no, true/false
        Public Shared Sub BitSet(Level As Int32, SetBitTo As String)
            Dim MyByte As Int32
            Dim MyBit As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3253, 10, "BitSet")
#End If
            MyByte = CInt(Fix(Level / 8))
            MyByte = MyMinMax(MyByte, 1, UBound(MyMessageBits) - 1)
            MyBit = MyMinMax(Level - (MyByte * 8), 0, 7)
            If Level < 100 Then
                If mydebug(9) Then follow(2742, 0, "Option bit error " & Level.ToString)
            End If
            Select Case LCase(SetBitTo)
                Case "yes", "true", "on"
                    MyMessageBits(MyByte) = CByte(MyMessageBits(MyByte) Or MyBits(MyBit))
                Case "no", "false", "off"
                    MyMessageBits(MyByte) = CByte(MyMessageBits(MyByte) And (Not MyBits(MyBit)))
                Case "otherthingsxxxx" 'Options for the third parameter
                Case Else
                    MyMsgCtr(1000, "BitSet", "BitSet()  Not yes,no, True,False, On,off ", "Set To >" & SetBitTo & "<", " Level=" & Level, " Bit=" & MyBit, " Byte=" & MyByte, "", "", "", "")
            End Select
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'returns if the bit is set or not
        Public Shared Function IsBitSet(Level As Int32) As Boolean
            Dim MyByte As Int32
            Dim MyBit As Int32
            Dim Temp As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3254, 10, "IsBitSet")
#End If
            MyByte = CInt(Fix(Level / 8))
            MyByte = MyMinMax(MyByte, 1, UBound(MyMessageBits) - 1)
            MyBit = MyMinMax(Level - (MyByte * 8), 0, 7)
            If MyByte < 0 Or MyByte > UBound(MyMessageBits) - 1 Then
                MSG_ABug(1611, "BitSet() : ", Level.ToString, CStr(MyByte) & ">?" & UBound(MyMessageBits).ToString + vbTab + CStr(MyBit))
            End If

            Temp = MyMessageBits(MyByte) And MyBits(MyBit)
            If (MyMessageBits(MyByte) And MyBits(MyBit)) > 0 Then
                IsBitSet = True
            Else
                IsBitSet = False
            End If
        End Function



        'This sets, or unsets a bit option
        ' Level is the number 1-1000, and passed on/off , yes/no, true/false
        Public Shared Sub BitSet1(Level As Int32, SetBitTo1 As String)
            Dim MyByte As Int32
            Dim MyBit As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3255, 10, "BitSet1")
#End If
            MyByte = CInt(Fix(Level / 8))
            MyByte = MyMinMax(MyByte, 1, UBound(MyTraceBits) - 1)
            MyBit = MyMinMax(Level - (MyByte * 8), 0, 7)
            If Level < 1 Or Level / 8 > UBound(MyTraceBits) - 1 Then
                If MyDebug(9) Then Follow(2183, "305 BitSet() : " & Level.ToString & ", " & CStr(SetBitTo1) & ", " & CStr(MyByte) & ", " & CStr(MyBit))
            End If
            If MyByte < 0 Or MyByte > UBound(MyTraceBits) - 1 Then
                If MyDebug(9) Then Follow(2184, "306 BitSet() : , " & Level.ToString & ", " & CStr(SetBitTo1) & ", " & CStr(MyByte) & ", " & CStr(MyBit))
            End If
            If MyBit < 0 Or MyBit > 7 Then
                If MyDebug(9) Then follow(2185, "306 BitSet() : , " & Level.ToString & ", " & CStr(SetBitTo1) & ", " & CStr(MyByte) & ", " & CStr(MyBit))
            End If

            Select Case LCase(SetBitTo1)
                Case "yes", "true", "on"
                    MyTraceBits(MyByte) = CByte(MyTraceBits(MyByte) Or MyBits(MyBit))
                Case "no", "false", "off"
                    MyTraceBits(MyByte) = CByte(MyTraceBits(MyByte) And (Not MyBits(MyBit)))
                Case "otherthingsxxxx" 'Options for the third parameter
                Case Else
                    MyMsgCtr(1000, "BitSet", "BitSet()  Not yes,no, True,False, On,off ", "Set To >" & SetBitTo1 & "<", " Level=" & Level, " Bit=" & MyBit, " Byte=" & MyByte, "", "", "", "")
            End Select
        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'returns if the bit is set or not
        Public Shared Function IsBitSet1(Level As Int32) As Boolean
            Dim MyByte As Int32
            Dim MyBit As Int32
            Dim Temp As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3256, 10, "IsBitSet1")
#End If
            MyByte = CInt(Fix(Level / 8))
            MyByte = MyMinMax(MyByte, 1, UBound(MyTraceBits) - 1)
            MyBit = MyMinMax(Level - (MyByte * 8), 0, 7)

            Temp = MyTraceBits(MyByte) And MyBits(MyBit)

            If (MyTraceBits(MyByte) And MyBits(MyBit)) > 0 Then
                IsBitSet1 = True
            Else
                IsBitSet1 = False
            End If
        End Function






        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'NOT USED
        'This returns if the point is closest enough to move (snap grid)

        Public Shared Function FlowChart_XY_IsClose(Index As Int32, X1 As Int32, Y1 As Int32, X2 As Int32, Y2 As Int32) As Boolean
            Dim Distance As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3257, 10, "FlowChart_XY_IsClose")
#End If
            FlowChart_XY_IsClose = False
            If Index < 1 Then Exit Function
            Distance = MyDistance(MyPoint1XY(X1, Y1), MyPoint2XY(X2, Y2))
            If Distance <= MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths Then
                FlowChart_XY_IsClose = True
            End If

            If MyABS(X1 - X2) < MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths Then
                FlowChart_XY_IsClose = True
            End If

            If MyABS(Y1 - Y2) < MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths Then
                FlowChart_XY_IsClose = True
            End If

        End Function


        Public Shared Sub CheckAndFixSyntax()
            Dim IndexNamed As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3258, 10, "CheckAndFixSyntax")
#End If

            For IndexNamed = 1 To TopOfFile("named")
                Named_FileSyntax_ISAM(IndexNamed) = IndexNamed
                If Named_TableSyntax(IndexNamed) = "" Then
                    If MyTrim(Named_TableMicroCodeText(IndexNamed)) = "" Then
                        MSG_ABug(1615, "No Program Text", "No Syntax", Named_TableSymbolName(IndexNamed))
                        Named_TableMicroCodeText(IndexNamed, MyUniverse.ProgramOptions.FCCL_Comment)
                        Named_TableSyntax(IndexNamed, MyUniverse.ProgramOptions.FCCL_Comment)
                    Else
                        If PrintAbleNull(Named_TableSyntax(IndexNamed)) = "_" Then
                            MyUniverse.MySS.Inputs.KPar = MyTrim(Named_TableMicroCodeText(IndexNamed))
                            Pop(MyUniverse.MySS.Inputs.KPar, MyUniverse.SysGen.Constants.ConstantDelimiters) ' get ride of the sort section of the program text
                            Named_TableSyntax(IndexNamed, Trim(MicroCodeText2Syntax(MyUniverse.MyStaticData.My_Code_Line_Parsed, MyUniverse.MySS.Inputs.KPar)))
                        End If
                    End If
                End If
                MyReSort("Named", Named_FileSyntax, Named_FileSyntax_ISAM, IndexNamed)
                MyReSort("Named", Named_FileSyntax, Named_FileSyntax_ISAM, TopOfFile("named"))
            Next IndexNamed


        End Sub


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' Checking if I had forgotten to sort an array?
        Public Shared Sub CheckForAnySortNeeded(Level As Int32)
            Dim LocalIndex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3256, 10, "CheckForAnySortNeeded")
#End If
            If MyUniverse.MyCheatSheet.DataTypeSorted <> 0 Then
                ShowSorts("DataType", SortDataType()) : MyUniverse.MyCheatSheet.DataTypeSorted = 0
            End If
            If MyUniverse.MyCheatSheet.NamedSorted <> 0 Then
                ShowSorts("Named", SortNamed())
                ' This is just to make sure the Symbol table is still in order
                For LocalIndex = 1 To TopOfFile("named")
                    GetSelfCorrectingIndexes(Named_TableSymbolName(LocalIndex))
                Next LocalIndex
                MyUniverse.MyCheatSheet.NamedSorted = 0
            End If
            If MyUniverse.MyCheatSheet.FlowChartSorted <> 0 Then
                ShowSorts("FlowChart", SortFlowChart())
                MyUniverse.MyCheatSheet.FlowChartSorted = 0
            End If

        End Sub

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Checking that everything is OK
        'Should be called inside of FindingMyBugs
        Public Shared Function MyCheckValidFlowChartRecord(Index As Int32) As Boolean
            'First check if valid Index
#If MINEDEBUG Then
  if mydebug(9) then follow(3260, 10, "MyCheckValidFlowChartRecord")
#End If
            If Index < 1 Then
                MyMsgCtr(1390, "MyCheckValidFlowChartRecord", Index.ToString, "", "", "", "", "", "", "", "")
                Return False
            End If
            If Index > TopOfFile("FlowChart") Then
                'MyMsgCtr(1250, "MyCheckValidFlowChartRecord", Index.ToString, TopOfFile("FlowChart"), "", "", "", "", "", "", "")
                Return False
            End If
            ' Next check for a valid code
            ' Also Then CHeck for the correct information on each type of Record
            Select Case LCase(FlowChart_TableCode(Index))
                Case My_keyWord(My_KeyConstUse)
                    If MyCheckValidUse(Index) = False Then
                        Return False
                    End If
                Case "/path"
                    If ConnectPath(Index) = 0 Then
                        Return False
                    End If
                Case "/Constant"
                Case "/error"
                Case Else
                    MyMsgCtr(1438, "MyCheckValidFlowChartRecord", FlowChart_TableCode(Index), Index.ToString, "", "", "", "", "", "", "")
                    Return False
            End Select
            ' if it makes all of these test then it must be a good/ok record ?
            Return True
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        Public Shared Function MyCheckValidUse(IndexFlowChart As Int32) As Boolean
            Dim Temp As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3261, 10, "MyCheckValidUse")
#End If
            MyCheckValidUse = False
            ' for now print out all things that are being checked
            'Check if valid index
            If MyCheckIndex_String("FlowChart", IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) = False Then Exit Function
            'if named
            If Len(FlowChart_TableSymbol_Name(IndexFlowChart)) < 1 Then
                MyMsgCtr(1164, "MyCheckValidUse", Str(IndexFlowChart), MyShowFlowChartRecord(True, IndexFlowChart), "", "", "", "", "", "", "")
                Exit Function
            End If
            'use code   
            Select Case LCase(FlowChart_TableCode(IndexFlowChart))
                Case My_keyWord(My_KeyConstUse)
                    ' removed     MyCheckValidUse = Not InvalidUse(IndexFlowChart , FlowChart_TableCompiledMacroCodeText(IndexFlowChart ))
                Case Else
                    'MyMsgCtr(1159, "MyCheckValidUse", FlowChart_TableCode(IndexFlowChart), "", "", "", "", "", "", "", "")
                    Exit Function
            End Select
            ' Checking that ALL ISAMs are indexed to something.(Should also make sure that it returns a match to what it is searching for
            'name
            Temp = FindIndexInISAMTable("FlowChart", "DoNotAdd", FlowChart_FilePathSymbolName, FlowChart_ISAM_Name, FlowChart_TableSymbol_Name(IndexFlowChart))
            If Temp < 1 Then
                MyCheckValidUse = MyCheckIndex_String("FlowChart", IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name)
            End If
            'X1
            Temp = FindIndexInISAMTable("FlowChart", "DoNotAdd", FlowChart_FileX1, FlowChart_ISAM_X1, FlowChart_TableX1(IndexFlowChart))
            If Temp < 1 Then
                MyCheckValidUse = MyCheckIndex_String("FlowChart", IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name)
            End If
            'Y1
            '?Temp = FindIndexInISAMTable("FlowChart", "DoNotAdd", FlowChart_FileY1, FlowChart_ISAM_Y1, FlowChart_TableY1(IndexFlowChart ))
            If MyCheckIndex_String("FlowChart", IndexFlowChart, FlowChart_FilePathSymbolName, FlowChart_ISAM_Name) = False Then
                Exit Function
            End If
            If FlowChart_Table_Rotation(IndexFlowChart) = Nothing Then
                MyMsgCtr(1163, "MyCheckValidUse", IndexFlowChart.ToString, """", "", "", "", "", "", "", "")
                Exit Function
            End If
            ' All Else works so it must be OK
            MyCheckValidUse = True
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        Public Shared Function MyCheckIndex_long(MyTable As String, Index As Int32, MyArray() As Int32, ByRef ISAM() As Int32) As Boolean ' returns false if the index is outside the array
#If MINEDEBUG Then
  if mydebug(9) then follow(3262, 10, "MyCheckIndex_Long")
#End If
            If Index < 1 Then
                'MyMsgCtr(1158, "MyCheckIndex_long", Index.ToString, "", "", "", "", "", "", "", "")
                Return False
            End If
            If Index > TopOfFile(MyTable) Then
                'MyMsgCtr(1256, "MyCheckIndex_long", Str(Index), Str(TopOfFile(MyTable)), "", "", "", "", "", "", "")
                Return False
            End If
            If ISAM(Index) <> 0 And ISAM(Index - 1) = ISAM(Index) Then
                DisplayMyStatus(3, "7845  Index Is wrong  index=" & Index & " ISAM = " & ISAM(Index - 1) & " : " & ISAM(Index))
                Return False
            End If
            If ISAM(1) <> 0 And ISAM(1) = ISAM(2) Then
                MyMsgCtr(1169, "MyCheckIndex_long", "", "", "", "", "", "", "", "", "")
                Return False
            End If
            If Index = 0 Then
                MyMsgCtr(1170, "MyCheckIndex_long", Index.ToString, ISAM(Index).ToString, "", "", "", "", "", "", "Index < 1")
                Return False
            End If
            If ISAM(Index) = 0 Then
                MyMsgCtr(1170, "MyCheckIndex_long", Index.ToString, ISAM(Index).ToString, "", "", "", "", "", "", "ISAM(index) < 1")
                Return False
            End If
            Return True
        End Function


        Public Shared Function MyCheckIndex_String(MyTable As String, Index As Int32, ByRef MyArray() As String, ByRef ISAM() As Int32) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3263, 10, "MyCheckIndex_String")
#End If
            MyCheckIndex_String = False
            If Index < 1 Then
                'MyMsgCtr(1158, "MyCheckIndex_String", Index.ToString, "", "", "", "", "", "", "", "")
                Exit Function
            End If
            If Index > TopOfFile(MyTable) Then
                'MyMsgCtr(1256, "MyCheckIndex_String", Str(Index), Str(TopOfFile(MyTable)), "", "", "", "", "", "", "")
                Exit Function
            End If
            If ISAM(Index) <> 0 And ISAM(Index - 1) = ISAM(Index) Then
                DisplayMyStatus(3, "7845  Index Is wrong  index=" & Index & " ISAM = " & ISAM(Index - 1) & " : " & ISAM(Index))
                Exit Function
            End If
            If ISAM(1) <> 0 And ISAM(1) = ISAM(2) Then
                MyMsgCtr(1169, "MyCheckIndex_String", "", "", "", "", "", "", "", "", "")
                Exit Function
            End If
            If Index = 0 Then
                MyMsgCtr(1170, "MyCheckIndex_String", Index.ToString, ISAM(Index).ToString, "", "", "", "", "", "", "Index < 1")
                Exit Function
            End If
            If ISAM(Index) = 0 Then
                MyMsgCtr(1170, "MyCheckIndex_String", Index.ToString, ISAM(Index).ToString, "", "", "", "", "", "", "ISAM(index) < 1")
                Exit Function
            End If
            MyCheckIndex_String = True
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'replacement string

        Public Shared Function MyFirstOne(StringToSearch As String, FindFirstcharacter As String) As Int32
            Dim t1 As Int32
            Dim t2 As Int32
            Dim t3 As Int32 = Len(StringToSearch)
            Dim B As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3264, 10, "MyFirstOne")
#End If
            'get rid of the first character because it is one that you are looking for the next
            B = StringToSearch
            For t1 = 1 To Len(FindFirstcharacter)
                t2 = InStr(B, Mid(FindFirstcharacter, t1, 1))
                If t2 >= 1 Then
                    If t2 < t3 Then
                        t3 = t2
                    Else
                        'ignore this because it's longer
                    End If
                End If
            Next
            Return t3
        End Function


        'myreplace is used to only replace the first one.
        Public Shared Function MyReplace(InputString As String, FindingString As String, ReplacementString As String) As String
            '#If MINEDEBUG Then
            If MyDebug(7) Then follow(3265, 7, "MyReplace " & InputString & "=====>>" & FindingString & "=======>>" & ReplacementString)
            '#End If
            If InputString = "" Then Return ""
            If FindingString = "" Then Return InputString
            If InStr(InputString, FindingString) = 0 Then Return InputString
            'start at col 1, and replace only 1 time
            MyReplace = Strings.Replace(InputString, FindingString, ReplacementString, 1, 1, CompareMethod.Text)
        End Function

        Public Shared Function HighLight(ShowString As String) As String
            If MyIsNothing(ShowString) Then Return ">?<" Else Return " --->" & ShowString & "<--- "
        End Function


        Public Shared Function SHL(ShowString As String) As String
            If MyIsNothing(ShowString) Then
                Return " ? "
            Else
                Return "[>" & ShowString & "<]"
            End If
        End Function

        Public Shared Function MyShowWindowSizes() As String
            Dim RTN As String
            RTN = " FlowChart size=(" & FlowChartWindow.PictureBox1.Width.ToString & FD & FlowChartWindow.PictureBox1.Height.ToString & ")"
            RTN &= FD & " Symbol size= (" & SymbolWindow.PictureBox1.Width.ToString & FD & SymbolWindow.PictureBox1.Height.ToString & ")"
            RTN &= FD & " world size = ( " & MyShowALine(MyUniverse.Area.MyWorldXY) & ")"
            RTN &= FD & " window size = ( " & MyShowALine(MyUniverse.Area.MyInputWindowXY) & ")"
            RTN &= FD & " Mouse size = ( " & MyShowALine(MyUniverse.MyMouseAndDrawing.MyWindow) & ")"
            Return RTN
        End Function


        Public Shared Function MyShowPicture(expanded As Boolean, P As PictureBox) As String
            Dim XY As MyPointStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3266, 10, "MyShowPicture")
#End If
            If ProgramBuzzy("Begin") Then Return ""
            If expanded = True Then
                MyShowPicture = "(\name=" + P.Parent.Name & "." & P.Name
                MyShowPicture += vbCrLf + "\visible=, " + P.Visible.ToString
                MyShowPicture += vbCrLf + "\form=, " + P.Parent.Name
                MyShowPicture += vbCrLf + "\bounds=, " + P.Bounds.ToString
                MyShowPicture += vbCrLf + "\enabled=, " + P.Enabled.ToString
                MyShowPicture += vbCrLf + "\text=, " + P.Text & ")"
                MyShowPicture += vbCrLf + "\size1=, " & MyShowXY(P.Height, P.Width)
                MyShowPicture += vbCrLf + "\size2=, " & MyShowXY(P.Size.Height, P.Size.Width)
                XY.Named.PathName = ""
                XY.Named.SymbolName = ""
                XY.Named.PointName = ""
                If P.Parent.Name = "SymbolWindow" Then
                    XY.x = P.Size.Height - 2
                    XY.y = P.Size.Width - 2
                    XY = Copy2WorldXY("?", P, XY)
                    MyShowPicture += vbCrLf + "\size3=, " & MyShowXY(XY.x, XY.y)
                    XY = Copy2WorldXY("?", P, MyPoint1XY(0, 0))
                    MyShowPicture += vbCrLf + "\size4=, " & MyShowXY(XY.x, XY.y)
                End If
                If P.Parent.Name = "FlowChartWindow" Then
                    XY.x = P.Size.Height
                    XY.y = P.Size.Width
                    XY = Copy2WorldXY("", P, XY)
                    MyShowPicture += vbCrLf + "\size3=, " & MyShowXY(XY.x, XY.y)
                    XY = Copy2WorldXY("", P, MyPoint1XY(0, 0))
                    MyShowPicture += vbCrLf + "\size4=, " & MyShowXY(XY.x, XY.y)
                End If
            Else
                MyShowPicture = "\name=" + P.Name
                XY.x = P.Size.Height
                XY.y = P.Size.Width
                XY.Named.PathName = ""
                XY.Named.SymbolName = ""
                XY.Named.PointName = ""
                If P.Parent.Name = "Symbol" Then XY = Copy2WorldXY("/point", P, XY)
                If P.Parent.Name = "FlowChart" Then XY = Copy2WorldXY("/use", P, XY)
                MyShowPicture += vbCrLf + "\size3=, " & MyShowXY(XY.x, XY.y)
            End If
            Return MyShowPicture 'implied
        End Function


        Public Shared Function MyShowSymbolWindowData() As String
            Dim RTN As String
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3267, 10, "MyShowSymbolWindowData")
#End If

            '    If ProgramBuzzy("Begin" Then
            '    Return ""
            '    End If
            RTN = ""
            RTN &= "/Name  = " & PrintAbleNull(SymbolWindow.TextBoxNamedSymbolName.Text)
            RTN &= "/Description = " & PrintAbleNull(SymbolWindow.TextBoxNamedDescription.Text)
            RTN &= "/FileName = " & PrintAbleNull(SymbolWindow.TextBoxNamedNameOfFile.Text)
            RTN &= "/Notes  = " & PrintAbleNull(SymbolWindow.TextBoxNamedNotes.Text)
            RTN &= "/Opcode  = " & PrintAbleNull(SymbolWindow.TextBoxNamedOpCode.Text)
            RTN &= "/MicroCodeText = " & PrintAbleNull(SymbolWindow.TextBoxNamedProgramText.Text)
            RTN &= "/Stroke  = " & PrintAbleNull(SymbolWindow.TextBoxNamedStroke.Text)
            RTN &= "/Syntax  = " & PrintAbleNull(SymbolWindow.TextBoxNamedSyntax.Text)
            RTN &= "/Version  = " & PrintAbleNull(SymbolWindow.TextBoxSymbolVersionAuthor.Text)
            FMB1(8035)
            For I = 0 To SymbolWindow.ComboBoxPointNameList.Items.Count - 1
                RTN &= "/Point name = " & PrintAbleNull(SymbolWindow.ComboBoxPointNameList.Items(I).ToString)
            Next I
            For I = 0 To SymbolWindow.ComboBoxLineNameList.Items.Count - 1
                RTN &= "/Line name = " & PrintAbleNull(SymbolWindow.ComboBoxLineNameList.Items(I).ToString)
            Next I
            RTN &= "/Name selected = " + PrintAbleNull(SymbolWindow.TextBoxNamedSyntax.Text)
            If mydebug(9) Then follow(2860, 10, "10011" & MyNoCR(" " & PrintAbleNull(RTN)) & vbCrLf)
            FMB1(8036)
            Return RTN
        End Function


        'input the "/text" string (what ever) and return the string with each line starting with that switch (used for all multi line import/export
        Public Shared Function MyShowMultilineText(MySwitch As String, OutputText As String) As String
            Dim Temp As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3268, 10, "MyShowMultiLineText")
#End If
            Temp = OutputText
            MyShowMultilineText = ""
            While Len(Temp) > 0
                MyShowMultilineText = vbCrLf & MySwitch & "=" & PopLine(Temp)
            End While

            If Len(MyShowMultilineText) > 0 Then MyShowMultilineText &= vbCrLf
        End Function


        Public Shared Function MyShowUsePoints(expanded As Boolean, IndexFlowChart As Int32) As String
            Dim IndexNamed, IndexSymbol As Int32
            Dim XY1, XY2 As MyPointStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3269, 10, "MyShowUsePoints")
#End If
            'todo is this nessary '''MyShowUsePoints = ""
            XY1 = Nothing
            XY1.x = FlowChart_TableX1(IndexFlowChart)
            XY1.y = FlowChart_TableY1(IndexFlowChart)
            IndexNamed = FindInNamedList(FlowChart_TableSymbol_Name(IndexFlowChart))
            If IndexNamed < 1 Then
                Return "No Symbol " & HighLight(FlowChart_TableSymbol_Name(IndexFlowChart))
            End If
            IndexSymbol = GetSelfCorrectingIndexes(Named_TableSymbolName(IndexNamed))
            If IndexSymbol < 1 Then
                Return "No Points " & Named_TableSymbolName(IndexNamed)
            End If
            MyShowUsePoints = MyShowSymbolPoint(False, IndexSymbol)
            IndexSymbol += 1 ' jump over the name 
            While IndexSymbol <= TopOfFile("Symbol")
                Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                    Case "/name"
                        Exit Function
                    Case "/point"
                        XY2 = MyRotated_1(IndexSymbol, XY1, FlowChart_Table_Rotation(IndexFlowChart))
                        MyShowUsePoints &= FD & MyShowPoint(XY2)
                    Case "/line" 'ignore
                    Case Else
                        MyShowUsePoints &= FD & MyShowSymbolPoint(False, IndexSymbol)
                End Select
                IndexSymbol += 1
            End While
        End Function






        Public Shared Function MyShowPath(expanded As Boolean, LocalIndex As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3270, 10, "MyShowPath")
#End If
            MyShowPath = FlowChart_TableCode(LocalIndex) & " = " & FlowChart_TablePathName(LocalIndex)
            MyShowPath &= FD & FlowChart_TableX1(LocalIndex)
            MyShowPath &= FD & FlowChart_TableY1(LocalIndex)
            MyShowPath &= FD & FlowChart_TableX2(LocalIndex)
            MyShowPath &= FD & FlowChart_TableY2(LocalIndex)
            MyShowPath &= FD & FlowChart_Table_DataType(LocalIndex)
            If MyOptionTest(22) = True Or expanded = True Then
                MyShowPath &= vbCrLf & "\Index=" & LocalIndex
                MyShowPath &= vbCrLf & "\NetLinks=" & MyShowNetLnks(FindIndex_In_TableNetLinks(LocalIndex))
            End If
        End Function

        Public Shared Function MyShowFlowChartRecord(expanded As Boolean, IndexFlowChart As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3271, 11, "MyShowFlowChartRecord")
#End If
            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName) Then
                Return "/Error=Invalid Index  " & SHL(IndexFlowChart.ToString)
            End If
            Select Case LCase(FlowChart_TableCode(IndexFlowChart))
                Case My_keyWord(My_KeyConstUse)
                    MyShowFlowChartRecord = FlowChart_TableCode(IndexFlowChart) & "=" & FlowChart_TableSymbol_Name(IndexFlowChart)
                    MyShowFlowChartRecord &= FD & FlowChart_TableX1(IndexFlowChart)
                    MyShowFlowChartRecord &= FD & FlowChart_TableY1(IndexFlowChart)
                    MyShowFlowChartRecord &= FD & FlowChart_Table_Rotation(IndexFlowChart)
                    MyShowFlowChartRecord &= FD & FlowChart_TableOption(IndexFlowChart)
                    'MyShowFlowChartRecord &= FD & FlowChart_TableOther_Name(IndexFlowChart)

                    MyShowFlowChartRecord &= FD & FlowChart_FilePathSymbolName(IndexFlowChart)
                    MyShowFlowChartRecord &= FD & FlowChart_TableSymbol_Name(IndexFlowChart)
                    If expanded = True Then
                        MyShowFlowChartRecord &= vbCrLf & "\DataType=" & FlowChart_Table_DataType(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\Index=" & IndexFlowChart.ToString
                        If FlowChart_TableCode(IndexFlowChart) = "/path" Then
                            MyShowFlowChartRecord &= vbCrLf & "\PathName=" & PrintAbleNull(FlowChart_TablePathName(IndexFlowChart))
                        End If
                        MyShowFlowChartRecord &= vbCrLf & "\PathNumber=" & PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart).ToString)
                        MyShowFlowChartRecord &= vbCrLf & "\Index=" & IndexFlowChart.ToString
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMname=" & FlowChart_ISAM_Name(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMx1=" & FlowChart_ISAM_X1(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMy1=" & FlowChart_ISAM_Y1(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMx2=" & FlowChart_ISAM_X2(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMy2=" & FlowChart_ISAM_Y2(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\path_Symbol name = " & FlowChart_Table_Path_SymbolName(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\Option = " & FlowChart_TableOption(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\pathnumber=" & FlowChart_TablePathNumber(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\PathName=" & FlowChart_TablePath_Name(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\SymbolName=" & FlowChart_TableSymbol_Name(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\DataType=" & FlowChart_Table_DataType(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\Path_SymbolName=" & FlowChart_Table_Path_SymbolName(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\RotationName=" & FlowChart_Table_Rotation(IndexFlowChart)
                    End If
                Case "/path"
                    MyShowFlowChartRecord = FlowChart_TableCode(IndexFlowChart) & "=" & FlowChart_TablePath_Name(IndexFlowChart)
                    MyShowFlowChartRecord &= FD & FlowChart_TableX1(IndexFlowChart)
                    MyShowFlowChartRecord &= FD & FlowChart_TableY1(IndexFlowChart)
                    MyShowFlowChartRecord &= FD & FlowChart_TableX2(IndexFlowChart)
                    MyShowFlowChartRecord &= FD & FlowChart_TableY2(IndexFlowChart)
                    If expanded = True Then
                        MyShowFlowChartRecord &= vbCrLf & "\DataType=" & FlowChart_Table_DataType(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\Option=" & FlowChart_TableOption(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\Link#=" & PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart).ToString)
                        MyShowFlowChartRecord &= vbCrLf & "\Index=" & IndexFlowChart.ToString
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMname=" & FlowChart_ISAM_Name(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMx1=" & FlowChart_ISAM_X1(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMy1=" & FlowChart_ISAM_Y1(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMx2=" & FlowChart_ISAM_X2(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMy2=" & FlowChart_ISAM_Y2(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\pathSymbolName=" & FlowChart_Table_Path_SymbolName(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\PathName=" & FlowChart_TablePath_Name(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\DataType=" & FlowChart_Table_DataType(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\pathSymbolName=" & FlowChart_Table_Path_SymbolName(IndexFlowChart)
                        ' THERE IS NO ROTATION ON A PATH MyShowFlowChartRecord &= FD & "\Rotation=" & FlowChart_Table_Rotation(IndexFlowChart)
                    End If
                Case "/Error"
                    'This is for debugging only need to fix
                    'todo make this into the correct inport/export format
                    'FormatError = "/Error = Code" & FD & " name" & FD & " x1" & FD & " y1" & FD & " Name " & FD & " {other things maybe}"
                    If expanded = True Then
                        MyShowFlowChartRecord = FlowChart_TableCode(IndexFlowChart) & "=" & FindInSymbolList(FlowChart_TableOther_Name(IndexFlowChart))
                        MyShowFlowChartRecord &= "(" & FlowChart_TableX1(IndexFlowChart)
                        MyShowFlowChartRecord &= FD & FlowChart_TableY1(IndexFlowChart)
                        MyShowFlowChartRecord &= ")_(" & FlowChart_TableX2(IndexFlowChart)
                        MyShowFlowChartRecord &= FD & FlowChart_TableY2(IndexFlowChart) & ") "
                        MyShowFlowChartRecord &= FD & FlowChart_Table_DataType(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\Index=" & IndexFlowChart.ToString
                        'MyShowFlowChartRecord &= FD & PrintAbleNull(FlowChart_Table_Rotation(IndexFlowChart))
                        MyShowFlowChartRecord &= FD & PrintAbleNull(FlowChart_Table_DataType(IndexFlowChart))
                        MyShowFlowChartRecord &= FD & PrintAbleNull(FlowChart_TablePathName(IndexFlowChart))
                        MyShowFlowChartRecord &= FD & PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart).ToString)
                        ' removed     myshowFlowChartrecord &= FD &  PrintAbleNull(FlowChart_TableCompiledMacroCodeText(IndexFlowChart ))
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMName=" & FlowChart_ISAM_Name(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMX1=" & FlowChart_ISAM_X1(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMy1=" & FlowChart_ISAM_Y1(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMx2=" & FlowChart_ISAM_X2(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMY2=" & FlowChart_ISAM_Y2(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\PathNumber=" & PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart).ToString)
                        MyShowFlowChartRecord &= vbCrLf & "\Index=" & IndexFlowChart.ToString
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMname=" & FlowChart_ISAM_Name(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMx1=" & FlowChart_ISAM_X1(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMy1=" & FlowChart_ISAM_Y1(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMx2=" & FlowChart_ISAM_X2(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\ISAMy2=" & FlowChart_ISAM_Y2(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\Path_SymbolName=" & FlowChart_Table_Path_SymbolName(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\Option=" & FlowChart_TableOption(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\OtherName=" & FlowChart_TableOther_Name(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\PathName=" & FlowChart_TablePathName(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\PathNumber=" & FlowChart_TablePathNumber(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\Path_Name=" & FlowChart_TablePath_Name(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\Symbol_Name=" & FlowChart_TableSymbol_Name(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\DataType=" & FlowChart_Table_DataType(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\Path_SymbolName=" & FlowChart_Table_Path_SymbolName(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\Rotation=" & FlowChart_Table_Rotation(IndexFlowChart)
                    Else
                        MyShowFlowChartRecord = FlowChart_TableCode(IndexFlowChart) & "=" & FindInSymbolList(FlowChart_TableOther_Name(IndexFlowChart))
                        MyShowFlowChartRecord &= "(" & FlowChart_TableX1(IndexFlowChart)
                        MyShowFlowChartRecord &= FD & FlowChart_TableY1(IndexFlowChart)
                        MyShowFlowChartRecord &= ")_(" & FlowChart_TableX2(IndexFlowChart)
                        MyShowFlowChartRecord &= FD & FlowChart_TableY2(IndexFlowChart)
                        MyShowFlowChartRecord &= FD & FlowChart_Table_DataType(IndexFlowChart)
                        If MyOptionTest(22) = True Then
                            MyShowFlowChartRecord &= vbCrLf & "\Index=" & IndexFlowChart.ToString
                            If SymbolWindow.ToolStripDropDownRotation.DropDownItems.Count < CInt(FlowChart_Table_Rotation(IndexFlowChart)) Then
                                MyShowFlowChartRecord &= vbCrLf & "\Rotation=" & PrintAbleNull(FlowChart_Table_Rotation(IndexFlowChart))
                            Else
                                MyShowFlowChartRecord &= vbCrLf & "\Y2=" & PrintAbleNull(FlowChart_TableY2(IndexFlowChart).ToString)
                            End If
                            MyShowFlowChartRecord &= vbCrLf & "\DataType=" & PrintAbleNull(FlowChart_Table_DataType(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\PathName=" & PrintAbleNull(FlowChart_TablePathName(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\PathNumber=" & PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart).ToString)
                            ' removed     myshowFlowChartrecord &= FD & "\" &  PrintAbleNull(FlowChart_TableCompiledMacroCodeText(IndexFlowChart ))
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMName=" & FlowChart_ISAM_Name(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMX1=" & FlowChart_ISAM_X1(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMY1=" & FlowChart_ISAM_Y1(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMX2=" & FlowChart_ISAM_X2(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMY2=" & FlowChart_ISAM_Y2(IndexFlowChart)
                        End If
                    End If
                Case "/origin"
                    'This is for debugging only need to fix
                    'todo make this into the correct inport/export format
                    'FormatError = "/Error = Code" & FD & " name" & FD & " x1" & FD & " y1" & FD & " Name " & FD & " {other things maybe}"
                    If expanded = True Then
                        MyShowFlowChartRecord = "/" & FlowChart_TableCode(IndexFlowChart) & "=" & FindInSymbolList(FlowChart_TableOther_Name(IndexFlowChart))
                        MyShowFlowChartRecord &= "(" & FlowChart_TableX1(IndexFlowChart)
                        MyShowFlowChartRecord &= FD & FlowChart_TableY1(IndexFlowChart)
                        MyShowFlowChartRecord &= ")_(" & FlowChart_TableX2(IndexFlowChart)
                        MyShowFlowChartRecord &= FD & FlowChart_TableY2(IndexFlowChart)
                        If MyOptionTest(22) = True Then
                            MyShowFlowChartRecord &= vbCrLf & "\Index=" & IndexFlowChart.ToString
                            MyShowFlowChartRecord &= vbCrLf & "\Rotation=" & PrintAbleNull(FlowChart_Table_Rotation(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\DataType=" & PrintAbleNull(FlowChart_Table_DataType(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\PathName=" & PrintAbleNull(FlowChart_TablePathName(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\PathNumber=" & PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart).ToString)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMName=" & FlowChart_ISAM_Name(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMX1=" & FlowChart_ISAM_X1(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMY1=" & FlowChart_ISAM_Y1(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMx2=" & FlowChart_ISAM_X2(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMY2=" & FlowChart_ISAM_Y2(IndexFlowChart)
                        End If
                    Else
                        MyShowFlowChartRecord = "/" & FlowChart_TableCode(IndexFlowChart) & "=" & FindInSymbolList(FlowChart_TableOther_Name(IndexFlowChart))
                        MyShowFlowChartRecord &= "(" & FlowChart_TableX1(IndexFlowChart)
                        MyShowFlowChartRecord &= FD & FlowChart_TableY1(IndexFlowChart)
                        MyShowFlowChartRecord &= ")_(" & FlowChart_TableX2(IndexFlowChart)
                        MyShowFlowChartRecord &= FD & FlowChart_TableY2(IndexFlowChart)
                        If MyOptionTest(22) = True Then
                            MyShowFlowChartRecord &= vbCrLf & "\Index=" & IndexFlowChart.ToString
                            MyShowFlowChartRecord &= vbCrLf & "\Rotation=" & PrintAbleNull(FlowChart_Table_Rotation(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\DataType=" & PrintAbleNull(FlowChart_Table_DataType(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\PathName=" & PrintAbleNull(FlowChart_TablePathName(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\PathNumber=" & PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart).ToString)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMName=" & FlowChart_ISAM_Name(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMX1=" & FlowChart_ISAM_X1(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMY1=" & FlowChart_ISAM_Y1(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMX2=" & FlowChart_ISAM_X2(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMY2=" & FlowChart_ISAM_Y2(IndexFlowChart)
                        End If
                    End If
                Case "/Constant"
                    'todo make this into the correct inport/export format
                    'This is for debugging only need to fix
                    'formatConstant = "\Constant=name " & FD & " X" & FD & " Y" & FD & " Value"
                    'todo make this into the correct inport/export format
                    If expanded = True Then
                        MyShowFlowChartRecord = FlowChart_TableCode(IndexFlowChart) & "=" & FindInSymbolList(FlowChart_TableOther_Name(IndexFlowChart))
                        MyShowFlowChartRecord &= vbCrLf & vbTab & "/ConstantInfo" & FlowChart_TableCode(IndexFlowChart) & "=" & Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart))
                        MyShowFlowChartRecord &= FD & "(" & FlowChart_TableX1(IndexFlowChart)
                        MyShowFlowChartRecord &= FD & FlowChart_TableY1(IndexFlowChart) & ") "
                        MyShowFlowChartRecord &= vbCrLf & "\DataType=" & FD & PrintAbleNull(FlowChart_Table_DataType(IndexFlowChart))
                        MyShowFlowChartRecord &= vbCrLf & "\Rotation=" & PrintAbleNull(FlowChart_Table_Rotation(IndexFlowChart))
                        MyShowFlowChartRecord &= vbCrLf & "\Option=" & FlowChart_TableOption(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\DataType=" & FlowChart_Table_DataType(IndexFlowChart)
                        If MyOptionTest(22) = True Then
                            MyShowFlowChartRecord &= vbCrLf & "\Index=" & IndexFlowChart.ToString
                            MyShowFlowChartRecord &= vbCrLf & "\PathName=" & PrintAbleNull(FlowChart_TablePathName(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\PathNumber=" & PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart).ToString)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMName=" & FlowChart_ISAM_Name(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMX1=" & FlowChart_ISAM_X1(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMY1=" & FlowChart_ISAM_Y1(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMX2=" & FlowChart_ISAM_X2(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMY2=" & FlowChart_ISAM_Y2(IndexFlowChart)
                        End If
                    Else
                        MyShowFlowChartRecord = FlowChart_TableCode(IndexFlowChart) & "=" & FindInSymbolList(FlowChart_TableOther_Name(IndexFlowChart))
                        MyShowFlowChartRecord &= vbCrLf & vbTab & "/ConstantInfo" & FlowChart_TableCode(IndexFlowChart) & "=" & Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart))
                        MyShowFlowChartRecord &= FD & "(" & FlowChart_TableX1(IndexFlowChart)
                        MyShowFlowChartRecord &= FD & FlowChart_TableY1(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\DataType=" & PrintAbleNull(FlowChart_Table_DataType(IndexFlowChart))
                        MyShowFlowChartRecord &= vbCrLf & "\Rotation=" & PrintAbleNull(FlowChart_Table_Rotation(IndexFlowChart))
                        MyShowFlowChartRecord &= vbCrLf & "\Option=" & FlowChart_TableOption(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\DataType=" & FlowChart_Table_DataType(IndexFlowChart)
                        If MyOptionTest(22) = True Then
                            MyShowFlowChartRecord &= vbCrLf & "\Index=" & IndexFlowChart.ToString
                            MyShowFlowChartRecord &= vbCrLf & "\PathName=" & PrintAbleNull(FlowChart_TablePathName(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\PathNumber=" & PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart).ToString)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMName=" & FlowChart_ISAM_Name(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMX1=" & FlowChart_ISAM_X1(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMY1=" & FlowChart_ISAM_Y1(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMX2=" & FlowChart_ISAM_X2(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMY2=" & FlowChart_ISAM_Y2(IndexFlowChart)
                        End If
                    End If
                Case Else
                    If expanded = True Then
                        MyShowFlowChartRecord = "\Invalid=" + FlowChart_TableCode(IndexFlowChart) & "=" & FindInSymbolList(FlowChart_TableOther_Name(IndexFlowChart))
                        MyShowFlowChartRecord &= vbCrLf & "\=(X1=" & FlowChart_TableX1(IndexFlowChart)
                        MyShowFlowChartRecord &= FD & "Y1=" & FlowChart_TableY1(IndexFlowChart)
                        MyShowFlowChartRecord &= ")-(X2=" & FlowChart_TableX2(IndexFlowChart)
                        MyShowFlowChartRecord &= FD & "Y2=" & FlowChart_TableY2(IndexFlowChart) & ")"
                        If MyOptionTest(22) = True Then
                            MyShowFlowChartRecord &= vbCrLf & "\index=" & IndexFlowChart.ToString
                            MyShowFlowChartRecord &= vbCrLf & "\Rotation=" & PrintAbleNull(FlowChart_Table_Rotation(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\DataType=" & PrintAbleNull(FlowChart_Table_DataType(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\PathName=" & PrintAbleNull(FlowChart_TablePathName(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\PathNumber=" & PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart).ToString)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMname=" & FlowChart_ISAM_Name(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMx1=" & FlowChart_ISAM_X1(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMy1=" & FlowChart_ISAM_Y1(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMx2=" & FlowChart_ISAM_X2(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMy2=" & FlowChart_ISAM_Y2(IndexFlowChart)
                        End If
                    Else
                        MyShowFlowChartRecord = "\Invalid=" + FlowChart_TableCode(IndexFlowChart) & "=" & FindInSymbolList(FlowChart_TableOther_Name(IndexFlowChart))
                        MyShowFlowChartRecord &= vbCrLf & "\X1=" & FlowChart_TableX1(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\Y1=" & FlowChart_TableY1(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\X2=" & FlowChart_TableX2(IndexFlowChart)
                        MyShowFlowChartRecord &= vbCrLf & "\Y2=" & FlowChart_TableY2(IndexFlowChart)
                        If MyOptionTest(22) = True Then
                            MyShowFlowChartRecord &= vbCrLf & "\index" & IndexFlowChart.ToString
                            MyShowFlowChartRecord &= vbCrLf & "\Rotation=" & PrintAbleNull(FlowChart_Table_Rotation(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\DataType=" & PrintAbleNull(FlowChart_Table_DataType(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\PathName=" & PrintAbleNull(FlowChart_TablePathName(IndexFlowChart))
                            MyShowFlowChartRecord &= vbCrLf & "\PathNumber=" & PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart).ToString)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMName=" & FlowChart_ISAM_Name(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMX1=" & FlowChart_ISAM_X1(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMY1=" & FlowChart_ISAM_Y1(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMX2=" & FlowChart_ISAM_X2(IndexFlowChart)
                            MyShowFlowChartRecord &= vbCrLf & "\ISAMY2=" & FlowChart_ISAM_Y2(IndexFlowChart)
                        End If
                    End If
            End Select
            Return MyShowFlowChartRecord
        End Function 'MyShowFlowChartRecord

        Public Shared Function MyShowNamedRecords(expanded As Boolean, IndexNamed As Int32) As String
            Dim X1, X2 As String
            Dim RTN As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3272, 10, "MyShowNamedRecord")
#End If
            If Len(Named_TableSymbolName(IndexNamed)) = 0 Then
                Return ""
            End If
            If IndexNamed = ConstantMyErrorCode Then
                Return ""
            End If
            'todo this is the wrong format for output fixed ?? needs checking
            RTN = My_keyWord(My_KeyConstName) & " = " & Named_TableSymbolName(IndexNamed) & vbCrLf
            RTN &= My_keyWord(My_KeyConstAuthor) & " = " & Named_TableAuthor(IndexNamed) & vbCrLf
            RTN &= My_keyWord(My_KeyConstVersion) & " = " & Named_TableVersion(IndexNamed) & vbCrLf
            RTN &= My_keyWord(My_KeyConstFileName) & " = " & Named_TableNameofFile(IndexNamed) & vbCrLf
            RTN &= My_keyWord(My_KeyConstStroke) & " = " & Named_TableStroke(IndexNamed) & vbCrLf
            X2 = MyTrim(Named_TableMicroCodeText(IndexNamed))
            While X2 <> ""
                X1 = MyTrim(PopLine(X2))
                If Len(X1) > 0 Then
                    RTN &= My_keyWord(My_KeyConstMicroCodeText) & " = " & X1 & vbCrLf
                End If
            End While
            X2 = MyTrim(Named_TableSyntax(IndexNamed))
            While X2 <> ""
                X1 = MyTrim(PopLine(X2))
                If Len(X1) > 0 Then
                    RTN &= My_keyWord(My_KeyConstSyntax) & " = " & X1 & vbCrLf
                End If
            End While
            X2 = MyTrim(Named_TableNotes(IndexNamed))
            While X2 <> ""
                X1 = MyTrim(PopLine(X2))
                If Len(X1) > 0 Then
                    RTN &= My_keyWord(My_KeyConstNotes) & "=" & X1 & vbCrLf
                End If
            End While
            X2 = MyTrim(Named_TableOpCode(IndexNamed))
            While X2 <> ""
                X1 = PopLine(X2)
                If Len(X1) > 0 Then
                    RTN &= My_keyWord(My_KeyConstOpcode) & " = " & X1 & vbCrLf
                End If
            End While

            If expanded = False Then
                RTN &= "/name= " & Named_TableSymbolName(IndexNamed)
                If Not MyIsNothing(Named_TableAuthor(IndexNamed)) Then
                    RTN &= "/Author" & " = " & Named_TableAuthor(IndexNamed) & vbCrLf
                End If
                If Not MyIsNothing(Named_TableVersion(IndexNamed)) Then
                    RTN &= "/version" & " = " & Named_TableVersion(IndexNamed) & vbCrLf
                End If
                If Not MyIsNothing(Named_TableNameofFile(IndexNamed)) Then
                    RTN &= "/filename" & " = " & Named_TableNameofFile(IndexNamed) & vbCrLf
                End If
                If Not MyIsNothing(Named_TableStroke(IndexNamed)) Then
                    RTN &= "/stroke" & " = " & Named_TableStroke(IndexNamed) & vbCrLf
                End If
                'hack there is a routine that does the multilines that should replace this
                '/MacroMicroCodeText 
                X2 = MyTrim(Named_TableMicroCodeText(IndexNamed))
                While X2 <> ""
                    X1 = MyTrim(PopLine(X2))
                    If Len(X1) > 0 Then
                        RTN &= "/MicroCodeText" & " = " & X1 & vbCrLf
                    End If
                    RTN = RTN.Replace(vbCrLf & vbCrLf, vbCrLf)
                End While
                X2 = MyTrim(Named_TableSyntax(IndexNamed))
                While X2 <> ""
                    X1 = MyTrim(PopLine(X2))
                    If Len(X1) > 0 Then
                        RTN &= "/Syntax" & " = " & X1 & vbCrLf
                    End If
                End While
                X2 = MyTrim(Named_TableNotes(IndexNamed))
                While X2 <> ""
                    X1 = MyTrim(MyTrim(PopLine(X2)))
                    RTN &= "/notes" & " = " & X1 & vbCrLf
                End While
                X2 = MyTrim(Named_TableOpCode(IndexNamed))
                While X2 <> ""
                    X1 = MyTrim(PopLine(X2))
                    If Len(X1) > 0 Then
                        RTN &= "/opcode" & " = " & PopLine(X2) & vbCrLf
                    End If
                End While
            End If
            Return RTN 'already has cr
        End Function


        Public Shared Function MyShowSymbolRecord(expanded As Boolean, IndexSymbol As Int32) As String
            Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                Case "/unknown"
                    Return "" ' end of the Symbol list
                Case "/name"
                    Return MyShowSymbolName(expanded, IndexSymbol)
                Case "/point"
                    Return MyShowSymbolGraphic(expanded, IndexSymbol)
                Case "/line"
                    Return MyShowLineRecord(expanded, IndexSymbol)
                Case "/delete"
                    Return "/delete = " & Symbol_TableX1(IndexSymbol) & FD & Symbol_TableY1(IndexSymbol) & FD & Symbol_TableSymbolName(IndexSymbol) & FD & Symbol_Table_NameOfPoint(IndexSymbol)
                Case "/Error"
                    Return "/Error = " & Symbol_TableX1(IndexSymbol) & FD & Symbol_TableY1(IndexSymbol) & " = " & Symbol_Table_InputOutput(IndexSymbol) & FD & Symbol_Table_DataType(IndexSymbol) & FD & Symbol_TableY1(IndexSymbol) & FD & Symbol_TableSymbolName(IndexSymbol) & FD & Symbol_Table_NameOfPoint(IndexSymbol)
                Case Else
                    Return "/Error In program Symbol Data Unknown Code " & Symbol_TableCoded_Byte(IndexSymbol).ToString & " /Error = " & IndexSymbol & FD & Symbol_TableCoded_String(IndexSymbol) & FD & Symbol_TableX1(IndexSymbol) & FD & Symbol_TableY1(IndexSymbol) & FD & Symbol_Table_X2(IndexSymbol) & FD & Symbol_Table_Y2(IndexSymbol) & FD & Symbol_Table_NameOfPoint(IndexSymbol) & FD & Symbol_TableSymbolName(IndexSymbol)
            End Select

        End Function

        Public Shared Function MyShowSymbolRecords(expanded As Boolean, IndexSymbol As Int32) As String
            Dim LocalIndexSymbol, IndexNamed As Int32
            Dim X2, X3 As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3273, 10, "MyShowSymbolRecords")
#End If
            MyShowSymbolRecords = ""

            LocalIndexSymbol = IndexSymbol

            IndexNamed = FindIndexInISAMTable("Named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, Symbol_TableSymbolName(LocalIndexSymbol))
            If IndexNamed = ConstantMyErrorCode Then
                ' removed not needed ?IndexNamed = CheckNotInList("Named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, Symbol_TableSymbolName(LocalIndexSymbol))
            Else
                If expanded = True Then MyShowSymbolRecords = MyShowNamedRecords(expanded, IndexNamed)
            End If
            '================================== Symbol graphics now for the above Symbol Named data.
            MyShowSymbolRecords &= MyShowSymbolName(expanded, LocalIndexSymbol) & vbCrLf

            LocalIndexSymbol += 1 'after the name
            Do
                Select Case LCase(Symbol_TableCoded_String(LocalIndexSymbol))
                    Case "/unknown"
                        Return MyShowSymbolRecords ' end of the Symbol list
                    Case "/name"
                        MyShowSymbolRecords &= MyShowSymbolName(expanded, LocalIndexSymbol)
                    Case "/point"
                        X3 = Symbol_Table_InputOutput(LocalIndexSymbol)
                        X2 = MyUniverse.ProgramOptions.SelectedDataType
                        X2 = CStr(FindIndexInISAMTable("DataType", "DoNotAdd", DataType_FileName, DataType_Name_ISAM, MyUniverse.ProgramOptions.SelectedDataType))

                        '/Point=X, Y, Input/Output, Data Type, Name
                        MyShowSymbolRecords &= MyShowSymbolGraphic(expanded, LocalIndexSymbol)
                    Case "/line"
                        MyShowSymbolRecords &= MyShowLineRecord(expanded, LocalIndexSymbol)
        'MyShowSymbolRecords &= vbCrLf
                    Case "/delete"
                        MyShowSymbolRecords &= "/delete"
                        MyShowSymbolRecords &= " = " & Symbol_TableX1(LocalIndexSymbol)
                        MyShowSymbolRecords &= FD & Symbol_TableY1(LocalIndexSymbol)
                        MyShowSymbolRecords &= FD & Symbol_TableSymbolName(LocalIndexSymbol)
                        MyShowSymbolRecords &= FD & Symbol_Table_NameOfPoint(LocalIndexSymbol)
                        MyShowSymbolRecords &= vbCrLf
                    Case "/Error"
                        MyShowSymbolRecords &= vbCrLf & "/Error"
                        MyShowSymbolRecords &= " = " & Symbol_TableX1(LocalIndexSymbol)
                        MyShowSymbolRecords &= FD & Symbol_TableY1(LocalIndexSymbol)
                        MyShowSymbolRecords &= " = " & Symbol_Table_InputOutput(LocalIndexSymbol)
                        MyShowSymbolRecords &= FD & Symbol_Table_DataType(LocalIndexSymbol)
                        MyShowSymbolRecords &= FD & Symbol_TableY1(LocalIndexSymbol)
                        MyShowSymbolRecords &= FD & Symbol_TableSymbolName(LocalIndexSymbol)
                        MyShowSymbolRecords &= FD & Symbol_Table_NameOfPoint(LocalIndexSymbol)
                    Case Else
                        MyShowSymbolRecords &= vbCrLf & "/Error In program Symbol Data Unknown Code " &
        Symbol_TableCoded_Byte(LocalIndexSymbol).ToString & " /Error = " & LocalIndexSymbol & FD
                        MyShowSymbolRecords &= Symbol_TableCoded_String(LocalIndexSymbol)
                        MyShowSymbolRecords &= FD & Symbol_TableX1(LocalIndexSymbol)
                        MyShowSymbolRecords &= FD & Symbol_TableY1(LocalIndexSymbol)
                        MyShowSymbolRecords &= FD & Symbol_Table_X2(LocalIndexSymbol)
                        MyShowSymbolRecords &= FD & Symbol_Table_Y2(LocalIndexSymbol)
                        MyShowSymbolRecords &= FD & Symbol_Table_NameOfPoint(LocalIndexSymbol)
                        MyShowSymbolRecords &= FD & Symbol_TableSymbolName(LocalIndexSymbol)
                End Select
                LocalIndexSymbol += 1
            Loop While LocalIndexSymbol <= TopOfFile("Symbol")
            If MyRight(MyShowSymbolRecords, 1) <> vbCrLf Then MyShowSymbolRecords &= vbCrLf
            Return MyShowSymbolRecords
        End Function


        Public Shared Function MyShowPointCounts(expanded As Boolean) As String ', A As MySymbolCountsStructure
            Dim RTN As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3274, 10, "MyShowPointCounts")
#End If
            'todo This needs to be change to use 
            'todo this needs to be change to only list things that are not zero
            'todo this needs to not use shorthand, but the long names of the points listed
            If expanded = True Then
                RTN = "Symbol name = " & MyUniverse.SymbolAndPath.Name
                If MyUniverse.SymbolAndPath.Total <> 0 Then RTN &= vbTab & " Total = " & MyUniverse.SymbolAndPath.Total.ToString
                If MyUniverse.SymbolAndPath.Path.Total <> 0 Then RTN &= vbTab & " Total = " & MyUniverse.SymbolAndPath.Path.Total.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Total <> 0 Then RTN &= vbTab & " Total = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Total.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Both <> 0 Then RTN &= vbTab & " Data.Both = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Both.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Input <> 0 Then RTN &= vbTab & " Data.Input = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Input.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Output <> 0 Then RTN &= vbTab & " Data.Output = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Output.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Other <> 0 Then RTN &= vbTab & " Data.Other = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Other.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Total <> 0 Then RTN &= vbTab & " Logic.Total = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Total.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Both <> 0 Then RTN &= vbTab & " Logic.Both = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Both.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Input <> 0 Then RTN &= vbTab & " Logic.Input = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Input.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Output <> 0 Then RTN &= vbTab & " Logic.Output = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Output.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Other <> 0 Then RTN &= vbTab & " Logic.Other = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Other.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Total <> 0 Then RTN &= vbTab & " Total = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Total.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Both <> 0 Then RTN &= vbTab & " Data.Both = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Both.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Input <> 0 Then RTN &= vbTab & " Data.Input = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Input.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Output <> 0 Then RTN &= vbTab & " Data.Output = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Output.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Other <> 0 Then RTN &= vbTab & " Data.Other = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Other.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Total <> 0 Then RTN &= vbTab & " Logic.Total = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Total.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Both <> 0 Then RTN &= vbTab & " Logic.Both = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Both.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Input <> 0 Then RTN &= vbTab & " Logic.Input = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Input.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Output <> 0 Then RTN &= vbTab & " Logic.Output = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Output.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Other <> 0 Then RTN &= vbTab & " Logic.Other = " & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Other.ToString
                If MyUniverse.SymbolAndPath.Path.NumberOfErrors <> 0 Then RTN &= vbTab & " NumberOfErrors = " & MyUniverse.SymbolAndPath.Path.NumberOfErrors.ToString
                If MyUniverse.SymbolAndPath.Symbol.Total <> 0 Then RTN &= vbTab & " Total = " & MyUniverse.SymbolAndPath.Symbol.Total.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Total <> 0 Then RTN &= vbTab & " Total = " & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Total.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Both <> 0 Then RTN &= vbTab & " Data.Both = " & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Both.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Input <> 0 Then RTN &= vbTab & " Data.Input = " & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Input.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Output <> 0 Then RTN &= vbTab & " Data.Output = " & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Output.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Other <> 0 Then RTN &= vbTab & " Data.Other = " & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Other.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Total <> 0 Then RTN &= vbTab & " Logic.Total = " & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Total.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Both <> 0 Then RTN &= vbTab & " Logic.Both = " & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Both.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Input <> 0 Then RTN &= vbTab & " Logic.Input = " & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Input.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Output <> 0 Then RTN &= vbTab & " Logic.Output = " & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Output.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Other <> 0 Then RTN &= vbTab & " Logic.Other = " & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Other.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Total <> 0 Then RTN &= vbTab & " Total = " & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Total.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Both <> 0 Then RTN &= vbTab & " Data.Both = " & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Both.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Input <> 0 Then RTN &= vbTab & " Data.Input = " & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Input.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Output <> 0 Then RTN &= vbTab & " Data.Output = " & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Output.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Other <> 0 Then RTN &= vbTab & " Data.Other = " & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Other.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Total <> 0 Then RTN &= vbTab & " Logic.Total = " & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Total.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Both <> 0 Then RTN &= vbTab & " Logic.Both = " & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Both.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Input <> 0 Then RTN &= vbTab & " Logic.Input = " & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Input.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Output <> 0 Then RTN &= vbTab & " Logic.Output = " & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Output.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Other <> 0 Then RTN &= vbTab & " Logic.Other = " & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Other.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total <> 0 Then RTN &= vbTab & " Total = " & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Total <> 0 Then RTN &= vbTab & " Data.Total = " & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Total.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Both <> 0 Then RTN &= vbTab & " Data.Both = " & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Both.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Input <> 0 Then RTN &= vbTab & " Data.Input = " & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Input.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Output <> 0 Then RTN &= vbTab & " Data.Output = " & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Output.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other <> 0 Then RTN &= vbTab & " Data.Other = " & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Total <> 0 Then RTN &= vbTab & " Logic.Total = " & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Total.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Both <> 0 Then RTN &= vbTab & " Logic.Both = " & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Both.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Input <> 0 Then RTN &= vbTab & " Logic.Input = " & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Input.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Output <> 0 Then RTN &= vbTab & " Logic.Output = " & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Output.ToString
                If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Other <> 0 Then RTN &= vbTab & " Logic.Other = " & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Other.ToString
                If MyUniverse.SymbolAndPath.Uses.Total <> 0 Then RTN &= vbTab & " Total = " & MyUniverse.SymbolAndPath.Uses.Total.ToString
                If MyUniverse.SymbolAndPath.Uses.IndexUseSymbol <> 0 Then RTN &= vbTab & " IndexUseSymbol = " & MyUniverse.SymbolAndPath.Uses.IndexUseSymbol.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.Total <> 0 Then RTN &= vbTab & " Total = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.Total.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Total <> 0 Then RTN &= vbTab & " NumberOfLines.Total = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Total.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Both <> 0 Then RTN &= vbTab & " NumberOfLines.Data.Both = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Both.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Input <> 0 Then RTN &= vbTab & " NumberOfLines.Data.Input = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Input.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Output <> 0 Then RTN &= vbTab & " NumberOfLines.Data.Output = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Output.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Other <> 0 Then RTN &= vbTab & " NumberOfLines.Data.Other = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Other.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Total <> 0 Then RTN &= vbTab & " NumberOfLines.Logic.Total = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Total.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Both <> 0 Then RTN &= vbTab & " NumberOfLines.Logic.Both = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Both.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Input <> 0 Then RTN &= vbTab & " NumberOfLines.Logic.Input = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Input.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Output <> 0 Then RTN &= vbTab & " NumberOfLines.Logic.Output = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Output.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Other <> 0 Then RTN &= vbTab & " NumberOfLines.Logic.Other = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Other.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Total <> 0 Then RTN &= vbTab & " NumberOfOther.Total = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Total.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Total <> 0 Then RTN &= vbTab & " NumberOfOther.Total = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Total.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Both <> 0 Then RTN &= vbTab & " NumberOfOther.Data.Both = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Both.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Input <> 0 Then RTN &= vbTab & " NumberOfOther.Data.Input = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Input.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Output <> 0 Then RTN &= vbTab & " NumberOfOther.Data.Output = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Output.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Other <> 0 Then RTN &= vbTab & " NumberOfOther.Data.Other = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Other.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Total <> 0 Then RTN &= vbTab & " NumberOfOther.Logic.Total = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Total.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Both <> 0 Then RTN &= vbTab & " NumberOfOther.Logic.Both = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Both.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Input <> 0 Then RTN &= vbTab & " NumberOfOther.Logic.Input = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Input.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Output <> 0 Then RTN &= vbTab & " NumberOfOther.Logic.Output = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Output.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Other <> 0 Then RTN &= vbTab & " NumberOfOther.Logic.Other = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Other.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Total <> 0 Then RTN &= vbTab & " NumberOfPoints.Total = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Total.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Both <> 0 Then RTN &= vbTab & " NumberOfPoints.Data.Both = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Both.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Input <> 0 Then RTN &= vbTab & " NumberOfPoints.Data.Input = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Input.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Output <> 0 Then RTN &= vbTab & " NumberOfPoints.Data.Output = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Output.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Other <> 0 Then RTN &= vbTab & " NumberOfPoints.Data.Other = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Other.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Total <> 0 Then RTN &= vbTab & " NumberOfPoints.Logic.Total = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Total.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Both <> 0 Then RTN &= vbTab & " NumberOfPoints.Logic.Both = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Both.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Input <> 0 Then RTN &= vbTab & " NumberOfPoints.Logic.Input = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Input.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Output <> 0 Then RTN &= vbTab & " NumberOfPoints.Logic.Output = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Output.ToString
                If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Other <> 0 Then RTN &= vbTab & " NumberOfPoints.Logic.Other = " & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Other.ToString


            Else
                RTN = ""
                RTN &= "/Ignore Total=" & MyUniverse.SymbolAndPath.Total
                If MyUniverse.SymbolAndPath.Symbol.Total <> 0 Then RTN &= " Symbol=" & MyUniverse.SymbolAndPath.Symbol.Total
                If MyUniverse.SymbolAndPath.Uses.Total <> 0 Then RTN &= " USE=" & MyUniverse.SymbolAndPath.Uses.Total
                If MyUniverse.SymbolAndPath.Path.Total <> 0 Then RTN &= " Path=" & MyUniverse.SymbolAndPath.Path.Total
            End If
            Return RTN
        End Function


        'for now only one point per line, until I change the import to be able to get more than one at a time.
        Public Shared Function MyShowSymbolLines1(expanded As Boolean, LocalIndex As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3275, 10, "MyShowSymbolLines1")
#End If
            MyShowSymbolLines1 = Symbol_TableCoded_String(LocalIndex)
            MyShowSymbolLines1 &= FD & Symbol_FileSymbolName(LocalIndex) 'color of the line
            MyShowSymbolLines1 &= "=" & Symbol_TableX1(LocalIndex)
            MyShowSymbolLines1 &= FD & Symbol_TableY1(LocalIndex)
            MyShowSymbolLines1 &= FD & Symbol_Table_X2(LocalIndex)
            MyShowSymbolLines1 &= FD & Symbol_Table_Y2(LocalIndex)
            MyShowSymbolLines1 &= FD & Symbol_Table_NameOfPoint(LocalIndex) 'Point Name should be color on a line
            Return MyShowSymbolLines1 & vbCrLf
        End Function



        Public Shared Function MyShowSymbolPoint(expanded As Boolean, LocalIndex As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3276, 10, "MyShowSymbolPoint")
#End If
            MyShowSymbolPoint = Symbol_TableCoded_String(LocalIndex)
            MyShowSymbolPoint &= "=" & Symbol_FileSymbolName(LocalIndex)
            MyShowSymbolPoint &= FD & Symbol_TableX1(LocalIndex)
            MyShowSymbolPoint &= FD & Symbol_TableY1(LocalIndex)
            MyShowSymbolPoint &= FD & Symbol_Table_InputOutput(LocalIndex)
            MyShowSymbolPoint &= FD & Pop(Symbol_Table_DataType(LocalIndex), FD)
            MyShowSymbolPoint &= FD & Symbol_Table_NameOfPoint(LocalIndex) 'Point Name

            If expanded = True Then
                'todo make sure that this takes care of /name,/linbe,/point, and anything else like /error
                MyShowSymbolPoint &= vbCrLf & "\data direction=" + Symbol_Table_InputOutput(LocalIndex)
                MyShowSymbolPoint &= vbCrLf & "\DataType=" + Symbol_Table_DataType(LocalIndex)
                MyShowSymbolPoint &= vbCrLf & "\PointName=" + Symbol_Table_NameOfPoint(LocalIndex) 'Point Name
                If MyOptionTest(22) = True Then
                    MyShowSymbolPoint &= vbCrLf & "\Index= " & LocalIndex
                End If
            End If
            MyShowSymbolPoint &= FD
            Return MyShowSymbolPoint & vbCrLf
        End Function


        Public Shared Function MyShowSymbolName(expanded As Boolean, LocalIndex As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3277, 10, "MyShowSymbolName")
#End If
            If expanded = True Then
                Return "/name = " & Symbol_TableSymbolName(LocalIndex) & FD & Symbol_Table_NameOfPoint(LocalIndex) & FD & " -----> " & Symbol_TableCoded_String(LocalIndex) & "= " & FD & Symbol_TableX1(LocalIndex).ToString & FD & Symbol_TableY1(LocalIndex).ToString & FD & Symbol_Table_X2(LocalIndex).ToString & FD & Symbol_Table_X2(LocalIndex).ToString & FD & Symbol_Table_DataType(LocalIndex) & FD & Symbol_Table_InputOutput(LocalIndex) & FD & Symbol_Table_LineColor(LocalIndex)
            End If
            Return "/name = " & Symbol_TableSymbolName(LocalIndex) & FD & Symbol_TableX1(LocalIndex).ToString & FD & Symbol_TableY1(LocalIndex).ToString & FD & Symbol_Table_X2(LocalIndex).ToString & FD & Symbol_Table_X2(LocalIndex).ToString & FD & Symbol_Table_LineColor(LocalIndex)

        End Function

        Public Shared Function MyShowSymbolGraphic(expanded As Boolean, LocalIndex As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3278, 10, "MyShowSymbolGraphic")
#End If
            'todo needs to change the expanded to have all of the /line, /point and all other graphic records displayed as a list( also for future input file)
            If Len(Symbol_TableCoded_String(LocalIndex)) = 0 Then
                MyShowSymbolGraphic = vbCrLf & "/ignore Invalide Symbol code, ->" & LocalIndex
                Exit Function
            End If
            If Symbol_TableCoded_String(LocalIndex) = "/unknown" Then
                MyShowSymbolGraphic = vbCrLf & "/ignore Invalide Symbol code, ->" & Symbol_TableCoded_Byte(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_TableCoded_String(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_FileSymbolName(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_TableX1(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_TableY1(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_Table_InputOutput(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_Table_X2(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_Table_DataType(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_Table_Y2(LocalIndex) 'Point Name
                MyShowSymbolGraphic &= vbCrLf
                Exit Function
            End If

            'todo need to change the format to ALSO include /point = pointname, X, Y [, pointname, x, y .... ]
            'todo need to change the format to ALSO include /line = color, x1,y1,x2,y2 [, {color,} x1, y1, x2, y2] ......
            ' removed not needed ?MyShowSymbolGraphic = ""
            Select Case LCase(Symbol_TableCoded_String(LocalIndex))
                Case "/name"
                    MyShowSymbolGraphic = MyShowSymbolRecords(expanded, LocalIndex)
                Case "/point"
                    MyShowSymbolGraphic = MyShowSymbolPoint(expanded, LocalIndex)
                Case "/line"
                    MyShowSymbolGraphic = MyShowSymbolLines1(expanded, LocalIndex)
                Case Else
                    '
                    'todo need to change this to something else that display the default record..
                    'MyShowSymbolGraphic = MyShowSymbolRecords(expanded, LocalIndex)
                    MyShowSymbolGraphic = Symbol_TableCoded_String(LocalIndex)
                    MyShowSymbolGraphic &= FD & Symbol_TableX1(LocalIndex)
                    MyShowSymbolGraphic &= FD & Symbol_TableY1(LocalIndex)
                    MyShowSymbolGraphic &= FD & Symbol_Table_X2(LocalIndex)
                    MyShowSymbolGraphic &= FD & Symbol_Table_InputOutput(LocalIndex)
                    MyShowSymbolGraphic &= FD & Symbol_Table_Y2(LocalIndex)
                    MyShowSymbolGraphic &= FD & Symbol_Table_DataType(LocalIndex)
                    MyShowSymbolGraphic &= FD & Symbol_Table_NameOfPoint(LocalIndex) 'Point Name
                    MyShowSymbolGraphic &= FD & Symbol_FileSymbolName(LocalIndex)
                    MyShowSymbolGraphic &= FD & LocalIndex.ToString
                    If expanded = True Then
                        MyShowSymbolGraphic &= "(" & Symbol_TableX1(LocalIndex)
                        MyShowSymbolGraphic &= FD & Symbol_TableY1(LocalIndex)
                        MyShowSymbolGraphic &= "),(" & Symbol_Table_X2(LocalIndex)
                        MyShowSymbolGraphic &= FD & Symbol_Table_Y2(LocalIndex)
                        MyShowSymbolGraphic &= ") " & vbCrLf & "\PointName " & Symbol_Table_NameOfPoint(LocalIndex) 'Point Name
                        MyShowSymbolGraphic &= vbCrLf & "\SymbolName = " & Symbol_FileSymbolName(LocalIndex)
                        MyShowSymbolGraphic &= FD & "Index->" & LocalIndex.ToString
                    End If
            End Select
            If MyRight(MyShowSymbolGraphic, 2) <> vbCrLf Then MyShowSymbolGraphic &= vbCrLf
            Return MyShowSymbolGraphic
        End Function



        Public Shared Function MyShowDataType(expand As Boolean, Index As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3279, 10, "MyShowDataType")
#End If
            MyShowDataType = "/DataType" & " = " & DataType_TableName(Index)
            'MyShowDataType &= Space(32 - Len(MyShowDataType)) & vbTab
            MyShowDataType &= FD & DataType_TableNumberOfBytes(Index)
            MyShowDataType &= FD & Color_TableName(DataType_TableColorIndex(Index)) 'DataType_TableColor( i )
            MyShowDataType &= FD & DataType_TableWidth(Index)
            MyShowDataType &= FD & PrintAbleNull(Trim(DataType_TableDescription(Index)))

        End Function

        Public Shared Function MyShowColor(Expand As Boolean, Indexcolor As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3280, 10, "MyShowColor")
#End If
            MyShowColor = "/color" & " = " & Color_TableName(Indexcolor)
            MyGetPen(Color_TableName(Indexcolor), "")
            MyShowColor &= FD & Color_TableAlpha(Indexcolor) 'PenColor.Color.A
            MyShowColor &= FD & Color_TableRed(Indexcolor) 'PenColor.Color.R
            MyShowColor &= FD & Color_TableGreen(Indexcolor) 'PenColor.Color.G
            MyShowColor &= FD & Color_TableBlue(Indexcolor) 'PenColor.Color.B
            MyShowColor &= FD & MyUnEnum(Color_TableStyle(Indexcolor), SymbolWindow.ToolStripDropDownPathLineStyle, 0)
            MyShowColor &= FD & MyUnEnum(Color_TableStartCap(Indexcolor), SymbolWindow.ToolStripDropDownPathStart, 0)
            MyShowColor &= FD & MyUnEnum(Color_TableEndCap(Indexcolor), SymbolWindow.ToolStripDropDownPathEnd, 0)
            If Expand = False Then Exit Function
            MyShowColor &= FD & "/ignore=" & formatColor
            MyShowColor &= vbCrLf & "\Index=" & Indexcolor.ToString

            If Len(Color_TableName(Indexcolor)) < 1 Then
                MyShowColor &= "/Error Invalid color Index at " & Indexcolor.ToString
                Exit Function
            End If
        End Function


        Public Shared Function MyShowDataTypeTable(expanded As Boolean, LocalIndex As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3281, 10, "MyShowDataqTable")
#End If
            If Len(DataType_FileName(LocalIndex)) < 1 Then
                MyShowDataTypeTable = "/ignore \Index=" & LocalIndex & " Invalid Data Type Name at " & LocalIndex.ToString
                Exit Function
            End If

            If DataType_TableColorIndex(LocalIndex) < 1 Then
                MyShowDataTypeTable = vbCrLf & "/ignore \Index=" & LocalIndex & " Invalid color For Data Type Name " & DataType_TableName(LocalIndex)
                Exit Function
            End If

            '"/DataType=DataTypename" & FD & " Number Of Bytes" & FD & " Color Name" & FD & " Color Width" & FD & " Description"
            If expanded = True Then
                MyShowDataTypeTable = "/DataType=" & DataType_FileName(LocalIndex)
                MyShowDataTypeTable &= FD & DataType_FileNumberOfBytes(LocalIndex)
                MyShowDataTypeTable &= FD & FindColorFromDataType(DataType_FileName(LocalIndex))
                MyShowDataTypeTable &= FD & DataType_FileWidth(LocalIndex)
                MyShowDataTypeTable &= FD & DataType_FileDescription(LocalIndex)
                MyShowDataTypeTable &= vbCrLf & "\Index=" & LocalIndex
                MyShowDataTypeTable &= FD & DataType_TableColorIndex(FindDataTypeIndex(DataType_FileName(LocalIndex)))
                MyShowDataTypeTable &= FD & MyShowColor(False, DataType_TableColorIndex(FindDataTypeIndex(DataType_FileName(LocalIndex))))
            Else
                MyShowDataTypeTable = "/DataType=" & DataType_FileName(LocalIndex)
                MyShowDataTypeTable &= FD & "/#bytes" & DataType_FileNumberOfBytes(LocalIndex)
                MyShowDataTypeTable &= FD & "/color=" & FindColorFromDataType(DataType_FileName(LocalIndex))
                MyShowDataTypeTable &= FD & "/size" & DataType_FileWidth(LocalIndex)
                MyShowDataTypeTable &= FD & "/Description=" & DataType_FileDescription(LocalIndex)
                MyShowDataTypeTable &= vbCrLf & "\Index=" & LocalIndex.ToString
            End If
        End Function


        Public Shared Function MyShowButton(A As ToolStripButton) As String
            Dim rtn As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3282, 10, "MyShowButton")
#End If
            rtn = A.Name
            rtn += FD + CStr(A.Enabled)
            rtn += FD + CStr(A.GetCurrentParent.ToString)
            rtn += FD + CStr(A.Pressed)
            rtn += FD + A.Selected.ToString
            rtn += FD + A.Text
            rtn += FD + A.ToolTipText
            rtn += FD + A.ToString
            Return rtn
        End Function

        Public Shared Function MyShowControl(CTL As Control, What As HelpProvider) As String
            Const Y As String = Chr(34) & vbTab & Chr(34)
            Dim X As String
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3283, 10, "MyShowControl")
#End If
            X = vbCrLf & "/Control display  "
            X = X & Y & " control parent " & CTL.Parent.Name
            X = X & Y & " control name " & CTL.Name
            X = X & Y & " Help " & What.ToString
            X = X & Y & " Help Name Space " & What.HelpNamespace
            X = X & Y & " Help tag " & What.Tag.ToString
            X = X & Y & " name " & What.GetType.Name
            X = X & Y & " fullname " & What.GetType.FullName
            X = X & Y & " length " & What.GetType.GetEnumNames.Length
            For I = 0 To What.GetType.GetEnumNames.Length - 1 ''What.GetType.GetEnumNames.Count - 1
                X = X & Y & " names Of  " & What.GetType.GetEnumNames(I).ToString
            Next
            X = X & Y & " Namespace " & What.GetType.Namespace
            X = X & Y & " DataType name " & What.GetType.UnderlyingSystemType.Name
            Return X
        End Function


        Public Shared Function MyShowComboBoxItems(ByRef X As ComboBox) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3284, 10, "MyShowComboBoxItems")
#End If
            Return vbTab & X.ToString & vbCrLf
        End Function



        Public Shared Function MyShowDropDownItems(ByRef X As ToolStripDropDownButton) As String
            Dim A As String
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3285, 10, "MyShowDropDownItems")
#End If
            A = ""
            A &= vbTab & "# rows " & X.DropDownItems.Count.ToString
            A &= vbTab & X.GetCurrentParent.Name
            A &= vbTab & X.Name
            A &= vbTab & X.Enabled.ToString
            A &= vbTab & X.Visible.ToString
            A &= vbTab & X.Text
            A = HighLight(A)
            For I = 0 To X.DropDownItems.Count - 1
                A &= vbCrLf & I.ToString & " = " & X.DropDownItems.Item(I).Text & vbTab & X.DropDownItems.Item(I).ToString & vbCrLf
            Next
            Return A
        End Function



        Public Shared Function MyShowUserInfo() As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3286, 10, "MyShowUserInfo")
#End If
            MyShowUserInfo = ””
            MyShowUserInfo &= vbCrLf & " Info_AssemblyName= “ & HighLight(My.Application.Info.AssemblyName)
            MyShowUserInfo &= vbCrLf & " Info_Copyright= “ & HighLight(My.Application.Info.Copyright)
            MyShowUserInfo &= vbCrLf & " Info_Description= “ & HighLight(My.Application.Info.Description)
            MyShowUserInfo &= vbCrLf & " DirectoryPath1= “ & HighLight(My.Application.Info.DirectoryPath)
            MyShowUserInfo &= vbCrLf & " DirectoryPath2= “ & HighLight(Application.UserAppDataPath.ToString())
            MyShowUserInfo &= vbCrLf & " Info_ProductName= “ & HighLight(My.Application.Info.ProductName)
            MyShowUserInfo &= vbCrLf & " Info_Title= “ & HighLight(My.Application.Info.Title)
            MyShowUserInfo &= vbCrLf & " Info_Trademark= “ & HighLight(My.Application.Info.Trademark)
            MyShowUserInfo &= vbCrLf & " Info_Version= “ & HighLight(My.Application.Info.Version.ToString)
            MyShowUserInfo &= vbCrLf & " Info_WorkingSet= “ & HighLight(My.Application.Info.WorkingSet.ToString)
            MyShowUserInfo &= vbCrLf & " FileSystem.SpecialDirectories.AllUsersApplicationData= “ & HighLight(My.Computer.FileSystem.SpecialDirectories.AllUsersApplicationData)
            MyShowUserInfo &= vbCrLf & " UICulture_DisplayName= “ & HighLight(My.Application.UICulture.DisplayName)
            MyShowUserInfo &= vbCrLf & " UICulture_EnglishName= “ & HighLight(My.Application.UICulture.EnglishName)
            MyShowUserInfo &= vbCrLf & " UICulture_Name= “ & HighLight(My.Application.UICulture.Name)
            MyShowUserInfo &= vbCrLf & " UICulture_NativeName= “ & HighLight(My.Application.UICulture.NativeName)
            MyShowUserInfo &= vbCrLf & " UICulture_Parent_Name= “ & HighLight(My.Application.UICulture.Parent.Name)
            MyShowUserInfo &= vbCrLf & " UICulture_TwoLetterISOLanguageName= “ & HighLight(My.Computer.Mouse.WheelExists.ToString)
            MyShowUserInfo &= vbCrLf & " UICulture_ThreeLetterWindowsLanguageName= “ & HighLight(My.Application.UICulture.ThreeLetterWindowsLanguageName)
            MyShowUserInfo &= vbCrLf & " FileSystem_SpecialDirectories_CurrentUserApplicationData= “ & HighLight(My.Computer.FileSystem.SpecialDirectories.CurrentUserApplicationData)
            MyShowUserInfo &= vbCrLf & " FileSystem_SpecialDirectories_CurrentUserApplicationData= “ & HighLight(My.Computer.FileSystem.SpecialDirectories.CurrentUserApplicationData)
            MyShowUserInfo &= vbCrLf & " FileSystem_SpecialDirectories_Desktop= “ & HighLight(My.Computer.FileSystem.SpecialDirectories.Desktop)
            MyShowUserInfo &= vbCrLf & " FileSystem_SpecialDirectories_MyDocuments= “ & HighLight(My.Computer.FileSystem.SpecialDirectories.MyDocuments)
            MyShowUserInfo &= vbCrLf & " FileSystem_SpecialDirectories_ProgramFiles= “ & HighLight(My.Computer.FileSystem.SpecialDirectories.ProgramFiles)
            MyShowUserInfo &= vbCrLf & " FileSystem_SpecialDirectories_Programs= “ & HighLight(My.Computer.FileSystem.SpecialDirectories.Programs)
            MyShowUserInfo &= vbCrLf & " FileSystem_SpecialDirectories_Temp= “ & HighLight(My.Computer.FileSystem.SpecialDirectories.Temp)
            MyShowUserInfo &= vbCrLf & " Info_AvailablePhysicaMemory= “ & HighLight(My.Computer.Info.AvailablePhysicalMemory.ToString)
            MyShowUserInfo &= vbCrLf & " Info_AvailableVirtualMemory= “ & HighLight(My.Computer.Info.AvailableVirtualMemory.ToString)
            MyShowUserInfo &= vbCrLf & " Info_OSFullName= “ & HighLight(My.Computer.Info.OSFullName)
            MyShowUserInfo &= vbCrLf & " Info_OSPlatform= “ & HighLight(My.Computer.Info.OSPlatform)
            MyShowUserInfo &= vbCrLf & " Info_OSVersion= “ & HighLight(My.Computer.Info.OSVersion)
            MyShowUserInfo &= vbCrLf & " Info_TotalPhysicalMemory= “ & HighLight(My.Computer.Info.TotalPhysicalMemory.ToString)
            MyShowUserInfo &= vbCrLf & " Info_TotalVirtualMemory= “ & HighLight(My.Computer.Info.TotalVirtualMemory.ToString)
            MyShowUserInfo &= vbCrLf & " Mouse_WheelScrollLines= “ & HighLight(My.Computer.Mouse.WheelExists.ToString)
            MyShowUserInfo &= vbCrLf & " Mouse_WheelExists= “ & HighLight(My.Computer.Mouse.WheelExists.ToString)
            MyShowUserInfo &= vbCrLf & " Name= “ & HighLight(My.Computer.Name)
            MyShowUserInfo &= vbCrLf & " Network_GetType_FullName= “ & HighLight(My.Computer.Screen.DeviceName)
            MyShowUserInfo &= vbCrLf & " Network_GetType_MemberType= “ & HighLight(My.Computer.Screen.DeviceName)
            MyShowUserInfo &= vbCrLf & " Network_GetType_Namespace= “ & HighLight(My.Computer.Screen.DeviceName)
            MyShowUserInfo &= vbCrLf & " Registry_CurrentUser_Name= “ & HighLight(My.Computer.Registry.CurrentUser.Name)
            MyShowUserInfo &= vbCrLf & " Registry_LocalMachine_Name= “ & HighLight(My.Computer.Registry.LocalMachine.Name)
            MyShowUserInfo &= vbCrLf & " Registry_PerformanceData_Name= “ & HighLight(My.Computer.Registry.PerformanceData.Name)
            MyShowUserInfo &= vbCrLf & " Window_DeviceName= “ & HighLight(My.Computer.Screen.DeviceName)
            MyShowUserInfo &= vbCrLf & " Window_BitsPerPixel= “ & HighLight(My.Computer.Screen.BitsPerPixel.ToString)
            MyShowUserInfo &= vbCrLf & " Window_Bounds_Size_Width= “ & HighLight(My.Computer.Screen.Bounds.Size.Width.ToString)
            MyShowUserInfo &= vbCrLf & " Window_Bounds_Size_Height= “ & HighLight(My.Computer.Screen.WorkingArea.Width.ToString)
            MyShowUserInfo &= vbCrLf & " Window_WorkingArea_Width= “ & HighLight(My.Computer.Screen.WorkingArea.Width.ToString)
            MyShowUserInfo &= vbCrLf & " Window_WorkingArea_Height= “ & HighLight(My.Computer.Screen.WorkingArea.Height.ToString)
            MyShowUserInfo &= vbCrLf & " CurrentPrincipal_Identity_Name= “ & HighLight(My.User.CurrentPrincipal.Identity.Name)
            MyShowUserInfo &= vbCrLf & " CurrentPrincipal_Identity_GetType_FullName= “ & HighLight(My.User.CurrentPrincipal.Identity.GetType.FullName)
            MyShowUserInfo &= vbCrLf & " CurrentPrincipal_Identity_GetType_GUID= “ & HighLight(My.User.CurrentPrincipal.Identity.GetType.GUID.ToString)
            MyShowUserInfo &= vbCrLf & " User_Name= “ & HighLight(My.User.Name)
            MyShowUserInfo &= vbCrLf & " WebServices_GetType_GUID= “ & HighLight(My.WebServices.GetType.GUID.ToString)
            MyShowUserInfo &= vbCrLf & " WebServices_GetType_Assembly_FullName= “ & HighLight(My.WebServices.GetType.Assembly.FullName)
            MyShowUserInfo &= vbCrLf & " WebServices_GetType_Assembly_Location= “ & HighLight(My.WebServices.GetType.Assembly.Location)
            MyShowUserInfo &= vbCrLf & " WebServices_GetType_AssemblyQualifiedName= “ & HighLight(My.WebServices.GetType.AssemblyQualifiedName)
            MyShowUserInfo &= vbCrLf & " WebServices_GetType_Name= “ & HighLight(My.WebServices.GetType.Name)
            MyShowUserInfo &= vbCrLf & " WebServices_GetType_Namespace= “ & HighLight(My.WebServices.GetType.Namespace)
            MyShowUserInfo &= vbCrLf & " WebServices_GetType_UnderlyingSystemType_FullName= “ & HighLight(My.WebServices.GetType.UnderlyingSystemType.FullName)

        End Function

        'Public Shared Function MyShow4(X1 As Int32, Y1 As Int32, X2 As Int32, Y2 As Int32) As String
        ' Return "(" + X1.ToString + ", " + Y1.ToString + ", " + X2.ToString + ", " + Y2.ToString + ")"
        ' End Function

        'Public Shared Function MyShow3Points(XY1 As MyPointStructure, XY2 As MyPointStructure, XY3 As' MyPointStructure) As String
        '        Return " (" & XY1.x & FD & XY1.y & ")" & shl(XY1.Named.PathName) & "" & shl(XY1.Named.SymbolName) & "" & shl(XY1.Named.Pointname) & "" & vbTab & ",(" & XY2.x & FD & XY2.y & ")" & shl(XY2.Named.PathName) & "" & shl(XY2.Named.SymbolName) & "" & shl(XY2.Named.Pointname) & "" & vbTab & ",(" & XY3.x & ", " & XY3.y & ")" & shl(XY3.Named.PathName) & "" & shl(XY3.Named.SymbolName) & "" & shl(XY3.Named.Pointname) & "" & " Distances[ A&B " & MyShowDistance(XY1, XY2) & " A&C " & MyShowDistance(XY1, XY3) & "B&C " & MyShowDistance(XY2, XY3)
        'End Function

        Public Shared Function MyShow4Points(XY1 As MyPointStructure, XY2 As MyPointStructure, XY3 As MyPointStructure, XY4 As MyPointStructure) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3287, 10, "MyShow4Points")
#End If
            Return " (" & XY1.x & FD & XY1.y & ")" &
                vbTab & ",(" & XY2.x & FD & XY2.y & ")" &
                vbTab & ",(" & XY3.x & ", " & XY3.y & ")" &
                vbTab & ",(" & XY4.x & ", " & XY4.y & ")"
        End Function



        Public Shared Function MyShowScale() As String
            Dim X As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3288, 10, "MyShowScale")
#End If
            X = " Scale Min,Is,max ="
            X &= vbTab
            X &= ConstantMinFlowChartScale.ToString
            X &= SHL(MyUniverse.SysGen.MyFlowChartScale.ToString)
            X &= SHL(ConstantMaxFlowChartScale.ToString)
            X &= vbTab & "(TopLine left window)" & MyShowPoint(MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.x, MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.y)
            X &= " Memory[Phy="
            X &= SHL(My.Computer.Info.AvailablePhysicalMemory.ToString())
            X &= " mb  "
            X &= My.Computer.Info.TotalPhysicalMemory.ToString()
            X &= " mb  "
            X &= " VirMem"
            X &= SHL(My.Computer.Info.AvailableVirtualMemory.ToString())
            X &= " mb  "
            X &= My.Computer.Info.TotalVirtualMemory.ToString()
            X &= " mb  "
            X &= vbTab
            X &= " Memory[Phy="
            X &= ((My.Computer.Info.TotalPhysicalMemory / 1000000) - (My.Computer.Info.AvailablePhysicalMemory / 1000000)).ToString
            X &= "]  [VirMem "
            X &= (My.Computer.Info.TotalVirtualMemory / 1000000) - (My.Computer.Info.AvailableVirtualMemory / 1000000)
            X &= "]"

            Return X
        End Function

        Public Shared Function MyShowDistance(XY1 As MyPointStructure, XY2 As MyPointStructure) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3289, 10, "MyShowDistance")
#End If
            Return SHL(CStr(MyABS(XY1.x - XY2.x) + MyABS(XY1.y - XY2.y))) & SHL(XY1.Named.PathName) & "" & SHL(XY1.Named.SymbolName) & "" & SHL(XY1.Named.PointName) & " , " & SHL(XY2.Named.PathName) & "" & SHL(XY2.Named.SymbolName) & "" & SHL(XY2.Named.PointName) & vbCrLf
        End Function


        Public Shared Function MyShow2Lines(a As MyLineStructure, b As MyLineStructure) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3290, 10, "MyShow2Lines")
#End If
            Return SHL(MyShowALine(a)) & vbTab & SHL((MyShowALine(b)))
        End Function
        Public Shared Function MyShow3Lines(a As MyLineStructure, b As MyLineStructure, c As MyLineStructure) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3300, 10, "MyShow3Lines()")
#End If
            Return SHL(MyShowALine(a)) & vbTab & SHL((MyShowALine(b)) & vbTab & SHL(MyShowALine(c)))
        End Function

        Public Shared Function MyShowLineRecord(expanded As Boolean, IndexSymbol As Int32) As String
            Dim RTN As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3301, 10, "MyShowLineRecord")
#End If
            RTN = Symbol_TableCoded_String(IndexSymbol)
            RTN &= " = " & Symbol_TableSymbolName(IndexSymbol)
            RTN &= FD & Symbol_TableX1(IndexSymbol)
            RTN &= FD & Symbol_TableY1(IndexSymbol)
            RTN &= FD & Symbol_Table_X2(IndexSymbol)
            RTN &= FD & Symbol_Table_Y2(IndexSymbol)
            RTN &= FD & Symbol_Table_NameOfPoint(IndexSymbol)
            If expanded = True Then
                RTN &= FD & vbTab & "\index" & IndexSymbol.ToString
                'lines do not have DataType and IO, they have x2 , y2
                'RTN &= FD & Symbol_Table_DataType(IndexSymbol)
                'RTN &= FD & Symbol_Table_InputOutput(IndexSymbol)
            End If
            Return RTN & vbCrLf
        End Function

        Public Shared Function MyShowLineXYXY(X1 As Int32, Y1 As Int32, X2 As Int32, Y2 As Int32) As String
            Return "(" & X1 & FD & Y1 & ")_(" & X2 & FD & Y2 & ")"
        End Function
        Public Shared Function MyShowLineXYXY(XY As MyLineStructure) As String
            Return "(" & XY.a.x & FD & XY.a.y & ")_(" & XY.b.x & FD & XY.b.y & ")"
        End Function
        Public Shared Function MyShowRect(XY As Rectangle) As String
            Return "(" & XY.X & FD & XY.Y & ")_(" & XY.Width & FD & XY.Height & ")"
        End Function



        Public Shared Function MyShowALine(XY As MyLineStructure) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3303, 10, "MyShowALine")
#End If
            Return "(" & XY.a.x & FD & XY.a.y & ")_(" & XY.b.x & FD & XY.b.y & ")"
        End Function


        Public Shared Function MyShowPoint(IndexFlowChart1 As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3304, 10, "MyShowPoint(A)")
#End If
            Return MyShowPoint(MyPoint1XY(FlowChart_TableX1(IndexFlowChart1), FlowChart_TableY1(IndexFlowChart1))) & "-" & MyShowPoint(MyPoint1XY(FlowChart_TableX2(IndexFlowChart1), FlowChart_TableY2(IndexFlowChart1)))
        End Function

        Public Shared Function MyShowPoint(X As Int32, Y As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3305, 10, "MyShowPoint (B)")
#End If
            Return MyShowPoint(MyPoint1XY(X, Y))
        End Function


        Public Shared Function MyShowPoints(X1 As Int32, Y1 As Int32, X2 As Int32, Y2 As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3306, 11, "MyShowPoints")
#End If
            Return "{(" + X1.ToString + ", " + Y1.ToString + ")-(" + X2.ToString + ", " + Y2.ToString + ")}"
        End Function


        Public Shared Function MyShowXY(X As Int32, Y As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3307, 10, "MyShowXY")
#End If
            Return "(" & X & FD & Y & ")"
        End Function

        Public Shared Function MyShowPoint(XY As MyPointStructure) As String
            Dim X As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3308, 10, "MyShowPoint")
#End If
            X = ""
            X &= "("
            X &= XY.x
            X &= FD
            X &= XY.y
            X &= ") "
            If Len(XY.Named.PathName) > 0 Then
                X &= HighLight(XY.Named.PathName)
            End If
            If Len(XY.Named.SymbolName) > 0 Then
                X &= "|"
                X &= HighLight(XY.Named.SymbolName)
            End If
            If Len(XY.Named.PointName) > 0 Then
                X &= "|"
                X &= HighLight(XY.Named.PointName)
            End If
            Return X
        End Function

        Public Shared Function MyShowAllNet(IndexNetLinks As Int32) As String
            Dim I As Int32
            Dim X As String
            Dim A As String
            Dim Del As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3309, 10, "MyShowAllNets")
#End If
            Del = ""
            A = "["
            X = Net_TableLinks(IndexNetLinks)
            Do
                X = NoFD(X)
                I = PopNonZeroValue(X)
                If InStr(FD & FlowChart_TablePath_Name(I) & FD, A) = 0 Then
                    If InStr(A, FD & FlowChart_TablePath_Name(I) & FD) = 0 Then
                        A &= Del & FlowChart_TablePath_Name(I)
                    End If
                Else
                    If MyDebug(9) Then follow(2192, 10, "773 widdle down = " & I.ToString & vbTab & A & vbTab & FlowChart_TablePath_Name(I))
                    MSG_AInfo1(1656, "Same Name ", X & " & ", A & HighLight(FlowChart_TablePath_Name(I)))
                End If
                Del = FD
            Loop While Len(X) > 0
            Return A & "]"
        End Function





        Public Shared Function MyShowNetLnks(IndexNetLink As Int32) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3310, 10, "MyShowNetLinks")
#End If
            If InvalidIndex(IndexNetLink, Net_FileLinks) = True Then
                Return HighLight("Nothing @ " & IndexNetLink.ToString)
            End If
            Return vbTab & " #" & IndexNetLink & Spaced(24, Net_TableNames(IndexNetLink)) & vbTab & vbTab & "paths : " & Net_TableLinks(IndexNetLink)
        End Function



        Public Shared Function MyShowkeyWord(Switch As String, KeyWord As String) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3311, 10, "MyShowKeyWord")
#End If
            Return Switch & "=" & KeyWord
        End Function

        Public Shared Function MakeStatementReplacements(CodeLine As String) As String
            Dim LocalIndex As Int32
            Dim A As String
            Dim myarray() As String
            ReDim myarray(256)
#If MINEDEBUG Then
  if mydebug(9) then follow(3312, 10, "MakeStatementReplacements")
#End If
            MakeStatementReplacements = ""
            ' LocalIndex might be counting twice and missing Syntax
            LocalIndex = 1
            MyUniverse.MyStaticData.Path_Names = MyParse(myarray, CodeLine)
            MyUniverse.MyStaticData.Path_NamesCounted = CountPathNames(MyUniverse.MyStaticData.Path_Names)
            'A = MyUniverse.MyStaticData.PathNames
            While PrintAbleNull(myarray(LocalIndex)) <> "_"
                A = myarray(LocalIndex)
                Select Case LCase(No_FieldDelimiter(IsThisAWhat(A)))
                    Case MyUniverse.ProgramOptions.FCCL_MultiLine
                    Case MyUniverse.ProgramOptions.FCCL_Comment
                    Case MyUniverse.ProgramOptions.FCCL_Extensions
                    Case MyUniverse.ProgramOptions.FCCL_VarChars
                    Case MyUniverse.SysGen.Constants.SyntaxCameFromLine
                        MakeStatementReplacements = Trim(MakeStatementReplacements & MyUniverse.ProgramOptions.FCCL_Comment & A)
                    Case MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine
                        MakeStatementReplacements = Trim(MakeStatementReplacements & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.ProgramOptions.FCCL_Comment & A)
                    Case MyUniverse.SysGen.Constants.SyntaxComments 'Ignore the rest of the line
                        MakeStatementReplacements = Trim(MakeStatementReplacements & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.ProgramOptions.FCCL_Comment & A)' Just add a comment
                    Case MyUniverse.SysGen.Constants.SyntaxQuotes
                        ' Save The First Quote
                        MakeStatementReplacements = Trim(MakeStatementReplacements & MyUniverse.ProgramOptions.FCCL_WhiteSpace & A) ' This should be Quote Marks
                    Case MyUniverse.SysGen.Constants.SyntaxKeyWords, MyUniverse.SysGen.Constants.SyntaxFunctions, MyUniverse.SysGen.Constants.SyntaxOperators
                        MakeStatementReplacements = Trim(MakeStatementReplacements & MyUniverse.ProgramOptions.FCCL_WhiteSpace & A) & MyUniverse.ProgramOptions.FCCL_WhiteSpace' put space around any keyword
                    Case MyUniverse.SysGen.Constants.SyntaxAlphas
                        MakeStatementReplacements = Trim(MakeStatementReplacements & MyUniverse.ProgramOptions.FCCL_WhiteSpace & AddRM(A & ".value"))
                    Case MyUniverse.SysGen.Constants.SyntaxNumbers
                        MakeStatementReplacements = Trim(MakeStatementReplacements & MyUniverse.ProgramOptions.FCCL_WhiteSpace & AddRM(A & ".value")) & MyUniverse.ProgramOptions.FCCL_WhiteSpace
                    Case MyUniverse.SysGen.Constants.SyntaxSpecialCharacters
                        MakeStatementReplacements = Trim(MakeStatementReplacements & MyUniverse.ProgramOptions.FCCL_WhiteSpace & A) & MyUniverse.ProgramOptions.FCCL_WhiteSpace
        'Case MyUniverse.SysGen.Constants.SyntaxVariables
        'MakeStatementReplacements = Trim(MakeStatementReplacements & MyUniverse.ProgramOptions.FCCL_WhiteSpace & AddRM(A & ".name")) & MyUniverse.ProgramOptions.FCCL_WhiteSpace
                    Case MyUniverse.SysGen.Constants.SyntaxUnknowns
                        MSG_ABug(1660, "unknown Character Classification", A, IsThisAWhat(A))
                        MakeStatementReplacements = Trim(MakeStatementReplacements & A)
                    Case Else
                        MakeStatementReplacements = Trim(MakeStatementReplacements & MyUniverse.ProgramOptions.FCCL_WhiteSpace & AddRM(A & ".name")) & MyUniverse.ProgramOptions.FCCL_WhiteSpace
                        MSG_ABug(1661, "program issue", "Did Not take care Of a IsThisAWhat", IsThisAWhat(A))
                        MakeStatementReplacements = Trim(MakeStatementReplacements & MyUniverse.ProgramOptions.FCCL_WhiteSpace & A) & MyUniverse.ProgramOptions.FCCL_WhiteSpace
                End Select
                ' I need to explain why I did this and am missing a null field?
                LocalIndex += 1
            End While
            If MyRight(MakeStatementReplacements, Len(FD)) <> FD Then
                MakeStatementReplacements &= FD
            End If
        End Function



        Public Shared Function MakeStatementSyntax(MyArray() As String) As String
            Dim LocalIndex As Int32
            Dim A1, B1 As String
            Dim DeLimit As String
            Dim WS As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3313, 10, "MakeStatementSyntax")
#End If
            'todo need to add white space between each 'atom' of the code line output
            WS = MyLeft(MyUniverse.SysGen.Constants.ConstantWhiteSpaces, 1)
            MakeStatementSyntax = WS
            ' LocalIndex might be counting twice and missing Syntax
            DeLimit = "" ' Do not start with a comma(or what ever the field delimiter is right now
            LocalIndex = 1
            While PrintAbleNull(MyArray(LocalIndex)) <> "_"
                A1 = MyArray(LocalIndex)
                B1 = LCase(IsThisAWhat(A1))
                Select Case B1
                    Case MyUniverse.ProgramOptions.FCCL_MultiLine
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.ProgramOptions.FCCL_MultiLine) & WS
                    Case MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine & FD & MakePathName(MyArray(LocalIndex + 1))) & WS 'HACK making it a code keyword Go_To, hope the computer language has that as a keyword!!!!!!!
                        LocalIndex += 1
                    Case MyUniverse.SysGen.Constants.SyntaxCameFromLine
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Constants.SyntaxCameFromLine & FD & MakePathName(MyArray(LocalIndex + 1)) & "") & WS
                        LocalIndex += 1
                    Case MyUniverse.ProgramOptions.FCCL_Comment
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.ProgramOptions.FCCL_Comment) & WS
                    Case MyUniverse.ProgramOptions.FCCL_Extensions
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & ThisExtension(MyUniverse.ProgramOptions.FCCL_Extension, 1)) & WS
                    Case MyUniverse.ProgramOptions.FCCL_VarChars 'todo Not so sure about this!!!!!!! ' Possible error
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine) & WS
                    Case MyUniverse.SysGen.Constants.SyntaxComments 'Ignore the rest of the line
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Constants.SyntaxComments) & WS
                    Case MyUniverse.SysGen.Constants.SyntaxQuotes
                        ' Save The First Quote
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Constants.SyntaxQuotes) & WS
                    Case MyUniverse.SysGen.Constants.SyntaxKeyWords
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & A1) & WS
                        FMB(3539, MakeStatementSyntax)
                    Case MyUniverse.SysGen.Constants.SyntaxOperators
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Constants.SyntaxOperators) & WS
                    Case MyUniverse.SysGen.Constants.SyntaxFunctions
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Constants.SyntaxFunctions) & WS
                    Case MyUniverse.SysGen.Constants.SyntaxSpecialCharacters
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & B1) & WS
                    Case MyUniverse.SysGen.Constants.SyntaxNumbers
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Constants.SyntaxNumbers) & WS
        ''''''''Case MyUniverse.SysGen.Constants.SyntaxVariables
        ''''''''MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Constants.SyntaxVariables)
                    Case MyUniverse.SysGen.Constants.SyntaxAlphas
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Constants.SyntaxAlphas) & WS
                    Case MyUniverse.SysGen.Constants.SyntaxAlphaNumeric
                        'todo THis needs to be changed to be {[(VariableName.PATH)]}
                        'MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Constants.SyntaxVariables)
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MakePathName(A1)) & WS
                    Case MyUniverse.SysGen.Constants.SyntaxFieldDelimiters 'do nothing
                        MakeStatementSyntax = Trim(MakeStatementSyntax) & WS
                    Case MyUniverse.SysGen.Constants.SyntaxUnknowns
                        MSG_ABug(1662, "unknown Character Classification", A1 & "=" & IsThisAWhat(A1), MyUniverse.SysGen.Constants.SyntaxUnknowns)
                        MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Constants.SyntaxUnknowns & A1) & WS
                    Case Else ' This is a variable period pointAttribute
                        If InStr(A1, ".") <> 0 Then
                            If InStr(A1, MyUniverse.SysGen.Constants.RMStart) > 0 Then
                                If InStr(A1, MyUniverse.SysGen.Constants.RMEnd) > 0 Then
                                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MakePathName(A1)) & WS
                                    FMB(3540, MakeStatementSyntax)
                                Else
                                    MSG_ABug(1663, "Variable Is missing the End marker " & MyUniverse.SysGen.Constants.RMEnd, " But has the first marker " & MyUniverse.SysGen.Constants.RMStart, " And has the period")
                                End If
                            Else
                                MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & A1) & WS
                            End If
                        Else
                            MSG_ABug(1665, "Unknow what this Is", HighLight(A1), HighLight(IsThisAWhat(A1)))
                        End If
                End Select
                ' I need to explain why I did this and am missing a null field?
                'While MyRight(MakeStatementSyntax, 2) = DeLimit & DeLimit
                ' MakeStatementSyntax = MyLeft(MakeStatementSyntax, Len(MakeStatementSyntax) - 1)
                ' End While
                ' While MyLeft(MakeStatementSyntax, 1) = DeLimit
                ' MakeStatementSyntax = Mid(MakeStatementSyntax, 2, Len(MakeStatementSyntax))
                ' End While
                LocalIndex += 1
                DeLimit = FD ' Now make everything seperated witha Field DeLimiteter
            End While
            If MyRight(MakeStatementSyntax, Len(FD)) <> FD Then
                MakeStatementSyntax &= FD
            End If
            DisplayMyStatus(3, "Syntax made " & MakeStatementSyntax)
            FMB(3541, MakeStatementSyntax)
            'Check that the Symbol matches the Syntax, matches the point names, matches the rest
        End Function


        Public Shared Function FindSymbolSyntax(Keyline As String) As Int32 ' This will return the Named_File(index) of the matching Syntax
            Dim Syntax As String
            'todo need to add to make a Symbol from the /Grammar if no syntax found
#If MINEDEBUG Then
  if mydebug(9) then follow(3314, 10, "FindSymbolSyntax")
#End If
            Syntax = Keyline
            MyUniverse.MyStaticData.Path_Names = MyParse(MyUniverse.MyStaticData.My_Syntax_Line_Parsed, Syntax)
            FMB(3542, MyUniverse.MyStaticData.Path_Names)
            MyUniverse.MyStaticData.Path_NamesCounted = CountPathNames(MyUniverse.MyStaticData.Path_Names)
            Syntax = MakeStatementSyntax(MyUniverse.MyStaticData.My_Syntax_Line_Parsed)
            FindSymbolSyntax = TopOfFile("named")
            While FindSymbolSyntax > 0
                If Syntax = Named_TableSyntax(FindSymbolSyntax) Then
                    If mydebug(9) Then follow(2884, 3, "Found matching syntax " & Syntax & vbTab & FindSymbolSyntax & Named_TableSyntax(FindSymbolSyntax))
                    Exit Function
                End If
                FindSymbolSyntax -= 1
            End While
            FindSymbolSyntax = 1
            If MyDebug(10) Then follow(2894, 10, "Find Grammar " & FindGrammarFromCode(Keyline, FindSymbolSyntax))
            FindSymbolSyntax = ConstantMyErrorCode
        End Function

        Public Shared Function MyCompareSyntax() As String
            Dim ParsedItem, MyErrors As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3315, 10, "MyCompareSyntax")
#End If
            MyErrors = 1024
            ' for now stupid comparison test
            ParsedItem = 0
            MyCompareSyntax = "equal"

            While MyErrors > 1
                Select Case LCase(No_FieldDelimiter(IsThisAWhat(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(ParsedItem))))
                    Case MyUniverse.ProgramOptions.FCCL_Comment
                    Case MyUniverse.ProgramOptions.FCCL_Extensions
                    Case MyUniverse.ProgramOptions.FCCL_MultiLine
                    Case MyUniverse.ProgramOptions.FCCL_VarChars
                    Case MyUniverse.SysGen.Constants.SyntaxCameFromLine
                        If Not IsThisACameFromLine(MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                            MyCompareSyntax = "notequal"
                            Exit Function
                        End If
                    Case MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine
                        If Not IsThisAGo_ToNextLine(MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                            MyCompareSyntax = "notequal"
                            Exit Function
                        End If
                    Case MyUniverse.SysGen.Constants.SyntaxComments ' The rest is all comment 
                        If Not IsThisAComment(MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                            MyCompareSyntax = "notequal"
                            Exit Function
                        End If
                    Case MyUniverse.SysGen.Constants.SyntaxKeyWords, MyUniverse.SysGen.Constants.SyntaxFunctions, MyUniverse.SysGen.Constants.SyntaxOperators 'must match exactly
                        Select Case MyCompareSyntax_S(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(ParsedItem), MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem))
                            Case "equal"
                                MyCompareSyntax = "notequal"
                                Exit Function
                            Case "notequal"
                        End Select
                    Case MyUniverse.SysGen.Constants.SyntaxSpecialCharacters 'must match exactly
                        Select Case MyCompareSyntax_S(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(ParsedItem), MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem))
                            Case "notequal"
                                MyCompareSyntax = "notequal"
                                Exit Function
                            Case "equal"
                        End Select
        'Case MyUniverse.SysGen.Constants.SyntaxVariables
        '    If Not IsThisAVariableName(MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
        '    MyCompareSyntax = "notequal"
        '    Exit Function
    '    End If
                    Case MyUniverse.SysGen.Constants.SyntaxQuotes
                        If Not IsThisAQuote(MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                            MyCompareSyntax = "notequal"
                            Exit Function
                        End If
                    Case MyUniverse.SysGen.Constants.SyntaxAlphas
                        If Not IsThisAnAlpha(MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                            MyCompareSyntax = "notequal"
                            Exit Function
                        End If
                    Case MyUniverse.SysGen.Constants.SyntaxNumbers
                        If Not IsThisANumber(MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                            MyCompareSyntax = "notequal"
                            Exit Function
                        End If
                    Case Nothing ' ran out of Syntax to compare to
                        MyCompareSyntax = "notequal"
                        Exit Function
                    Case MyUniverse.SysGen.Constants.SyntaxUnknowns ' DoNot know what it is but it is not a good suntax
                        'If MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                        MyCompareSyntax = "notequal"
                        Exit Function
                        'End If
                    Case Else
                        If IsThisAVariableName(MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                            MyCompareSyntax = "notequal"
                            Exit Function
                        End If

                End Select
                ParsedItem += 1
            End While
        End Function

        Public Shared Sub MakeUseANDPath(Code_Line As String, SymbolName As String, IndexSymbol As Int32, PathName As String)
            Dim LocalIndex, FCKounter, IndexFlowChart As Int32
            Dim x1, y1 As Int32
            ' Dim D As Int32
            Dim TempXY As MyPointStructure
            Dim NumberOfPoints As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3316, 1, "MakeUseANDPath  " & vbTab & SymbolName & vbTab & PathName & vbTab & Code_Line)
#End If
            If Len(SymbolName) < 2 Then
                SymbolName = MakeNewName("Copy3" & Symbol_TableSymbolName(IndexSymbol), SymbolName)
            End If
            If Len(PathName) < 3 Then
                PathName = MakePathName("V_3_" & MyRight(MyRnd(), 6)) & FD
            End If

            NumberOfPoints = 1
            'x1 = MyUniverse.MySymbolPoints(NumberOfPoints).X ' This should be from the Symbol !
            '?y1 = MyUniverse.MySymbolPoints(NumberOfPoints).Y

            '?LocalIndex = 
            FMB(5056)
            AddFlowChartRecordUse(SymbolName, My_keyWord(My_KeyConstUse), MyUniverse.SysGen.Placement.x, MyUniverse.SysGen.Placement.y, "Default", "") 'no DataType, no links
            FMB(5057)
            FCKounter = TopOfFile("FlowChart") - 1
            LocalIndex = 1
            While PrintAbleNull(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex)) <> "_"
                'FindingMyBugs(50) 'hack Least amount of checking here
                Select Case LCase(No_FieldDelimiter(IsThisAWhat(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex))))
                    Case MyUniverse.ProgramOptions.FCCL_MultiLine
        'MSG_AInfo1(1670, IsThisAWhat(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex)) & " Is ignored", LocalIndex, MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex))
                    Case MyUniverse.SysGen.Constants.SyntaxCameFromLine
                    Case MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine
                    Case MyUniverse.ProgramOptions.FCCL_Comment
                        MSG_AInfo1(1671, IsThisAWhat(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex)) & " Is ignored", LocalIndex, MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex))
                    Case MyUniverse.ProgramOptions.FCCL_Extensions
        'MSG_AInfo1(1672, IsThisAWhat(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex)) & " Is ignored", LocalIndex, MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex))
                    Case MyUniverse.ProgramOptions.FCCL_VarChars
        'MSG_AInfo1(1673, IsThisAWhat(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex)) & " Is ignored", LocalIndex, MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex))
                    Case MyUniverse.SysGen.Constants.SyntaxComments
                        MSG_AInfo1(1674, IsThisAWhat(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex)) & " Is ignored", LocalIndex, MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex))
                    Case MyUniverse.SysGen.Constants.SyntaxKeyWords, MyUniverse.SysGen.Constants.SyntaxFunctions, MyUniverse.SysGen.Constants.SyntaxOperators
        'MSG_AInfo1(1675, IsThisAWhat(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex)) & " Is ignored", LocalIndex, MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex))
                    Case MyUniverse.SysGen.Constants.SyntaxQuotes
        'MSG_AInfo1(1676, IsThisAWhat(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex)) & " Is ignored", LocalIndex, MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex))
                    Case MyUniverse.SysGen.Constants.SyntaxAlphas, MyUniverse.SysGen.Constants.SyntaxNumbers
                        x1 = MyUniverse.MySymbolPoints(NumberOfPoints).x
                        y1 = MyUniverse.MySymbolPoints(NumberOfPoints).y
                        TempXY = OtherEndOfNewMadePath(MyUniverse.SysGen.Placement.x, MyUniverse.SysGen.Placement.y, x1, y1, PathName)
                        NumberOfPoints += 1
                        'FindingMyBugs(30) 'hack Least amount of checking here

                        ' Need to have the line point away from the center of the Symbol, not at the center (usex1,usey1) 2020 08 17  "Errored" DataType, since we do not know it yet
                        IndexFlowChart = AddNEWFlowChartRecordPath(My_VariableName(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex), LocalIndex), "/Path", TempXY.x, TempXY.y, CInt(MyUniverse.SysGen.Placement.x + x1), CInt(MyUniverse.SysGen.Placement.y + y1), "errored") ', LineNumber


                        IndexFlowChart = AddNEWFlowChartRecordPath(My_VariableName(Code_Line, LocalIndex), "/Path", TempXY.x, TempXY.y, CInt(MyUniverse.SysGen.Placement.x + x1), CInt(MyUniverse.SysGen.Placement.y + y1), "errored") ', LineNumber
                        MyShowAndUpDateProperties(IndexFlowChart) ', LineNumber, Net_TableNames(FindIndex_In_TableNetLinks(IndexFlowChart)))

                        ConnectPath(IndexFlowChart)
                        FindingMyBugs(30) 'hack Least amount of checking here
                        MyPlacement(False)
                    Case MyUniverse.SysGen.Constants.SyntaxSpecialCharacters
                        MSG_AInfo(1677, "Ignore syntax special characters ", "a", "")
                    Case MyUniverse.SysGen.Constants.SyntaxFieldDelimiters
                        MSG_AInfo(1678, "Ignore syntax field delimiters", "b", "")
                    Case Nothing
                        MSG_AInfo(1679, "Ignore nothing", "c", "")
                    Case MyUniverse.SysGen.Constants.SyntaxUnknowns
                        MSG_AInfo(1680, "Ignore unknown syntax ", "d", "")
                    Case Else
                        If MyLeft(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex), Len(MyUniverse.SysGen.Constants.RMStart)) = MyUniverse.SysGen.Constants.RMStart Then
                            If InStr(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex), MyUniverse.SysGen.Constants.RMEnd) > 0 Then
                                If InStr(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex), ".") < InStr(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex), MyUniverse.SysGen.Constants.RMEnd) Then
                                    Return 'Left(myCodeLine, InStr(myCodeLine, MyUniverse.SysGen.Constants.RMEnd))
                                End If
                            End If
                            x1 = MyUniverse.MySymbolPoints(NumberOfPoints).x
                            y1 = MyUniverse.MySymbolPoints(NumberOfPoints).y
                            TempXY = OtherEndOfNewMadePath(MyUniverse.SysGen.Placement.x, MyUniverse.SysGen.Placement.y, x1, y1, PathName)
                            NumberOfPoints += 1
                            'FindingMyBugs(30) 'hack Least amount of checking here

                            ' Need to have the line point away from the center of the Symbol, not at the center (usex1,usey1) 2020 08 17  "Errored" DataType, since we do not know it yet


                            IndexFlowChart = AddNEWFlowChartRecordPath(My_VariableName(MyUniverse.MyStaticData.My_Code_Line_Parsed(LocalIndex), LocalIndex), "/Path", TempXY.x, TempXY.y, CInt(MyUniverse.SysGen.Placement.x + x1), CInt(MyUniverse.SysGen.Placement.y + y1), "errored") ', LineNumber
                            IndexFlowChart = AddNEWFlowChartRecordPath(My_VariableName(Code_Line, LocalIndex), "/Path", TempXY.x, TempXY.y, CInt(MyUniverse.SysGen.Placement.x + x1), CInt(MyUniverse.SysGen.Placement.y + y1), "errored") ', LineNumber
                            MyShowAndUpDateProperties(IndexFlowChart) ', LineNumber, Net_TableNames(FindIndex_In_TableNetLinks(IndexFlowChart)))

                            ConnectPath(IndexFlowChart)
                            FindingMyBugs(30) 'hack Least amount of checking here
                            MyPlacement(False)
                        End If
                End Select
                LocalIndex += 1
            End While
            Return 'ConstantMyErrorCode
        End Sub

        Public Shared Function CreateFileNameFromSyntax(SyntaxLine As String) As String
            Dim X, Y As String
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3317, 10, "CreateFileNameFromSyntax")
#End If
            Y = ""
            X = SyntaxLine
            CreateFileNameFromSyntax = ""
            While Len(X) > 0
                X = MyTrim(X)
                Select Case LCase(IsThisAWhat(X))
                    Case MyUniverse.SysGen.Constants.SyntaxFieldDelimiters
                        X = Mid(X, Len(FD) + 1, Len(X))
                    Case MyUniverse.ProgramOptions.FCCL_MultiLine
                        Pop1(X, FD)
                        CreateFileNameFromSyntax &= "a"
                    Case MyUniverse.SysGen.Constants.SyntaxCameFromLine
                        CreateFileNameFromSyntax &= "g"
                        Pop1(X, FD)
                    Case MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine
                        CreateFileNameFromSyntax &= "c"
                        Pop1(X, FD)
                    Case MyUniverse.ProgramOptions.FCCL_Comment
                        CreateFileNameFromSyntax &= "r"
                        Pop1(X, FD)
                    Case MyUniverse.ProgramOptions.FCCL_Extensions
                        Y = Pop(X, FD) ' Save the extension till last
                        CreateFileNameFromSyntax &= "e"
                    Case MyUniverse.ProgramOptions.FCCL_VarChars
                        CreateFileNameFromSyntax &= Pop1(X, FD)
                    Case MyUniverse.SysGen.Constants.SyntaxComments 'Ignore the rest of the line
                        CreateFileNameFromSyntax &= "h"
                        PopLine(X)
                    Case MyUniverse.SysGen.Constants.SyntaxQuotes
                        'CreateFileNameFromSyntax &=
                        PopQuote(X) 'Throw quote away???
                        CreateFileNameFromSyntax &= "q"
                    Case MyUniverse.SysGen.Constants.SyntaxKeyWords

                        CreateFileNameFromSyntax &= Pop(X, FD)'Save the actual keyword...
                    Case MyUniverse.SysGen.Constants.SyntaxFunctions
                        CreateFileNameFromSyntax &= "f"
                        Pop(X, FD)
                    Case MyUniverse.SysGen.Constants.SyntaxOperators
                        CreateFileNameFromSyntax &= "o"
                        Pop(X, FD)'Save the actual keyword...
                    Case MyUniverse.SysGen.Constants.SyntaxAlphas
                        CreateFileNameFromSyntax &= "l"
                        Pop1(X, FD)'should be a variable name
                    Case MyUniverse.SysGen.Constants.SyntaxNumbers
                        Pop(X, FD) 'treated as a variable name
                        CreateFileNameFromSyntax &= "3"
                    Case MyUniverse.SysGen.Constants.SyntaxSpecialCharacters
                        Pop(X, FD)
                        CreateFileNameFromSyntax &= "_"
        'Case MyUniverse.SysGen.Constants.SyntaxVariables
        '    CreateFileNameFromSyntax &= "V"
    '    Pop1(X, FD)
                    Case MyUniverse.SysGen.Constants.SyntaxUnknowns
                        CreateFileNameFromSyntax &= "_"
                        Pop(X, FD)
                    Case Else
                        If IsThisAVariableName(No_FieldDelimiter(IsThisAWhat(X))) = True Then
                            CreateFileNameFromSyntax &= "V"
                        Else
                            CreateFileNameFromSyntax &= IsThisAWhat(X)
                        End If
                        Pop1(X, FD)
                End Select
            End While

            ' re-moved any special characters from the file name
            For I = 1 To Len(CreateFileNameFromSyntax)
                While IsThisASpecalCharacter(Mid(CreateFileNameFromSyntax, I, 1)) And PrintAbleNull(Mid(CreateFileNameFromSyntax, I, 1)) <> "_"
                    CreateFileNameFromSyntax = Mid(CreateFileNameFromSyntax, 1, I - 1) & Mid(CreateFileNameFromSyntax, I + 1, Len(CreateFileNameFromSyntax))
                    '2020 0907    mid(CreateFileNameFromSyntax, I, 1) = "_" ' Over ride any left over special characters with an underscore
                End While
            Next
            If CreateFileNameFromSyntax = "" Or MyIsNothing(CreateFileNameFromSyntax) Then
                CreateFileNameFromSyntax = MakeNewName("FileName_", SyntaxLine) & ".Symbol"
            Else
                'need to know if it will become a Symbol or will become program code
                If Y = "" Then
                    CreateFileNameFromSyntax &= ".Symbol"
                Else
                    CreateFileNameFromSyntax &= "." & Y
                End If
            End If
        End Function

        Public Shared Sub MakeSymbolOutline(MySymbolName As String)
            Dim MyColorName As String
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3318, 10, "MakeSymbolOutline")
#End If
            GetSelfCorrectingIndexes(MySymbolName)
            I = MyUniverse.SysGen.Constants.ConstantSymbolCenter
            MyColorName = Color_FileName(MyMinMax(TopOfFile("Symbol") Mod TopOfFile("Color"), 1, TopOfFile("Color")))
            AddNEWSymbolLineRecord(MySymbolName, "/Line", I, I, I, -I, MyColorName)
            MyColorName = Color_FileName(MyMinMax(TopOfFile("Symbol") Mod TopOfFile("Color"), 1, TopOfFile("Color")))
            AddNEWSymbolLineRecord(MySymbolName, "/Line", I, -I, -I, -I, MyColorName)
            MyColorName = Color_FileName(MyMinMax(TopOfFile("Symbol") Mod TopOfFile("Color"), 1, TopOfFile("Color")))
            AddNEWSymbolLineRecord(MySymbolName, "/Line", -I, -I, I, -I, MyColorName)
            MyColorName = Color_FileName(MyMinMax(TopOfFile("Symbol") Mod TopOfFile("Color"), 1, TopOfFile("Color")))
            AddNEWSymbolLineRecord(MySymbolName, "/Line", I, -I, I, I, MyColorName)
            MyColorName = Color_FileName(MyMinMax(TopOfFile("Symbol") Mod TopOfFile("Color"), 1, TopOfFile("Color")))

            AddNEWSymbolLineRecord(MySymbolName, "/Line", I, I, -I, -I, MyColorName)
            MyColorName = Color_FileName(MyMinMax(TopOfFile("Symbol") Mod TopOfFile("Color"), 1, TopOfFile("Color")))
            AddNEWSymbolLineRecord(MySymbolName, "/Line", -I, I, I, -I, MyColorName)

        End Sub


        Public Shared Function MakeSymbolFromSyntax(CodeLine As String) As Int32
            Dim IndexSymbol, IndexFlowChart, IndexNamed As Int32 ', SavedSymbolIndex 
            Dim MySymbolName As String
            Dim SyntaxLine As String
            'Dim PathName As String
            Dim I, x1, y1 As Int32
            ' Dim D As Int32
            Dim TempXY As MyPointStructure
            Dim PointCount As Int32
            Dim PointsCounted As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3319, 10, "MakeSymbolFromSyntax")
#End If
            If mydebug(9) Then follow(3319, 1, "MakeSymbolFromSyntax")
            If CodeLine = "" Then Return ConstantMyErrorCode

            '?MakeSymbolFromSyntax = 0 ' named index

            MyParse(MyUniverse.MyStaticData.My_Syntax_Line_Parsed, CodeLine)
            PointsCounted = CountPathNames(MyUniverse.MyStaticData.Path_Names)

            FindingMyBugs(20) 'hack Least amount of checking here

            SyntaxLine = MicroCodeText2Syntax(MyUniverse.MyStaticData.My_Syntax_Line_Parsed, CodeLine)

            MySymbolName = Trim(MakeNewName("S_", CodeLine)) '& keyWordForCodeLine(CodeLine)

            ' 2020 08 06 added to make a named record first
            AddNewNamedRecord(MySymbolName, CodeLine, "nop", "Made With DeCompile", CreateFileNameFromSyntax(SyntaxLine), "FlowChart Decompile", ".01", "", SyntaxLine) ', MyUniverse.ProgramOptions.FCCL_LanguageClassName
            For I = 1 To PointsCounted
                AddNEWSymbolpointRecord(MySymbolName, "/Name", 0, 0, MyUniverse.ProgramOptions.SelectedInputOutput, MyUniverse.ProgramOptions.SelectedDataType, My_VariableName(CodeLine, I))
            Next I

            'FindingMyBugs(70) 'hack Least amount of checking here
            ' removed not needed ?IndexSymbol = FindInSymbolList(MySymbolName)
            'not used? x1 = MyUniverse.MySymbolPoints(PointCount).X
            'not used? y1 = MyUniverse.MySymbolPoints(PointCount).Y
            FMB(5058)
            IndexFlowChart = AddFlowChartRecordUse(MySymbolName, My_keyWord(My_KeyConstUse), MyUniverse.SysGen.Placement.x, MyUniverse.SysGen.Placement.y, "Default", "errored")
            FMB(5059)
            'FindingMyBugs(70) 'hack Least amount of checking here

            MyUniverse.MyStaticData.Path_Names = MyParse(MyUniverse.MyStaticData.My_Code_Line_Parsed, CodeLine)
            MyUniverse.MyStaticData.Path_NamesCounted = CountPathNames(MyUniverse.MyStaticData.Path_Names)
            SyntaxLine = MakeStatementSyntax(MyUniverse.MyStaticData.My_Syntax_Line_Parsed)

            ' This should decompile a line of code, add a Symbol, and lines and a syntax for it.
            'LocalIndex = TopOfFile("Symbol") + 1
            'FindingMyBugs ( 9 0) 'hack Least amount of checking here
            IndexSymbol = FindInSymbolList(MySymbolName) ' Should Never Happen
            'FindingMyBugs(70) 'hack Least amount of checking here
            'MyMsgCtr(1010, "MakeSymbolFromSyntax", MakeStatementReplacements(CodeLine), CodeLine, MySymbolName, My_VariableName(CodeLine, NumberOfPoints), IndexSymbol.ToString, IndexNamed.ToString, "", "", "")
            If IndexSymbol < 1 Then
                'FindingMyBugs(10) 'hack Least amount of checking here
                '?IndexSymbol = NewTopOfFile("Symbol") '20200629 ' extra?
                AddNEWSymbolpointRecord(MySymbolName, "/name", 0, 0, MyUniverse.ProgramOptions.SelectedInputOutput, MyUniverse.ProgramOptions.SelectedDataType, "") 'SyntaxLine) No Options for now ' This is adding a /name that should have already been added.
                IndexSymbol = FindInSymbolList(MySymbolName) ' Should Never Happen
            Else
                ' Should not happen, but why are we adding a name record, when we just found a name record?
                'FindingMyBugs ( 9  9) 'hack Least amount of checking here ' Add a bug test for Symbol with out a named record
            End If
            'SavedSymbolIndex = IndexSymbol
            PointCount = 0
            I = 1
            PointCount = MyMinMax(PointCount, 0, MyUniverse.MyStaticData.Path_NamesCounted)
            While I < UBound(MyUniverse.MyStaticData.My_Syntax_Line_Parsed)
                FMB(5060)
                '2020 07 28 change ifthenelse to selectcase
                Select Case IsThisAWhat(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I))
                    Case MyUniverse.SysGen.Constants.SyntaxQuotes, MyUniverse.SysGen.Constants.SyntaxAlphas, MyUniverse.SysGen.Constants.SyntaxNumbers, MyUniverse.SysGen.Constants.SyntaxUnknowns, MyUniverse.SysGen.Constants.SyntaxCameFromLine, MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine
                        PointCount = MyMinMax(PointCount + 1, 0, MyUniverse.MyStaticData.Path_NamesCounted)
                        'todo the point count gets to high right here.
                        IndexSymbol += 1
                        If PointCount > UBound(MyUniverse.MySymbolPoints) Then
                            MSG_ABug(1684, "More than 121 points in the syntax, no where else to place pooints", CodeLine, "")
                            Exit While
                        End If
                        PointCount = MyMinMax(PointCount + 1, 0, MyUniverse.MyStaticData.Path_NamesCounted)
                        x1 = MyUniverse.MySymbolPoints(PointCount).x
                        y1 = MyUniverse.MySymbolPoints(PointCount).y
                        AddNEWSymbolpointRecord(MySymbolName, "/Point", x1, y1, "both", "errored", My_VariableName(CodeLine, PointCount)) ' errored as the data type
                        TempXY = OtherEndOfNewMadePath(MyUniverse.SysGen.Placement.x, MyUniverse.SysGen.Placement.y, x1, y1, My_VariableName(CodeLine, PointCount))
                        ' A I N F O 2 (170)
                        IndexFlowChart = AddFlowChartRecordPath(My_VariableName(CodeLine, PointCount), "/path", MyUniverse.SysGen.Placement.x + x1, MyUniverse.SysGen.Placement.y + y1, TempXY.x, TempXY.y, "logic", My_VariableName(CodeLine, PointCount))
                        ' A I N F O 2 (171)
                        'why am I trying to connect paths here? or even see if it is connected?
                        If ConnectPath(IndexFlowChart) < 1 Then
                            MSG_AInfo(1685, "Can Not connect this path TypeOf anything?", "Or else this Is Not connected", MyShowFlowChartRecord(True, IndexFlowChart))
                        Else
                            MSG_AInfo1(1686, "Path Is connected to something", ConnectPath(IndexFlowChart), "")
                        End If
        'NumberOfPoints += 1
                    Case MyUniverse.ProgramOptions.FCCL_MultiLine
                        MSG_MyTrace1(1687, "Multi Line =  " & HighLight(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I)))
                    Case MyUniverse.ProgramOptions.FCCL_Comment
                        MSG_MyTrace3(1688, "Comment, " & HighLight(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I)))
                    Case MyUniverse.ProgramOptions.FCCL_Extensions
                        MSG_MyTrace1(1689, "Extensions = " & HighLight(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I)))
                    Case MyUniverse.ProgramOptions.FCCL_VarChars
                        MSG_MyTrace1(1690, "Variable characters = " & HighLight(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I)))
                    Case MyUniverse.SysGen.Constants.SyntaxComments, MyUniverse.SysGen.Constants.SyntaxKeyWords, MyUniverse.SysGen.Constants.SyntaxSpecialCharacters, MyUniverse.SysGen.Constants.SyntaxFunctions, MyUniverse.SysGen.Constants.SyntaxOperators
                        If MyDebug(10) Then follow(1691, 10, "Comments, KeyWords, SpecialCharacters, Functions, Operators ---- >" & MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I) & vbCrLf)
#If MINEDEBUG Then
     if mydebug(9) then follow(1691, 1, "Comments, KeyWords, SpecialCharacters, Functions, Operators ---- >" & MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I) & vbCrLf)
#End If
                    Case Nothing
        'do nothing (emptying out the array 
                    Case MyUniverse.SysGen.Constants.SyntaxFieldDelimiters ' no use continuing with nothing there.
                        MSG_MyTrace1(1693, "Delimiters " & MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I))
                    Case FD, MyUniverse.SysGen.Constants.SyntaxFieldDelimiters
                        MyInfo(2116, "This Is a possible problem", MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I), "")
                    Case Else
                        If IsThisAVariableName(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I)) = True Then
                            'THis is a copy of what's above 
                            FMB(5061)
                            PointCount = MyMinMax(PointCount + 1, 0, MyUniverse.MyStaticData.Path_NamesCounted)
                            IndexSymbol += 1
                            x1 = MyUniverse.MySymbolPoints(PointCount).x
                            y1 = MyUniverse.MySymbolPoints(PointCount).y
                            ' errored as the data type
                            PointCount = MyMinMax(PointCount + 1, 0, MyUniverse.MyStaticData.Path_NamesCounted)
                            AddNEWSymbolpointRecord(MySymbolName, "/Point", x1, y1, "both", "errored", My_VariableName(CodeLine, PointCount))
                            If MyDebug(10) Then follow(2730, 10, MyShowSymbolGraphic(True, TopOfFile("Symbol")))
                            TempXY = OtherEndOfNewMadePath(MyUniverse.SysGen.Placement.x, MyUniverse.SysGen.Placement.y, x1, y1, My_VariableName(CodeLine, PointCount))
                            ' A I N F O 2 (170)
                            IndexFlowChart = AddFlowChartRecordPath(My_VariableName(CodeLine, PointCount), "/path", MyUniverse.SysGen.Placement.x + x1, MyUniverse.SysGen.Placement.y + y1, TempXY.x, TempXY.y, "logic", My_VariableName(CodeLine, PointCount))
                            ' A I N F O 2 (171)
                            'why am I trying to connect paths here? or even see if it is connected?
                            'NumberOfPoints += 1
                            FMB(5062)
                        Else
                            If MyDebug(9) Then follow(2199, 10, "This Is a possible problem " & MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I) & vbCrLf & IsThisAWhat(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I)))
                            MSG_ABug(1696, "Unknown Parse = " & IsThisAWhat(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I)), ", Syntax = " & MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I), " Parsed# = " & I.ToString)
                        End If
                End Select
                I += 1
                FMB(5063)
            End While

            IndexNamed = AddNewNamedRecord(MySymbolName, CodeLine, "nop", CodeLine, CreateFileNameFromSyntax(SyntaxLine), "FlowChart", "0.0", "?", SyntaxLine) ', MyUniverse.ProgramOptions.FCCL_LanguageClassName


            'need to pan here to the location of the Symbol
            If IndexNamed < 1 Then
                MakeSymbolOutline(MySymbolName)
            End If

            ReSortSymbolList()


            Clear_Window(SymbolWindow.PictureBox1)
            AddSymbolToDropDown(MySymbolName)
            'todo to speed up Mydoevents(203)
            ' Below should redraw the top of the list (providing it is not sorted (Which is is now), if it is, then it has to 
            'be changed to a FindIndexOfComboBoxList.....
            '2020 07 04 SymbolWindow.ToolStripDropDownButtonSynbolNames.SelectedIndex = MyMinMax(LocalIndex, 1, SymbolWindow.ToolStripDropDownButtonSynbolNames.Items.Count - 1)
            SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownSelectSymbol, MySymbolName)
            'todo to speed up Mydoevents(204)
            FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol)
            'todo to speed up Mydoevents(205)
            CheckSymbolByNamedIndex(IndexNamed)
            FMB(5064)
            Return IndexNamed
        End Function


        'used 
        Public Shared Function CheckPointNameToDropDown(MyPointName As String) As Int32
            Dim I As Int32
            Dim Z1 As String, Z2 As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3320, 10, "CheckPointNameToDropDown")
#End If
            FMB1(8037)
            Z2 = MyPointName
            Z2 = Pop(Z2, FD) 'make sure that we only have the point name passed
            If PrintAbleNull(MyPointName) = "_" Then Return 1 'nothing in the point name so it is an error
            FMB1(8038)
            For I = 0 To SymbolWindow.ComboBoxPointNameList.Items.Count - 1
                Z1 = SymbolWindow.ComboBoxPointNameList.Items.Item(I).ToString
                Z1 = Pop(Z1, FD)
                If Z2 = Z1 Then
                    Return 0 ' Do Not Add it again.
                End If
            Next I
            FMB1(8039)
            SymbolWindow.ComboBoxPointNameList.Items.Add(MyPointName)
            If MyDebug(9) Then follow(2201, 10, "Added point name " & MyPointName & vbCrLf)
            'FindingMyBugs(100)
            FMB1(8040)
            Return 1 ' there is no match, so the proGrammar (me) needs to find out why not.
        End Function 'CheckPointNameToDropDown

        Public Shared Sub AddPointNameToDropDownX(MyPointName As String)
            Dim I As Int32
            Dim Z1 As String, Z2 As String, Z3 As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3321, 10, "AddPointNameToDropDown")
#End If
            Z2 = NameOfPointOnly(MyPointName)
            If Len(MyPointName) = 0 Then Return
            'to make a new name and return it if mypointname is unusable 
            Z3 = ","
            FMB1(8041)
            If PrintAbleNull(MyPointName) = "_" Then
                For I = 0 To SymbolWindow.ComboBoxPointNameList.Items.Count - 1
                    Z3 &= SymbolWindow.ComboBoxPointNameList.Items.Item(I).ToString & FD
                Next
                FMB1(8042)
                Z2 = My_VariableName(Z3, SymbolWindow.ComboBoxPointNameList.Items.Count)
            End If

            FMB1(8043)
            For I = 0 To SymbolWindow.ComboBoxPointNameList.Items.Count - 1
                Z1 = SymbolWindow.ComboBoxPointNameList.Items.Item(I).ToString
                Z1 = Pop(Z1, FD)

                If I <> 0 Then Z3 = SymbolWindow.ComboBoxPointNameList.Items.Item(I - 1).ToString
                If Z2 = Z3 Then
                    MSG_ABug(2749, "dropdown ERROR", I.ToString & " " & Z1, (I - 1).ToString & " " & Z3)
                End If

                If Z2 = Z1 Then
                    If MyPointName <> SymbolWindow.ComboBoxPointNameList.Items.Item(I).ToString Then
                        MSG_ABug(1701, " Points names are the same , but there Is a change ", HighLight(MyPointName), HighLight(SymbolWindow.ComboBoxPointNameList.Items.Item(I).ToString) & vbCrLf)
                    End If
                    Return ' Do Not Add it again.
                End If
            Next I
            FMB1(8044)
            For I = 0 To SymbolWindow.ComboBoxPointNameList.Items.Count - 1
                If SymbolWindow.ComboBoxPointNameList.Items.Item(I).ToString = MyPointName Then
                    If mydebug(9) Then follow(2744, 1, "Name of Point already in list ---> " & MyPointName & SymbolWindow.ComboBoxPointNameList.Items.Item(I).ToString)
                End If
            Next
            FMB1(8045)
            SymbolWindow.ComboBoxPointNameList.Items.Add(MyPointName)
            'if mydebug(9) then follow(2743, 5, "Name of Point added to list  ---> " & shl(MyPointName) & MyShowComboBoxItems(SymbolWindow.ComboBoxPointNameList))
            FMB1(8046)
        End Sub


        Public Shared Sub AddLineNameToDropDown(MyLineName As String)
            Dim I As Int32
            Dim Z1 As String, Z2 As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3322, 10, "AddLineNameToDropDown")
#End If
            Z2 = MyLineName
            Z2 = Pop(Z2, FD)

            For I = 0 To SymbolWindow.ComboBoxLineNameList.Items.Count - 1
                Z1 = SymbolWindow.ComboBoxLineNameList.Items.Item(I).ToString
                Z1 = Pop(Z1, FD)
                If Z2 = Z1 Then
                    Return ' Do Not Add it again.
                End If
            Next I
            SymbolWindow.ComboBoxLineNameList.Items.Add(Z2)     'MyLineName)
            'FindingMyBugs(100)
        End Sub


        Public Shared Sub AddSymbolToDropDown(MySymbolName As String)
            Dim I As Int32
            Dim FlowChartFlag As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3323, 10, "AddSymbolToDropDown")
#End If
            If MyDebug(10) Then
                If FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count > 0 Then
                    If mydebug(9) Then follow(2861, 10, FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(0).Text)
                End If
                If FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count > 1 Then
                    If mydebug(9) Then follow(2862, 10, FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(1).Text)
                End If
                If FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count > 2 Then
                    If mydebug(9) Then follow(2863, 10, FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(2).Text)
                End If
            End If

            If IsTheDropDownText_TheSameAs_TheSelectedText(False, FlowChartWindow.ToolStripDropDownSelectSymbol.Text, SymbolWindow.ToolStripDropDownSelectSymbol) = False Then
                MSG_ABug(1704, "FlowChart Window selected Symbol  does Not match Symbol Window selected Symbol ", HighLight(FlowChartWindow.ToolStripDropDownSelectSymbol.Text), HighLight(SymbolWindow.ToolStripDropDownSelectSymbol.Text))
                If IsTheDropDownText_TheSameAs_TheSelectedText(False, MyUniverse.ProgramOptions.SelectedSymbolName, SymbolWindow.ToolStripDropDownSelectSymbol) = True Then
                    MSG_AInfo1(1705, "Mismatch Selection Symbol, FlowChart selection text changed", "to " & MyUniverse.ProgramOptions.SelectedSymbolName, " From " & FlowChartWindow.ToolStripDropDownSelectSymbol.Text)
                    SelectInToolStripDropDownButton(FlowChartWindow.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName)
                End If
                If IsTheDropDownText_TheSameAs_TheSelectedText(False, MyUniverse.ProgramOptions.SelectedSymbolName, FlowChartWindow.ToolStripDropDownSelectSymbol) = True Then
                    MSG_AInfo1(1706, "Mismatch Selection Symbol, Symbol Window selection text changed", "to " & MyUniverse.ProgramOptions.SelectedSymbolName, " From " & SymbolWindow.ToolStripDropDownSelectSymbol.Text)
                    SelectInToolStripDropDownButton(SymbolWindow.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName)
                End If
            End If


            FlowChartFlag = False
            'make sure that the Symbol is not already in the DropDownList
            If FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count <> SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count Then
                MSG_ABug(1707, "The number Of Symbols In the FlowChart And Symbol Window's do not match", FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count.ToString, SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count.ToString)
            End If

            'This takes way to long, need to change to a .find()
            For I = 0 To FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count - 1
                If MySymbolName = FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(I).ToString Then
                    FlowChartFlag = True
                    Exit For ' Do Not Add it again.
                End If
            Next I

            If FlowChartFlag = False Then
                FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Add(MySymbolName)
                'todo need to also add the .changed from FlowChart to SymbolWindow., to make sure they are both in sync.
                SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Add(MySymbolName)
            End If
            FindingMyBugsDropDowns() 'only check the drop downs for errors now.
        End Sub

        Public Shared Function OtherEndOfNewMadePath(Symbolx1 As Int32, Symboly1 As Int32, Pointx1 As Int32, Pointy1 As Int32, PathName As String) As MyPointStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3324, 10, "OtherEndOfNewMadePath")
#End If
            OtherEndOfNewMadePath = Nothing
            OtherEndOfNewMadePath.Named.PathName = PathName
            'MSG_AInfo1(1709, "A" & MyShowPoint(OtherEndOfNewMadePath.x, OtherEndOfNewMadePath.y), MyShowPoint(Pointx1, Pointy1), MyShowPoint(Symbolx1, Symboly1))
            OtherEndOfNewMadePath.x = MySign(Pointx1) * MyUniverse.SysGen.Constants.ConstantSymbolCenter
            OtherEndOfNewMadePath.y = MySign(Pointy1) * MyUniverse.SysGen.Constants.ConstantSymbolCenter

            OtherEndOfNewMadePath.x = MySign(Pointx1) * MyUniverse.SysGen.Constants.ConstantSymbolCenter + Pointx1 + Symbolx1
            OtherEndOfNewMadePath.y = MySign(Pointy1) * MyUniverse.SysGen.Constants.ConstantSymbolCenter + Pointy1 + Symboly1
            'MSG_AInfo1(1710, "Other End Distance,point,path=" & MyShowPoint(DistanceBetweenTwoPoints(Pointx1 + Symbolx1, Pointy1 + Symboly1, OtherEndOfNewMadePath.x, OtherEndOfNewMadePath.y)),    MyShowPoint(MyPoint1XY(Pointx1 + Symbolx1, Pointy1 + Symboly1)),       MyShowPoint(MyPoint2XY(OtherEndOfNewMadePath.x, OtherEndOfNewMadePath.y)))
        End Function

        Public Shared Function MyQuickNumbersort_Unused(MyTable As String, MyArray_Long() As Int32, ByRef ISAM() As Int32, minIndex As Integer, maxIndex As Integer) As Int32
            Dim med_valueNumber, Med_valueIndex As Int32
            Dim hiIndex As Integer
            Dim loIndex As Integer
            Dim index As Integer
            Dim Temp As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3325, 10, "MyQuickNumberSort_Unused")
#End If
            MyQuickNumbersort_Unused = 0
            If (ISAM(1) <> 0) And (ISAM(1) = ISAM(2)) Then
                MyMsgCtr(1167, "MyQuickNumbersort_Unused", ISAM(1).ToString, ISAM(2).ToString, "", "", "", "", "", "", "")
                MyQuickNumbersort_Unused += MyReSortAll_long(MyTable, MyArray_Long, ISAM)
            End If
            ' If the list has no more than 1 element, it's sorted.
            If minIndex >= maxIndex Then Exit Function

            ' Pick a dividing item.
            index = CInt((maxIndex - minIndex + 1) * Rnd() + minIndex)
            If index <= 0 Then
                MyMsgCtr(1168, "MyQuickNumbersort_Unused", index.ToString, "", "", "", "", "", "", "", "")
            End If
            If index <= 0 Then index = 1
            med_valueNumber = MyArray_Long(ISAM(index))
            Med_valueIndex = index

            ' Swap it to the front so we can find it easily.
            'ISAM(index) = ISAM(minIndex)
            MySwapNn(MyTable, MyArray_Long, ISAM, index, minIndex)
            MyQuickNumbersort_Unused += 1
            If MyCheckIndex_long(MyTable, index, MyArray_Long, ISAM) = False Then Exit Function


            ' Move the items smaller than this into the left
            ' half of the list.Move the others into the right.
            loIndex = minIndex
            hiIndex = maxIndex
            Do
                ' Look down from hi for a value < med_value.
                Do While MyArray_Long(ISAM(hiIndex)) >= med_valueNumber
                    hiIndex -= 1 'hiIndex = hiIndex -1
                    If hiIndex <= loIndex Then Exit Do
                Loop
                If hiIndex <= loIndex Then
                    Temp = MyArray_Long(loIndex)
                    MyArray_Long(loIndex) = MyArray_Long(Med_valueIndex)
                    MyArray_Long(med_valueNumber) = Temp
                    MyQuickNumbersort_Unused += 1
                    MyCheckIndex_long(MyTable, index, MyArray_Long, ISAM)
                    Exit Do
                End If

                ' Swap the lo and hi values.
                MySwapNn(MyTable, MyArray_Long, ISAM, loIndex, hiIndex)
                MyQuickNumbersort_Unused += 1
                MyCheckIndex_long(MyTable, index, MyArray_Long, ISAM)

                loIndex += 1
                Do While MyArray_Long(ISAM(loIndex)) < med_valueNumber
                    loIndex += 1
                    If loIndex >= hiIndex Then Exit Do
                Loop
                If loIndex >= hiIndex Then
                    loIndex = hiIndex
                    Temp = MyArray_Long(hiIndex)
                    MyArray_Long(hiIndex) = MyArray_Long(Med_valueIndex)
                    MyArray_Long(Med_valueIndex) = Temp
                    MyQuickNumbersort_Unused += 1
                    MyCheckIndex_long(MyTable, index, MyArray_Long, ISAM)
                    Exit Do
                End If

                ' Swap the lo and hi values.
                MySwapNn(MyTable, MyArray_Long, ISAM, hiIndex, loIndex)
                MyQuickNumbersort_Unused += 1
                MyCheckIndex_long(MyTable, index, MyArray_Long, ISAM)
            Loop

            ' Sort the two sublists
            MyQuickNumbersort_Unused += MyQuickNumbersort_Unused(MyTable, MyArray_Long, ISAM, minIndex, loIndex - 1)
            MyQuickNumbersort_Unused += MyQuickNumbersort_Unused(MyTable, MyArray_Long, ISAM, loIndex + 1, maxIndex)
            MyCheckIndex_long(MyTable, index, MyArray_Long, ISAM)

        End Function




        Public Shared Sub MyErrorMessages(Hiding As String, ErrorNumber As Int32, Severity As String, Message As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3326, 10, "MyErrorMessages")
#End If
            Select Case LCase(Severity)
                Case "wrong"
                Case "information"
                Case "warning"
                Case "error"
                Case "display"
                Case "status"
                Case Else
                    MSG_ABug(1717, Severity, "", "")
                    MyBeep()
                    MsgBox("Invalid Message Severity in Error Message", MsgBoxStyle.Information, ErrorNumber & FD & Severity & " : " & Message & vbCrLf & "Must be :information warning wrong Error checking display")
            End Select
            OptionsWindow.ComboBoxDebug.Items.Add(ErrorNumber & FD & Severity & FD & Message)
            BitSet(ErrorNumber, Hiding)
        End Sub

        Public Shared Function ReBubbleSortAll(MyTable As String, ByRef MyArray() As String, ByRef ISAM() As Int32) As Int32
            Dim Index, Jdex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3327, 10, "ReBubbleSortAll")
#End If
            ReBubbleSortAll = 0
            Jdex = TopOfFile(MyTable)
            For Index = 1 To Jdex
                ReBubbleSortAll += (MyReSort(MyTable, MyArray, ISAM, Index))
            Next
            MyUniverse.MyCheatSheet.ColorsSorted = 0
        End Function




        'Numbers
        Public Shared Function ReBubbleSortAt(MyTable As String, MyArrayLong() As Int32, ByRef ISAM() As Int32, IndexInput As Int32) As Int32
            Dim Flag, Index As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3328, 10, "ReBubbleSortAt")
#End If
            ReBubbleSortAt = 0
            Index = IndexInput
            While Index > 2 And ISAM(Index) = 0
                Index -= 1
            End While

            Flag = 1
            While Flag > 0
                Flag = 0
                If ISAM(Index) <> 0 Then
                    While Index > 2 And MyCompared2(MyArrayLong, ISAM, Index - 1, Index) > 0 'MyCompared(MyArrayLong(ISAM(Index - 1)), MyArrayLong(ISAM(Index))) > 0
                        'MyMsgCtr(1016, "ReBubbleSortAt", Str(Index - 1), Str(ISAM(Index - 1)), MyArrayLong(ISAM(Index - 1)).ToString, Str(Index), Str(ISAM(Index)), MyArrayLong(ISAM(Index)).ToString, "", "", "")
                        MySwapNn(MyTable, MyArrayLong, ISAM, Index - 1, Index)
                        ReBubbleSortAt += 1
                        Index -= 1
                        Flag += 1
                    End While
                End If
                Index -= 1
            End While
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        ' Check if this is something, nothing, or flagged as nothing ('_')
        Public Shared Function IsNullOrNothing(StringA As String) As Boolean
            '#If MINEDEBUG Then
            'if mydebug(9) then follow(1720, 10, "Shared:  Is Null Or Nothing()")
            '#End If
            If IsNothing(StringA) Then
                Return True
            ElseIf MyIsNothing(StringA) Then
                Return True
            ElseIf StringA = "" Then
                Return True
            ElseIf StringA = "_" Then
                Return True
            End If
            Return False
        End Function

        Public Shared Function DoesPathNamesMatch(IndexFlowChart1 As Int32, IndexFlowChart2 As Int32, XY As MyPointStructure) As MyPointStructure
            ' removed not used? Dim Temp As MyPointStructure
            'todo need to change this for case sentive in the future.
#If MINEDEBUG Then
  if mydebug(9) then follow(3329, 10, "DoesPathNamesMatch")
#End If
            If IndexFlowChart1 = IndexFlowChart2 Then Return MyUniverse.MyStaticData.ZeroZero 'same so they match
            If FlowChart_TablePathName(IndexFlowChart1) = FlowChart_TablePathName(IndexFlowChart2) Then
                If FindIndex_In_TableNetLinks(IndexFlowChart1) <> FindIndex_In_TableNetLinks(IndexFlowChart2) Then
                    MSG_ABug(1722, "Two paths with the same name", MyShowFlowChartRecord(True, IndexFlowChart1), MyShowFlowChartRecord(True, IndexFlowChart2))
                    MSG_ABug(1723, "Two paths ", MyShowNetLnks(FindIndex_In_TableNetLinks(IndexFlowChart1)), MyShowNetLnks(FindIndex_In_TableNetLinks(IndexFlowChart2)))
                    ConnectPaths(IndexFlowChart1, IndexFlowChart2, FlowChart_TablePathName(IndexFlowChart2))
                    Return Nothing
                End If
            Else 'test if any end of the path matches each other
                If DoesPathMeet(MyLine1(IndexFlowChart1), MyLine2(IndexFlowChart2)) = True Then
                    Return XY
                End If
                MSG_ABug(1724, MyShowPoint(IndexFlowChart1) & MyShowPoint(IndexFlowChart2) & " but different names error ", FlowChart_TablePathName(IndexFlowChart1), FlowChart_TablePathName(IndexFlowChart2))
                'todo This is an error and needs to be corrected, two paths (Different names) at same point 
                MakeErrorAt(FlowChartWindow.PictureBox1, XY,
        MyErrorList(1016 - 1001) & MyUniverse.ProgramOptions.FCCL_WhiteSpace &
        FlowChart_TablePath_Name(IndexFlowChart1) & MyUniverse.ProgramOptions.FCCL_WhiteSpace &
        FlowChart_TablePath_Name(IndexFlowChart2))
                Return XY 'failed because the names do not match
            End If
            Return Nothing
        End Function



        Public Shared Function DistanceBetweenTwoPaths(IndexFlowChart1 As Int32, IndexFlowChart2 As Int32) As Int32
            Dim Xa1, Ya1, Xa2, Ya2 As Int32
            Dim Xb1, Yb1, Xb2, Yb2 As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3331, 10, "DistanceBetweenTwoPaths")
#End If
            DistanceBetweenTwoPaths = 98989898
            If IndexFlowChart1 = IndexFlowChart2 Then Return DistanceBetweenTwoPaths
            If FlowChart_TableCode(IndexFlowChart1) <> "/path" Then Return DistanceBetweenTwoPaths
            If FlowChart_TableCode(IndexFlowChart2) <> "/path" Then Return DistanceBetweenTwoPaths

            Xa1 = FlowChart_TableX1(IndexFlowChart1)
            Ya1 = FlowChart_TableY1(IndexFlowChart1)
            Xa2 = FlowChart_TableX2(IndexFlowChart1)
            Ya2 = FlowChart_TableY2(IndexFlowChart1)

            Xb1 = FlowChart_TableX1(IndexFlowChart2)
            Yb1 = FlowChart_TableY1(IndexFlowChart2)
            Xb2 = FlowChart_TableX2(IndexFlowChart2)
            Yb2 = FlowChart_TableY2(IndexFlowChart2)

            DistanceBetweenTwoPaths = MyMin(DistanceBetweenTwoPaths, DistanceBetweenTwoPoints(Xa1, Ya1, Xb1, Yb1))
            DistanceBetweenTwoPaths = MyMin(DistanceBetweenTwoPaths, DistanceBetweenTwoPoints(Xa1, Ya1, Xb2, Yb2))
            DistanceBetweenTwoPaths = MyMin(DistanceBetweenTwoPaths, DistanceBetweenTwoPoints(Xa2, Ya2, Xb1, Yb1))
            DistanceBetweenTwoPaths = MyMin(DistanceBetweenTwoPaths, DistanceBetweenTwoPoints(Xa2, Ya2, Xb2, Yb2))

            Return DistanceBetweenTwoPaths
        End Function


        Public Shared Function DistanceBetweenTwoPoints(X1 As Int32, Y1 As Int32, X2 As Int32, Y2 As Int32) As Int32
            'todo to get the 'real' distance you need to take the square root of the return value, 
            'todo but since It is only to compare relitave distance . ...
#If MINEDEBUG Then
  if mydebug(9) then follow(3332, 10, "Distance Between Two Points")
#End If
            Return MyABS(X1 - X2) + MyABS(Y1 - Y2)
            'not taking the 'real' distance between them to avoid using floating point (since I am only comparing this distance with another.
        End Function



        'why is this combining two nets with different names?
        Public Shared Sub CombineNetLinksInto(LocalIndexNetLinks As Int32, JdexNetLinks As Int32)
            Dim I, J As Int32
            Dim Temp As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3333, 10, "CombineNetLinksInto")
#End If
            If mydebug(9) Then follow(2476, 5, "Combine Net Links together ")
            If LocalIndexNetLinks = JdexNetLinks Then Return

            'Check the links of the two nets
            If Net_TableNames(LocalIndexNetLinks) <> Net_TableNames(JdexNetLinks) Then
                MSG_ABug(1730, " Combining nets with different names? Why", MyShowNetLnks(LocalIndexNetLinks), MyShowNetLnks(JdexNetLinks))
                Temp = CombineNames(Net_TableNames(LocalIndexNetLinks), Net_TableNames(JdexNetLinks))
            Else
                Temp = Net_TableNames(LocalIndexNetLinks) ' since they match, Net_TableLinks(JdexNetLinks))
            End If

            'The nets in this list is in Temp
            Net_TableLinks(JdexNetLinks, Net_TableLinks(JdexNetLinks) & Net_TableLinks(LocalIndexNetLinks)) 'Combine the two nets
            CleanListOfNet_TableLinks(LocalIndexNetLinks)

            For I = 1 To TopOfFile("FlowChart")
                If FlowChart_TableCode(I) = "/path" Then
                    J = FindIndex_In_TableNetLinks(I) 'index of this /pathindex =I
                    Temp = Net_TableLinks(J)    'The list of links of this path name
                    While Len(Temp) > 0     'loop through all of the paths find this one
                        J = PopValue(Temp)  'Get another /path
                        If J = LocalIndexNetLinks Then
                            If I = JdexNetLinks Then
                                If FindIndex_In_TableNetLinks(J) > 0 Then
                                    If FindIndex_In_TableNetLinks(I) > 1 Then
                                        If Net_TableNames(I) = Net_TableNames(J) Then
                                            'Finally combine the two nets and get rid of the old, it does not matter which is changed.
                                            Net_TableLinks(I, Net_TableLinks(I) & FD & Net_TableLinks(J))
                                            CleanListOfNet_TableLinks(I)
                                            CleanListOfNet_TableLinks(J)
                                            Net_TableNameS(J, "") 'Erase the old dup
                                            Net_TableLinks(J, "") 'Erase the old dup
                                            Return
                                        End If
                                    Else
                                        MSG_ABug(1731, "The names are different for the two links", MyShowFlowChartRecord(True, I), MyShowFlowChartRecord(True, J))
                                    End If
                                Else
                                    'Connecting to itself MSG_ABug(1732, "path links error? ", MyShowFlowChartRecord(true , I), MyShowFlowChartRecord(true , J))
                                End If
                            Else
                                'connecting to itself MSG_ABug(1733, "path links error? ", MyShowFlowChartRecord(true , I), MyShowFlowChartRecord(true , J))
                            End If
                        Else
                            'connecting to itself    MSG_ABug(1734, "path links error? ", MyShowFlowChartRecord(true , I), MyShowFlowChartRecord(true , J))
                        End If
                    End While
                End If
            Next
            'MSG_ABug(1735, "path links error They are not really connected,  ", MyShowFlowChartRecord(true , I), MyShowFlowChartRecord(true , J))
        End Sub


        Public Shared Function CombineNames(A As String, B As String) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3334, 10, "CombineNames")
#End If
            If mydebug(9) Then follow(2477, 5, "Combine Names " & A & ", " & B)
            If InStr(A, "_&_" & B) > 0 Then 'is A&B already there?
                Return A
            ElseIf InStr(B, "_&_" & A) > 0 Then 'is B&A already there
                Return B
            End If
            Return A & "_&_" & B
        End Function 'CombineNames


        Public Shared Function RemoveNumberFromTextList(InputString As String, NumberToRemove As Int32) As String
            Dim Temp As String
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3335, 10, "RemoveNumberFromTextList")
#End If
            If mydebug(9) Then follow(2478, 9, "Remove Number From Text List " & InputString & " Delete " & NumberToRemove.ToString)
            Temp = FD & NumberToRemove.ToString & FD
            I = InStr(InputString, Temp)
            If I <> 0 Then
                Return Mid(InputString, 1, I) & FD & Mid(InputString, I + Len(Temp), Len(InputString))
            End If
            Return InputString
        End Function



        Public Shared Function MyROUTERnetIndex(IndexNet As Int32) As Int32
            Dim IndexFlowChart As Int32
            Dim Temp As String
            Dim DebugTemp As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3336, 10, "MyROUTERNetIndex")
#End If
            If mydebug(9) Then follow(2479, 3, "Router Net Index " & MyShowNetLnks(IndexNet))
            MyROUTERnetIndex = 0

            Temp = Net_TableLinks(IndexNet)
            DebugTemp = Net_TableNames(IndexNet)
            While Len(Temp) > 0
                IndexFlowChart = PopNonZeroValue(Temp)
                If IndexFlowChart > 0 Then
                    If ROUTERIndex2Net(IndexFlowChart, IndexNet) = True Then
                        MyROUTERnetIndex += 1
                    End If
                End If
            End While
        End Function


        Public Shared Function Line2WindowScale(xy As MyLineStructure) As MyLineStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3337, 10, "Line2WindowScale")
#End If
            If mydebug(9) Then follow(2480, 5, "R2Lscale ")
            Line2WindowScale.a = Copy2WindowXY(FlowChartWindow.PictureBox1, xy.a)
            Line2WindowScale.b = Copy2WindowXY(FlowChartWindow.PictureBox1, xy.b)
        End Function

        Public Shared Sub MyDrawPaths(IndexFlowChart1 As Int32, IndexFlowChart2 As Int32, ColorCode As Int32)
#If MINEDEBUG Then
  if mydebug(9) then follow(3338, 10, "MyDrawPaths")
#End If
            If mydebug(9) Then follow(2481, 5, "my Paths " & MyShowLineRecord(False, IndexFlowChart1) & MyShowLineRecord(False, IndexFlowChart2))
            MyDrawPaths(MyLine1(IndexFlowChart1), MyLine2(IndexFlowChart2), MyUniverse.OptionDisplay(ColorCode).ColorName)
        End Sub



        Public Shared Sub ROUTERMakePath(IndexFlowChart1 As Int32, InDexFlowChart2 As Int32)
            'todo Need to get the two closest ends.
            Dim XY As MyLineStructure
            Dim IndexFlowChart As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3339, 10, "ROUTERMakePath")
#End If
            If mydebug(9) Then follow(2482, 3, "Routermakepath " & vbCrLf & MyShowFlowChartRecord(False, IndexFlowChart1) & vbCrLf & vbTab & MyShowFlowChartRecord(False, InDexFlowChart2))
            MyDrawPaths(IndexFlowChart1, InDexFlowChart2, 9) ' number 9 is red "Red")
            XY = FindClosestPathEnds(IndexFlowChart1, InDexFlowChart2)
            'bug this should not just draw a path, but should route it here
            If XY.a.x <> 0 Or XY.a.y <> 0 Or XY.b.x <> 0 Or XY.b.y <> 0 Then
                'MSG_ABug(1742, "Needs to route path better", "", MyShowALine(XY))

                AutoROUTERPath(IndexFlowChart1, InDexFlowChart2)
                IndexFlowChart = AddFlowChartRecordPath(FlowChart_TablePathName(IndexFlowChart1), "/path", XY.a.x, XY.a.y, XY.b.x, XY.b.y, FlowChart_Table_DataType(IndexFlowChart1), "")
                PaintAll(FlowChartWindow.PictureBox1, IndexFlowChart, IndexFlowChart)
            End If
        End Sub
        Public Shared Sub RouterMakePath(myXY1 As MyPointStructure, MyXy2 As MyPointStructure)
            Dim IndexFlowChart As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3340, 10, "ROUTERMakePath")
#End If
            If mydebug(9) Then follow(2483, 3, "Make Path " & MyShowPoint(myXY1) & vbTab & MyShowPoint(MyXy2))
            If myXY1.x <> 0 Or myXY1.y <> 0 Or MyXy2.x <> 0 Or MyXy2.y <> 0 Then
                MSG_AInfo1(1744, "Make a path to ", MyShowPoint(myXY1), MyShowPoint(MyXy2))
                'first find net name for this point
                IndexFlowChart = FindPathNameAt(myXY1)
                'then add a new path there 
                AddFlowChartRecordPath(FlowChart_TablePathName(IndexFlowChart), "/path", myXY1.x, myXY1.y, MyXy2.x, MyXy2.y, FlowChart_Table_DataType(IndexFlowChart), "")
                PaintAll(FlowChartWindow.PictureBox1, IndexFlowChart, IndexFlowChart)
            Else
                MSG_AInfo(1745, "Not doable ", MyShowPoint(myXY1), MyShowPoint(MyXy2))
            End If
        End Sub



        Public Shared Function ROUTERPointsMatch(XY1 As MyPointStructure, XY2 As MyPointStructure) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3341, 10, "ROUTERPointsMatch")
#End If
            If mydebug(9) Then follow(2484, 1, "Router Points Match ? ")
            If XY1.x = XY2.x And XY1.y = XY2.y Then Return True
            Return False
        End Function


        Public Shared Function ROUTERend(IndexFlowChart As Int32, MyXY As MyPointStructure) As MyPointStructure
            If mydebug(9) Then follow(2485, 8, "Rout End " & MyShowPoint(MyXY) & MyShowFlowChartRecord(False, IndexFlowChart))
#If MINEDEBUG Then
  if mydebug(9) then follow(3342, 10, "ROUTERend")
#End If
            If FlowChart_TableCode(IndexFlowChart) <> "/path" Then
                MSG_AInfo(1748, "Trying to route to a non /path", MyShowFlowChartRecord(True, IndexFlowChart), "")
                Return MyUniverse.MyStaticData.ZeroZero
            End If
            If FlowChart_TableX1(IndexFlowChart) = MyXY.x And FlowChart_TableY1(IndexFlowChart) = MyXY.y Then
                Return MyPoint1_1XY(IndexFlowChart)
            End If
            If FlowChart_TableX2(IndexFlowChart) = MyXY.x And FlowChart_TableY2(IndexFlowChart) = MyXY.y Then
                Return MyPoint2_1XY(IndexFlowChart)
            End If
            'MSG_ABug(1749, "Neither end of the path is connected", MyShowFlowChartRecord(True, IndexFlowChart), MyShowPoint(MyXY))
            Return MyUniverse.MyStaticData.ZeroZero
        End Function

        Public Shared Sub MyDrawPaths(XY1 As MyLineStructure, XY2 As MyLineStructure, ColorName As String)
            Dim xy As MyLineStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3343, 10, "MyDrawPath")
#End If
            'if mydebug(9) then follow(2486, 5, "Draw Paths " & MyShowALine(XY1) & MyShowALine(XY2))
            xy = Nothing

            'todo change the search pattern color to be changeable.

            xy.a.x = XY1.a.x : xy.a.y = XY1.a.y : xy.b.x = XY2.a.x : xy.b.y = XY2.a.y ': xy = Line2WindowScale(xy)
            'MSG_AInfo(1751, "Showing where a path can go  ", MyShow3Lines(XY1, xy, XY2), "")
            My_Draw_Line_Or_Path(FlowChartWindow.PictureBox1, xy, ColorName, 1)
            xy.a.x = XY1.a.x : xy.a.y = XY1.b.y : xy.b.x = XY2.a.x : xy.b.y = XY2.a.y ': xy = Line2WindowScale(xy)
            'MSG_AInfo(1752, "Showing where a path can go  ", MyShow3Lines(XY1, xy, XY2), "")
            My_Draw_Line_Or_Path(FlowChartWindow.PictureBox1, xy, ColorName, 1)
            xy.a.x = XY1.b.x : xy.a.y = XY1.a.y : xy.b.x = XY2.b.x : xy.b.y = XY2.b.y ': xy = Line2WindowScale(xy)
            'MSG_AInfo(1753, "Showing where a path can go  ", MyShow3Lines(XY1, xy, XY2), "")
            My_Draw_Line_Or_Path(FlowChartWindow.PictureBox1, xy, ColorName, 1)
            xy.a.x = XY1.b.x : xy.a.y = XY1.b.y : xy.b.x = XY2.b.x : xy.b.y = XY2.b.y ': xy = Line2WindowScale(xy)
            'MSG_AInfo(1754, "Showing where a path can go  ", MyShow3Lines(XY1, xy, XY2), "")
            My_Draw_Line_Or_Path(FlowChartWindow.PictureBox1, xy, ColorName, 1)

        End Sub



        'make a list of paths that connect these two
        'trying to connect from the indexFlowChart (which is the first in the netlinks list) to anything else in the netlinks list
        Public Shared Function ROUTERIndex2Net(IndexFlowChart As Int32, IndexNets As Int32) As Boolean
            Dim Temp1, Temp2, Temp3 As String ' 1 holds the list not tried (to try others) , 2 holds the list of the one we are trying to ROUTER
            Dim XY1, XY2 As MyLineStructure
            Dim LastDistance, LastIndexFlowChart, LocalIndex As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3344, 10, "ROUTERIndex2Net")
#End If
            'option (19) turns off auto ROUTER
            If mydebug(9) Then follow(2487, 5, "Router index 2 net " & vbCrLf & vbTab & MyShowFlowChartRecord(False, IndexFlowChart) & vbCrLf & vbTab & MyShowNetLnks(IndexNets))
            If MyOptionTest(19) = False Then
                MSG_AInfo1(1755, "Auto router option is turned off:", "", "")
                Return False
            End If

            'MSG_AInfo(1756, "ROUTER Starting to find a path between ", MyShowFlowChartRecord(true , IndexFlowChart), MyShowNetLnks(IndexNets))

            LastDistance = 100000000 'really really big number.
            LastIndexFlowChart = -1
            'First find the closest one
            Temp1 = Net_TableLinks(IndexNets)
            XY1 = FlowChart2Line(IndexFlowChart)

            Temp2 = RemoveNumberFromTextList(Temp1, IndexFlowChart)

            While Len(Temp2) > 0
                LocalIndex = PopNonZeroValue(Temp2)
                If LocalIndex <> IndexFlowChart And LocalIndex <> 0 Then
                    MSG_AInfo(1757, "trying to route between ", vbCrLf & MyShowFlowChartRecord(True, IndexFlowChart), vbCrLf & MyShowFlowChartRecord(True, LocalIndex))
                    XY2 = FlowChart2Line(LocalIndex)
                    Temp3 = MyShowALine(XY1) & "  " & MyShowALine(XY2)

                    If FlowChart_TablePathName(IndexFlowChart) <> FlowChart_TablePathName(LocalIndex) Then
                        MSG_ABug(1758, "trying to connect paths with different names ", MyShowFlowChartRecord(True, IndexFlowChart), MyShowFlowChartRecord(True, LocalIndex))
                    End If

                    '    MyDrawPaths(XY1, XY2, MyUniverse.OptionDisplay(LocalIndex Mod UBound(MyUniverse.OptionDisplay)).ColorName)

                    If MyDistancePath(XY1, XY2) < LastDistance Then
                        MSG_AInfo1(1759, "saving a closer distance to something else", MyDistancePath(XY1, XY2), LastDistance & " " & MyDistancePath(XY1, XY2))
                        LastDistance = MyDistancePath(XY1, XY2)
                        LastIndexFlowChart = LocalIndex
                    End If
                End If
                Temp2 = RemoveNumberFromTextList(Temp2, LocalIndex)
            End While

            'This is where the router actually starts to work between two paths.
            If LastIndexFlowChart = ConstantMyErrorCode Then Return False
            XY1 = FlowChart2Line(IndexFlowChart)
            XY2 = FlowChart2Line(LastIndexFlowChart)
            MyDrawPaths(XY1, XY2, MyUniverse.OptionDisplay(LocalIndex Mod UBound(MyUniverse.OptionDisplay)).ColorName)

            ' re-moved this selected from the list

            LocalIndex = LastIndexFlowChart
            MSG_AInfo1(1760, "Closest other path to route to.", MyShowFlowChartRecord(True, IndexFlowChart), MyShowFlowChartRecord(True, LocalIndex))
            If MyOptionTest(14) = True Then
                If IndexFlowChart > 0 And LocalIndex > 0 Then
                    ROUTERMakePath(IndexFlowChart, LocalIndex)
                    Return True
                Else
                    MSG_ABug(1761, "Trying to route to an invalid index ", MyShowFlowChartRecord(True, IndexFlowChart), MyShowFlowChartRecord(True, LocalIndex))
                    Return False
                End If
            End If

            'Now should have the two closest together
            If LastIndexFlowChart > ConstantMyErrorCode Then 'We found something to ROUTER to
                If ROUTERPath_IsAPathROUTERd(IndexFlowChart, LastIndexFlowChart) = True Then
                    Return True
                Else
                    If AutoROUTERPath(IndexFlowChart, LastIndexFlowChart) = False Then
                        MSG_ABug(1762, "Auto route did not find a clear path", MyShowFlowChartRecord(True, IndexFlowChart), MyShowFlowChartRecord(True, LastIndexFlowChart))
                    Else
                        'todo need to make the path of the auto route success? (or do it in the recurression
                        MSG_ABug(1763, "Auto Route Worked", "", "")
                        Return True
                    End If
                End If
            End If
            Return False
        End Function


        'have determined that a path needs to be between indexflowchar1 and indexFlowChart2

        Public Shared Function AutoROUTERPath(IndexFlowChart1 As Int32, IndexFlowChart2 As Int32) As Boolean
            Dim TempXY As MyLineStructure
            Dim PathName As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3345, 10, "AutoROOUTERPath")
#End If
            If MyDebug(5) Then follow(2488, 5, "Router Path " & MyShowFlowChartRecord(False, IndexFlowChart1) & MyShowFlowChartRecord(False, IndexFlowChart2))
            If FlowChart_TablePathName(IndexFlowChart1) = FlowChart_TablePathName(IndexFlowChart2) Then
                PathName = FlowChart_TablePathName(IndexFlowChart1)
            Else
                PathName = FlowChart_TablePathName(IndexFlowChart1) & "_" & FlowChart_TablePathName(IndexFlowChart2)
            End If
            TempXY = FindClosestPathEnds(IndexFlowChart1, IndexFlowChart2)
            Return AutoROUTER_Path(TempXY.a, TempXY.b, PathName)
        End Function 'AutoROUTERPath


        'This is to see if the line is clear all the way from a to b with out anything in the way
        ' returns MyUniverse.MyStaticData.Zerozero if not doable
        ' return the A if recursion is doable
        'returns b when finished
        ' assumes that a path is then made from A to Be if returns B 
        ' all the way back to the top
        'Calls itself with a point between A and B going to B till it finds a path
        'First find where the list of the path is in X
        ' Why I am only using X, I have no Idea, it should be for X for directions 
        ' and when using Y it should be fore directions 
        'Y1 XY2 X3 X4 X5 XY6 Y7 Y8 Y9 XY10 X11 X12 X13 XY14 Y15 Y16
        Public Shared Function ROUTERIsItClearPath(A As MyPointStructure, B As MyPointStructure) As MyPointStructure
            Dim LocalIndex, ZDEX, MyDirZ As Int32
            Dim MyXYZ0, MyXYZ1, Myxyz2 As MyPointStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3346, 10, "ROUTERIsItClearPath")
#End If
            If MyDebug(1) Then follow(2489, 1, "clear Path " & MyShowPoint(A) & MyShowPoint(B))
            ' removed not needed ?MyDirZ = MyDirection(A, B)
            'Select Case MyDirZ
            ' Case 1, 7, 8, 9, 15, 16 'search in Y direction instead
            ' Case 2, 6, 10, 14 'specail case search in both directions
            ' Case 3, 4, 5, 11, 12, 13
            LocalIndex = FindIndexInISAMTable("FlowChart", "DoNotAdd", FlowChart_FileX1, FlowChart_ISAM_X1, A.x)
            If LocalIndex < 1 Then
                LocalIndex = 1
                While FlowChart_TableX1(FlowChart_ISAM_X1(LocalIndex)) > A.x
                    LocalIndex -= 1
                    If LocalIndex < 1 Then Return MyUniverse.MyStaticData.ZeroZero
                End While
                While FlowChart_TableX1(FlowChart_ISAM_X1(LocalIndex)) < A.x
                    LocalIndex += 1
                    If LocalIndex > TopOfFile("FlowChart") Then Return MyUniverse.MyStaticData.ZeroZero
                End While
                LocalIndex -= 1
            End If
            'todo check if there is a path that overlaps this one.
            MSG_AInfo1(1766, "Recursive find a clear path", MyShowPoint(A) & MyShowPoint(B), "Index in FlowChart X1 =" & LocalIndex.ToString)
            'todo this will go through Symbols, but I didn't want to subtract myuniverse...Symbolcenter for the x1
            Do
                MyXYZ1 = ROUTERend(LocalIndex, A) ' only trying for first end?
                If ROUTERPointsMatch(MyXYZ1, MyUniverse.MyStaticData.ZeroZero) Then MyXYZ1 = ROUTERend(LocalIndex, B) ' only trying for one end?

                If ROUTERPointsMatch(MyXYZ1, MyUniverse.MyStaticData.ZeroZero) = True And ROUTERPointsMatch(B, MyUniverse.MyStaticData.ZeroZero) = True Then
                    MSG_ABug(1767, "Make a path here ", MyShowPoint(A), MyShowPoint(MyXYZ1)) '
                    RouterMakePath(MyXYZ1, B)
                    Return MyXYZ1 ' cause we made it to the end ' so tell itself to make a path from a to myxyz1
                End If
                If ROUTERPointsMatch(MyXYZ1, MyUniverse.MyStaticData.ZeroZero) = False Then 'test if made it.
                    MSG_ABug(1768, "Make a path here ", MyShowPoint(A), MyShowPoint(MyXYZ1)) '
                    RouterMakePath(MyXYZ1, B)
                    Return MyXYZ1 ' cause we made it to the end ' so tell itself to make a path from a to myxyz1
                End If


                'else

                'first try stepping in the right directions
                For ZDEX = -4 To 4
                    MyDirZ = (MyDirection(A, B) + ZDEX + 16) Mod 16 ' clock step about the direction of where we are going
                    Myxyz2 = MyXYZ1
                    Myxyz2.x += MyUniverse.SysGen.Snaps.MyPointSnap * MySign(MyDirections(MyDirZ, 1, 1)) + MyUniverse.SysGen.Snaps.MyPointSnap * MySign(MyDirections(MyDirZ, 1, 2))
                    Myxyz2.y += MyUniverse.SysGen.Snaps.MyPointSnap * MySign(MyDirections(MyDirZ, 2, 1)) + MyUniverse.SysGen.Snaps.MyPointSnap * MySign(MyDirections(MyDirZ, 2, 2))

                    MyXYZ0 = ROUTERCheckLinesEndAtEachOther(MyLine1(A, Myxyz2), MyLine1(Myxyz2, B))
                    If ROUTERPointsMatch(MyXYZ0, MyUniverse.MyStaticData.ZeroZero) = False Then
                        RouterMakePath(Myxyz2, B)
                        Return Myxyz2
                    End If
                Next ZDEX
                LocalIndex += 1
            Loop While LocalIndex <= TopOfFile("FlowChart") And FlowChart_TableX1(LocalIndex) = A.x
            Return MyUniverse.MyStaticData.ZeroZero  ' return how far it Go_To below
        End Function



        'Find a line all the want to match
        'returns A if path found, MyUniverse.MyStaticData.Zerozero if not possible, and B if did not make it to B
        Public Shared Function HowCloseCanYouGet2(A As MyPointStructure, B As MyPointStructure) As MyPointStructure
            Dim XY As MyPointStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3347, 10, "HowCloseCanYouGet2")
#End If
            If MyDebug(5) Then follow(2490, 5, "Router How Far " & MyShowPoint(A) & MyShowPoint(B))
            'Find the longest stright line from a to b
            'First try the longest way
            XY.x = B.x - A.x 'Direction and distance to get from a toward b
            XY.y = B.y - A.y

            If ROUTERPointsMatch(ROUTERIsItClearPath(A, B), MyUniverse.MyStaticData.ZeroZero) = False Then
                'getting here means that I need to add a path from A to B
                RouterMakePath(A, B)
                Return A
            End If

            'from here on we should step in any direction to find a path
            MSG_ABug(1770, "Looking for a path here to here.", MyShowPoint(A), MyShowPoint(B))

            If ROUTERPointsMatch(ROUTERIsItClearPath(A, MyPoint1XY(A.x, B.y)), MyUniverse.MyStaticData.ZeroZero) = False Then
                RouterMakePath(A, MyPoint1XY(A.x, A.y + XY.y))
                Return MyPoint1XY(A.x, A.y + XY.y)
            End If

            If ROUTERPointsMatch(ROUTERIsItClearPath(A, MyPoint1XY(A.x + XY.x, A.y)), MyUniverse.MyStaticData.ZeroZero) = False Then
                Return MyPoint1XY(A.x + XY.x, A.y)
            End If
            Return A
        End Function




        'THis tries to find a path from A to B (If fails then save the path that ends  closest to B)
        Public Shared Function AutoROUTER_Path(P_A As MyPointStructure, P_B As MyPointStructure, PathName As String) As Boolean
            Dim NextPointXY As MyPointStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3348, 10, "AutoROUTER_Path")
#End If
            ' If I can find a point between these two then make a path, and then return true
            ' If NOT try again from as close as I got.(Recursive trying) utile it makes it (or is unable to make it.

            '1.0 try stepping across the longest path looking for one that goes the the X or Y of B
            'Assume that there is already a point where we are starting from.
            'ToDo make it so that it can do 8 directions, (For now just 4)  Angles will be off the grid by half so that they will not interfer with the horx/vert lines..

            'sets the myuniver.....to have the distance you can go in each direction 
            If MyDebug(5) Then follow(2491, 5, "AutoROUTER_Path " & MyShowPoint(P_A) & MyShowPoint(P_B))
            MSG_AInfo1(1772, "Starting to find a path for " & SHL(PathName), MyShowPoint(P_A), MyShowPoint(P_B))

            If P_A.x = 0 And P_A.y = 0 And P_B.x = 0 And P_B.y = 0 Then
                Return False
            End If

            NextPointXY = HowCloseCanYouGet2(P_A, P_B) 'returns the longest that you can go in the (1-16) directions.
            MSG_AInfo1(1773, "Found CLosest to end at ", MyShowPoint(NextPointXY), MyShowPoint(P_B))
            If NextPointXY.x = P_B.x Then
                If NextPointXY.y = P_B.y Then
                    MSG_AInfo1(1774, "Finished Found a path from a to b =", MyShowPoint(P_A), MyShowPoint(P_B))
                    AddFlowChartRecordPath(PathName, "/path", NextPointXY.x, NextPointXY.y, P_B.x, P_B.y, "DataType", "")
                    Return True
                End If
            End If
            If (P_A.x = NextPointXY.x) And (P_A.y = NextPointXY.y) Then
                MSG_AInfo1(1775, "Failed to route", MyShowPoint(P_A), "")
                Return False
            End If
            If AutoROUTER_Path(NextPointXY, P_B, PathName) = True Then
                'So we have to add the path before this also (Cause the recursion found the above or the below and is returning here
                AddFlowChartRecordPath(PathName, "/path", P_A.x, P_A.y, NextPointXY.x, NextPointXY.y, "DataType", "")
                Return True
            End If

            'todo in the future
            '2.0 try stepping across the shortest path looking for one that goes the the X or Y of B
            MSG_ABug(1776, "Attempted path not clear", "", "")
            Return False
        End Function 'AutoROUTER_Path

        Public Shared Function FlowChart2Point(IndexFlowChart As Int32) As MyPointStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3349, 10, "FlowChart2Point")
#End If
            If MyDebug(5) Then follow(2492, 5, "FlowChart2Point ")
            FlowChart2Point.x = FlowChart_TableX1(IndexFlowChart)
            FlowChart2Point.y = FlowChart_TableY1(IndexFlowChart)
            FlowChart2Point.Named.PathName = FlowChart_TablePathName(IndexFlowChart)
            FlowChart2Point.Named.SymbolName = ""
            FlowChart2Point.Named.PointName = ""
            Return FlowChart2Point
        End Function

        Public Shared Function FlowChart2Line(IndexFlowChart As Int32) As MyLineStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3340, 10, "FlowChart2Line")
#End If
            FlowChart2Line = Nothing
            If FlowChart_TableCode(IndexFlowChart) <> "/path" Then
                MSG_ABug(1778, "This is not a Path ", MyShowFlowChartRecord(True, IndexFlowChart), "")
                Return MyUniverse.MyStaticData.ZeroZeroZeroZero
            End If
            FlowChart2Line.a.x = FlowChart_TableX1(IndexFlowChart)
            FlowChart2Line.a.y = FlowChart_TableY1(IndexFlowChart)
            FlowChart2Line.b.x = FlowChart_TableX2(IndexFlowChart)
            FlowChart2Line.b.y = FlowChart_TableY2(IndexFlowChart)
            If mydebug(9) Then follow(2493, 9, "Flow Chart 2 Line " & MyShowFlowChartRecord(False, IndexFlowChart) & vbTab & MyShowALine(FlowChart2Line))
        End Function


        'test all four ends of the two paths to see if they are connected together.
        Public Shared Function FindClosestPathEnds(IndexFlowChart1 As Int32, IndexFlowChart2 As Int32) As MyLineStructure
            Dim XY1, XY2 As MyLineStructure
            Dim T1, T2, T3, T4, T5, T6, T7 As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3341, 10, "FindClosestPathEnds")
#End If
            XY1 = FlowChart2Line(IndexFlowChart1)
            XY2 = FlowChart2Line(IndexFlowChart2)
            If MyDebug(5) Then follow(2494, 5, "Find Closest Path Ends " & MyShowALine(XY1) & MyShowALine(XY2))

            If XY1.a.x = 0 And XY1.a.y = 0 Then MSG_ABug(1780, "Trying to route to Zero, Zero ", "", "")
            If XY1.b.x = 0 And XY1.b.y = 0 Then MSG_ABug(1781, "Trying to route to Zero, Zero ", "", "")
            If XY2.a.x = 0 And XY2.a.y = 0 Then MSG_ABug(1782, "Trying to route to Zero, Zero ", "", "")
            If XY2.b.x = 0 And XY2.b.y = 0 Then MSG_ABug(1783, "Trying to route to Zero, Zero ", "", "")
            'Test if they are already connected
            T1 = MyDistancePath(XY1, XY2)
            If T1 = 0 Then Return Nothing 'do not need to route it, cause they are connected.
            'First find one from each that is the closest 
            T1 = MyDistance(XY1.a, XY2.a)
            T2 = MyDistance(XY1.a, XY2.b)
            T3 = MyDistance(XY1.b, XY2.a)
            T4 = MyDistance(XY1.b, XY2.b)
            T5 = MyMin(T1, T2)
            T6 = MyMin(T3, T4)
            T7 = MyMin(T5, T6)
            If T7 = T1 Then Return MyLine1(XY1.a, XY2.a) 'a to a
            If T7 = T2 Then Return MyLine1(XY1.a, XY2.a) 'a to b
            If T7 = T3 Then Return MyLine1(XY1.a, XY2.a) 'b to a
            If T7 = T4 Then Return MyLine1(XY1.a, XY2.a) 'b to b
            Return MyLine1(XY1.a, XY2.a)

        End Function

        'checks if there is a path
        ' returns false if the two line segments meet.
        ' if the two do not meet then this path is not routed between paths 1 and path 2)
        Public Shared Function ROUTERPath_IsAPathROUTERd(IndexFlowChart1 As Int32, IndexFlowChart2 As Int32) As Boolean
            Dim XY As MyLineStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3342, 10, "ROUTERPath_IsAPathROUTEd")
#End If
            If MyDebug(5) Then follow(2495, 5, "RouterPathComplete? ")
            XY = FindClosestPathEnds(IndexFlowChart1, IndexFlowChart2)
            'Now find a path for the line XY
            If XY.a.x = 0 And XY.a.y = 0 And XY.b.x = 0 And XY.b.y = 0 Then 'returning nothing , which is all zeros 
                Return False
            End If

            MSG_AInfo1(1785, "Need path for this line", MyShowALine(XY), MyShowFlowChartRecord(True, IndexFlowChart1) & vbCrLf & MyShowFlowChartRecord(True, IndexFlowChart2))
            AutoROUTERPath(IndexFlowChart1, IndexFlowChart2)
            Return True
        End Function


        Public Shared Sub ConnectPaths(IndexFlowChart1 As Int32, IndexFlowChart2 As Int32, PathName As String)
            Dim I As Int32 ' look through all of the NetLinks
            Dim PutIt1, Putit2 As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3343, 10, "ConnectPaths")
#End If
            If MyDebug(5) Then follow(2500, 5, "ConnectPaths ")
            'todo is this nessary '''I1 = FindIndex_In_TableNetLinks(IndexFlowChart1)
            'todo is this nessary '''I2 = FindIndex_In_TableNetLinks(IndexFlowChart2)
            PathName = CheckThisPathName(PathName, IndexFlowChart1)
            PathName = CheckThisPathName(PathName, IndexFlowChart2)

            If IndexFlowChart1 = IndexFlowChart2 Then Return
            PutIt1 = 0
            Putit2 = 0
            For I = LBound(Net_FileLinks) To UBound(Net_FileLinks)
                If InStr(Net_TableLinks(I), FD & IndexFlowChart1 & FD) > 0 Then
                    PutIt1 = I
                End If
                If InStr(Net_TableLinks(I), FD & IndexFlowChart2 & FD) > 0 Then
                    Putit2 = I
                End If
                If PutIt1 <> 0 And Putit2 <> 0 Then Exit For
            Next

            'Everything is OK
            If PutIt1 <> 0 And Putit2 <> 0 And PutIt1 = Putit2 Then
                Return
            End If



            'One not there so add to two
            If PutIt1 = 0 And Putit2 <> 0 Then
                Net_TableLinks(Putit2, Net_TableLinks(Putit2) & FD & IndexFlowChart1 & FD)
                CleanListOfNet_TableLinks(Putit2)
                Return
            End If
            'Two not there so add to one
            If Putit2 = 0 And PutIt1 <> 0 Then
                Net_TableLinks(PutIt1, Net_TableLinks(PutIt1) & FD & IndexFlowChart2 & FD)
                CleanListOfNet_TableLinks(PutIt1)
                Return
            End If

            ' If neither one or two is there then add a new netlinks
            If PutIt1 = 0 And Putit2 = 0 Then
                I = UBound(Net_FileLinks) + 1
                ReDim Preserve Net_FileLinks(I)
                ReDim Preserve Net_FileNames(I)
                Net_TableLinks(I, FD & IndexFlowChart1 & FD & IndexFlowChart2 & FD)
                Net_TableNameS(I, PathName) ' Add a new path name
                Return
            End If

            ' Check if they are in different ones, not and fix them.
            If PutIt1 <> 0 And Putit2 <> 0 And PutIt1 <> Putit2 Then
                ' We have to connect the two nets together.
                CombineNetLinksInto(PutIt1, Putit2)
            Else
            End If


        End Sub


        'This tries to combine paths with or without the same name when they both end at the same point
        Public Shared Function ConnectPath(IndexFlowChart_1 As Int32) As Int32 ' Returns the NetIndex that it is in, and cleans up (ignores what it say's it is in for now)
            Dim IndexFlowChart_2, IndexNetLinks_1, IndexNetLinks_2 As Int32
            Dim Temp As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3344, 10, "ConnectPath")
            FindingMyBugsChangeOfWindows()
#End If
            If MyDebug(8) Then
                Follow(2501, 8, "Connect Path " & MyShowFlowChartRecord(True, IndexFlowChart_1))
            End If

            '
            '            If FlowChartWindow.Visible = False Then
            '            ShowAllForms(ShowWindow, HideWindow, HideWindow, HideWindow)
            '            End If
            FMB_IsXY(
                FlowChart_TableX1(IndexFlowChart_1),
                FlowChart_TableY1(IndexFlowChart_1),
                FlowChart_TableX2(IndexFlowChart_1),
                FlowChart_TableY2(IndexFlowChart_1))

            IndexFlowChart_2 = PathConnects2(FlowChart_TableCode(IndexFlowChart_1), IndexFlowChart_1) ' get what else it is connected to (Could return either to another path, or to a Symbol or nothing (an error?)
            If IndexFlowChart_2 <= 1 Then
                Return ConstantMyErrorCode
            End If
            If IndexFlowChart_2 = IndexFlowChart_1 Then
                MSG_AInfo(1788, MyShowFlowChartRecord(True, IndexFlowChart_1), MyShowFlowChartRecord(True, IndexFlowChart_2), MyShowNetLnks(FindIndex_In_TableNetLinks(IndexFlowChart_1)))
            End If

            Temp = DistanceBetweenTwoPaths(IndexFlowChart_1, IndexFlowChart_2)
            If Temp <> 0 Then
                MSG_AInfo1(1789, "These two are not connected." & MyShowPoint(Temp), MyShowFlowChartRecord(True, IndexFlowChart_1), MyShowFlowChartRecord(True, IndexFlowChart_2))
                Return ConstantMyErrorCode
            End If
            Temp = DistanceBetweenTwoPaths(IndexFlowChart_1, IndexFlowChart_2)

            IndexNetLinks_1 = FindIndex_In_TableNetLinks(IndexFlowChart_1) ' Get if this is already there
            IndexNetLinks_2 = FindIndex_In_TableNetLinks(IndexFlowChart_2) ' Get if this is already there
            If Net_TableNames(IndexNetLinks_1) <> Net_TableNames(IndexNetLinks_2) Then
                'need to tell more about this XY point (and Symbols attached? more lines?
                MSG_ABug(1790, "two Nets have different names ", MyShowAllNet(IndexNetLinks_1) & MyShowAllNet(IndexNetLinks_2), MyShowNetLnks(IndexNetLinks_1) & vbCrLf & MyShowNetLnks(IndexNetLinks_2))
                MakeErrorAt(FlowChartWindow.PictureBox1, MyPoint1XY(IndexFlowChart_1),
        MyErrorList(1016 - 1001) & MyUniverse.ProgramOptions.FCCL_WhiteSpace &
        MyShowFlowChartRecord(True, IndexFlowChart_1) & MyUniverse.ProgramOptions.FCCL_WhiteSpace &
        MyShowFlowChartRecord(True, IndexFlowChart_2))
                Return ConstantMyErrorCode
            End If
            If IndexNetLinks_1 <> IndexNetLinks_2 Then
                If IndexNetLinks_1 > 0 Then ' Found the nets that index FlowChart is in
                    If IndexNetLinks_2 > 0 Then ' also found that it is in this network
                        If FlowChart_TableCode(IndexFlowChart_1) = "/path" Then
                            If FlowChart_TableCode(IndexFlowChart_2) = "/path" Then
                                MSG_AInfo(1791, "Combine two paths because ??", MyShowFlowChartRecord(True, IndexFlowChart_1), MyShowNetLnks(IndexNetLinks_1) & vbCrLf & MyShowFlowChartRecord(True, IndexFlowChart_2))
                                'DoesPathNamesMatch(IndexFlowChart_1 , IndexFlowChart_2  )
                                CombineNetLinksInto(IndexNetLinks_1, IndexNetLinks_2) ' combine them together and change all of the FlowChart links to point to the new
                                Return IndexNetLinks_2
                            Else
                                If FlowChart_TableCode(IndexFlowChart_2) = My_keyWord(My_KeyConstUse) Then
                                    MSG_AInfo(1792, MyShowFlowChartRecord(True, IndexFlowChart_2), MyShowFlowChartRecord(True, IndexFlowChart_1), MyShowNetLnks(IndexNetLinks_1) & vbCrLf & MyShowNetLnks(IndexNetLinks_2))
                                Else
                                    MSG_AInfo(1793, "WARNING Path is connected to Something else might be a /error or a /origin or a /Constant) ", MyShowFlowChartRecord(True, IndexFlowChart_1), MyShowNetLnks(IndexNetLinks_1) & vbCrLf & MyShowNetLnks(IndexNetLinks_2))
                                End If
                            End If
                        Else
                            If FlowChart_TableCode(IndexFlowChart_2) = "/path" Then
                                MSG_AInfo(1794, "Symbol is connected to a path", MyShowFlowChartRecord(True, IndexFlowChart_1), MyShowNetLnks(IndexNetLinks_1) & vbCrLf & MyShowNetLnks(IndexNetLinks_2))
                            Else
                                MSG_AInfo(1795, "Symbol is NOT connected to a path", MyShowFlowChartRecord(True, IndexFlowChart_1), MyShowNetLnks(IndexNetLinks_1) & vbCrLf & MyShowNetLnks(IndexNetLinks_2))
                            End If
                        End If
                    End If
                End If
            End If
            'autoroute path
            If CountLinks(IndexNetLinks_1) > 1 Then
                'MSG_AInfo(1796, "It should be auto routed here if there is another point the the pathlinks ", vbCrLf & "/point=" & MyShowNetLnks(IndexNetLinks_1), vbCrLf & "/point=" & MyShowNetLnks(IndexNetLinks_2))
                If IndexNetLinks_1 > 0 And IndexFlowChart_1 > 0 And IndexNetLinks_2 <> IndexNetLinks_1 Then
                    MSG_AInfo(1796, "It should be auto routed here if there is another point the the pathlinks ", vbCrLf & "/point=" & MyShowNetLnks(IndexNetLinks_1), vbCrLf & "/point=" & MyShowNetLnks(IndexNetLinks_2))
                    If ROUTERIndex2Net(IndexFlowChart_1, IndexNetLinks_1) = True Then
                        MSG_ABug(1797, "Path already routed", MyShowNetLnks(IndexNetLinks_1) & vbCrLf & MyShowNetLnks(IndexNetLinks_2), MyShowFlowChartRecord(False, IndexFlowChart_1))
                    Else
                        MSG_ABug(1798, "Needs to do something else", "", "")
                    End If
                End If
            End If
            Return 0
        End Function


        Public Shared Function CountLinks(IndexNetLinks As Int32) As Int32
            Dim Temp As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3345, 10, "CountLinks")
#End If
            If mydebug(9) Then follow(2502, 6, "Count Links " & IndexNetLinks.ToString)
            'would be faster to count the comma's (FD's)  than decompile the numbers from the list
            CountLinks = 0
            Temp = Net_TableLinks(IndexNetLinks)

            While Len(Temp) > 0
                If PopValue(Temp) > 0 Then
                    CountLinks += 1
                End If
            End While
        End Function 'count links




        ' returns the index of the FlowChart atom that it connects to.(or zero if none)
        ' return to what other FlowChart it connect to (either /use or /path)
        Public Shared Function PathConnects2(Connects2 As String, IndexFlowChart1 As Int32) As Int32
            Dim IndexFlowChart, IndexNamed, IndexSymbol, MyTopOfFile, X1, Y1 As Int32
            Dim TempR As MyPointStructure
            Dim TempD As Int32
#If MINEDEBUG Then
            if MyDebug(6 ) then follow(3346, 10, "PathConnects2")
#End If
            If MyDebug(8) Then If MyDebug(8) Then follow(2503, 8, "PathConnects2 " & Connects2 & ", " & IndexFlowChart.ToString)
            'FindingMyBugs(100)
            If InvalidIndex(IndexFlowChart1, FlowChart_FilePathSymbolName) = True Then Return ConstantMyErrorCode
            For IndexFlowChart = 1 To TopOfFile("FlowChart")
                If IndexFlowChart = IndexFlowChart1 Then 'do nothing with itself 
                Else
                    Select Case LCase(FlowChart_TableCode(IndexFlowChart))
                        Case My_keyWord(My_KeyConstUse)
                            If Connects2 = "/path" Then
                                IndexNamed = GetSelfCorrectingIndexes(FlowChart_TableSymbol_Name(IndexFlowChart))
                                If IndexNamed > 0 Then
                                    IndexSymbol = Named_TableSymbolIndexes(IndexNamed) ' Get the shortcut to the start of the name
                                    If IndexSymbol > 0 Then
                                        If MyDebug(7) Then follow(2696, 7, SHL(MyNoCR(MyShowFlowChartRecord(False, IndexFlowChart))) & FD & SHL(MyNoCR(MyShowSymbolGraphic(False, IndexSymbol))))
                                        IndexSymbol += 1 ' move over the name
                                        MyTopOfFile = TopOfFile("Symbol") ' For the last Symbol in the list
                                        While Symbol_TableCoded_String(IndexSymbol) <> "/name" And IndexSymbol <= MyTopOfFile
#If MINEDEBUG Then
                                            if MyDebug(8 ) then follow(2697, 8, SHL(MyNoCR(MyShowFlowChartRecord(False, IndexFlowChart))) & FD & SHL(MyNoCR(MyShowSymbolGraphic(False, IndexSymbol))))
#End If
                                            Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                                                Case "/point"
                                                    TempR = MyRotated(IndexSymbol, IndexFlowChart)
                                                    X1 = FlowChart_TableX1(IndexFlowChart) + TempR.x 'Symbol_TableX1(IndexSymbol)
                                                    Y1 = FlowChart_TableY1(IndexFlowChart) + TempR.y 'Symbol_TableY1(IndexSymbol)
                                                    TempD = DistanceBetweenTwoPoints(FlowChart_TableX1(IndexFlowChart1), FlowChart_TableY1(IndexFlowChart1), X1, Y1)
                                                    If TempD = 0 Then
                                                        MSG_AInfo1(1801, "This Point connected to this Path A ", MyShowNamedRecords(True, IndexNamed), MyShowFlowChartRecord(True, IndexFlowChart))
                                                        Return IndexFlowChart1
                                                    End If
                                                    TempD = DistanceBetweenTwoPoints(FlowChart_TableX2(IndexFlowChart1), FlowChart_TableY2(IndexFlowChart1), X1, Y1)
                                                    If TempD = 0 Then
                                                        MSG_AInfo1(1802, "This Point connected to this Path B ", MyShowNamedRecords(True, IndexNamed), MyShowFlowChartRecord(True, IndexFlowChart))
                                                        Return IndexFlowChart1
                                                    End If
                                                Case Nothing
                                                    Exit While' Must be at the end of the list (last Symbol)
                                                Case "/unknown" 'ignore 
                                                    MSG_AInfo1(1803, "Ignoreing unknown code", MyShowSymbolGraphic(True, IndexFlowChart1), Symbol_TableCoded_String(IndexFlowChart1))
                                                Case "/line" ' ignore lines
                                                Case Else
                                                    MSG_AInfo(1804, "Should have programmed for ", Symbol_TableCoded_String(IndexSymbol), IndexSymbol & vbCrLf & MyShowSymbolGraphic(False, IndexSymbol))
                                                    Exit While
                                            End Select
                                            IndexSymbol += 1 ' Try next
                                        End While
                                    End If
                                Else
                                    If FlowChart_TableCode(IndexFlowChart1) <> "/path" Then
                                        MSG_AInfo(1805, "Symbol not in short cut", MyShowFlowChartRecord(True, IndexFlowChart), MyShowFlowChartRecord(True, IndexFlowChart1))
                                    End If
                                End If
                            End If
                        Case "/path"
                            If Connects2 = "/path" Then
                                ' Check Points
                                TempD = DistanceBetweenTwoPaths(IndexFlowChart1, IndexFlowChart)
                                If TempD <> 0 Then
                                    MSG_AInfo(1806, "NOT CONNECTED " & vbCrLf & vbTab & TempD.ToString, vbTab & MyShowFlowChartRecord(True, IndexFlowChart1) & vbCrLf, vbTab & MyShowFlowChartRecord(True, IndexFlowChart) & vbCrLf)
                                Else
                                    'MSG_AInfo(1807, "   Connected " & MyShowPoint(Temp), MyShowFlowChartRecord(True, IndexFlowChart1), MyShowFlowChartRecord(True, IndexFlowChart))
                                    If FlowChart_TablePath_Name(IndexFlowChart1) <> FlowChart_TablePath_Name(IndexFlowChart) Then
                                        MSG_ABug(1808, "Two paths are connected but the path names are different", "#" & IndexFlowChart1.ToString & " " & MyShowFlowChartRecord(False, IndexFlowChart1), "# " & IndexFlowChart.ToString & " " & MyShowFlowChartRecord(False, IndexFlowChart))
                                        MSG_AInfo1(2358, "Problem here between ", vbCrLf & MyShowEveryThingAtXY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), vbCrLf & MyShowEveryThingAtXY(FlowChart_TableX1(IndexFlowChart1), FlowChart_TableY1(IndexFlowChart1)))
                                        'todo need to fix this overlay
                                        'MoveSymbolAndAllPaths(FlowChartWindow.PictureBox1, IndexFlowChart, MyPoint1XY(1000, 1000))
                                        'MyPoint1XY(MyUniverse.SysGen.Snaps.MaxSymbolInYSpacing * MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Snaps.MaxSymbolInYSpacing * MyUniverse.SysGen.Constants.ConstantSymbolCenter))
                                        FindingMyBugs(10)
                                        MakeErrorAt(FlowChartWindow.PictureBox1, MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), MyErrorList(1024 - 1001) & FlowChart_TablePath_Name(IndexFlowChart1))
                                        PanTo(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart))
                                    Else
                                        If MyDebug(9) Then follow(2210, 10, "???????" & vbCrLf)
                                    End If
                                    Return IndexFlowChart
                                End If
                            Else
                                If MyDebug(9) Then follow(2211, 10, "?.?.?.?.?.?.")
                            End If
                        Case "/error" 'ignore
                        Case "/origin" 'ignore
                        Case "/unknown"
                        Case Else
                            MSG_ABug(1809, "code not taken care of ", MyShowFlowChartRecord(True, IndexFlowChart1), My_keyWord(My_KeyConstUse))
                    End Select
                End If
            Next
            Return 0 ' not connected anywhere
        End Function




        Public Shared Function FindingMyBugsTOF_Indexes(IndexFlowChart As Int32, IndexSymbol As Int32, IndexNamed As Int32, IndexColor As Int32, IndexDataType As Int32) As Int32
            FindingMyBugsTOF_Indexes = 0
            If DontFindMyBugs() = True Then Return 0

#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3347, 10, "FindingMyBugsTOF_Indexes " & IndexFlowChart.ToString & FD & IndexSymbol.ToString & FD & IndexNamed.ToString & FD & IndexColor.ToString & FD & IndexDataType.ToString)
#End If
            If MyDebug(11) Then If MyDebug(11) Then follow(2504, 11, "FMB: TOF _Indexes")

            If IndexFlowChart < 0 Then FindingMyBugsTOF_Indexes += 1
            If IndexNamed < 0 Then FindingMyBugsTOF_Indexes += 1
            If IndexSymbol < 0 Then FindingMyBugsTOF_Indexes += 1
            If IndexColor < 0 Then FindingMyBugsTOF_Indexes += 1
            If IndexDataType < 0 Then FindingMyBugsTOF_Indexes += 1

            'ignore if it is set to zero and fool the invalid check
            If IndexFlowChart = 0 Then IndexFlowChart = 1 : FindingMyBugsTOF_Indexes += 1
            If IndexNamed = 0 Then IndexNamed = 1 : FindingMyBugsTOF_Indexes += 1
            If IndexSymbol = 0 Then IndexSymbol = 1 : FindingMyBugsTOF_Indexes += 1
            If IndexColor = 0 Then IndexColor = 1 : FindingMyBugsTOF_Indexes += 1
            If IndexDataType = 0 Then IndexDataType = 1 : FindingMyBugsTOF_Indexes += 1



            If InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName) = True Then FindingMyBugsTOF_Indexes += 1
            If InvalidIndex(IndexSymbol, Symbol_FileSymbolName) = True Then FindingMyBugsTOF_Indexes += 1
            If InvalidIndex(IndexNamed, Named_FileSymbolName) = True Then FindingMyBugsTOF_Indexes += 1
            If InvalidIndex(IndexColor, Color_FileName) = True Then FindingMyBugsTOF_Indexes += 1
            If InvalidIndex(IndexDataType, DataType_FileName) = True Then FindingMyBugsTOF_Indexes += 1


            If IndexSymbol > TopOfFile("Symbol") Then MyMsgCtr(1433, "FMB-Index ", "Symbol ", IndexSymbol.ToString, " : ", TopOfFile("Symbol").ToString, "", "", "", "", "") : FindingMyBugsTOF_Indexes += 1

            If IndexNamed > TopOfFile("Named") Then MyMsgCtr(1433, "FMB-Index ", "Named ", IndexNamed.ToString, " : ", TopOfFile("Named ").ToString, "", "", "", "", "") : FindingMyBugsTOF_Indexes += 1
            If IndexColor > TopOfFile("Color") Then MyMsgCtr(1433, "FMB-Index ", "Color ", IndexSymbol.ToString, " : ", TopOfFile("Color").ToString, "", "", "", "", "") : FindingMyBugsTOF_Indexes += 1
            If IndexDataType > TopOfFile("DataType") Then MyMsgCtr(1433, "FMB-Index ", "DataType ", IndexSymbol.ToString, " : ", TopOfFile("DataType").ToString, "", "", "", "", "") : FindingMyBugsTOF_Indexes += 1
            If IndexFlowChart > TopOfFile("FlowChart") Then MyMsgCtr(1433, "Index past end of table ", "FlowChart ", IndexFlowChart.ToString, " : ", TopOfFile("FlowChart").ToString, "", "", "", "", "") : FindingMyBugsTOF_Indexes += 1
            ' Also Check these
            If FlowChart_ISAM_X1(IndexFlowChart) > TopOfFile("FlowChart") Then MyMsgCtr(1433, "FMB-Index ", "FlowChartX1 ", IndexFlowChart.ToString, " : ", TopOfFile("FlowChart").ToString, "", "", "", "", "") : FindingMyBugsTOF_Indexes += 1
            If FlowChart_ISAM_Y1(IndexFlowChart) > TopOfFile("FlowChart") Then MyMsgCtr(1433, "FMB-Index ", "FlowChartY1 ", IndexFlowChart.ToString, " : ", TopOfFile("FlowChart").ToString, "", "", "", "", "") : FindingMyBugsTOF_Indexes += 1
            If FlowChart_ISAM_X2(IndexFlowChart) > TopOfFile("FlowChart") Then MyMsgCtr(1433, "FMB-Index ", "FlowChartX2 ", IndexFlowChart.ToString, " : ", TopOfFile("FlowChart").ToString, "", "", "", "", "") : FindingMyBugsTOF_Indexes += 1
            If FlowChart_ISAM_Y2(IndexFlowChart) > TopOfFile("FlowChart") Then MyMsgCtr(1433, "FMB-Index ", "FlowChartY2 ", IndexFlowChart.ToString, " : ", TopOfFile("FlowChart").ToString, "", "", "", "", "") : FindingMyBugsTOF_Indexes += 1
            If FlowChart_ISAM_Name(IndexFlowChart) > TopOfFile("FlowChart") Then MyMsgCtr(1433, "FMB-Index ", "FlowChartName ", IndexFlowChart.ToString, " : ", TopOfFile("FlowChart").ToString, "", "", "", "", "") : FindingMyBugsTOF_Indexes += 1

        End Function

        Public Shared Sub DoThisEvent(BugNumber As Int32)
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2940, 10, ">>>>DoEvents  " & BugNumber.ToString)
#End If
            System.Windows.Forms.Application.DoEvents()
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(2941, 10, ">>>>DoneEvent " & BugNumber.ToString)
#End If
        End Sub
        Public Shared Sub DoEvents(BugNumber As Int32)
            If FMBRecurse("DoEvents") > 7 Then
                MSG_ABug(2731, " Recursive do events > 7. ", "Message Number " & BugNumber.ToString.ToString, "")
                Return
            End If
            ''''''''''''''''''''''''''''''''''''''            System.Windows.Forms.Application.DoEvents()
        End Sub

        Public Shared Sub MyDoEvents(at As Int32)
            'todo need to put this back in, (remove all of them first and then but back only when 'safe'
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3349, 10, "MyDoEvents(Doesn't do events (See do this event)")
            if MyDebug(10 ) then follow(2864, 10, "10012 " & at.ToString & FD & FMBRecurse("DoEvents").ToString())
#End If
            Return 'todo remove this
            System.Windows.Forms.Application.DoEvents()
        End Sub

        Public Shared Sub MySortHints()
            Dim I, Flag As Int32
            Dim Temp As String
#If MINEDEBUG Then
            FindingMyBugsChangeOfWindows()
            if MyDebug(10 ) then follow(3350, 10, "MySortHints")
#End If
            'todo bug, it does not trickle the list down if there is a blank made from deleting the hint number
            'if MyDebug(8 ) then follow(2506, 8, "My Sort Hints")
            Do
                Flag = 0
                For I = 0 To UBound(MyUniverse.MyStaticData.Hints) - 1
                    If PrintAbleNull(MyUniverse.MyStaticData.Hints(I)) = "_" And PrintAbleNull(MyUniverse.MyStaticData.Hints(I + 1)) = "_" Then
                        Exit For
                    End If
                    If PrintAbleNull(MyUniverse.MyStaticData.Hints(I)) = "_" And PrintAbleNull(MyUniverse.MyStaticData.Hints(I + 1)) <> "_" Then
                        'not used? Temp = MyUniverse.MyStaticData.Hints(I + 1) 'todo remove this not needed debug
                        Temp = MyUniverse.MyStaticData.Hints(I)
                        MyUniverse.MyStaticData.Hints(I) = MyUniverse.MyStaticData.Hints(I + 1)
                        MyUniverse.MyStaticData.Hints(I + 1) = Temp
                        Flag += 1
                    End If
                Next
            Loop While Flag <> 0
            Do
                Flag = 0
                For I = 0 To UBound(MyUniverse.MyStaticData.Hints) - 1
                    If FlowChartWindow.Visible = True Then ' sor the hints with lowest first
                        If PrintAbleNull(MyUniverse.MyStaticData.Hints(I)) = "_" Then
                            Exit For
                        Else
                            'ignore it if it is a blank
                            If PrintAbleNull(MyUniverse.MyStaticData.Hints(I + 1)) = "_" Then ' it shouldn't be because the list  is shuffled down 
                                Exit For
                            ElseIf MyUniverse.MyStaticData.Hints(I) < MyUniverse.MyStaticData.Hints(I + 1) Then
                                Temp = MyUniverse.MyStaticData.Hints(I)
                                MyUniverse.MyStaticData.Hints(I) = MyUniverse.MyStaticData.Hints(I + 1)
                                MyUniverse.MyStaticData.Hints(I + 1) = Temp
                                Flag += 1
                            End If
                        End If
                    Else ' sor the other way for Symbols 
                        If PrintAbleNull(MyUniverse.MyStaticData.Hints(I)) = "_" Then
                            Exit For
                        Else
                            'ignore it if it is a blank
                            If PrintAbleNull(MyUniverse.MyStaticData.Hints(I + 1)) = "_" Then ' it shouldn't be because the list  is shuffled down 
                                Exit For
                            ElseIf MyUniverse.MyStaticData.Hints(I) > MyUniverse.MyStaticData.Hints(I + 1) Then
                                'Temp = MyUniverse.MyStaticData.Hints(I + 1)
                                Temp = MyUniverse.MyStaticData.Hints(I)
                                MyUniverse.MyStaticData.Hints(I) = MyUniverse.MyStaticData.Hints(I + 1)
                                MyUniverse.MyStaticData.Hints(I + 1) = Temp
                                Flag += 1
                            End If
                        End If

                    End If
                Next I
            Loop While Flag <> 0
        End Sub


        'This is to show the last 10 hints (ie something wrong, and needs to be changed so that the buttons(options) are available.
        Public Shared Function A_Hint(BugNumber As Int32, WindowName As String, ButtonName As String, Because As String) As Int32
            'todo need to change this so that it takes hints out when the conditions are men (with negitive bug number ie: no longer a bug/info/hint)
            'need to display the status when a hint  is deleted.
            Const Seperator As String = " <---> "
            ReDim Preserve MyUniverse.MyStaticData.Hints(10)
            Dim I, Flag As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3351, 10, "A_Hint")
#End If
            'todo to speed up Mydoevents(206)
            If ProgramBuzzy("Begin") Then Return 0
            'if MyDebug(7 ) then follow(2507, 7, "A_Hint " & BugNumber.ToString & " " & WindowName & " " & ButtonName & " Because: " & Because)
            A_Hint = 0 ' Where all of the errors are added from here
            'First make sure that this is not already there (and delete it if it not suppose to be
            'see if it is already there
            For I = 0 To 10
                If BugNumber > 0 Then
                    If PrintAbleNull(MyUniverse.MyStaticData.Hints(I)) = "_" Then
                        Exit For
                    End If
                    If MyUniverse.MyStaticData.Hints(I) = BugNumber.ToString & " = " & WindowName & Seperator & ButtonName & HighLight(Because) Then
                        DisplayMyStatus(3, MyUniverse.MyStaticData.Hints(0))
                        Exit Function
                    End If
                Else
                    If InStr(MyUniverse.MyStaticData.Hints(I), CStr(-BugNumber) & Seperator) <> 0 Then
                        MyUniverse.MyStaticData.Hints(I) = "" ' Delete This hint, as it is no longer valid
                        MySortHints()
                        'todo only display the hint (for now) needs to change
                        DisplayMyStatus(3, MyUniverse.MyStaticData.Hints(0))
                        'DisplayMyStatus(3,MyUniverse.MyStaticData.Hints(0))
                        Exit For
                    End If
                End If
            Next I

            'next we move everything to fill it from zero to the end
            Flag = 1
            While Flag <> 0
                Flag = 0
                For I = 0 To 9
                    'todo this needs to be change to move from the (one) up till the last, OR AN EMPTY IS FILLED
                    If PrintAbleNull(MyUniverse.MyStaticData.Hints(I)) = "_" Then
                        If PrintAbleNull(MyUniverse.MyStaticData.Hints(I + 1)) <> "_" Then
                            MyUniverse.MyStaticData.Hints(I) = MyUniverse.MyStaticData.Hints(I + 1)
                            MyUniverse.MyStaticData.Hints(I + 1) = Nothing
                            Flag += 1 ' untill we do not move any more.
                        End If
                    End If
                Next
            End While

            If BugNumber < 0 Then Exit Function
            'next move everything up if you can 

            'last we add this hint to the first spot (And move every thing else up out of the way.
            For I = 10 To 1 Step -1
                MyUniverse.MyStaticData.Hints(I) = MyUniverse.MyStaticData.Hints(I - 1)
            Next I
            MyUniverse.MyStaticData.Hints(0) = BugNumber.ToString & Seperator & WindowName & Seperator & ButtonName & HighLight(Because)
            MySortHints()
        End Function


        Public Shared Function Bin2HEX(S As String) As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3352, 10, "Bin2HEX")
#End If

            Bin2HEX = S
            Bin2HEX = Bin2HEX.Replace(vbCrLf, "'0x000D'") 'CRLF to CR (not 202B or 2029)
            Bin2HEX = Bin2HEX.Replace(vbLf, "'0x000D'") 'LF to CR
            Bin2HEX = Bin2HEX.Replace(vbCr, "'0x000D'") 'CRonly to CR
            Bin2HEX = Bin2HEX.Replace("\", "'0x005c'") 'Backslash 
            Bin2HEX = Bin2HEX.Replace(Chr(34), "'0x0022'") 'Quote (0x201c and 0x201D)
            Bin2HEX = Bin2HEX.Replace("'", "'0x0027'") 'single quote mark
            Bin2HEX = Bin2HEX.Replace(vbTab, "'0x0009'") 'tab
            Bin2HEX = Bin2HEX.Replace("-", "'0x002D'") 'minus / hyphen
            Bin2HEX = Bin2HEX.Replace(".", "'0x002E'")
            Bin2HEX = Bin2HEX.Replace("_", "'0x005F'")
            Bin2HEX = Bin2HEX.Replace(" ", "'0x0020'")
            If S <> Bin2HEX Then
                DebugPrint("212 ," & S & "---->" & Bin2HEX)
            End If
        End Function

        Public Shared Function MyNoCR(A As String) As String
            'if MyDebug(10 ) then follow(2508, 10, "No Cr Lf " & A)
            '#If MINEDEBUG Then
            '           if MyDebug(10 ) then follow(3353, 10, "MyNoCR")
            '#End If
            MyNoCR = A
            While InStr(MyNoCR, vbCrLf) <> 0
                MyNoCR = MyNoCR.Replace(vbCrLf, vbTab)
            End While
            While InStr(MyNoCR, vbLf) <> 0
                MyNoCR = MyNoCR.Replace(vbLf, vbTab)
            End While
            While InStr(MyNoCR, vbCr) <> 0
                MyNoCR = MyNoCR.Replace(vbCr, vbTab)
            End While
            While InStr(MyNoCR, vbTab & vbTab) <> 0
                MyNoCR = MyNoCR.Replace(vbTab & vbTab, " , " & vbTab)
            End While
        End Function


        Public Shared Sub MyInfo(BugNumber As Int32, AA As Object, BB As Object, CC As Object)
            Dim A, B, C As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3354, 10, "MyInfo")
#End If
            If MyIsNothing(AA.ToString) Then A = "" Else A = vbCrLf & vbTab & AA.ToString
            If MyIsNothing(BB.ToString) Then B = "" Else B = vbCrLf & vbTab & BB.ToString
            If MyIsNothing(CC.ToString) Then C = "" Else C = vbCrLf & vbTab & CC.ToString
            If MyDebug(4) Then follow(2212, 2, "Info: " & "I" & BugNumber.ToString & " MyInfo: " & A & " <--->  " & B & " <--->  " & C)
        End Sub



        'This is used to count the number of times the routine is called, so should only have one at the top of every routine.
        Public Shared Sub MSG_MyTrace1(BugNumber As Int32, Routine As String)
            Dim Temp As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3355, 10, "MSG_MyTrace1")
#End If
            If MyDebug(10) Then follow(2512, 10, "MSG Trace1: " & Routine)
            If BugNumber < 1 Or BugNumber / 8 > UBound(MyTraceBits) Then
                MSG_ABug(1813, "MyTrace number is out of range 1- " & (UBound(MyTraceBits) * 8).ToString, BugNumber.ToString, "")
            End If

            Temp = MyMinMax(BugNumber, 1, UBound(MyTraceCount))
            If Temp <> BugNumber Then
                MSG_ABug(1814, " greater than array size set to " & Temp.ToString, UBound(MyTraceCount).ToString, BugNumber.ToString)
            End If
            MyTraceCount(Temp) += 1
            MyTraceRoutine(Temp) = MyLeft(Routine, 16)
            If IsBitSet1(Temp) = False Then
                Return
            End If
            MyBeep()
            Select Case MsgBox("#" + BugNumber.ToString & ":" & CStr(Temp) + vbTab + Routine + vbCrLf + MyTraceCount(Temp).ToString, MsgBoxStyle.YesNo, "Yes to see, No To stop Seeing This message A")
                Case MsgBoxResult.Yes
                    BitSet1(BugNumber, "On")
                Case MsgBoxResult.No
                    BitSet1(BugNumber, "Off")
                Case Else
                    BitSet1(BugNumber, "Off")
            End Select

        End Sub



        'This is a copy of MSG_MyTrace2() where I am not stopping
        Public Shared Sub MSG_MyTrace3(BugNumber As Int32, Routine As String)
            Dim A As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3356, 10, "MSG_MyTrace3")
#End If
            If MyDebug(5) Then follow(2513, 5, "Trace3: " & BugNumber.ToString & vbCrLf & Routine)
            A = BugNumber
            If A < 1 Or A / 8 > UBound(MyTraceBits) Then
                MSG_ABug(1818, "MyTrace3 number is out of range 1- " & UBound(MyTraceBits).ToString, BugNumber.ToString, A.ToString)
            End If
        End Sub
        'this is only used to print out what the trace is doing right now.


        Public Shared Function CommandLineIs() As String
            Dim RTN As String = ""
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3357, 10, "CommandLineIs")
#End If
            For Each s As String In My.Application.CommandLineArgs
                RTN &= s & FD & MyUniverse.ProgramOptions.FCCL_WhiteSpace
                If MyDebug(3) Then follow(2514, 3, "Command Line Is " & RTN)
            Next
#If MINEDEBUG Then
            if MyDebug(3 ) then follow(2514, 3, "Command Line Is " & RTN)
#End If



            Return RTN
        End Function


        'This is not really used, it is to get the directory of where the default files should go (and where to get the definition files.
        Public Shared Sub MyTraceSystem()
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3358, 10, "MyTraceSystem")
#End If
            If MyDebug(5) Then Follow(2641, " User = " & Environment.UserName & vbCrLf)
            If MyDebug(5) Then follow(2642, " Cmd = " & Environment.CommandLine & vbCrLf)
            If MyDebug(5) Then Follow(2643, " Dir = " & Environment.CurrentDirectory & vbCrLf)
            If MyDebug(5) Then follow(2644, " 64 Bit = " & Environment.Is64BitOperatingSystem.ToString & vbCrLf)
            If MyDebug(5) Then follow(2645, " Machine = " & Environment.MachineName & vbCrLf)
            If MyDebug(5) Then follow(2646, " OS ver = " & Environment.OSVersion.ToString & vbCrLf)
            If MyDebug(5) Then follow(2647, " Processor Count = " & Environment.ProcessorCount.ToString & vbCrLf)
            If MyDebug(5) Then follow(2648, " Domain = " & Environment.UserDomainName & vbCrLf)
            If MyDebug(5) Then Follow(2649, " Working Set = " & Environment.WorkingSet.ToString & vbCrLf)

            MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastIndex = -2
            MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = -2
            MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName = "xyzzy"

            MyUniverse.MyStaticData.MyEnum.LastWhatString = MyConstantIgnoreFunctionOperatorKeyWord
            MyUniverse.MyStaticData.MyEnum.LastComboBox = MyConstantIgnoreFunctionOperatorKeyWord
            MyUniverse.MyStaticData.MyEnum.Last_Enum = -1
            MyUniverse.MyStaticData.MyUnEnum.LastWhatString = MyConstantIgnoreFunctionOperatorKeyWord
            MyUniverse.MyStaticData.MyUnEnum.LastComboBox = MyConstantIgnoreFunctionOperatorKeyWord
            MyUniverse.MyStaticData.MyUnEnum.LastUnEnum = MyConstantIgnoreFunctionOperatorKeyWord
        End Sub
        'This is just to show what's goin on.
        Public Shared Sub MSG_AInfo1(BugNumber As Int32, AA As Object, BB As Object, CC As Object)
            Dim A, B, C As String
#If MINEDEBUG Then
            if MyDebug(1 ) then follow(BugNumber, 11, "AT MSG_AInfo1 : ")
#End If
            If MyIsNothing(AA.ToString) Then A = "" Else A = vbCrLf & vbTab & AA.ToString
            If MyIsNothing(BB.ToString) Then B = "" Else B = vbCrLf & vbTab & BB.ToString
            If MyIsNothing(CC.ToString) Then C = "" Else C = vbCrLf & vbTab & CC.ToString
            If mydebug(9) Then follow(BugNumber, 2, " MSG_A info1 : " & FD & MyNoCR(A & vbTab & B & vbTab & C))
        End Sub


        'This is to just show whats going on.
        Public Shared Function MSG_AInfo(BugNumber As Int32, AA As String, BB As Object, CC As Object) As Int32
            Dim A, B, C As String
#If MINEDEBUG Then
            if MyDebug(0 ) then follow(BugNumber, 10, "MSG_AInfo ")
#End If
            If IsNothing(AA) Then AA = ""
            If IsNothing(BB) Then BB = ""
            If IsNothing(CC) Then CC = ""
            'todo make sure that the bug number is in the range of bug numbers.
            If MyIsNothing(AA.ToString) Then A = "" Else A = AA.ToString
            If MyIsNothing(BB.ToString) Then B = "" Else B = BB.ToString
            If MyIsNothing(CC.ToString) Then C = "" Else C = CC.ToString
            If A = "" And B = "" And C = "" Then Return 0
            'todo need to be able to set the level of information messages (or yes no option)
            'if MyDebug5 ) then follow(2517, 5, "Info " & BugNumber.ToString & A & B & C)
            Dump3(BugNumber, "Info: " & vbTab & A & vbTab & B & vbTab & C & "<---")
            Return 0
        End Function
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'highest info or bug number is 
        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This is to show a problem, and if you want to see this problem again.  
        'If you choose to not see them, they will still be printed out in the dump file.
        Public Shared Function MSG_ABug(BugNumber As Int32, AA As String, BB As String, CC As String) As Int32
            Dim A, B, C As String
            Dim Location As MyPointStructure
            MSG_ABug = 1 ' where all of the error are 
#If MINEDEBUG Then
            FindingMyBugsChangeOfWindows()
#End If
            If FMBRecurse("MSG_ABug") > 5 Then Return MSG_ABug
            If mydebug(9) Then follow(BugNumber, 1, " ERROR-->MSG_ABug : " & MyNoCR(BugNumber.ToString & vbTab & AA & vbTab & BB & vbTab & CC))
            Location = Nothing
            MyUniverse.MyCheatSheet.BugsCounted += 1
            If IsNothing(AA) Then AA = ""
            If IsNothing(BB) Then BB = ""
            If IsNothing(CC) Then CC = ""
            If MyIsNothing(AA.ToString) Then A = "" Else A = AA.ToString
            If MyIsNothing(BB.ToString) Then B = "" Else B = BB.ToString
            If MyIsNothing(CC.ToString) Then C = "" Else C = CC.ToString

            ' removed causes recursion       MyDoEvents(116)
            If IsBitSet(BugNumber) = True Then
                Location.x = 50
                Location.y = 50
                'Windows.Forms.Help.ShowPopup(FlowChartWindow.PictureBox1, "Help on " & BugNumber, MyPointStruct2Point(Location))
                'Windows.Forms.Help.ShowPopup(SymbolWindow.PictureBox1, "Help on " & BugNumber.ToString, MyPointStruct2Point(Location))
                'replaced MsgBoxStyle.YesNoCancel  with 6
                MyBeep()
                Select Case MsgBox(Now().ToString & "====> Bug:" & BugNumber.ToString & vbCrLf & "===a>" & A & vbCrLf & "===b>" & B & vbCrLf & "===c>" & C, MsgBoxStyle.YesNoCancel Or MsgBoxStyle.AbortRetryIgnore, "Yes =Display Help / No = continue / Cancel to ignore this message")

                    Case MsgBoxResult.Yes
                        Windows.Forms.Help.ShowHelp(SymbolWindow, MyUniverse.ProgramOptions.Helpurl, BugNumber.ToString)
                        If FlowChartWindow.Visible = True Then Windows.Forms.Help.ShowHelp(SymbolWindow, MyUniverse.ProgramOptions.Helpurl, HelpNavigator.Find, BugNumber.ToString)
                        If SymbolWindow.Visible = True Then Windows.Forms.Help.ShowHelp(SymbolWindow, MyUniverse.ProgramOptions.Helpurl, HelpNavigator.Find, BugNumber.ToString)
                        If FileInputOutputWindow.Visible = True Then Windows.Forms.Help.ShowHelp(FileInputOutputWindow, MyUniverse.ProgramOptions.Helpurl, HelpNavigator.Find, BugNumber.ToString)
                        If OptionsWindow.Visible = True Then Windows.Forms.Help.ShowHelp(OptionsWindow, MyUniverse.ProgramOptions.Helpurl, HelpNavigator.Find, BugNumber.ToString)
                    Case MsgBoxResult.No
                    Case MsgBoxResult.Cancel
                        BitSet(BugNumber, "off")
                End Select
            Else
                FollowLog(BugNumber, 1, "Bug:" & SHL(A) & SHL(B) & SHL(C))
            End If
            DisplayMyStatus(3, "Bug:" & SHL(A) & SHL(B) & SHL(C))
            Dump3(BugNumber, "Bug:" & vbCrLf & vbTab & HighLight(A) & vbCrLf & vbTab & HighLight(B) & vbCrLf & vbTab & HighLight(C))
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Part of finding internal bugs that I think should never happen (See FindingMyBugs)
        Public Shared Function FindingSymbolOutOfXYSizeBugs(IndexSymbol As Int32) As Int32 ' Checks Symbol record indexSymbol if it is more then the allowed size.(if /point or /line)
            Dim NumberOfNames, NumberOfPoints, NumberOfLines As Int32
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3361, 10, "FindingSymbolOutOfXYSizeBugs")
#End If
            FindingSymbolOutOfXYSizeBugs = 0
            '            Exit Function

            NumberOfNames = 0
            NumberOfPoints = 0
            NumberOfLines = 0
            Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                Case "/name"
                    NumberOfNames += 1
                Case "/line"
                    If MyABS(Symbol_FileX1(IndexSymbol)) > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                        FindingSymbolOutOfXYSizeBugs += MSG_ABug(1830, "FindingMyBugs: The x1 line Symbol is out of bounds at ", IndexSymbol.ToString, Symbol_FileX1(IndexSymbol).ToString)
                        If mydebug(9) Then follow(2519, 3, "Finding Symbol Name Out Of XY Size Bugs")
                    End If
                    If MyABS(Symbol_FileY1(IndexSymbol)) > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                        FindingSymbolOutOfXYSizeBugs += MSG_ABug(1831, "FindingMyBugs: The y1 line Symbol is out of bounds at ", IndexSymbol.ToString, Symbol_FileY1(IndexSymbol).ToString)
                        If mydebug(9) Then follow(2520, 3, "Finding Symbol Name Out Of XY Size Bugs")
                    End If
                    If MyABS(Symbol_FileX2_io(IndexSymbol).MyNumber) > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                        FindingSymbolOutOfXYSizeBugs += MSG_ABug(1832, "FindingMyBugs: The x2 line Symbol is out of bounds at ", IndexSymbol.ToString, Symbol_FileX2_io(IndexSymbol).ToString)
                        If mydebug(9) Then follow(2521, 3, "Finding Symbol Name Out Of XY Size Bugs")
                    End If
                    If MyABS(Symbol_FileY2_dt(IndexSymbol).MyNumber) > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                        FindingSymbolOutOfXYSizeBugs += MSG_ABug(1833, "FindingMyBugs: The y2 line Symbol is out of bounds at ", IndexSymbol.ToString, Symbol_FileY2_dt(IndexSymbol).ToString)
                        If mydebug(9) Then follow(2522, 3, "Finding Symbol Name Out Of XY Size Bugs")
                    End If
                    ' removed not needed ?NumberOfLines += 1
                Case "/point"
                    If MyABS(Symbol_FileX1(IndexSymbol)) > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                        FindingSymbolOutOfXYSizeBugs += MSG_ABug(1834, "FindingMyBugs: The x1 point Symbol is out of bounds at ", IndexSymbol.ToString, Symbol_FileX1(IndexSymbol).ToString)
                        If mydebug(9) Then follow(2523, 3, "Finding Symbol Point Out Of XY Size Bugs")
                    End If
                    If MyABS(Symbol_FileY1(IndexSymbol)) > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                        FindingSymbolOutOfXYSizeBugs += MSG_ABug(1835, "FindingMyBugs: The y1 point Symbol is out of bounds at ", IndexSymbol.ToString, Symbol_FileY1(IndexSymbol).ToString)
                        If mydebug(9) Then follow(2524, 3, "Finding Symbol Point Out Of XY Size Bugs")
                    End If
                    ' removed not needed ?NumberOfPoints += 1
                Case "/unknown"
                    MSG_AInfo1(1836, "Ignoreing unknown code", MyShowSymbolGraphic(True, IndexSymbol), Symbol_TableCoded_String(IndexSymbol))
                Case Else
                    FindingSymbolOutOfXYSizeBugs += MSG_ABug(1837, "FindingMyBugs: Invalid code inthe Symbol table", Symbol_TableCoded_String(IndexSymbol), Symbol_TableCoded_String(IndexSymbol))
            End Select
            If FindingSymbolOutOfXYSizeBugs > 0 Then
                If MyDebug(9) Then follow(2317, 10, Symbol_TableSymbolName(IndexSymbol) & " Number of errors " & FindingSymbolOutOfXYSizeBugs.ToString & " numbedr of points " & NumberOfLines.ToString & FD & NumberOfNames.ToString & FD & NumberOfPoints.ToString & FD & NumberOfLines.ToString)
            End If
            Return FindingSymbolOutOfXYSizeBugs
        End Function



        Public Shared Function MyOptionTest(WhatOption As Int32) As Boolean
            If ProgramBuzzy("Begin") Then Return False
            Return OptionsWindow.CheckedListBoxOptionSelection.GetItemChecked(WhatOption)
        End Function

        'outputs everything into a dump file
        Public Shared Sub Dump2()
#If MINEDEBUG Then
  if mydebug(9) then follow(3362, 10, "Dump2")
#End If
            If mydebug(9) Then follow(2526, 5, "Starting Dump2(" & MyUniverse.MySystem.Dumps.OutputFileName2 & ")")
            If Dir(MyUniverse.MySystem.Dumps.OutputFileName2) <> "" Then
                Kill(MyUniverse.MySystem.Dumps.OutputFileName2)
            End If
            Dumping(False, MyUniverse.MySystem.Dumps.OutputFileName2)
        End Sub 'dump2

        'the routine that dumps to dump2
        'dumps to a new file of normal export then Constants that are changeable
        Public Shared Sub Dumping(expanded As Boolean, FileName As String)
            Dim I As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3363, 10, "Dumping")
#End If
            If mydebug(9) Then follow(2527, 5, "Dumping " & FileNameOnly(FileName))
            Export(expanded, FileName)
            Dump2a(FileName, "/ignore= Parameters")
            Dump2a(FileName, "/ConstantQuote = " & MyUniverse.SysGen.Constants.ConstantQuote & vbCrLf)
            Dump2a(FileName, "/SyntaxQuotes = " & MyUniverse.SysGen.Constants.SyntaxQuotes & vbCrLf)
            '''''''Dump2a(FileName, "/SyntaxVariable = " & MyUniverse.SysGen.Constants.SyntaxVariables & vbCrLf)
            Dump2a(FileName, "/SyntaxNumber = " & MyUniverse.SysGen.Constants.SyntaxNumbers & vbCrLf)
            Dump2a(FileName, "/SyntaxAlpha = " & MyUniverse.SysGen.Constants.SyntaxAlphas & vbCrLf)
            Dump2a(FileName, "/SyntaxSpecialCharacters = " & MyUniverse.SysGen.Constants.SyntaxSpecialCharacters & vbCrLf)
            Dump2a(FileName, "/SyntaxComment = " & MyUniverse.SysGen.Constants.SyntaxComments & vbCrLf)
            Dump2a(FileName, "/ConstantSymbolCenter = " & MyUniverse.SysGen.Constants.ConstantSymbolCenter & vbCrLf)
            Dump2a(FileName, "/ConstantSpacingFactor = " & MyUniverse.SysGen.Constants.ConstantSpacingFactor & vbCrLf)
            Dump2a(FileName, "/ConstantMinPenSize = " & MyUniverse.SysGen.Constants.ConstantMinPenSize & vbCrLf)
            Dump2a(FileName, "/ConstantMaxPenSize = " & MyUniverse.SysGen.Constants.ConstantMaxPenSize & vbCrLf)
            Dump2a(FileName, "/ConstantMinBoxSize = " & MyUniverse.SysGen.Constants.ConstantMinBoxSize & vbCrLf)
            Dump2a(FileName, "/ConstantFirstLineTextOffset = " & MyUniverse.SysGen.Constants.ConstantFirstLineTextOffset & vbCrLf)
            Dump2a(FileName, "/ConstantSecondLineTextOffset = " & MyUniverse.SysGen.Constants.ConstantSecondLineTextOffset & vbCrLf)
            Dump2a(FileName, "/ConstantDistanceBetweenControls = " & MyUniverse.SysGen.Constants.ConstantDistanceBetweenControls & vbCrLf)
            Dump2a(FileName, "/ConstantRecordsBeforeSaveIsAllowed = " & MyUniverse.SysGen.Constants.ConstantRecordsBeforeSaveIsAllowed & vbCrLf)
            Dump2a(FileName, "/ConstantDistanceToMovePaths = " & MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths & vbCrLf)
            Dump2a(FileName, "/ConstantSpecialCharacters = " & MyUniverse.SysGen.Constants.ConstantSpecialCharacters & vbCrLf)
            '    Dump2a(FileName, "/ConstantWhiteSpace = " & MyUniverse.SysGen.Constants.ConstantWhiteSpaces & vbCrLf)
            Dump2a(FileName, "/ConstantDelimiters = " & MyUniverse.SysGen.Constants.ConstantDelimiters & vbCrLf)
            Dump2a(FileName, "/SyntaxCameFromLine = " & MyUniverse.SysGen.Constants.SyntaxCameFromLine & vbCrLf)
            Dump2a(FileName, "/ConstantGo_Tonextlin = " & MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine & vbCrLf)
            Dump2a(FileName, "/route=tries to connect all paths with the same name " & vbCrLf)
            Dump2a(FileName, "/ignore= " & MyUniverse.MySS.Inputs.KPar & vbCrLf)
            Dump2a(FileName, "/FormatSet = " & FormatSet_ & vbCrLf)
            Dump2a(FileName, "/option " & FormatOption & vbCrLf)
            Dump2a(FileName, "/FCCL_case = " & vbCrLf)
            Dump2a(FileName, "/FCCL_multiline = " & MyUniverse.ProgramOptions.FCCL_MultiLine & vbCrLf)
            Dump2a(FileName, "/FCCL_comment = " & MyUniverse.ProgramOptions.FCCL_Comment & vbCrLf)
            Dump2a(FileName, "/FCCL_Extension = " & MyUniverse.ProgramOptions.FCCL_Extension & vbCrLf)
            Dump2a(FileName, "/FCCL_varchars= " & MyUniverse.ProgramOptions.FCCL_VarChars & vbCrLf)
            Dump2a(FileName, "/FCCL_DialectName = " & MyUniverse.ProgramOptions.FCCL_DialectName & vbCrLf)
            Dump2a(FileName, "/syntaxGo_Tonextline = " & MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine & vbCrLf)
            Dump2a(FileName, "/syntaxCameFromline = " & MyUniverse.SysGen.Constants.SyntaxCameFromLine & vbCrLf)
            Dump2a(FileName, "/FCCL_process = " & MyUniverse.ProgramOptions.FCCL_Process & vbCrLf)
            Dump2a(FileName, "/FormatColor = " & formatColor & vbCrLf)
            Dump2a(FileName, "/FormatDataType = " & formatDataType & vbCrLf)
            Dump2a(FileName, "/FormatPoint = " & formatPoint & vbCrLf)
            Dump2a(FileName, "/FormatLine = " & formatLine & vbCrLf)
            Dump2a(FileName, "/FormatPath = " & formatPath & vbCrLf)
            Dump2a(FileName, My_keyWord(My_KeyConstUse) & " =" & formatUse & vbCrLf)
            Dump2a(FileName, "/FormatMicrocodetext = " & FormatMacroText & vbCrLf)
            Dump2a(FileName, "/FormatSyntax = " & FormatSyntax & vbCrLf)
            Dump2a(FileName, "/Formatorder = " & FormatOrder & vbCrLf)
            Dump2a(FileName, "/order = " & MyUniverse.SysGen.Order & vbCrLf)
            Dump2a(FileName, "/FormatFilename = " & formatNameOfFile & vbCrLf)
            Dump2a(FileName, "/Formatlanguage = " & formatLanguage & vbCrLf)
            Dump2a(FileName, "/Formatstroke = " & formatStroke & vbCrLf)
            Dump2a(FileName, "/Formatnotes = " & formatNotes & vbCrLf)
            Dump2a(FileName, "/version = " & formatVersion & vbCrLf)
            Dump2a(FileName, "/author = " & formatAuthor & vbCrLf)
            Dump2a(FileName, "/opcode = " & formatOpcode & vbCrLf)
            Dump2a(FileName, "/Constant = " & formatConstant & vbCrLf)
            Dump2a(FileName, "/error = " & FormatError & vbCrLf)
            Dump2a(FileName, "/delete = " & FormatDelete & vbCrLf)
            Dump2a(FileName, "/keyword = " & FormatLanguage_KeyWord & vbCrLf)
            Dump2a(FileName, "/operator = " & FormatLanguage_Operator & vbCrLf)
            Dump2a(FileName, "/function = " & FormatLanguage_Function & vbCrLf)
            Dump2a(FileName, "/function = " & FormatLanguage_Grammar & vbCrLf) 'todo need to fix this one day
            Dump2a(FileName, "/finish" & vbCrLf)
            Dump2a(FileName, "/formatSet " & FormatSet_ & vbCrLf)
            For I = 0 To UBound(MyUniverse.MySymbolPoints)
                Dump2a(FileName, "/set=points," & I.ToString & FD & MyUniverse.MySymbolPoints(I).x & FD & MyUniverse.MySymbolPoints(I).y & vbCrLf)
            Next I
            For I = 0 To MyUniverse.OptionDisplay.Count - 1
                Dump2a(FileName, "/set=text," & MyUniverse.OptionDisplay(I).x.ToString & FD & MyUniverse.OptionDisplay(I).y.ToString & FD & MyUniverse.OptionDisplay(I).Textwidth.ToString & FD & MyUniverse.OptionDisplay(I).Textheight.ToString & FD & MyUniverse.OptionDisplay(I).ColorName & vbCrLf)
            Next I
            For I = 0 To OptionsWindow.CheckedListBoxOptionSelection.Items.Count - 1
                Dump2a(FileName, "/set=options," & I.ToString & FD & OptionsWindow.CheckedListBoxOptionSelection.Items(I).ToString & vbCrLf)
            Next I

            Dump2a(FileName, "/set=delimiters," & AddRM(FD) & vbCrLf)
            'Dump2a(FileName, "/set=language,name of language to add to the list box, which will be useless."
            Dump2a(FileName, "/set=scale," & Int(MyUniverse.SysGen.MyFlowChartScale * 1000).ToString & vbCrLf)
            Dump2a(FileName, "/ignore= format of set=Grids,snap=1-10,point snap =1-250, Symbol snap 1-10000, Symbol column snap 500-2500" & vbCrLf)
            Dump2a(FileName, "/set=Grids," & MyUniverse.SysGen.Snaps.MySnap.ToString & FD & MyUniverse.SysGen.Snaps.MyPointSnap.ToString & FD & MyUniverse.SysGen.Snaps.MySymbolSnap.ToString & vbCrLf)
            Dump2a(FileName, "/set=dump," & MyUniverse.MySystem.Dumps.OutputFileName1 & FD & MyUniverse.MySystem.Dumps.OutputFileName2 & FD & MyUniverse.MySystem.Dumps.OutputFileName3 & vbCrLf)
        End Sub

        'dumping() uses to output each line/blocks(multilines) of exporting
        Public Shared Sub Dump2a(FileName As String, SaveString As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3364, 10, "Dump2a ")
#End If
            If mydebug(9) Then follow(2528, 10, "Dump2a " & FileName)
            If ProgramBuzzy("Alive") Then 'hack texting to make sure that the checked list box is valid
                If MyOptionTest(30) = True Then
                    System.IO.File.AppendAllText(FileName, SaveString & vbCrLf)
                End If
            End If
        End Sub

        'This is writting out lines of what is happening, so that when (not if) it dies, you can see where it died at.
        Public Shared Sub Dump3(BugNumber As Int32, ErrorMessage As String) ' Dump every possible issues to a saved file 
#If MINEDEBUG Then
  if mydebug(9) then follow(3365, 10, "Dump3")
#End If
            If ProgramBuzzy("Begin") Then
                FollowLog(BugNumber, 11, "Startup: " & ErrorMessage)
                DoThisEvent(2912)
                Return  'hack texting to make sure that the CheckedList box is valid
            End If
            If MyOptionTest(30) = True Then
                If MyDebug(3) = True Then If mydebug(9) Then follow(BugNumber, 3, "Dump3 " & vbTab & MyNoCR(ErrorMessage))
            End If
            ' removed, shown in Follow above            System.Diagnostics.Debug. Write(ErrorMessage & vbCrLf)
        End Sub 'dump3

        Public Shared Sub Dump1() ' Dumping only the Symbol table for Debugging ' extra
            Dim LocalIndex As Int32
            Dim MyWriter As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3366, 10, "Dump1")
#End If
            If mydebug(9) Then follow(2530, 5, "Dump1")
            If Dir(MyUniverse.MySystem.Dumps.OutputFileName1) <> "" Then
                Kill(MyUniverse.MySystem.Dumps.OutputFileName1)
            End If
            'Using Writer As System.IO.StreamWriter = System.IO.File.CreateText(MyUniverse.MySystem.Dumps.OutputFileName1)
            MyWriter = FreeFile()
            FileOpen(MyWriter, MyUniverse.MySystem.Dumps.OutputFileName1, OpenMode.Output, OpenAccess.Write, OpenShare.LockReadWrite, -1)
            'End Using
            'Else
            '    Using Writer As System.IO.StreamWriter = System.IO.File.CreateText(MyUniverse.MySystem.Dumps.OutputFileName1)
            'End Using
            '    End If

            'Using Writer As System.IO.FileStream = System.IO.File.OpenWrite(MyUniverse.MySystem.Dumps.OutputFileName1)
            For LocalIndex = 1 To TopOfFile("Named")
                WriteLine(MyWriter, MyShowNamedRecords(True, LocalIndex))
            Next
            For LocalIndex = 1 To TopOfFile("Symbol")
                WriteLine(MyWriter, MyShowSymbolGraphic(True, LocalIndex))
            Next LocalIndex
            For LocalIndex = 1 To TopOfFile("FlowChart")
                WriteLine(MyWriter, MyShowFlowChartRecord(True, LocalIndex))
            Next

            FileClose(MyWriter)
            'End Using

        End Sub 'dump1





        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'todo need to add the button rules here
        'This is to clear the message text 
        Public Shared Function ButtonStarted(ButtonName As String) As Boolean ' Make sure that no more than X number of buttons deep (or stack over flow)
#If MINEDEBUG Then
  if mydebug(9) then follow(3367, 10, "ButtonStarted")
#End If
            If MyDebug(9) = True Then If mydebug(9) Then follow(2532, 9, "Button Started " & ButtonName)
            If MyUniverse.SysGen.NumberOfButtonsActive > 88 Then
                'todo turn off all button rules
                Return False ' can not do any more buttons
            End If

            MyUniverse.SysGen.NumberOfButtonsActive += 1
            Return True
        End Function 'Button Started

        Public Shared Function ButtonFinished(ButtonName As String) As Boolean  ' Make sure that no more than X number of buttons deep (or stack over flow)
#If MINEDEBUG Then
  if mydebug(9) then follow(3368, 11, "ButtonFinished")
#End If
            If MyDebug(9) = True Then If mydebug(9) Then follow(2533, 9, "Finished Button>" & ButtonName & "<")
            MyUniverse.SysGen.NumberOfButtonsActive -= 1
            If MyUniverse.SysGen.NumberOfButtonsActive < 0 Then
                'todo needs to add to the dump the button list of buttons currently active.
                MyBeep()
                MsgBox("Program data error Button pushes counted wrongly needs to report what report", MsgBoxStyle.OkOnly)
            End If
            'reset all button rules if all turned off
            'MyButtonsEnableRules()
            Return True ' toto for now All finished buttons worked and stopped
        End Function

        Public Shared Sub ClearSymbolDisplay() 'used to display nothing (over the status messages
#If MINEDEBUG Then
  if mydebug(9) then follow(3369, 10, "ClearSymbolDisplay")
#End If
            If mydebug(9) Then follow(2534, 5, "ClearDisplay ")
            MyUniverse.ProgramOptions.SymbolChanged = False ' Nothing has change from nothing
            SymbolWindow.TextBoxNamedSymbolName.Text = ""
            'SymbolWindow.TextBoxNamedDescription.Text = ""
            SymbolWindow.TextBoxNamedNameOfFile.Text = ""
            SymbolWindow.TextBoxNamedNotes.Text = ""
            SymbolWindow.TextBoxNamedOpCode.Text = ""
            SymbolWindow.TextBoxNamedStroke.Text = ""
            SymbolWindow.TextBoxNamedSyntax.Text = ""
            SymbolWindow.TextBoxNamedProgramText.Text = ""
            SymbolWindow.TextBoxSymbolVersionAuthor.Text = ""
        End Sub

        Public Shared Sub DisplaySymbolText(SymbolName As String)
            Dim IndexNamed, IndexSymbol As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3370, 10, "DisplaySymbolText")
#End If
            If mydebug(9) Then follow(2535, 5, "SymbolName " & SymbolName)
            IndexNamed = FindIndexInISAMTable("Named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, SymbolName)
            If IndexNamed = ConstantMyErrorCode Then
                MSG_ABug(1846, "Did not find Symbol name " & HighLight(SymbolName), "", "")
                ClearSymbolDisplay()
            End If
            FindingMyBugs(100)
            IndexSymbol = GetSelfCorrectingIndexes(SymbolName)
            If IndexSymbol = ConstantMyErrorCode Then
                MSG_ABug(1847, "There is no Symbol graphics", "", "")
                ClearSymbolDisplay()
            End If
            If Named_TableSymbolName(IndexNamed) <> SymbolName Then
                MSG_ABug(1848, "Looking for Symbol NameOf " & HighLight(SymbolName), "Error Integer finding the symname ", Named_TableSymbolName(IndexNamed))
            End If

            FindingMyBugs(100)
            SymbolWindow.TextBoxNamedSymbolName.Text = Named_TableSymbolName(IndexNamed)
            FindingMyBugs(100)
            SymbolWindow.TextBoxNamedNameOfFile.Text = Named_TableNameofFile(IndexNamed)
            FindingMyBugs(100)
            SymbolWindow.TextBoxNamedNotes.Text = Named_TableNotes(IndexNamed)
            FindingMyBugs(100)
            SymbolWindow.TextBoxNamedOpCode.Text = Named_TableOpCode(IndexNamed)
            FindingMyBugs(100)
            SymbolWindow.TextBoxNamedStroke.Text = Named_TableStroke(IndexNamed)
            FindingMyBugs(100)
            SymbolWindow.TextBoxNamedSyntax.Text = Named_TableSyntax(IndexNamed)
            FindingMyBugs(100)
            SymbolWindow.TextBoxNamedProgramText.Text = Named_TableMicroCodeText(IndexNamed)
            FindingMyBugs(100)
            SymbolWindow.TextBoxSymbolVersionAuthor.Text = Named_TableAuthor(IndexNamed)
            FindingMyBugs(100)
            'todo need to check that the name is matching.
            IndexSymbol += 1 'jump after the name
            SymbolWindow.ComboBoxLineNameList.Items.Clear()
            SymbolWindow.ComboBoxPointNameList.Items.Clear()
            While Symbol_TableCoded_String(IndexSymbol) <> "/Name" And IndexSymbol <= TopOfFile("Symbol")
                FindingMyBugs(100)
                Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                    Case "/name"
                        Return
                    Case "/point" ' Add to point list
                        FixSyntaxCode(IndexNamed)
                        AddPointNameToDropDownX(Symbol_Table_NameOfPoint(IndexSymbol) + FD + MyShowSymbolRecords(True, IndexSymbol))
                        FindingMyBugs(100)
                    Case "/line" ' Add to line list
                        AddLineNameToDropDown(Symbol_Table_NameOfPoint(IndexSymbol))
                        FindingMyBugs(100)
                End Select
                IndexSymbol += 1
                FindingMyBugs(100)
            End While
            FindingMyBugs(100)
        End Sub


        Public Shared Sub DisplayStatus(ByRef StatusBox As ToolStripLabel, Status_Message As String) 'used to show what is currently happening. (also slows down the system. 
            Dim Temp As String
            If ProgramBuzzy("Begin") Then Return
            Static LastTemp As String = ""
            Static LastStatusBox As ToolStripLabel
#If MINEDEBUG Then
  if mydebug(9) then follow(3371, 10, "DisplayStatus " & Status_Message)
#End If
            If ProgramBuzzy("Begin") Then Return
            If IsNothing(MyUniverse.MyStaticData.Hints) Then Return
            If MyIsNothing(MyUniverse.MyStaticData.Hints.ToString) Then Return
            If FMBRecurse("DisplayStatus") > 5 Then Return
            If IsNothing(LastStatusBox) Then LastStatusBox = StatusBox
            'todo Temp = SplashWindow.LabelExpireDate.Text & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.MyStaticData.Hints(0) & Status_Message
            Temp = SplashWindow.Text & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.MyStaticData.Hints(0) & Status_Message
            If Temp = LastTemp And LastStatusBox.Name = StatusBox.Name Then Return 'do not update if the same
            LastTemp = Temp
            LastStatusBox = StatusBox

            If Len(Status_Message) = 0 Then
                Temp = ""
            End If
            If Temp <> "" And InStr(StatusBox.Text, Temp) <> 0 Then
                If mydebug(9) Then follow(2536, 6, "Display Status: NOT UPDATED " & HighLight(StatusBox.Text) & Status_Message)
                Return
            End If
            If Status_Message = "" Then
                If MyDebug(5) = True Then If mydebug(9) Then follow(2537, 5, "Display Status: Clear" & HighLight(StatusBox.Text) & Status_Message)
                'return
            End If
            If Len(Status_Message) > 120 Then
                If mydebug(9) Then follow(2539, 3, "Display Status: message to large " & Status_Message)
            End If
            StatusBox.Text = Temp
        End Sub





        'If the passed index is zero, then those function can not/are not checked
        Public Shared Function FindingMyBugsCheckForErrors(IndexFlowChart As Int32, IndexNamed As Int32, IndexSymbol As Int32) As Int32
            Dim BitFlagNamed, CDex As Int32
            Dim I, J, K, ZZ As Int32
            Dim DataType, PointName, Syntax, Temp As String
            Dim MyXY As MyPointStructure = Nothing
            Dim MyArray(256) As String
            FindingMyBugsCheckForErrors = 0
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3372, 10, "FindingMyBugsCheckForErrors")
#End If
            'turned off
            If MyOptionTest(31) = False Then
                FindingMyBugsCheckForErrors += 1
                Exit Function
            End If
            'nothing to check
            If IndexFlowChart = 0 And IndexNamed = 0 And IndexSymbol = 0 Then
                FindingMyBugsCheckForErrors += 1
                Exit Function
            End If




            'check Symbol index first
            If IndexSymbol > 0 And IndexNamed > 0 Then
                CDex = IndexSymbol
                While CDex > 0 And Symbol_TableCoded_String(CDex) <> "/name"
                    'find the beginning of the Symbolgraphics
                    If Named_TableSymbolName(IndexNamed) <> Symbol_TableSymbolName(CDex - 1) Then
                        FindingMyBugsCheckForErrors += MSG_ABug(1860, "Finding My Bugs:  Checking Symbol vs graphics indexs " & CDex.ToString, Symbol_TableCoded_String(CDex), Symbol_TableSymbolName(CDex))
                    End If ' check back one more
                    CDex -= 1 ' back up to the nead of the Symbol
                End While
            End If

            If IndexNamed > 0 And CDex > 0 Then
                'are we on the Symbol still?
                If Named_TableSymbolName(IndexNamed) <> Symbol_TableSymbolName(CDex) Then
                    MSG_ABug(3456, "FMB: named index not on the Symbol index", MyShowNamedRecords(False, IndexNamed), MyShowSymbolGraphic(False, CDex))
                    Dump2()
                    FindingMyBugsCheckForErrors += MSG_ABug(1861, "FindingMyBugsCheckForErrors()index to name of Symbol does not match the sybol name of the index to the graphics " & vbCrLf & Named_TableSymbolName(IndexNamed) & vbTab & Symbol_TableSymbolName(CDex), vbCrLf & IndexNamed.ToString & vbTab & MyShowNamedRecords(False, IndexNamed), vbCrLf & CDex.ToString & vbTab & MyShowSymbolRecords(False, CDex))
                    'B dex = IndexNamed
                End If
            End If
            CDex += 1 ' move off of the name

            'loop through this Symbol graphics
            While CDex <= TopOfFile("Symbol") And Symbol_TableCoded_String(CDex) <> "/name"
                If Symbol_TableCoded_String(CDex) = "/point" Then
                    '1010 All Points have a valid DataType
                    Temp = Symbol_Table_DataType(CDex)
                    FindingMyBugsDataType(CDex)
                    'DataType = MyUnEnum(J, SymbolWindow.ToolStripDropDownButtonPointDataType)
                    J = FindIndexInISAMTable("DataType", "DoNotAdd", DataType_FileName, DataType_Name_ISAM, Temp)
                    If J >= 0 And J < UBound(DataType_FileName) Then
                        DataType = DataType_FileName(J)
                    Else
                        FindingMyBugsCheckForErrors += 1
                        DataType = "Errored"
                        MSG_ABug(1862, "Invalid DataType ", Temp, "")
                    End If

                    I = FindIndexInISAMTable("DataType", "DoNotAdd", DataType_FileName, DataType_Name_ISAM, DataType)
                    If I = ConstantMyErrorCode Then
                        FindingMyBugsCheckForErrors += MSG_ABug(1863, "Invalid DataType in Symbol " & MyShowSymbolRecords(False, CDex) & ", " & FindSymbolName(IndexSymbol), "DataType set to Errored " & HighLight(DataType), J.ToString)
                        MyFlowChartErrors(1010, 0, 0, IndexSymbol, " Symbol " & HighLight(FindSymbolName(IndexSymbol)))
                        '1011 All DataType have a valid Color
                        ' removed not used ?  DataType = "Errored" 'todo this is ABug that needs to be fixed
                    ElseIf I >= 0 Then
                        J = FindIndexInISAMTable("Color", "DoNotAdd", Color_FileName, Color_Name_ISAM, DataType_Color(I))
                        If J = ConstantMyErrorCode Then
                            FindingMyBugsCheckForErrors += MSG_ABug(1864, "invalid Color for DataType ", DataType, DataType_Color(I))
                            MyFlowChartErrors(1011, 0, 0, IndexSymbol, " DataType " & DataType)
                        End If
                    Else
                        If mydebug(9) Then follow(3457, 1, "Should never get here program error ")
                    End If
                    'todo not tested for yet
                    '1012 All Colors are valid (in MicroSoft, they can only be the assigned colors, and are 'switched if wrong) ?

                    '1013 All /point names are in either the MicroCodeText or the Syntax
                    PointName = Symbol_Table_NameOfPoint(CDex)

                    'todo We need a better check for what this should be checking 2020 09 13
                    Select Case LCase(IsThisAWhat(Symbol_Table_NameOfPoint(CDex)))
        'Case MyUniverse.SysGen.Constants.SyntaxVariables
        '    If InStr(Named_TableSyntax(IndexNamed),
        '     MyUniverse.SysGen.Constants.RMStart & NameOfPointOnly(Symbol_Table_NameOfPoint(CDex) & ".")) = 0 Then
        '    MSG_AInfo(1865, " Variable " & AddRM(Symbol_Table_NameOfPoint(CDex)) & "." & " Not found in program code text ",
        '  Named_TableSyntax(IndexNamed), NameOfPointOnly(Symbol_Table_NameOfPoint(CDex)) & ".")
        ' 'MyFlowChartErrors(1013, 0, 0, CDex, " Symbol " & FindSymbolName(IndexSymbol))
        ' Named_TableMicroCodeText(IndexNamed, Named_TableMicroCodeText(IndexNamed) & vbCrLf & MyUniverse.ProgramOptions.FCCL_MultiLine &' MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.SysGen.Constants.RMStart & Symbol_Table_NameOfPoint(CDex) & ".pathname" & MyUniverse.SysGen.Constants.RMEnd)
        'Else
        '    if mydebug(4) then  follow(2289, "Stop here and fix it " & vbCrLf & Named_TableSyntax(IndexNamed) & vbCrLf & MyUniverse.SysGen.Constants.RMStart & vbCrLf & NameOfPointOnly(Symbol_Table_NameOfPoint(CDex) & "."))
        'End If
                        Case MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine
                        Case MyUniverse.SysGen.Constants.SyntaxCameFromLine
                        Case MyUniverse.SysGen.Constants.SyntaxQuotes
                        Case MyUniverse.SysGen.Constants.SyntaxComments
                        Case MyUniverse.SysGen.Constants.SyntaxKeyWords
                        Case MyUniverse.SysGen.Constants.SyntaxFunctions
                        Case MyUniverse.SysGen.Constants.SyntaxOperators
                        Case MyUniverse.SysGen.Constants.SyntaxNumbers
                        Case MyUniverse.SysGen.Constants.SyntaxAlphas
                        Case MyUniverse.ProgramOptions.FCCL_MultiLine
                        Case MyUniverse.ProgramOptions.FCCL_Comment
                        Case MyUniverse.ProgramOptions.FCCL_Extensions
                        Case MyUniverse.ProgramOptions.FCCL_VarChars
                        Case MyUniverse.SysGen.Constants.SyntaxSpecialCharacters
                        Case MyUniverse.SysGen.Constants.SyntaxUnknowns
                        Case Else ' does not need a marker
                            If InStr(PointName, MyUniverse.SysGen.Constants.SyntaxCameFromLine) <> 0 Then
                                MSG_AInfo1(1866, "This is a Go_ToNextLine line marker  ", Symbol_Table_NameOfPoint(CDex), PointName)
                            ElseIf InStr(PointName, MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine) <> 0 Then
                            ElseIf IsThISAMarker2(Symbol_Table_NameOfPoint(CDex)) <> "" Then
                                MSG_AInfo1(1867, "This is a variable name ", Symbol_Table_NameOfPoint(CDex), "")
                            ElseIf IsThisAVariableName(Symbol_Table_NameOfPoint(CDex)) Then
                                MSG_AInfo(2117, "Making this a variable name", Symbol_Table_NameOfPoint(CDex), "")
                            Else
                                MSG_ABug(1868, " This is not a variable name", Symbol_Table_NameOfPoint(CDex), IsThisAWhat(Symbol_Table_NameOfPoint(CDex)))
                            End If
                    End Select
                End If
                CDex += 1
            End While ' looping through the Symbol
            '1014 No Duplicate /point names

            'Check for the named possible errors
            If IndexNamed > 0 Then
                BitFlagNamed = 0
                'CDex = 0
                If InStr(MyUniverse.SysGen.Constants.SyntaxCameFromLine, Named_TableSyntax(IndexNamed)) = 0 Then
                    BitFlagNamed = BitFlagNamed Or 2 ' has a come from in the syntax (even if remarked out
                End If
                If InStr(MyUniverse.SysGen.Constants.SyntaxGo_ToNextLine, Named_TableSyntax(IndexNamed)) = 0 Then
                    BitFlagNamed = BitFlagNamed Or 4 ' has a come from in the syntax ...
                End If
                Select Case BitFlagNamed
                    Case 2
                        '1002 Symbol does not have a /point Go_ToNextLine
                        MyFlowChartErrors(1002, 0, 0, CDex, " Symbol " & FindSymbolName(IndexSymbol))
                        FindingMyBugsCheckForErrors += 1
                    Case 4
                        '1001 Symbol does not have a /point CameFromLine
                        MyFlowChartErrors(1001, 0, 0, CDex, " Symbol " & FindSymbolName(IndexSymbol))
                        FindingMyBugsCheckForErrors += 1
                    Case 6 ' It has them both so this error is ok
                    Case Else
                        MSG_AInfo(1856, "Error bits ", BitFlagNamed.ToString, MyShowNamedRecords(True, IndexNamed))
                        FindingMyBugsCheckForErrors += 1
                End Select 'checking if the Symbol has CameFromLine and a Go_ToNextLine
            End If


            '1006 That all of the point names are in the syntax
            If Named_TableSyntax(IndexNamed) = "" Then
                MSG_ABug(1869, "empty syntax", IndexNamed.ToString, "")
                If Named_TableMicroCodeText(IndexNamed) <> "" Then ' Can we make the syntax from the code line?
                    MyUniverse.MyStaticData.Path_Names = MyParse(MyArray, Named_TableMicroCodeText(IndexNamed))
                    MyUniverse.MyStaticData.Path_NamesCounted = CountPathNames(MyUniverse.MyStaticData.Path_Names)
                    Syntax = MakeStatementSyntax(MyArray)
                    '1015 No Syntax and No Program Code to make it from
                    'MyFlowChartErrors(1015, 0, IndexNamed, 0, " Symbol " & Named_TableSymbolName(IndexNamed)) ' issue with Named only
                End If
                MyFlowChartErrors(1006, IndexFlowChart, IndexNamed, IndexSymbol, " Symbol " & FindSymbolName(IndexSymbol))
            End If
            '1007 That the syntax matches the program text.
            '1008 Make sure that the point names are in the point list


            ' Check Path
            If IndexFlowChart > 0 Then
                '1009 All paths must have at least one output or Constant
                Select Case LCase(FlowChart_TableCode(IndexFlowChart))
                        'todo this is not checking paths, it only referances the XY of the Symbol
                    Case My_keyWord(My_KeyConstUse)
                        MyXY.x = FlowChart_TableX1(IndexFlowChart)
                        MyXY.y = FlowChart_TableY1(IndexFlowChart)
                        K = MyFindSymbolPoint(MyXY, FlowChart_TableSymbol_Name(IndexFlowChart))
                        If K = ConstantMyErrorCode Then
                            'todo need to add this FindAllPointsOnSymbol(IndexFlowChart)
                            For ZZ = 1 To TopOfFile("Named")
                                If FlowChart_TableSymbol_Name(IndexFlowChart) = Named_TableSymbolName(ZZ) Then
                                    'do not need to know when it works. :) MSG_AInfo(1870, "FMB:Found the Symbol Named ", FlowChart_TableSymbol_Name(IndexFlowChart), MyShowNamedRecords(False, ZZ))
                                    Exit Select
                                End If
                            Next
                            MSG_ABug(1871, "FMB:Unable to find the /USE Name ", FlowChart_TableSymbol_Name(IndexFlowChart), MyShowPoint(MyXY) & MyShowFlowChartRecord(False, IndexFlowChart))
                        End If
                    Case "/path"
                        MyXY.x = FlowChart_TableX1(IndexFlowChart)
                        MyXY.y = FlowChart_TableY1(IndexFlowChart)
                        K = MyFindPoint(FlowChartWindow.PictureBox1, MyXY, IndexFlowChart)
                        If K = ConstantMyErrorCode Then
                            MSG_ABug(1872, "Unable to find the Symbol XY ", FlowChart_TablePath_Name(IndexFlowChart), MyShowPoint(MyXY))
                        End If
                    Case "/Constant"
                    Case "/error"
                    Case Else
                End Select
                '1003 output on Symbol goes to two or more places (A Symbol can come from many places, but can only Go_To one place)
                '1004 Points of a Symbol is not connected to any path
                '1005 Paths are not connected to any Symbol or Constant - they must all connect to both ends to Symbol or another path, or a Constant
            End If
        End Function


        Public Shared Sub MyFlowChartErrors(ErrNumber As Int32, IndexFlowChart As Int32, IndexNamed As Int32, IndexSymbol As Int32, ErrMsg As String) 'checking for all of the errors with all of the flow chart records.
            Dim MyXY As MyPointStructure = Nothing
            Dim WhatDoIDoWithThis As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3373, 10, "MyFlowChartErrors")
#End If
            If mydebug(9) Then follow(2538, 5, "Errors " & ErrNumber.ToString)
            'from the indexs tells where to put the error
            WhatDoIDoWithThis = MyMinMax(IndexFlowChart, 0, 1) & MyMinMax(IndexNamed, 0, 1) & MyMinMax(IndexSymbol, 0, 1)
            Select Case WhatDoIDoWithThis
                Case "000" ' No Indexes, 
                    MyXY.x = 0
                    MyXY.y = 0
                    MakeErrorAt(SymbolWindow.PictureBox1, MyXY, MyErrorList(ErrNumber - 1001) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & ErrMsg)
                    MyXY.x = 1000
                    MyXY.y = 1000
                    MakeErrorAt(FlowChartWindow.PictureBox1, MyXY, MyErrorList(ErrNumber - 1001) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & ErrMsg)
                Case "001" 'Symbol Index Only (you must be on SymbolWindow)
                    MyXY.x = Symbol_TableX1(IndexSymbol) ' Assume it is a Symbol
                    MyXY.y = Symbol_TableY1(IndexSymbol)
                    MakeErrorAt(SymbolWindow.PictureBox1,
        MyXY,
        MyErrorList(ErrNumber - 1001) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & ErrMsg)
                Case "010" 'Named Index Only (you must be on SymbolWindow)
                    MyXY.x = Symbol_TableX1(IndexSymbol) ' Assume it is a Symbol
                    MyXY.y = Symbol_TableY1(IndexSymbol)
                    MakeErrorAt(SymbolWindow.PictureBox1, MyXY, MyErrorList(ErrNumber - 1001) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & ErrMsg)
                Case "011" 'Named and Symbol Index (you must be on SymbolWindow)
                    MyXY.x = Symbol_TableX1(IndexSymbol) ' Assume it is a Symbol
                    MyXY.y = Symbol_TableY1(IndexSymbol)
                    MakeErrorAt(SymbolWindow.PictureBox1, MyXY, MyErrorList(ErrNumber - 1001) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & ErrMsg)
                Case "100" 'FlowChart index only (you must be on FlowChartWindow)
                    MyXY.x = FlowChart_TableX1(IndexFlowChart) + Symbol_TableX1(IndexSymbol) ' Assume it is a Symbol
                    MyXY.y = FlowChart_TableY1(IndexFlowChart) + Symbol_TableY1(IndexSymbol)
                    MakeErrorAt(FlowChartWindow.PictureBox1, MyXY, MyErrorList(ErrNumber - 1001) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & ErrMsg)
                Case "101" 'FlowChart and Symbol index (you must be on FlowChartWindow)
                    MyXY.x = FlowChart_TableX1(IndexFlowChart) + Symbol_TableX1(IndexSymbol) ' Assume it is a Symbol
                    MyXY.y = FlowChart_TableY1(IndexFlowChart) + Symbol_TableY1(IndexSymbol)
                    MakeErrorAt(FlowChartWindow.PictureBox1, MyXY, MyErrorList(ErrNumber - 1001) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & ErrMsg)
                Case "110" 'FlowChart and Named (you must be on FlowChartWindow)
                    MyXY.x = FlowChart_TableX1(IndexFlowChart) + Symbol_TableX1(IndexSymbol) ' Assume it is a Symbol
                    MyXY.y = FlowChart_TableY1(IndexFlowChart) + Symbol_TableY1(IndexSymbol)
                    MakeErrorAt(FlowChartWindow.PictureBox1, MyXY, MyErrorList(ErrNumber - 1001) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & ErrMsg)
                Case "111" 'FlowChart, Named, Symbol (you must be on FlowChartWindow)
                    MyXY.x = FlowChart_TableX1(IndexFlowChart) + Symbol_TableX1(IndexSymbol) ' Assume it is a Symbol
                    MyXY.y = FlowChart_TableY1(IndexFlowChart) + Symbol_TableY1(IndexSymbol)
                    MakeErrorAt(FlowChartWindow.PictureBox1, MyXY, MyErrorList(ErrNumber - 1001) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & ErrMsg)
            End Select

        End Sub


        ' This will highlight the button that is the current mode.
        Public Shared Sub MySetToolStripHighlight(a As ToolStripButton, Cmd As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(3374, 10, "MySetToolStripHighLight")
#End If
            If MyUniverse.SysGen.Constants.MyCmdModeString = Cmd Then
                a.BackColor = SystemColors.Highlight
            Else
                a.BackColor = SystemColors.Control
            End If
        End Sub


        Public Shared Sub MySetButtonEnable(HintNumber As Int32, A As ToolStripButton, B As Boolean, Because As String)
#If MINEDEBUG Then
            If MyDebug(10) = True Then if mydebug(9) then follow(3375, 10, "MySetButtonEnable")
#End If
            If MyDebug(8) = True Then
                If B = True Then
                    If mydebug(9) Then follow(2540, 8, HintNumber.ToString & FD & A.Name & "ButtonEnable Because: " & Because)
                Else
                    If mydebug(9) Then follow(2541, 8, HintNumber.ToString & FD & A.Name & "Button disabled Because: " & Because)
                End If
            End If
            Select Case A.Name
                Case Nothing
                    MSG_ABug(1874, "Does not have a toolstrip button name " + MyShowButton(A), "", "")
            End Select
            A_Hint(HintNumber, "", A.Name, Because)
            If A.Enabled = B Then
                Return
            Else
                A.Enabled = B
            End If
        End Sub



        Public Shared Sub MysetDropDownButtonEnable(HintNumber As Int32, A As ToolStripDropDownButton, B As Boolean, Because As String)
#If MINEDEBUG Then
  if mydebug(9) then follow(2542, 9, "My Set Drop Down Button Enabled " & HintNumber.ToString & ", " & A.Name & ", " & Because)
#End If
            If A.Enabled = B Then
                Return
            Else
                A.Enabled = B
            End If
        End Sub


        'right now I am only testing if it is not zero, then I apply the rules to return true if the condition is true or false if not
        Public Shared Sub MyButtonsEnableRules()
#If MINEDEBUG Then
  if mydebug(9) then follow(3377, 10, "MyButtonsEnableRules")
#End If
            'Dim ax As Int32
            ' removed to stop _paint Mydoevents(208)
            'ax = 0
            'todo  I am using the Window , but I should have that data defined in MuUniverse.programoptions.
            'missing rules.
            'You can not display the FlowChart Window if there is no Symbols.

            'Test when one required rule fails, other wise do all of the rules asked for (by non-zero means it has to be visible or enable or has text in it.
            'rule 999, change no button while the splash Window is displayed
            If ProgramBuzzy("Begin") Then
                A_Hint(-999, "Splash", "No buttons", "Program not alive yet")
                Return
            End If
            '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            'Now Symbol Window buttons
            If MyDebug(6) = True Then If mydebug(9) Then follow(2543, 6, "ButtonEnabledRules() ")

            'rule 923 You need to have a color selected to add a line
            If MyIsNothing(SymbolWindow.ToolStripDropDownButtonColor.Text) Then
                MySetButtonEnable(923, SymbolWindow.ToolStripButtonAddLine, False, "Add Line in Symbol Window is off because Color is not selected in the Symbol Window Color drop down is not selected")
            Else
                MySetButtonEnable(-923, SymbolWindow.ToolStripButtonAddLine, True, " a line color has not been selected.")
            End If

            If MyUniverse.ProgramOptions.SelectedSymbolName <> SymbolWindow.ToolStripDropDownSelectSymbol.Text Or
    MyUniverse.ProgramOptions.SelectedSymbolName <> FlowChartWindow.ToolStripDropDownSelectSymbol.Text Or
    Len(MyUniverse.ProgramOptions.SelectedSymbolName) = 0 Then
                'deleted     AHint(920, "Symbol", "Need To Select a Symbol named from the Symbol selection tool strip drop down button ",MyUniverse.ProgramOptions.SelectedSymbolName,SymbolWindow.ToolStripDropDownSelectSymbol.Text)
                MySetButtonEnable(920, SymbolWindow.ToolStripButtonAddLine, False, "Add Line in Symbol Window is off because the internal of [" + MyUniverse.ProgramOptions.SelectedSymbolName + "] is not equal to Symbol window [" + SymbolWindow.ToolStripDropDownSelectSymbol.Text + "] or [" + FlowChartWindow.ToolStripDropDownSelectSymbol.Text + "] or No selected Symbol name [" + MyUniverse.ProgramOptions.SelectedSymbolName + "].")
            Else
                MySetButtonEnable(-920, SymbolWindow.ToolStripButtonAddLine, True, " a Symbol has been selected")
            End If

            'rule 906 910 911 912 919 924 to enable an add a point button you need:
            '   to enter the name of the point
            FMB1(8047)
            If Len(SymbolWindow.ComboBoxPointNameList.Text) <> 0 Then
                A_Hint(-911, "Symbol", SymbolWindow.ComboBoxPointNameList.Name, " you have a point name " & SymbolWindow.ComboBoxPointNameList.Text)
                'Next you need a DataType selected
                If Len(SymbolWindow.ToolStripDropDownDataType.Text) <> 0 Then
                    A_Hint(-912, "Symbol", SymbolWindow.ToolStripDropDownDataType.Name, " you have a data type name")
                    'rule 906 910 919
                    If SymbolWindow.ToolStripDropDownInputOutput.DropDownItems.Count > 0 Then
                        MysetDropDownButtonEnable(-906, SymbolWindow.ToolStripDropDownInputOutput, True, " there are I/O types selectable")
                        'next you need if it is input or output
                        If SymbolWindow.ToolStripDropDownInputOutput.Text <> MyUniverse.ProgramOptions.SelectedInputOutput Or
        Len(SymbolWindow.ToolStripDropDownInputOutput.Text) = 0 Or
        Len(MyUniverse.ProgramOptions.SelectedInputOutput) = 0 Then
                            MySetButtonEnable(924, SymbolWindow.ToolStripButtonAddPoint, False,
"The Add Point is disabled because the Symbol Window does Not match the selection [" + SymbolWindow.ToolStripDropDownInputOutput.Text + "]  [" + MyUniverse.ProgramOptions.SelectedInputOutput + "]")
                            If Len(MyUniverse.ProgramOptions.SelectedInputOutput) = 0 Then
                                A_Hint(919, "Symbol", "SelectedInputOutput list", " Select the input Or output to add Symbol point")
                                MyUniverse.ProgramOptions.SelectedInputOutput = SymbolWindow.ToolStripDropDownInputOutput.Text
                            Else
                                A_Hint(-919, "Symbol", SymbolWindow.ToolStripDropDownInputOutput.Name, "Selected Symbol Type Is [" + MyUniverse.ProgramOptions.SelectedInputOutput + "]")
                                MyUniverse.ProgramOptions.SelectedInputOutput = SymbolWindow.ToolStripDropDownInputOutput.Text
                            End If
                        Else
                            MysetDropDownButtonEnable(910, SymbolWindow.ToolStripDropDownInputOutput, False, "The I/O type is disabled because [" + SymbolWindow.ToolStripDropDownInputOutput.Text + "] and [" + MyUniverse.ProgramOptions.SelectedInputOutput + "] does not match [" & MyUniverse.ProgramOptions.SelectedInputOutput & "]")
                            MySetButtonEnable(910, SymbolWindow.ToolStripButtonAddPoint, True, " internal name not equal to Symbol window " + SHL(MyUniverse.ProgramOptions.SelectedInputOutput) + SHL(SymbolWindow.ToolStripDropDownInputOutput.Text))
                            If Len(SymbolWindow.ToolStripDropDownInputOutput.Text) = 0 Then
                                MySetButtonEnable(910, SymbolWindow.ToolStripButtonAddPoint, False, " No Point name selected " + SHL(SymbolWindow.ToolStripDropDownInputOutput.Text))
                            End If


                            If Len(MyUniverse.ProgramOptions.SelectedInputOutput) <> 0 Then
                                MysetDropDownButtonEnable(906, SymbolWindow.ToolStripDropDownInputOutput, True, "internal selected Input Output type not set [" + MyUniverse.ProgramOptions.SelectedInputOutput + "]")
                            Else
                                MysetDropDownButtonEnable(906, SymbolWindow.ToolStripDropDownInputOutput, False, " there is no list for input output point type")
                            End If
                        End If
                        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                        'todo these line should not have to be here , there is a logic bug missing two end if's
                    Else
                        MSG_ABug(1881, "Lost", "?", "There are I/O selections available to select from ")
                    End If
                Else
                    MySetButtonEnable(912, SymbolWindow.ToolStripButtonAddPoint, False, " there is no DataType tool strip dropdown button on the Symbol window")
                End If

            Else
                MySetButtonEnable(911, SymbolWindow.ToolStripButtonAddPoint, False, " you need to enter a name of the point to be added")
            End If

            'rule 925 The delete object is always available
            MySetButtonEnable(925, SymbolWindow.ToolStripButtonDelete, True, " the delete button is always available.")

            'rule 913 If there are any Symbols defined then you can go to the FlowChart.
            'Since right now I define one, just to make it always work.doesn't mean that will happen in the future.
            'todo this needs something better, just seeing if start has more than a Go_To is not good enough
            MySetButtonEnable(-913, SymbolWindow.ToolStripButtonFlowChartForm_FromSymbolWindow, True, "Flow Chart is always available.") 'Because 

            'rule 915 916  You must have something to move.
            NumberOfGraphicsInASymbol(FindInSymbolList(MyUniverse.ProgramOptions.SelectedSymbolName), 0)
            If MyUniverse.SymbolAndPath.Symbol.Total > 0 Then
                A_Hint(-915, "Symbol", "", " there are Symbols or paths on the selected Symbol name.  " & HighLight(MyUniverse.ProgramOptions.SelectedSymbolName))
                If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total + MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Total > 0 Then
                    'deleted AHint(-916, "Symbol", "", "", "")
                    MySetButtonEnable(-916, SymbolWindow.ToolStripButtonDelete, True, " there is something to delete.") 'moved Because the number of Symbol and paths are greater than zero.
                    MySetButtonEnable(-916, SymbolWindow.ToolStripButtonMove, True, " there is something to move.") ' removed Because the number of Symbol and paths are greater than zero.
                Else
                    MySetButtonEnable(916, SymbolWindow.ToolStripButtonDelete, False, "Select the object to delete")
                    MySetButtonEnable(916, SymbolWindow.ToolStripButtonMove, False, "Select the object to move")
                End If
            Else
                A_Hint(915, "Symbol", MyUniverse.ProgramOptions.SelectedSymbolName, "you need to add points and lines to the Symbol.")
            End If

            'rule 926a clearing out an old Symbol data is always acceptable.
            MySetButtonEnable(926, SymbolWindow.ToolStripButtonNewSymbol, True, "Clearing Old Data is always acceptable") ' removedBecause you can always start a new Symbol

            'rule 929 The option Window is always available.
            MySetButtonEnable(929, SymbolWindow.ToolStripButtonOptionForm_FromSymbolWindow, True, "The option window is always available")
            'rule 903 one something has to have change to update.
            'todo updateing is not written yet
            If MyUniverse.ProgramOptions.SymbolChanged = True Then
                'deleted AHint(-903, "Symbol", "", "", SymbolWindow.ToolStripButtonUpdateSymbol.ToString)
                MySetButtonEnable(-903, SymbolWindow.ToolStripButtonUpdateSymbol, True, "Because Symbol Name Changed") ' removed Because Symbol name changed
            Else
                'deleted AHint(903, "Symbol", " Symbolchanged has not been set/reset", SymbolWindow.ToolStripButtonUpdateSymbol.ToString, "")
                MySetButtonEnable(903, SymbolWindow.ToolStripButtonUpdateSymbol, False, " the Symbol has not been changed")
            End If

            'rule 904 If there is a color available then enable it (assumed for now it has colors, cause I currently define them for the user.
            If SymbolWindow.ToolStripDropDownButtonColor.DropDownItems.Count > 0 Then
                MysetDropDownButtonEnable(-904, SymbolWindow.ToolStripDropDownButtonColor, True, " there are colors in the drop down")
                'deleted AHint(-904, "Symbol", "", "", "")
            Else
                MysetDropDownButtonEnable(904, SymbolWindow.ToolStripDropDownButtonColor, True, " there are no colors in the color dropdown")
                'deleted AHint(904, "Symbol", "No color names have been entered or imported.", CStr(SymbolWindow.ToolStripDropDownButtonColor.DropDownItems.Count), "")
            End If


            'rule 905 if there is some DataType available then allow them to be selected.
            If SymbolWindow.ToolStripDropDownDataType.DropDownItems.Count > 0 Then
                MysetDropDownButtonEnable(-905, SymbolWindow.ToolStripDropDownDataType, True, " There are DataTypes available ")
                'deleted AHint(-905, "Symbol", "", "", "")
            Else
                'deleted AHint(905, "Symbol", "No data types have been entered or imported.", "", "")
                MysetDropDownButtonEnable(905, SymbolWindow.ToolStripDropDownDataType, False, " There are no DataTypes in the Symbol window drop down")
            End If


            'rule 907 The line width is always on.
            If SymbolWindow.ToolStripDropDownLineWidth.DropDownItems.Count > 0 Then
                MysetDropDownButtonEnable(-907, SymbolWindow.ToolStripDropDownLineWidth, True, " a line width can be selected.")
                'deleted AHint(-907, "Symbol", "", "", "")
            Else
                'deleted  AHint(907, "Symbol", "program issue, return this error message", "no line widths are available to be selected.", "")
                MysetDropDownButtonEnable(907, SymbolWindow.ToolStripDropDownLineWidth, False, " There is no line widths")
            End If

            'rule 908
            If SymbolWindow.ToolStripDropDownNumberOfBytes.DropDownItems.Count > 0 Then
                MysetDropDownButtonEnable(-908, SymbolWindow.ToolStripDropDownNumberOfBytes, True, " There is a list of the number of bytes")
                'deleted AHint(-908, "Symbol", "", "", "")
            Else
                'deleted AHint(908, "Symbol", "program issue, return this error message", "a number of bytes is not available.", "")
                MysetDropDownButtonEnable(908, SymbolWindow.ToolStripDropDownNumberOfBytes, False, " there is no list of the number of bytes")
            End If

            'rule 909 927, 928 The start and end are always available.(but has to be re-written)
            'todo make sure that the start/end caps and line styles are available and working
            If Len(SymbolWindow.ToolStripDropDownPathStart.Text) > 0 Then MysetDropDownButtonEnable(909, SymbolWindow.ToolStripDropDownPathStart, True, " list is available [" + SymbolWindow.ToolStripDropDownPathStart.Text + "]")
            If Len(SymbolWindow.ToolStripDropDownPathEnd.Text) > 0 Then MysetDropDownButtonEnable(927, SymbolWindow.ToolStripDropDownPathEnd, True, " list is available [" + SymbolWindow.ToolStripDropDownPathEnd.Text + "]")
            If Len(SymbolWindow.ToolStripDropDownPathLineStyle.Text) > 0 Then MysetDropDownButtonEnable(928, SymbolWindow.ToolStripDropDownPathLineStyle, True, " list is available [" + SymbolWindow.ToolStripDropDownPathLineStyle.Text + "]")
            'deleted AHint(-909, "Symbol", "", "", "")
            MysetDropDownButtonEnable(928, SymbolWindow.ToolStripDropDownPathLineStyle, False, "Disable Style first ")
            If SymbolWindow.ToolStripDropDownPathStart.DropDownItems.Count > 0 Then
                MysetDropDownButtonEnable(909, SymbolWindow.ToolStripDropDownPathStart, True, " list is available [" + SymbolWindow.ToolStripDropDownPathStart.Text + "]")
            Else
                MysetDropDownButtonEnable(909, SymbolWindow.ToolStripDropDownPathStart, False, " the path start list is empty")
            End If

            If SymbolWindow.ToolStripDropDownPathEnd.DropDownItems.Count > 0 Then
                MysetDropDownButtonEnable(927, SymbolWindow.ToolStripDropDownPathEnd, True, " list is available [" + SymbolWindow.ToolStripDropDownPathEnd.Text + "]")
            Else
                MysetDropDownButtonEnable(927, SymbolWindow.ToolStripDropDownPathEnd, False, " the path end style is not available")
            End If



            If SymbolWindow.ToolStripDropDownPathLineStyle.DropDownItems.Count > 0 Then
                MysetDropDownButtonEnable(928, SymbolWindow.ToolStripDropDownPathLineStyle, True,
" list is available [" +
          SymbolWindow.ToolStripDropDownPathLineStyle.Text + "]")
            End If

            If Len(SymbolWindow.ToolStripDropDownPathStart.Text) > 0 Then
                MysetDropDownButtonEnable(909, SymbolWindow.ToolStripDropDownPathStart, True,
" path start list is available but not selected.")
            End If
            If Len(SymbolWindow.ToolStripDropDownPathEnd.Text) > 0 Then
                MysetDropDownButtonEnable(927, SymbolWindow.ToolStripDropDownPathEnd, True,
" path end list is available but not selected.")
            End If
            If Len(SymbolWindow.ToolStripDropDownPathLineStyle.Text) > 0 Then
                MysetDropDownButtonEnable(928, SymbolWindow.ToolStripDropDownPathLineStyle, True,
" Line Style list is available but not selected")
            End If
            'deleted  A_Hint(909, "Symbol", "Either the line style, line start or line end of line drop down does not have a valid list", "", "")
            '    'deleted AHint(-914, "Symbol", "", "", "")
            If Len(SymbolWindow.ToolStripDropDownPathStart.Text) < 1 Then
                MysetDropDownButtonEnable(909, SymbolWindow.ToolStripDropDownPathStart, True, " list is not available ")
            End If
            If Len(SymbolWindow.ToolStripDropDownPathEnd.Text) < 1 Then
                MysetDropDownButtonEnable(927, SymbolWindow.ToolStripDropDownPathEnd, True, " list is not available ")
            End If
            If Len(SymbolWindow.ToolStripDropDownPathLineStyle.Text) < 1 Then
                MysetDropDownButtonEnable(928, SymbolWindow.ToolStripDropDownPathLineStyle, True, " list is not available ")
            End If

            'rule 921 A list of drop down rotations.
            If SymbolWindow.ToolStripDropDownRotation.DropDownItems.Count > 0 Then
                'deleted AHint(-921, "Symbol", "", "", "")
                MysetDropDownButtonEnable(-921, SymbolWindow.ToolStripDropDownRotation, False, " rotation list availably")
                If Len(SymbolWindow.ToolStripDropDownRotation.Text) > 0 Then
                    'deleted AHint(-917, "Symbol", "", "", "")
                    MysetDropDownButtonEnable(-917, SymbolWindow.ToolStripDropDownRotation, True, " a Rotation has been selected")
                Else
                    MysetDropDownButtonEnable(917, SymbolWindow.ToolStripDropDownRotation, True, "A Rotation needs to be selected")
                    'deleted AHint(917, "Symbol", "Select a rotation for placing the Symbol from the rotation drop down button", "", "")
                End If
            Else
                'deleted AHint(921, "Symbol", "There is no rotation options in the list", "", "")
                MysetDropDownButtonEnable(921, SymbolWindow.ToolStripDropDownRotation, False, " there are no rotation list")
            End If

            If SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count > 0 Then
                MysetDropDownButtonEnable(-918, SymbolWindow.ToolStripDropDownSelectSymbol, True, " Symbols list is available")
            Else
                MysetDropDownButtonEnable(918, SymbolWindow.ToolStripDropDownSelectSymbol, False, " there are no Symbols available.")
            End If

            'rule 922 there must be colors available before selection is able
            If SymbolWindow.ToolStripDropDownButtonColor.DropDownItems.Count > 0 Then
                'deleted AHint(-922, "Symbol", "", "", "")
                MysetDropDownButtonEnable(922, SymbolWindow.ToolStripDropDownButtonColor, True, " Color list available")
            Else
                'deleted AHint(922, "Symbol", "Select a color from the color tool strip drop down button", "", "")
                MysetDropDownButtonEnable(-922, SymbolWindow.ToolStripDropDownButtonColor, False, " no color list available")
            End If
            'now back to the FlowChart Window


            'rule 900 you can add a Constant if there is no Constant text to add
            If Len(FlowChartWindow.ToolStripTextBoxMyInputText.Text) = 0 Then
                'deleted AHint(900, "FlowChart", "Enter path name on FlowChart Window", "To add a Constant to the FlowChart", "")
                MySetButtonEnable(900, FlowChartWindow.ToolStripButtonAddConstant, False, " you have not entered a path name")
            Else
                MySetButtonEnable(-900, FlowChartWindow.ToolStripButtonAddConstant, True, " there is text in the in the text entered " & HighLight(FlowChartWindow.ToolStripTextBoxMyInputText.Text))
            End If

            'rule 901 you can not add a path unless it has a name in the text box.
            'to Need to be able to add paths by connecting/moving the first point to the closest named path if there is no name in the text box
            If Len(FlowChartWindow.ToolStripTextBoxMyInputText.Text) = 0 Then
                MySetButtonEnable(901, FlowChartWindow.ToolStripButtonAddPath, False, "Input Text is disabled   there is no path name in the text box")
            Else
                MySetButtonEnable(-901, FlowChartWindow.ToolStripButtonAddPath, True, " There is a path name in the text box")
            End If ' no name for this Path
            'AHint(901, "FlowChart", "Enter the name of the path in the tool strip text box", "", "")
            'MySetButtonEnable(FlowChartWindow.ToolStripButtonAddPath, False)
            'Else
            'AHint(-901, "FlowChart", "", "", "")
            'End If

            'rule 928 The delete is always available 
            'todo you can not delete if there is nothing to delete.
            'todo   check this?    MySetButtonEnable(928, FlowChartWindow.ToolStripButtonDeleteObject, True, " delete is always available ")
            'todo make it available only if there is something to delete

            'rule 952 Always available
            'todo Mat move button available only if there is something to move.
            If TopOfFile("FlowChart") > 3 Then
                MySetButtonEnable(-952, FlowChartWindow.ToolStripButtonDeleteobject, True, " Flow Chart has data ")
                MySetButtonEnable(-952, FlowChartWindow.ToolStripButtonMoveObject, True, " there are Flow Chart Records.")
            Else
                MySetButtonEnable(952, FlowChartWindow.ToolStripButtonDeleteobject, False, " not enough records to delete to delete one")
                MySetButtonEnable(952, FlowChartWindow.ToolStripButtonMoveObject, False, " not enough records to move to move one")
            End If


            'rule 953 The Flow Chart Window is only available if there is at least on point defined for the "Start" Symbol
            MySetButtonEnable(953, FlowChartWindow.ToolStripButtonOpenForm, True, " you can always move from FlowChart to File IO options")

            'rule 930 the button to the option Window is always available
            MySetButtonEnable(930, FlowChartWindow.ToolStripButtonOptionForm, True, "Option Window Is Always Available") ' removed   you can always change to another window

            'rule 931 you can always redraw the Window
            'todo need to always make sure that there is something to redraw, even if moving the referance point to make something appear
            'todo always make sure that a paint all will draw something in the display (by moving it right/left and up/down to a corner being displayed
            MySetButtonEnable(931, FlowChartWindow.ToolStripButtonRedraw, True, "Flow Chart window always available")

            'rule 932 other Windows are always available to be displayed

            If Security_Option(SecurityFlowChart) > 0 Then
                MySetButtonEnable(932, FlowChartWindow.ToolStripButtonSymbolForm, True, " the Symbol window is always available ")
            Else
                MySetButtonEnable(932, FlowChartWindow.ToolStripButtonSymbolForm, False, " the Symbol window is not available to students")
            End If
            'rule 954 the zoom in button is not available when you can not zoom in any move
            If MyUniverse.SysGen.MyFlowChartScale <= ConstantMinFlowChartScale Then
                'deleted AHint(-954, "FlowChart", "", "", "")
                MySetButtonEnable(-954, FlowChartWindow.ToolStripButtonZoomIn, False, " the grid scale for the Symbol is to small")
            Else
                MySetButtonEnable(-954, FlowChartWindow.ToolStripButtonZoomIn, True, "You can zoom in more")
            End If

            LimitScale()
            'rule 955 the zoom out button is no available when you are zoomed out all of the way.
            If MyUniverse.SysGen.MyFlowChartScale >= ConstantMaxFlowChartScale Then
                MySetButtonEnable(-955, FlowChartWindow.ToolStripButtonZoomOut, False, "Zoom out button is not available   you are zoomed out as far as the limits allow.")
            Else
                MySetButtonEnable(955, FlowChartWindow.ToolStripButtonZoomOut, True, "You can zoom out more")
            End If

            'rule 956 If there are no Symbols, then the select a Symbol should not be available.
            If FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count = 0 Then
                'deleted AHint(956, "FlowChart", "There are no Symbols defined to select", "", "")
                MysetDropDownButtonEnable(956, FlowChartWindow.ToolStripDropDownSelectSymbol, False, " the is not a Symbol name in the list.")
            Else
                'deleted AHint(-956, "FlowChart", "", "", "")
                MysetDropDownButtonEnable(-956, FlowChartWindow.ToolStripDropDownSelectSymbol, True, "Symbol list has names")
            End If

            'Rule 902.the text box is always available.But if it is blank then other buttons can not work
            If Len(FlowChartWindow.ToolStripTextBoxMyInputText.Text) = 0 Then
                'deleted AHint(902, "FlowChart", "Adding Paths requires you To enter a path name", "Constants a Constant value To attach To a path", "")
                MySetButtonEnable(902, FlowChartWindow.ToolStripButtonAddConstant, False, " Adding Paths requires you To enter a path name [" + FlowChartWindow.ToolStripButtonAddConstant.Text + "]")
                'MySetButtonEnable(FlowChartWindow.ToolStripButtonAddPath, False)
            Else
                'deleted AHint(-902, "FlowChart", "", "", "")
                MySetButtonEnable(-902, FlowChartWindow.ToolStripButtonAddConstant, True, "No Path Name entered.") ' removed Because You can not add a constant with out a value in the text box [" + FlowChartWindow.ToolStripButtonAddConstant.Text
                'MySetButtonEnable(FlowChartWindow.ToolStripButtonAddPath, True)
            End If

            'deleted AHint(-951, "Symbol", "", "", "") ' take it out, because it's still showing up.put it back if it needs to be there
            'deleted AHint(-951, "FlowChart", "", "", "") ' Turn hint off
            'todo removed 2023/06/24 MyDoEvents(215)
            If MyUniverse.ProgramOptions.FCCL_LanguageClassName = "" Then ' No Language selected
                'deleted AHint(951, "FlowChart", "No buttons allowed until you have selected a computer language", "", "Button Rules")
                'MysetDropDownButtonEnable(OptionsWindow.ListBoxComputerLanguage, True)
                MySetButtonEnable(941, OptionsWindow.ToolStripButtonCheckAllData, False, "No buttons allowed until you have selected a computer language")
                MySetButtonEnable(942, OptionsWindow.ToolStripButtonDeleteErrorMsgs, False, "No buttons allowed until you have selected a computer language")
                MySetButtonEnable(943, OptionsWindow.ToolStripButtonDeleteUnusedSymbols, False, "No buttons allowed until you have selected a computer language")
                MySetButtonEnable(944, OptionsWindow.ToolStripButtonDump, False, "No buttons allowed until you have selected a computer language")
                MySetButtonEnable(945, OptionsWindow.ToolStripButtonFlowChartForm_FromOptionsWindow, False, "No buttons allowed until you have selected a computer language")
                MySetButtonEnable(946, OptionsWindow.ToolStripButtonSymbolForm_FromOptionsWindow, False, "No buttons allowed until you have selected a computer language")
            Else
                'deleted AHint(-951, "FlowChart", "", "", "") ' Turn hint off
                'deleted AHint(-951, "Symbol", "", "", "")
                MySetButtonEnable(-941, OptionsWindow.ToolStripButtonCheckAllData, True, "Computer Language has not been selected")
                MySetButtonEnable(-942, OptionsWindow.ToolStripButtonDeleteErrorMsgs, True, "Computer Language has not been selected")
                MySetButtonEnable(-943, OptionsWindow.ToolStripButtonDeleteUnusedSymbols, True, "Computer Language has not been selected")
                MySetButtonEnable(-944, OptionsWindow.ToolStripButtonDump, True, "Computer Language has not been selected")
                MySetButtonEnable(-945, OptionsWindow.ToolStripButtonFlowChartForm_FromOptionsWindow, True, "Computer Language has not been selected")
                MySetButtonEnable(-946, OptionsWindow.ToolStripButtonSymbolForm_FromOptionsWindow, True, "Computer Language has not been selected")

                DisplayStatus(SymbolWindow.LabelProgramStatus, "") ' now display the next hint
                'MysetDropDownButtonEnable(OptionsWindow.ToolStripDropDownComputerLanguage, True)
            End If


            MySetButtonEnable(934, FileInputOutputWindow.ToolStripButtonFlowChartToSourceCode, True, "FC to Source always available")
            MySetButtonEnable(935, FileInputOutputWindow.ToolStripButtonOpenFile, True, "Open File always available")
            MySetButtonEnable(936, FileInputOutputWindow.ToolStripButtonSaveFileAs, True, "Save file always available")
            MySetButtonEnable(937, FileInputOutputWindow.ToolStripButtonShowFlowChart, True, "Flow Chart screen always available")
            MySetButtonEnable(938, FileInputOutputWindow.ToolStripButtonShowOptionsWindow, True, "Options Window always available")
            MySetButtonEnable(939, FileInputOutputWindow.ToolStripButtonShowSymbolWindow, True, "Symbol Window always available")
            MySetButtonEnable(940, FileInputOutputWindow.ToolStripButtonSourceCodeToFlowChartCode, True, "Source to FlowChart always available")

            MySetToolStripHighlight(FlowChartWindow.ToolStripButtonAddConstant, "CommandAddConstant")
            MySetToolStripHighlight(FlowChartWindow.ToolStripButtonAddPath, "CmdAddPath")
            MySetToolStripHighlight(FlowChartWindow.ToolStripButtonDeleteobject, "CmdDeleteObject")
            MySetToolStripHighlight(FlowChartWindow.ToolStripButtonMoveHand, "CmdMoveHand")
            MySetToolStripHighlight(FlowChartWindow.ToolStripButtonMoveObject, "CmdMove")
            'FlowChartWindow.ToolStripButtonOpenForm 
            'FlowChartWindow.ToolStripButtonOptionForm
            'FlowChartWindow.ToolStripButtonRedraw
            'FlowChartWindow.ToolStripButtonSymbolForm
            'FlowChartWindow.ToolStripButtonZoomIn
            'FlowChartWindow.ToolStripButtonZoomOut
            'FlowChartWindow.ToolStripDropDownSelectSymbol
            'FlowChartWindow.ToolStripFlowChart
            'FlowChartWindow.ToolStripTextBoxMyInputText

            '"CmdMoveHand","CmdAddPath", "CmdDelete", "Command_Add_Symbol", "CmdAddPoint", "CmdAddLine", "CmdMove", "CommandAddConstant"
            '"CommandAddConstant", "CmdAddPath", "CmdDeleteObject", "CmdMoveHand", "CmdMove"
            MySetToolStripHighlight(SymbolWindow.ToolStripButtonAddLine, "CmdAddLine")
            MySetToolStripHighlight(SymbolWindow.ToolStripButtonAddPoint, "CmdAddPoint")
            MySetToolStripHighlight(SymbolWindow.ToolStripButtonDelete, "CmdDelete")
            MySetToolStripHighlight(SymbolWindow.ToolStripButtonFlowChartForm_FromSymbolWindow, "cmd")
            MySetToolStripHighlight(SymbolWindow.ToolStripButtonMove, "CmdMove")
            MySetToolStripHighlight(SymbolWindow.ToolStripButtonNewSymbol, "cmd")
            MySetToolStripHighlight(SymbolWindow.ToolStripButtonNewSymbol, "cmd")
            MySetToolStripHighlight(SymbolWindow.ToolStripButtonOptionForm_FromSymbolWindow, "cmd")
            MySetToolStripHighlight(SymbolWindow.ToolStripButtonUpdateSymbol, "cmd")
            'MySetToolStripHighlight(SymbolWindow.ToolStripDropDownButtonColor, "cmd")


            '"CmdMoveHand","CmdAddPath", "CmdDelete", "Command_Add_Symbol", "CmdAddPoint", "CmdAddLine", "CmdMove", "CommandAddConstant"
            '"CommandAddConstant", "CmdAddPath", "CmdDeleteObject", "CmdMoveHand", "CmdMove"
            MySetToolStripHighlight(OptionsWindow.ToolStripButtonCheckAllData, "cmd")
            MySetToolStripHighlight(OptionsWindow.ToolStripButtonDeleteErrorMsgs, "cmd")
            MySetToolStripHighlight(OptionsWindow.ToolStripButtonDeleteUnusedSymbols, "cmd")
            MySetToolStripHighlight(OptionsWindow.ToolStripButtonDump, "cmd")
            MySetToolStripHighlight(OptionsWindow.ToolStripButtonFlowChartForm_FromOptionsWindow, "cmd")
            MySetToolStripHighlight(OptionsWindow.ToolStripButtonSymbolForm_FromOptionsWindow, "cmd")

            '"CmdMoveHand","CmdAddPath", "CmdDelete", "Command_Add_Symbol", "CmdAddPoint", "CmdAddLine", "CmdMove", "CommandAddConstant"
            '"CommandAddConstant", "CmdAddPath", "CmdDeleteObject", "CmdMoveHand", "CmdMove"
            MySetToolStripHighlight(FileInputOutputWindow.ToolStripButtonFlowChartToSourceCode, "cmd")
            MySetToolStripHighlight(FileInputOutputWindow.ToolStripButtonOpenFile, "cmd")
            MySetToolStripHighlight(FileInputOutputWindow.ToolStripButtonSaveFileAs, "cmd")
            MySetToolStripHighlight(FileInputOutputWindow.ToolStripButtonShowFlowChart, "cmd")
            MySetToolStripHighlight(FileInputOutputWindow.ToolStripButtonShowOptionsWindow, "cmd")
            MySetToolStripHighlight(FileInputOutputWindow.ToolStripButtonShowSymbolWindow, "cmd")
            MySetToolStripHighlight(FileInputOutputWindow.ToolStripButtonSourceCodeToFlowChartCode, "cmd")
            'MySetToolStripHighlight(FileInputOutputWindow.ToolStripFileInputOutput, "cmd")

            'end of MyBUttonEnable Rules
        End Sub

        Public Shared Sub FixSyntaxCode(IndexNamed As Int32)
            Dim IndexSymbol As Int32
            Dim PointName As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3378, 10, "FixSyntaxCode")
#End If
            If mydebug(9) Then follow(2544, 5, "Fix Syntax Code " & MyShowNamedRecords(True, IndexNamed))
            IndexSymbol = Named_TableSymbolIndexes(IndexNamed)
            If Symbol_TableCoded_String(IndexSymbol) <> "/name" Then Return
            IndexSymbol += 1
            While Symbol_TableCoded_String(IndexSymbol) <> "/name" And IndexSymbol <= TopOfFile("Symbol")
                FMB1(8048)
                Select Case Symbol_TableCoded_String(IndexSymbol)
                    Case "/point"
                        PointName = NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol))
                        If Len(PointName) < 1 Then
                            If Len(SymbolWindow.ComboBoxPointNameList.Text) = 0 Then
                                FMB1(8049)
                                MSG_ABug(1883, "Point name Is Nothing changed To unknown", MyShowNamedRecords(True, IndexNamed), MyShowSymbolGraphic(True, IndexSymbol))
                                Symbol_Table_NameOfPoint(IndexSymbol, MakeNewName("Var_", "Var_"))
                            Else
                                'MSG_ABug(1884, "Point name Is Nothing changed To " & SymbolWindow.ComboBoxPointNameList.text, MyShowNamedRecords(true, IndexNamed), MyShowSymbolGraphic(true, IndexSymbol))
                                FMB1(8050)
                                If Len(SymbolWindow.ComboBoxPointNameList.Text) > 0 Then
                                    Symbol_Table_NameOfPoint(IndexSymbol, SymbolWindow.ComboBoxPointNameList.Text)
                                    SymbolWindow.ComboBoxPointNameList.Text = "" 'Used this name so erase it
                                Else
                                    Symbol_Table_NameOfPoint(IndexSymbol, "unknown2")
                                End If
                            End If
                        Else
                            FMB1(8051)
                            'todo this is failing to find what it should find
                            If InStr(Named_TableSyntax(IndexNamed), MyUniverse.SysGen.Constants.RMStart & PointName & ".") = 0 Then
                                'todo need to tell what and where this was not found, and why
                                MSG_ABug(1885, "this is failing to find what it should find",
"point name = " & MyUniverse.SysGen.Constants.RMStart & PointName & ".", "Syntax = " & Named_TableSyntax(IndexNamed))
                                'Todo add the name to the code/syntax/pointnames list
                                If MyDebug(9) Then follow(2292, MyUniverse.SysGen.Constants.RMStart & Symbol_Table_NameOfPoint(IndexSymbol) & "." & " is not in the micro text " & MyShowSymbolPoint(False, IndexSymbol) & vbCrLf & Named_TableSyntax(IndexNamed) & vbCrLf)
                                If MyLeft(Symbol_Table_NameOfPoint(IndexSymbol), Len(MyUniverse.SysGen.Constants.RMStart)) = MyUniverse.SysGen.Constants.RMStart Then
                                    MSG_ABug(1887, "Not sure how I can get here", MyShowSymbolGraphic(True, IndexSymbol), Symbol_Table_NameOfPoint(IndexSymbol))
                                Else
                                    Named_TableSyntax(IndexNamed, Named_TableSyntax(IndexNamed) & vbCrLf & AddRM(Symbol_Table_NameOfPoint(IndexSymbol) & ".PATHName"))
                                    AddPointNameToDropDownX(Symbol_Table_NameOfPoint(IndexSymbol))
                                    SymbolWindow.TextBoxNamedProgramText.Text = Named_TableSyntax(IndexNamed)
                                    AddPointNameToDropDownX(Symbol_Table_NameOfPoint(IndexSymbol) + FD + MyShowSymbolRecords(True, IndexSymbol))
                                End If
                            Else
                                'todo make sure that the point name is in the drop down list on the Symbol screen
                                'The point name is found in the micro code correctly (almost) formated
                                If CheckPointNameToDropDown(PointName) <> 0 Then
                                    MSG_ABug(1888, "The point name " & PointName & " is not in the drop down for ", MyShowNamedRecords(False, IndexNamed), "")
                                End If
                                FMB1(8052)
                            End If
                            FMB1(8053)
                        End If
                        FMB1(8054)
                    Case "/line"
                    Case Else 'not a point to fix
                End Select
                IndexSymbol += 1
            End While
            FMB1(8055)
        End Sub


        Public Shared Function FindingMyBugsNets() As Int32
            Dim LocalIndex, Jdex, K As Int32
            Dim TempI, tempJ As String
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3379, 10, "FindingMyBugsNets")
#End If
            If Not MyDebug(7) Then Return 0
            If mydebug(9) Then follow(2545, 9, "FMB: nets")
            If FMBRecurse("FindingMyBugs") > 5 Then Return 1
            For LocalIndex = LBound(Net_FileLinks) + 1 To UBound(Net_FileLinks)
                Select Case LCase(FlowChart_TableCode(LocalIndex))
                    Case My_keyWord(My_KeyConstUse)
                    Case "error"
                    Case MyUniverse.SysGen.Constants.SyntaxUnknowns
                    Case "/path" ' We are only interested in the paths (for now, )
                        Jdex = FindIndex_In_TableNetLinks(LocalIndex) ' make sure that path is in a net
                        If Jdex = ConstantMyErrorCode Then
                            MSG_ABug(1890, "Finding My Bugs: Path not in any path link", MyShowFlowChartRecord(True, LocalIndex), "")
                        Else
                            If FlowChart_TablePath_Name(LocalIndex) <> Net_TableNames(FindIndex_In_TableNetLinks(LocalIndex)) Then
                                MSG_ABug(1891, "Finding My Bugs: Path name does not match path links name", MyShowNetLnks(LocalIndex), MyShowNetLnks(Jdex))
                            End If
                        End If
                        ' A I N F O 2 (183)
                        TempI = Net_FileLinks(LocalIndex)
                        For Jdex = LocalIndex + 1 To UBound(Net_FileLinks)
                            ' A I N F O 2 (184)
                            If Len(Net_TableNames(LocalIndex)) > 0 Then
                                If Net_TableNames(LocalIndex) = Net_TableNames(Jdex) Then
                                    ' A I N F O 2 (172)
                                    Return MSG_ABug(1892, "Finding My Bugs:  2 different paths with the same name.", MyShowNetLnks(LocalIndex), MyShowNetLnks(Jdex))
                                End If
                            End If
                            ' A I N F O 2 (185)
                            tempJ = Net_FileLinks(Jdex)
                            ' A I N F O 2 (186)
                            While Len(tempJ) > 0
                                ' A I N F O 2 (187)
                                K = PopValue(tempJ)
                                'search for ,x, in temp1
                                If InStr(FD & K.ToString & FD, TempI) <> 0 Then
                                    ' A I N F O 2 (173)
                                    Return MSG_ABug(1893, "Finding My Bugs: 2 path links have the same path", MyShowNetLnks(LocalIndex), MyShowNetLnks(Jdex))
                                End If
                            End While
                            ' A I N F O 2 (188)
                        Next
                End Select
                ' A I N F O 2 (189)
            Next
            ' A I N F O 2 (174)
            Return 0
        End Function




        'todo add this all over the place when something changes (for now it is inside FindingMyBugs()
        Public Shared Function FindingMyBugsPoints(SymbolName As String) As Int32
            'This is to find issues when dealing with points
            Dim IndexNamed, IndexSymbol As Int32
            Dim PointNumber, LineNumber As Int32
            Dim IndexDataType, IndexColor As Int32
            Dim DataTypeName, ColorName As String
            Dim Kounter As Int32
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3380, 10, "FindingMyBugsPoints")
#End If
            If mydebug(9) Then follow(2546, 9, "FMB: points")
            If FMBRecurse("FindingMyBugs") > 5 Then Return 1
            'Make sure that we are on the Symbol in the Symbol Window 
            'because it should then have the points and lines correct
            FindingMyBugsPoints = 0
            If LCase(Trim(SymbolName)) <> LCase(Trim(MyUniverse.ProgramOptions.SelectedSymbolName)) Then
#If MINEDEBUG Then
                FindingMyBugsChangeOfWindows()
#End If
                If SymbolWindow.Visible = True Then
                    MSG_AInfo1(1895, " This is NOT The selected Symbol.", HighLight(SymbolName), HighLight(MyUniverse.ProgramOptions.SelectedSymbolName))
                End If
            End If
            PointNumber = 0
            LineNumber = 0
            'Find the IndexSymbol
            IndexNamed = FindIndexInISAMTable("named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_ISAM, SymbolName)
            IndexSymbol = GetSelfCorrectingIndexes(SymbolName)

            'DOC only if the SymbolWindow is visiable do I check if it is valid 
#If MINEDEBUG Then
            FindingMyBugsChangeOfWindows()
#End If
            If SymbolWindow.Visible = True Then
                If Symbol_TableCoded_String(IndexSymbol) = "/name" Then
                    'DOC AND if the Symbol is selected as the Symbol to edit/place
                    If Symbol_TableSymbolName(IndexSymbol) = SymbolName Then 'we have a match
                        IndexSymbol += 1 ' Go past the "/name"

                        NumberOfGraphicsInASymbol(IndexSymbol, 0) ' Get a count of all of the points for this Symbol

                        If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Total > 0 Then
                            MSG_ABug(1896, "Finding My Bugs: Error messages inside this Symbol", HighLight(SymbolName), MyShowPointCounts(False))
                            MSG_ABug(1896, "Finding My Bugs: Error messages inside this Symbol", HighLight(SymbolName), MyShowPointCounts(True))
                        End If

                        If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Total > 0 Then
                            MSG_ABug(1898, "Finding My Bugs: unknown Symbol graphics", HighLight(SymbolName), MyUniverse.SymbolAndPath.Symbol.NumberOfOther.ToString)
                        End If

                        If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Both > 0 Then
                            MSG_ABug(1899, "Finding My Bugs: Logic can only have an input or an output, because a Path can only have one output (destination)", HighLight(SymbolName), MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Both.ToString)
                        End If


                        If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other > 0 Then
                            MSG_ABug(1902, "Finding My Bugs: unknown point type for data", HighLight(SymbolName), MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other.ToString)
                        End If

                        'Only If this Is a Then name record Do I check the rest Of the records.
                        While IndexSymbol <= TopOfFile("Symbol")
                            ' Now go through the Symbol and check against everything
                            Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                                Case "/name"
                                    Exit Function'Finished checking the Symbol
                                Case "/point"
                                    FMB1(8056)
                                    'MSG_AInfo(1903, "Checking point names ", MyShowSymbolGraphic(true, IndexSymbol), MyShowNamedRecords(true, IndexNamed))
                                    'todo add the above checks
                                    '1.See if the Symbol points is in the syntax
                                    'todo add the above check
                                    '3.if the Symbol Window is there then make sure that the names of the points are in the right place in the name of the points
                                    If InStr(Named_TableSyntax(IndexNamed), MyUniverse.SysGen.Constants.RMStart & NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol))) <> 0 Then
                                    Else
                                        MSG_ABug(1905, "Finding My Bugs: The point name Is Not In the syntax With a variable attribute.", MyShowSymbolGraphic(True, IndexSymbol), MyShowNamedRecords(True, IndexNamed))
                                    End If

                                    '2.see if the Symbol point is in the program code line
                                    If InStr(Named_TableMicroCodeText(IndexNamed), Symbol_Table_NameOfPoint(IndexSymbol)) <> 0 Then
                                    Else
                                        FindingMyBugsPoints += MSG_ABug(1907, "Finding My Bugs: Warning the name Of the point Is Not In the program code." & vbCrLf & Named_TableMicroCodeText(IndexNamed) & Symbol_Table_NameOfPoint(IndexSymbol) & vbCrLf, MyShowSymbolGraphic(True, IndexSymbol), MyShowNamedRecords(True, IndexNamed))
                                        'Todo add the name to the code/syntax/pointnames list
                                    End If

                                    '3.if the Symbol Window is there then make sure that the names of the points are in the right place in the name of the points
                                    FMB1(8057)
                                    'DOC does the selected Symbol match to this tymbol
                                    If MyUniverse.ProgramOptions.SelectedSymbolName = Symbol_TableSymbolName(IndexNamed) Then
                                        'DOC does the SymbolName match what is in the Symbol Window text box (ie active Symbol)
                                        If Named_TableSymbolName(IndexNamed) = SymbolWindow.TextBoxNamedSymbolName.Text Then
                                            'DOC is there enough points in the drop down to check this name
                                            If PointNumber < SymbolWindow.ComboBoxPointNameList.Items.Count - 1 Then
                                                'DOes the names match
                                                If Symbol_Table_NameOfPoint(IndexSymbol) = SymbolWindow.ComboBoxPointNameList.Items(PointNumber).ToString Then
                                                    'DOC everything matches so its OK
                                                    MSG_AInfo(1908, MyShowNamedRecords(True, IndexNamed), MyShowSymbolGraphic(True, IndexSymbol), " Everything Is OK")
                                                Else
                                                    For Kounter = 0 To SymbolWindow.ComboBoxPointNameList.Items.Count - 1
                                                        MSG_AInfo(1909, "Point number " & Kounter & " " & SymbolWindow.ComboBoxPointNameList.Items.Item(Kounter).ToString, "", "")
                                                    Next
                                                    MSG_AInfo(1910, "The Symbol point list box, does Not match the order Or point name for point # " & PointNumber, "For Symbol " & Symbol_TableSymbolName(IndexSymbol), " Indexes " & IndexNamed & ": " & IndexSymbol & vbCrLf & HighLight(Symbol_TableSymbolName(IndexSymbol)) & " " & HighLight(SymbolWindow.ComboBoxPointNameList.Items(PointNumber).ToString))
                                                End If
                                            Else
                                                'DOC There is not enough points on the Symbol point list, (usually because we are not on the Symbol Window doing this sub routine.
                                                If SymbolWindow.ComboBoxPointNameList.Items.Count <> 0 Then
                                                    For Kounter = 0 To SymbolWindow.ComboBoxPointNameList.Items.Count - 1
                                                        MSG_AInfo(1911, "Point number " & Kounter & " " & SymbolWindow.ComboBoxPointNameList.Items.Item(Kounter).ToString, "", "")
                                                    Next
                                                    FindingMyBugsPoints += MSG_ABug(1912, "Finding My Bugs: The Symbol Window does not have enough point names in the drop down list.", "need " & PointNumber + 1 & " Have: " & SymbolWindow.ComboBoxPointNameList.Items.Count - 1, "")
                                                End If
                                            End If
                                        End If
                                    Else
                                        'DOC this is not the active Symbol so not checking
                                        MSG_AInfo(1915, "This is not the selected Symbol", MyShowSymbolGraphic(True, IndexSymbol), "")
                                    End If

                                    '4 check that this point has a valid data type
                                    DataTypeName = Symbol_Table_DataType(IndexSymbol)
                                    If IndexDataType = ConstantMyErrorCode Then
                                        MSG_ABug(1916, "Finding My Bugs: invalid DataType ", MyShowSymbolGraphic(True, IndexSymbol), "")
                                    Else
                                        ColorName = FindColorFromDataType(DataTypeName)
                                        If IndexColor = ConstantMyErrorCode Then
                                            MSG_ABug(1917, "Finding My Bugs: the DataType table points to an invalid color name", MyShowDataTypeTable(True, IndexDataType), MyShowColor(False, IndexColor))
                                        End If
                                        PointNumber += 1
                                    End If
                                Case "/line"
                                    IndexColor = FindColor(Symbol_File_NameOfPoint(IndexSymbol))
                                    If IndexColor < 0 Then
                                        MSG_AInfo(2118, "line color name is invalid ", MyShowSymbolGraphic(True, IndexSymbol), Symbol_File_NameOfPoint(IndexSymbol))
                                    End If
                                    '4.and while we are at it, make sure the color of lines in the Symbol is in the line color list
                                    '5.make sure that line color names in the line color list is valid colors
                                    LineNumber += 1
                                Case "/unknown"
                                    MSG_AInfo1(1919, "Ignoreing unknown code", MyShowSymbolGraphic(True, IndexSymbol), Symbol_TableCoded_String(IndexSymbol))
                                    If Symbol_TableCoded_Byte(IndexSymbol) <> 0 Then
                                        MSG_AInfo(1920, "This record should not be in the Symbol graphics table ", MyShowSymbolGraphic(True, IndexSymbol), "Indexs " & IndexNamed & " : " & IndexSymbol)
                                    End If
                                Case Else
                                    FindingMyBugsPoints += MSG_ABug(1921, "Finding My Bugs: this Symbol Graphics code is not taken care of", "", MyShowSymbolGraphic(False, IndexSymbol))
                            End Select
                            IndexSymbol += 1
                        End While
                    End If
                End If

            End If
        End Function

        Public Shared Function Recursive() As Int32
            Dim Debug1, Debug2 As String
            Dim RTN As Int32 = 0
            Debug1 = ""
            Debug2 = ""
#If MINEDEBUG Then
  if mydebug(9) then follow(3381, 10, "FMB:recursive(B)")
#End If
            If MyDebug(5) = False Then Return ConstantMyErrorCode
            If MyUniverse.FCCLDebugLevel > 0 Then
                Debug1 = My.Application.Info.StackTrace
                'find any resursive routines.
                Debug2 = MyTrim(PopLine(Debug1))
                While Debug1.Length > 0
                    Debug2 = PopLine(Debug1)
                    Debug2 = MyTrim(Debug2)
                    Debug1 = MyTrim(Debug1)
                    If MyLeft(Debug2, 3) = "at " Then Debug2 = Debug2.Substring(3)
                    If InStr(Debug2, ")") <> 0 Then Debug2 = Debug2.Substring(0, InStr(Debug2, ")"))
                    If InStr(Debug2, " in ") <> 0 Then Debug2 = Debug2.Replace(" in ", " ")

                    If InStr(Debug2, "System.Windows.Forms.") <> 0 Then Debug2 = "*" & Debug2
                    If InStr(Debug2, "MicroSoft.VisualBasic.ApplicationServices.") <> 0 Then Debug2 = "*" & Debug2
                    If InStr(Debug2, "MicroSoft.VisualBasic.Interaction.") <> 0 Then Debug2 = "*" & Debug2
                    If InStr(Debug2, "System.EventHandler.") <> 0 Then Debug2 = "*"
                    If InStr(Debug2, "System.Environment.") <> 0 Then Debug2 = "*"
                    If InStr(Debug1, Debug2) <> 0 Then
                        RTN += 1
                        'if mydebug(9) then follow(2668, 9, "Count Stack - Recursive " & RTN.ToString & FD & Debug2)
                    End If
                End While
            End If
            If RTN > 0 Then
                DebugPrint("213 ," & "Count Stack - Recursive " & RTN.ToString & " times " & FD & Debug2)
                Return RTN
            Else
                Return 0
            End If
        End Function

        Public Shared Function FMBRecurse(routine As String) As Int32
            Dim Counter, Kounter, Last1, Last2 As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3382, 10, "FMB:Recurse(A) " & routine)
#End If
            Counter = 1
            Kounter = 0
            While Counter <> 0
                Counter += 1
                Kounter += 1
                Last2 = Last1
                Last1 = Counter
                Counter = InStr(Counter, My.Application.Info.StackTrace, routine)
            End While
            Kounter -= 1
            If Kounter > 7 Then
                If mydebug(9) Then follow(2865, 10, "2722,0, recursive routine " & HighLight(Kounter.ToString) & ", " & Counter.ToString & FD & Last1.ToString & FD & Last2.ToString & vbCrLf & "--> " & Mid(My.Application.Info.StackTrace, MyMinMax(Last2, 1, Len(My.Application.Info.StackTrace)), InStr(My.Application.Info.StackTrace, vbCrLf)) & vbCrLf & "--> " & Mid(My.Application.Info.StackTrace, MyMinMax(Last2, 1, Len(My.Application.Info.StackTrace))))
                Return Kounter 'todo
            ElseIf Kounter > 2 Then 'todo need to change this to msgbox()
                '   if mydebug(9) then follow(2866,10,"2723, recursive routine " & HighLight(Kounter.ToString) & Last1.ToString)
                Return Kounter 'todo
            ElseIf Kounter = 2 Then
                Return Kounter
            ElseIf Kounter = 1 Then
                'if mydebug(9) then follow(2867,10," " & Kounter.ToString & " " & routine & vbCrLf)
                Return Kounter
            End If
            If MyDebug(10) Then follow(2868, 10, Counter.ToString & FD & Kounter.ToString & " " & routine)
            Return Kounter
        End Function

        Public Shared Function CountStackI(DebugLevel As Int32) As Int32
            Dim Counter, Kounter As Int32
            '#If MINEDEBUG Then
            '            DebugWrite(" CountStackI ")
            '#End If
            Counter = 1
            Kounter = 0
            While Counter <> 0
                Counter += 1
                Kounter += 1
                Counter = InStr(Counter, My.Application.Info.StackTrace, vbCrLf)
            End While
            'todo it also would be helpful if I made this a function to always fail when the stack gets to big
            ' removed if mydebug(9) then follow(BugNumber, "Count Stack " & Kounter.ToString)
            Return Kounter
        End Function 'CountStack()

        Public Shared Function CountStackS(DebugLevel As Int32) As String
            Dim Kounter As Int32
            Static NumberOfTimes As Int32 = 0
            NumberOfTimes += 1
            CountStackS = ""
            If MyDebug(DebugLevel) = False Then Return ""
            'todo removed this (recursive problem)            If MyOptionTest(31) = False Then Return Nothing
            If DebugLevel > 9000 Then
                DebugWrite("Fix This " & vbTab)
            End If
            Kounter = CountStackI(DebugLevel)
            'todo it also would be helpful if I made this a function to always fail when the stack gets to big
            If Kounter > 350 Then
                CountStackS = "2553, 3, " & NumberOfTimes.ToString & "," & DebugLevel.ToString & ", ERROR Program is over 150 routines deep, Possible forever Loop " & Kounter.ToString
            ElseIf Kounter > 300 Then
                CountStackS = "2552, 3, " & NumberOfTimes.ToString & "," & DebugLevel.ToString & ", ERROR is over 150 routines deep, Possible forever loop " & Kounter.ToString
            ElseIf Kounter > 250 Then
                CountStackS = "2551, 3, " & NumberOfTimes.ToString & "," & DebugLevel.ToString & ", Error is over 150 routines deep, Possible forever Loop " & Kounter.ToString
            ElseIf Kounter > 200 Then
                CountStackS = "2550, 3, " & NumberOfTimes.ToString & "," & DebugLevel.ToString & ", WARNING is over 150 routines deep, Possible forever loop " & Kounter.ToString
            ElseIf Kounter > 150 Then
                CountStackS = "2549, 3, " & NumberOfTimes.ToString & "," & DebugLevel.ToString & ", WARNING is over 150 routines deep, Possible forever Loop " & Kounter.ToString
            ElseIf Kounter > 100 Then
                CountStackS = "2548, 1, " & NumberOfTimes.ToString & "," & DebugLevel.ToString & ", WARNING stack is " & Kounter.ToString & " routines deep." & " " & Recursive()
            ElseIf Kounter > 100 Then
                Return "stack = " & Kounter.ToString & " deep. " & SHL(NumberOfTimes.ToString)
            ElseIf Kounter > 30 Then
                Return "stack=" & Kounter.ToString & " "
            End If
            Return CountStackS
        End Function 'CountStack(a)




        Public Shared Function DontFindMyBugs() As Boolean
            If MyDebug(4) = False Then Return True
            If ProgramBuzzy("Begin") Then Return True
            If FMBRecurse("FindingMyBugs") > 5 Then Return True
            If MyOptionTest(31) = False Then Return True
            If MyUniverse.SysGen.FindingMyBugsFlag = True Then Return True
            Return False
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'hack
        'This routine is here to try and find all of the possible issues that I am aware
        'of that was causing issues in not doing what I thought that it should be doing 
        'what I think the data should be doing.
        ' This is to trace down all of my know bug issues And I can put this everywhere 
        Public Shared Function FindingMyBugs(BugNumber As Int32) As Int32 'hack
#If MINEDEBUG Then
  if mydebug(9) then follow(3383, 10, "FindMyBugs(" & BugNumber.ToString & ")")
#End If
            FindingMyBugs = 0
            If DontFindMyBugs() = True Then Return 0

#If MINEDEBUG Then
            Dim IndexFlowChart As Int32
  if mydebug(9) then follow(2555, 3, "Finding My Bugs " & BugNumber.ToString)
            MyUniverse.SysGen.FindingMyBugsFlag = True
            FindMyBugsROUTER_OnTop()
            For IndexFlowChart = 1 To TopOfFile("FlowChart")
                If FlowChart_TableCode(IndexFlowChart) = "/use" Then
                    FindingMyBugs += FindingMyBugsSyntax(IndexFlowChart)
                End If
            Next
#End If
            FindingMyBugs += FindingMyBugsDropDowns()
            FindingMyBugs += FindingMyBugsSorted()
            FindingMyBugs += FindingMyBugsColor()
            FindingMyBugs += FindingMyBugsDataType()
            FindingMyBugs += FindingMyBugsSymbol()
            FindingMyBugs += FindingMyBugsNamed()
            FindingMyBugs += FindingMyBugsFlowChart()
            FindingMyBugs += FindingMyBugsKeyWord(MyUniverse.SysGen.Constants.SyntaxKeyWords, Language_KeyWord)
            FindingMyBugs += FindingMyBugsKeyWord(MyUniverse.SysGen.Constants.SyntaxOperators, Language_Operator)
            FindingMyBugs += FindingMyBugsKeyWord(MyUniverse.SysGen.Constants.SyntaxFunctions, Language_Function)
            FindingMyBugs += FindingMyBugsNets()
            MyUniverse.SysGen.FindingMyBugsFlag = False
        End Function

        Public Shared Function FindingMySortedBugNumber(MyArrayLong() As Int32, ISAM() As Int32, LocalIndex As Int32, What As String) As Int32
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3384, 10, "FindMySortedBugNumber")
#End If
            If MyOptionTest(31) = False Then Return 0
            If FMBRecurse("FindingMySortedBugNumber") > 5 Then Return 1
            If Not MyDebug(4) Then Return 0
            If InvalidIndex(LocalIndex, MyArrayLong, ISAM) = True Then
                If mydebug(9) Then follow(2554, 10, "FMB: invalid index " & What & ", @" & LocalIndex.ToString)
                Return 1
            Else
                Return 0 ' index is ok (within bounds)
            End If
        End Function
        Public Shared Function FindingMySortedBugString(MyArray() As String, ISAM() As Int32, MyIndex As Int32, What As String) As Int32
            Dim LocalIndex As Int32
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3385, 10, "FindMySortedBugString")
#End If
            LocalIndex = MyIndex
            If MyOptionTest(31) = False Then Return 0
            If InvalidIndex(LocalIndex, MyArray, ISAM) = True Then Return 0
            If InvalidIndex(LocalIndex - 1, MyArray, ISAM) = True Then Return 0
            If InvalidIndex(LocalIndex + 1, MyArray, ISAM) = True Then Return 0

            LocalIndex = ISAM(LocalIndex)
            If InvalidIndex(LocalIndex, MyArray, ISAM) = True Then Return 0
            If InvalidIndex(LocalIndex - 1, MyArray, ISAM) = True Then Return 0
            If InvalidIndex(LocalIndex + 1, MyArray, ISAM) = True Then Return 0

            If MyDebug(7) Then FMBRecurse("FindingMysortedBugs:")
            If MyArray(ISAM(LocalIndex)) <= MyArray(ISAM(LocalIndex - 1)) Then
                DebugWrite("2557, 6, Finding My Sorted Bug String ERROR 2557 ")
                DebugWrite(vbTab & LocalIndex.ToString)
                DebugWrite(vbTab & (LocalIndex - 1).ToString)
                DebugWrite(vbTab & ISAM(LocalIndex).ToString)
                DebugWrite(vbTab & ISAM(LocalIndex - 1).ToString)
                DebugWrite(vbTab & MyArray(ISAM(LocalIndex)).ToString)
                DebugPrint("214 ," & vbTab & MyArray(ISAM(LocalIndex - 1)).ToString)
                Return 1
            End If

            If MyArray(ISAM(LocalIndex)) >= MyArray(ISAM(LocalIndex + 1)) Then
                DebugWrite("2558, 6, Finding My Sorted Bug String ERROR 2558 ")
                DebugWrite(vbTab & "Index = " & LocalIndex.ToString)
                DebugWrite(vbTab & " Index-1 = " & (LocalIndex - 1).ToString)
                DebugWrite(vbTab & " ISAM()=" & ISAM(LocalIndex).ToString)
                DebugWrite(vbTab & " ISAM(-1) = " & ISAM(LocalIndex - 1).ToString)
                DebugWrite(vbTab & "() = " & MyArray(ISAM(LocalIndex)).ToString)
                DebugPrint("216 ," & vbTab & "(-1) = " & MyArray(ISAM(LocalIndex - 1)).ToString)
                Return 1
            End If
            Return 0
        End Function


        'Find any and all bugs if there is any left.
        Public Shared Function FindingMyBugsSorted() As Int32
            Dim I As Int32
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3386, 10, "FindMyBugsSorted")
#End If
            If Not MyDebug(6) Then Return 0
            If mydebug(9) Then follow(2559, 10, "FMB: Sort")
            'DisplayMyStatus(3,"Checking Sorts . . . ")
            FindingMyBugsSorted = 0
            If FMBRecurse("FindingMyBugsSorted") > 5 Then Return 1
            If MyOptionTest(31) = False Then Exit Function
            'DisplayMyStatus(3,"Sorting . . . FlowCharts ")
            'if mydebug(9) then follow(2560, 9, "FMB: Index FlowChart ")
            For I = 1 To TopOfFile("FlowChart") '  UBound(FlowChart_FileCoded)
                FindingMyBugsSorted += FindingMySortedBugNumber(FlowChart_FileX1, FlowChart_ISAM_X1, I, "x1")
                FindingMyBugsSorted += FindingMySortedBugNumber(FlowChart_FileY1, FlowChart_ISAM_Y1, I, "Y1")
                FindingMyBugsSorted += FindingMySortedBugNumber(FlowChart_File_X2_Rotation, FlowChart_ISAM_X2, I, "X2")
                FindingMyBugsSorted += FindingMySortedBugNumber(FlowChart_File_Y2_Option, FlowChart_ISAM_Y2, I, "Y2")
                'FindingMyBugsSorted += FindingMySortedBugString(FlowChart_FilePathSymbolName, FlowChart_ISAM_Name, I, "name")
            Next


            'DisplayMyStatus(3,"Sorting . . . syntaxs")
            'if mydebug(9) then follow(2561, 9, "FMB: Index Named")
            For I = 1 To TopOfFile("named") 'UBound(Named_FileSyntax_ISAM)
                FindingMyBugsSorted += FindingMySortedBugString(Named_FileSymbolName, Named_FileSymbolName_ISAM, I, "NamedName")
                FindingMyBugsSorted += FindingMySortedBugString(Named_FileSyntax, Named_FileSyntax_ISAM, I, "NamedSyntax")
            Next



            'DisplayMyStatus(3,"Sorting . . . DataTypes")
            'if mydebug(9) then follow(2562, 9, "FMB: Index DataTypes")
            For I = 1 To TopOfFile("DataType") 'UBound(DataType_FileName)
                FindingMyBugsSorted += FindingMySortedBugString(DataType_FileName, DataType_Name_ISAM, I, "DataType")
            Next



            'DisplayMyStatus(3,"Sorting . . . colors")
            'if mydebug(9) then follow(2563, 9, "FMB: Index Colors")
            For I = 1 To TopOfFile("Color") 'UBound(Color_FileName)
                FindingMyBugsSorted += FindingMySortedBugString(Color_FileName, Color_Name_ISAM, I, "Color")
            Next

            'DisplayMyStatus(3,"Sorting . . . keywords")
            'if mydebug(9) then follow(2564, 9, "FMB: Sort keywords")
            For I = 1 + 1 To TopOfFile("keyword") - 1 'UBound(Language_KeyWord) - 1
                If Language_KeyWord(I - 1) >= Language_KeyWord(I) Then FindingMyBugsSorted += 1
                If Language_KeyWord(I) >= Language_KeyWord(I + 1) Then FindingMyBugsSorted += 1
            Next

            'DisplayMyStatus(3,"Sorting . . . operators")
            'if mydebug(9) then follow(2565, 9, "FMB: Sort Operators")
            For I = 1 + 1 To TopOfFile("operator") - 1 'UBound(Language_Operator) - 1
                If Language_Operator(I - 1) >= Language_Operator(I) Then FindingMyBugsSorted += 1
                If Language_Operator(I) >= Language_Operator(I + 1) Then FindingMyBugsSorted += 1
            Next

            'DisplayMyStatus(3,"Sorting . . . functions")
            'if mydebug(9) then follow(2566, 9, "FMB: Sort Functions")
            For I = 1 + 1 To TopOfFile("function") - 2 'UBound(Language_Function) - 1
                If Language_Function(I - 1) >= Language_Function(I) Then FindingMyBugsSorted += 1
                If Language_Function(I) >= Language_Function(I + 1) Then FindingMyBugsSorted += 1
            Next

            'DisplayMyStatus(3,"Sorting . . . Grammar ")
            'if mydebug(9) then follow(2567, 9, "FMB: Sort Grammar")
            For I = 1 + 1 To TopOfFile("Grammar") - 1 'UBound(Language_Grammar) - 1
                If Language_Grammar(I - 1) >= Language_Grammar(I) Then FindingMyBugsSorted += 1
                If Language_Grammar(I) >= Language_Grammar(I + 1) Then FindingMyBugsSorted += 1
            Next
        End Function

        Public Shared Function FindingMyBugsFlowChart() As Int32
            Dim IndexFlowChart As Int32
            Dim I, J As Int32
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3387, 10, "FindMyBugsFlowChart")
#End If
            '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            If MyDebug(6) = True Then If mydebug(9) Then follow(2568, 6, "FMB: Flow Chart " & TopOfFile("FlowChart").ToString)
            FindingMyBugsFlowChart = 0


            For I = 1 To TopOfFile("FlowChart")
                FindingMyBugsFlowChart += FindingMyBugsSyntax1(I)
                For J = I + 1 To TopOfFile("FlowChart")
                    If SymbolOnTopOfSymbol(I, J) = True Then
                        FindingMyBugsFlowChart += 1
                        MSG_ABug(2869, "Two Symbols on top of each other", MyShowFlowChartRecord(True, I), MyShowFlowChartRecord(True, J))
                    End If
                Next
            Next




            If MyOptionTest(31) = False Then Exit Function
            If FMBRecurse("FindingMyBugs") > 5 Then Return 1


            'todo CheckAllSymbolsOnFlowChart(FlowChartWindow.PictureBox1)
            For IndexFlowChart = 1 To MyUniverse.MyStaticData.FlowChart_TableCount ' Through all of the /use/path records (and others)
                Select Case LCase(FlowChart_TableCode(IndexFlowChart))
                    Case My_keyWord(My_KeyConstUse)
                        'todo check that this Symbol exist
                        'todo check that it is not negitive ( I might want to use - later as a flag for compiling
                        ' Test that the rotation and DataType is valid
                        If FlowChart_TableX2(IndexFlowChart) > SymbolWindow.ToolStripDropDownRotation.DropDownItems.Count - 1 Then ' Check that the number of rotations against the stored Value
                            FindingMyBugsFlowChart += MSG_ABug(1944, "Finding My Bugs: " & MyShowFlowChartRecord(True, IndexFlowChart), IndexFlowChart.ToString, "Invalid rotation ")
                        End If
                        If FlowChart_TableX2(IndexFlowChart) < 0 Then ' Check that the number of rotations against the stored Value
                            FindingMyBugsFlowChart += MSG_ABug(1945, "Finding My Bugs: " & MyShowFlowChartRecord(True, IndexFlowChart), IndexFlowChart.ToString, "might be an Invalid rotation ")
                        End If
                        ' todo Need to check for the future options
                        If FlowChart_TableY2(IndexFlowChart) <> 0 Then
                            FindingMyBugsFlowChart += MSG_AInfo(1946, MyShowFlowChartRecord(True, IndexFlowChart), IndexFlowChart, "This is for future expansion of the /use record")
                        End If
                    Case "/path" ' currently no checks (should check if connected etc...
                        If FlowChart_FilePathSymbolName(IndexFlowChart) <> Net_TableNames(FindIndex_In_TableNetLinks(IndexFlowChart)) Then
                            MSG_ABug(1947, "Finding My Bugs: Problem with names saved ", MyShowFlowChartRecord(True, IndexFlowChart), MyShowNetLnks(FindIndex_In_TableNetLinks(IndexFlowChart)))
                        End If
                        FindingMyBugsFlowChart += FindingMyBugsPath(IndexFlowChart)
                    Case "/Constant" ' currently no checks, should check that only one per path(s)
                    Case "/unknown"
                        MSG_AInfo(1948, "FlowChart has record with a unused code", MyShowFlowChartRecord(True, IndexFlowChart), MyShowEveryThingAtXY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)))
                    Case "/error" ' Need to recheck all /errors
                        'todo see what and avoid the MSG_AInfo message.
                        DebugPrint(" delete this line 1 ")
                    Case "/delete"
                        DebugPrint(" delete this line 1 ")
                    Case Nothing
                        FindingMyBugsFlowChart += MSG_AInfo(1950, "FindingMyBugsFlowChart: invalid code in the Symbol table", MyShowFlowChartRecord(True, IndexFlowChart), "??")
                    Case Else
                        FindingMyBugsFlowChart += MSG_ABug(1951, "FindingMyBugsFlowChart: invalid code in the Symbol table", MyShowFlowChartRecord(True, IndexFlowChart), "??")
                End Select
            Next IndexFlowChart
            '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

        End Function

        Public Shared Function FindingMyBugsSymbol() As Int32
            Dim IndexSymbol, Jndex As Int32
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3388, 10, "FindMyBugsSymbol")
#End If
            FMB(5065)
            If mydebug(9) Then follow(2569, 7, "FMB: Symbol")
            FindingMyBugsSymbol = 0
            If Not MyDebug(7) Then Return 0
            If MyOptionTest(31) = False Then Exit Function
            '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            For IndexSymbol = 1 To NewTopOfFile("Symbol") - 1 'Symbol_TableCount '2020 07 19 replaced count
                If InStr(Symbol_FileX2_io(IndexSymbol).MyString, FD) <> 0 Then
                    MSG_ABug(2318, "Should never be a comma in the data ", Symbol_FileX2_io(IndexSymbol).MyString, "")
                End If
                If InStr(Symbol_FileY2_dt(IndexSymbol).MyString, FD) <> 0 Then
                    MSG_ABug(2319, "Should never be a comma in the data ", Symbol_FileX2_io(IndexSymbol).MyString, "")
                End If
                If MyDebug(7) Then FMB(5066)
                FindingMyBugsSymbol += FindingSymbolOutOfXYSizeBugs(IndexSymbol) ' Check if the Symbol is within the allowed bounds (??,??)
                If Symbol_TableCoded_String(IndexSymbol) = "/name" Then
                    For Jndex = IndexSymbol + 1 To NewTopOfFile("Symbol") - 1
                        If Symbol_TableCoded_String(IndexSymbol + 1) = "/name" Then
                            If Symbol_TableSymbolName(IndexSymbol) = Symbol_TableSymbolName(IndexSymbol + 1) Then
                                FindingMyBugsSymbol += MSG_ABug(1953, "Finding My Bugs: Duplicate Symbol name in the Symbol graphics table", MyShowSymbolGraphic(True, IndexSymbol), MyShowSymbolGraphic(True, IndexSymbol + 1))
                            End If
                        End If
                    Next Jndex
                End If

                ' Test for duplicate names in the Symbol table 
                If Symbol_TableCoded_String(IndexSymbol) = "/name" Then ' Test if this is a /name record
                    For Jndex = IndexSymbol + 1 To NewTopOfFile("Symbol") ' from that record to the end (since before has already been checked)
                        If Symbol_TableCoded_String(Jndex) = "/name" Then 'If this is also a /name record
                            If MyCompared1_a(Symbol_FileSymbolName(IndexSymbol), Symbol_FileSymbolName(Jndex)) = 0 Then 'If they match =0
                                FMB(5067)
                                FindingMyBugsSymbol += MSG_ABug(1954, "Finding My Bugs: The same Symbol name ", MyShowSymbolGraphic(True, IndexSymbol), MyShowSymbolGraphic(True, Jndex))
                                FMB(5068)
                                Dump1()
                            End If
                        End If
                    Next Jndex
                End If


                If Symbol_FileCoded(IndexSymbol) = MyKeyword_2_Byte("/name") Then
                    If Symbol_FileCoded(IndexSymbol + 1) = MyKeyword_2_Byte("/name") Then
                        If MyIsNothing(Symbol_FileSymbolName(IndexSymbol)) Or MyIsNothing(Symbol_FileSymbolName(IndexSymbol + 1)) Then
                        Else
                            FindingMyBugsSymbol += MSG_ABug(1955, "FindingMyBugsSymbol() Two name with no graphics between", MyShowSymbolGraphic(True, IndexSymbol), MyShowSymbolGraphic(True, IndexSymbol + 1))
                            If Symbol_FileSymbolName(IndexSymbol) = Symbol_FileSymbolName(IndexSymbol + 1) Then
                                FindingMyBugsSymbol += MSG_ABug(1956, "FindingMyBugsSymbol() Duplicated Symbol name ", MyShowSymbolGraphic(True, IndexSymbol), MyShowSymbolGraphic(True, IndexSymbol))
                            End If
                        End If
                    End If
                End If

                'test if DataType is OK
                If ProgramBuzzy("Alive") Then
                    Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                        Case "/name", "/line", "/point" 'OK, so ignore.
                        Case "/error"
                            If Symbol_TableSymbolName(IndexSymbol) <> "" Or Symbol_Table_NameOfPoint(IndexSymbol) <> "" Then
                            Else
                                MSG_AInfo1(1957, Symbol_TableCoded_String(IndexSymbol) & " in the Symbol table should not happen?", MyShowSymbolGraphic(True, IndexSymbol), HighLight(Symbol_Table_NameOfPoint(IndexSymbol)))
                            End If
                        Case "/unknown"
                            If Symbol_TableSymbolName(IndexSymbol) <> "" Or Symbol_Table_NameOfPoint(IndexSymbol) <> "" Then
                                FindingMyBugsSymbol += MSG_ABug(1958, "Finding My Bugs: " & Symbol_TableCoded_String(IndexSymbol) & " in the Symbol table should not happen?", MyShowSymbolGraphic(True, IndexSymbol), HighLight(Symbol_Table_NameOfPoint(IndexSymbol)))
                            Else
                            End If
                        Case Else
                            MSG_AInfo(1959, HighLight(Symbol_TableCoded_String(IndexSymbol)) & " Not a known code", HighLight(Symbol_TableCoded_String(IndexSymbol)), MyShowSymbolGraphic(True, IndexSymbol))
                            If Symbol_Table_DataType(IndexSymbol) = "" Then
                                FindingMyBugsSymbol += MSG_ABug(1960, "Finding My Bugs: Invalid data type for " & MyShowSymbolGraphic(True, IndexSymbol), "", "")
                            End If
                    End Select
                End If
            Next IndexSymbol

        End Function

        Public Shared Function FindingMyBugsDataType(IndexDataType As Int32) As Int32
            'Dim IndexDataType As Int32
            FindingMyBugsDataType = 0
            If DontFindMyBugs() = True Then Return 0
            If InvalidIndex(IndexDataType, DataType_FileName) = True Then Return ConstantMyErrorCode
            If DataType_Name_ISAM(IndexDataType) > 0 Then 'if a valid index
                If DataType_Name_ISAM(IndexDataType) = DataType_Name_ISAM(IndexDataType + 1) Then 'Is the index all messed up, with two index to the same data type name
                    FindingMyBugsDataType += MSG_ABug(1962, "Finding My Bugs: The duplicate DataType index", MyShowDataTypeTable(True, IndexDataType), MyShowDataTypeTable(True, IndexDataType))
                End If
            End If
            'if the index is wrong then there is a issue, that needs to be fixed (Make it Black?)
            If DataType_FileColorIndex(IndexDataType) <= 0 Then 'Invalid index Indexes
                FindingMyBugsDataType += MSG_ABug(1963, "Finding My Bugs: Invalid DataType Color Index ", MyShowDataTypeTable(True, IndexDataType), "") ' Was an invalid color
            ElseIf DataType_FileColorIndex(IndexDataType) > 0 Then ' Valid index Indexes
                If DataType_FileColorIndex(IndexDataType) > UBound(Color_FileName) Then 'checking if the Indexes is greater then the number of colors 
                    FindingMyBugsDataType += MSG_ABug(1964, "Finding My Bugs: points to a color name that does exist non existent color : ", MyShowDataTypeTable(True, IndexDataType), "Maxiumn number of known colors" & " : " & UBound(Color_FileName))
                End If
                ' points to a valid color so skip @@@@@@@@@@@@@@@@@@@@
            Else ' will never get to the else (Program issue if you do)
                FindingMyBugsDataType += MSG_ABug(1965, "Finding My Bugs: There is no color for this data type : " & MyShowDataTypeTable(True, IndexDataType), IndexDataType.ToString, "")
            End If
            'Making sure that the data type is in order

            Select Case MyCompared3(DataType_TableName(DataType_Name_ISAM(IndexDataType - 1)), DataType_TableName(DataType_Name_ISAM(IndexDataType)), DataType_TableName(DataType_Name_ISAM(IndexDataType + 1)))
                Case -5 '9   -5  A > C 'Unsorted List
                    FindingMyBugsDataType += MSG_ABug(1966, "Finding My Bugs: DataType is unsorted ERROR ", MyShowDataTypeTable(True, DataType_Name_ISAM(IndexDataType - 1)) & vbCrLf & MyShowDataTypeTable(True, DataType_Name_ISAM(IndexDataType)) & vbCrLf & MyShowDataTypeTable(True, DataType_Name_ISAM(IndexDataType - 1)), "")
                Case -4 ' beginning of the list so ignore it
                    '5   -4  A=nothing And b< C
                    '7   -4  A=Nothing
                    If Not MyIsNothing(DataType_TableName(DataType_Name_ISAM(IndexDataType - 1))) Then ' It is not the beginning of the list
                        FindingMyBugsDataType += MSG_ABug(1967, "Finding My Bugs: DataType List Out of order", IndexDataType.ToString, "{" & DataType_TableName(DataType_Name_ISAM(IndexDataType - 1)) & "} : {" & DataType_TableName(DataType_Name_ISAM(IndexDataType)) & "} : {" & DataType_TableName(DataType_Name_ISAM(IndexDataType + 1)) & "}")
                    End If
                Case -3 '11  -3 A is higher than B  and C = nothing
                    FindingMyBugsDataType += MSG_ABug(1968, "Finding My Bugs: DataType List Out of order", IndexDataType.ToString, MyShowDataTypeTable(True, IndexDataType - 1) & vbCrLf & MyShowDataTypeTable(True, IndexDataType) & vbCrLf & MyShowDataTypeTable(True, IndexDataType + 1))
                Case -2 '12  -2  b > C List is out of order
                    FindingMyBugsDataType += MSG_ABug(1969, "Finding My Bugs: DataType List is out of order ", IndexDataType.ToString, MyShowDataTypeTable(True, IndexDataType - 1) & vbCrLf & MyShowDataTypeTable(True, IndexDataType) & vbCrLf & MyShowDataTypeTable(True, IndexDataType + 1))
                Case -1 '3   -1 A=b
                    FindingMyBugsDataType += MSG_ABug(1970, "Finding My Bugs: DataType List has a duplicate ", IndexDataType.ToString, MyShowDataTypeTable(True, IndexDataType - 1) & vbCrLf & MyShowDataTypeTable(True, IndexDataType) & vbCrLf & MyShowDataTypeTable(True, IndexDataType + 1))
                    FindingMyBugsDataType += MSG_ABug(1971, "Finding My Bugs: " & MyShowDataTypeTable(True, IndexDataType - 1), MyShowDataTypeTable(True, IndexDataType), MyShowDataTypeTable(True, IndexDataType + 1))
                Case 0  ' they are equal , which they should never be.only one name allowed per data type
        ' or they are between nulls or should be between -1 and +1
        '2   0   A And C = nothing
        '10  0 A<b<C 'not in the list but should go between these
                Case 1 '4   1   b=C  DataType Should never have a duplicate

                    FindingMyBugsDataType += MSG_ABug(1972, "Finding My Bugs: DataType List has a duplicate ", IndexDataType.ToString, MyShowDataTypeTable(True, IndexDataType - 1) & vbCrLf & MyShowDataTypeTable(True, IndexDataType) & vbCrLf & MyShowDataTypeTable(True, IndexDataType + 1))
                Case 2        '14  2   A < b The list is ok, so ignore it
                Case 3        '13  3 b < C The list is ok, so ignore it
                Case 4'end of the list SO IGNORE IT
        '6   4 C=nothing And b > A
        '8   4 C = nothing
                Case 5 ' LocalIndex = null Which is not a bug if -1 or +1 is also null
                    FindingMyBugsDataType += MSG_ABug(1973, "Finding My Bugs: The compare of the DataTypes are wrong because they are out of order", IndexDataType.ToString, MyShowDataTypeTable(True, IndexDataType - 1) & vbCrLf & MyShowDataTypeTable(True, IndexDataType) & vbCrLf & MyShowDataTypeTable(True, IndexDataType + 1))
                    '1   5 b=nothing
            End Select
            Return FindingMyBugsDataType
        End Function

        Public Shared Function FindingMyBugsDataType() As Int32
            Dim IndexDataType As Int32
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3389, 10, "FindMyBugsDataType")
#End If
            If mydebug(9) Then follow(2570, 9, "FMB: Data Types")
            FindingMyBugsDataType = 0
            If MyOptionTest(31) = False Then Exit Function
            For IndexDataType = 1 To MyUniverse.MyStaticData.DataType_TableCount
                FindingMyBugsDataType(IndexDataType)
            Next IndexDataType


        End Function

        Public Shared Function FindingMyBugsColor() As Int32
            Dim indexColor As Int32
            FindingMyBugsColor = 0
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3390, 10, "FindMyBugsColor")
#End If
            If mydebug(9) Then follow(2571, 9, "FMB: Colors")
            If MyOptionTest(31) = False Then Exit Function


            '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            For indexColor = 1 To MyUniverse.MyStaticData.Color_TableCount
                ' The color table should never be nothing
                If Not MyIsNothing(Color_FileName(Color_Name_ISAM(indexColor))) Then '20200630
                    'The color table should never be nothing
                    If Not MyIsNothing(Color_FileName(Color_Name_ISAM(indexColor + 1))) Then '20200630
                        ' Testing if two names are out of order
                        If Color_FileName(Color_Name_ISAM(indexColor)) > Color_FileName(Color_Name_ISAM(indexColor + 1)) Then '20200630
                            FindingMyBugsColor += MSG_ABug(1975, "Finding My Bugs: " & Color_FileName(Color_Name_ISAM(indexColor)), "<<==Color Name Not in order ==>", Color_FileName(Color_Name_ISAM(indexColor + 1))) ' unsorted color names
                        End If
                    End If
                End If
                'Testing each to see if it is in order and returns correctly
                Select Case MyCompared3(Color_FileName(Color_Name_ISAM(indexColor - 1)), Color_FileName(Color_Name_ISAM(indexColor)), Color_FileName(Color_Name_ISAM(indexColor + 1)))
                    Case -5 '9   -5  A > C 'Unsorted List
                        FindingMyBugsColor += MSG_ABug(1976, "Finding My Bugs: color table is out of order === ", indexColor.ToString, "{" & Color_FileName(Color_Name_ISAM(indexColor - 1)) & "} < {" & Color_FileName(Color_Name_ISAM(indexColor)) & "} < {" & Color_FileName(Color_Name_ISAM(indexColor + 1)) & "}")
                    Case -4 ' beginning of the list so ignore it
                        '5   -4  A=nothing And b< C
                        '7   -4  A=Nothing
                        If Not MyIsNothing(Color_FileName(Color_Name_ISAM(indexColor - 1))) Then
                            FindingMyBugsColor += MSG_ABug(1977, "Finding My Bugs: Color Table is out of order ===", indexColor.ToString, "{" & Color_FileName(Color_Name_ISAM(indexColor - 1)) & "} < {" & Color_FileName(Color_Name_ISAM(indexColor)) & "} < {" & Color_FileName(Color_Name_ISAM(indexColor + 1)) & "}") ' color table is out of order
                        End If
                    Case -3 '11  -3 A is higher than B  and C = nothing
                        FindingMyBugsColor += MSG_ABug(1978, "Finding My Bugs: Color Table is out of order ===", indexColor.ToString, "{" & Color_FileName(Color_Name_ISAM(indexColor - 1)) & "} < {" & Color_FileName(Color_Name_ISAM(indexColor)) & "} < {" & Color_FileName(Color_Name_ISAM(indexColor + 1)) & "}") ' color table is out of order
                    Case -2 '12  -2  b > C List is out of order
                        FindingMyBugsColor += MSG_ABug(1979, "Finding My Bugs: Color Table is out of order ===", indexColor.ToString, "{" & Color_FileName(Color_Name_ISAM(indexColor - 1)) & "} < {" & Color_FileName(Color_Name_ISAM(indexColor)) & "} < {" & Color_FileName(Color_Name_ISAM(indexColor + 1)) & "}")' color table is out of order
                    Case -1 '3   -1 A=b
                        FindingMyBugsColor += MSG_ABug(1980, "Finding My Bugs: Color Table  has a duplicate", indexColor.ToString, "{" & Color_FileName(Color_Name_ISAM(indexColor - 1)) & "} < {" & Color_FileName(Color_Name_ISAM(indexColor)) & "} < {" & Color_FileName(Color_Name_ISAM(indexColor + 1)) & "}")' color table should never have a duplicate
                    Case 0  ' they are equal , which they should never be.only one name allowed per data type
        ' or they are between nulls or should be between -1 and +1
        '2   0   A And C = nothing
        '10  0 A<b<C 'not in the list but should go between these
                    Case 1 '4   1   b=C  Color Table Should never have a duplicate
                        FindingMyBugsColor += MSG_ABug(1981, "Finding My Bugs: Color Table has a duplicate ===", indexColor.ToString, "{" & Color_FileName(Color_Name_ISAM(indexColor - 1)) & "} < {" & Color_FileName(Color_Name_ISAM(indexColor)) & "} < {" & Color_FileName(Color_Name_ISAM(indexColor + 1)) & "}")
                    Case 2        '14  2   A < b The list is ok, so ignore it
                    Case 3        '13  3 b < C The list is ok, so ignore it
                    Case 4'end of the list so Ignore it
        '6   4 C=nothing And b > A
        '8   4 C = nothing
                    Case 5 ' IndexColor = null Which is not a bug if -1 or +1 is also null
                        FindingMyBugsColor += MSG_ABug(1982, "Finding My Bugs: The Color Table is out of Order ===", indexColor.ToString, "{" & Color_FileName(Color_Name_ISAM(indexColor - 1)) & "} < {" & Color_FileName(Color_Name_ISAM(indexColor)) & "} < {" & Color_FileName(Color_Name_ISAM(indexColor + 1)) & "}")
                        '1   5 b=nothing
                End Select
            Next indexColor
        End Function



        'You ask why are you doing this instead of just a if a = b then
        ''well I DoNot have an answer for you ( I guess that I just like to pop things to the stacek
        ' (Except that it is easier to put a break point at the return false part to catch this issue
        Public Shared Function IsTheDropDownText_TheSameAs_TheSelectedText(FixIt As Boolean, ByRef A As String, B As ToolStripDropDownButton) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3391, 10, "IsTheDropDownText_TheSameAs_TheSelectedText ")
#End If
            If A = B.Text Then Return True
            If mydebug(9) Then follow(2572, 5, "Is The Drop Down Text The Same As Selected Text " & A & " <<--->>  " & B.Text)
            If FixIt = True Then 'so that I can use this in finding my bugs, (with out changing anything)
                If MyIsNothing(B.Text) Then
                    MSG_ABug(1984, "Selection is B blank", HighLight(A.ToString), HighLight(B.Text))
                    SelectInToolStripDropDownButton(B, A)
                    Return True 'cause it is equal now.
                Else
                    If MyIsNothing(A) Then
                        MSG_ABug(1985, "Selection A is blank", HighLight(A.ToString), HighLight(B.Text))
                        A = B.Text
                        Return True
                    End If
                End If
            Else
                If MyOptionTest(25) = True Then
                    MSG_AInfo(1986, "Selection and drop downs do not match", HighLight(A.ToString), HighLight(B.Text) & " = " & HighLight(B.Name))
                    B.Text = A
                    Return True
                Else
                    MSG_AInfo(1986, "Selection and drop downs do not match", HighLight(A.ToString), HighLight(B.Text) & " = " & HighLight(B.Name))
                    B.Text = A
                    Return True
                End If
            End If
            Return False
        End Function


        Public Shared Function GetMarker(WhichOne As Int32, FromWhat As String) As String
            Dim I, J, K As Int32
            J = InStr(FromWhat, MyUniverse.SysGen.Constants.RMStart)
            If J = 0 Then Return ""
            For I = 1 To WhichOne
                J = InStr(J + 1, FromWhat, MyUniverse.SysGen.Constants.RMStart)
                If J = 0 Then Return ""
            Next
            K = InStr(J, FromWhat, MyUniverse.SysGen.Constants.RMEnd)
            Return Mid(FromWhat, J, K - J + Len(MyUniverse.SysGen.Constants.RMEnd))
        End Function

        Public Shared Function FindingMyBugsSyntax1(IndexFlowChart As Int32) As Int32
            Dim Symbol, Syntax, Marker As String
            Dim MyConnectionsToMyCode As String
            Dim IndexNamed, I As Int32
            FindingMyBugsSyntax1 = 0
            'First check that every marker in the syntax has an attribute defined in the graphics to text source code
            Symbol = FlowChart_TableSymbol_Name(IndexFlowChart)
            IndexNamed = FindSymbol_StartIndex(Symbol)
            If IndexNamed < 1 Then Return 1
            Syntax = Named_TableMicroCodeText(IndexNamed)
            MyConnectionsToMyCode = MyShowAndUpDateProperties(IndexFlowChart)


            I = 1
            While I > 0
                Marker = GetMarker(I, " " & Syntax)
                If Marker = "" Then Exit While
                Marker = "/" & No_FieldDelimiter(Marker)
                If InStr(MyConnectionsToMyCode, Marker) > 0 Then
                    '                    DebugPrint("Yes " & Marker) ' Yes so keep going
                Else
                    FindingMyBugsSyntax1 += 1
                    '                    DebugPrint("No " & Marker) ' So error message
                    MSG_ABug(1152, "Symbol " & Symbol & " is not defined in the symbol attribute : " & Marker, MyNoCR(MyConnectionsToMyCode), "")
                End If
                I += 1
            End While
            Return FindingMyBugsSyntax1
        End Function



        'check and make sure that the syntax matches the source code 
        Public Shared Function FindingMyBugsSyntax(IndexFlowChart As Int32) As Int32
            Dim IndexNamed As Int32
            Dim A As String
            Dim MyArray(10) As String
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3392, 1, "FindMyBugsSyntax " & IndexFlowChart.ToString)
#End If
            If mydebug(9) Then follow(2573, 9, "FMB: Syntax " & FlowChart_TableCode(IndexFlowChart))
            If FlowChart_TableCode(IndexFlowChart) <> My_keyWord(My_KeyConstUse) Then Return 0
            FindingMyBugsSyntax = 0
            'todo this should take a while, but who cares, all of the FindingMyBugs should disappear
            A = FlowChart_TableSymbol_Name(IndexFlowChart)
            IndexNamed = FindInSymbolList(A)
            If FlowChart_TableCode(IndexFlowChart) <> My_keyWord(My_KeyConstUse) Then
                If Named_TableSymbolName(IndexNamed) <> FlowChart_TableSymbol_Name(IndexFlowChart) Then
                    Return FindingMyBugsSyntax
                End If
            End If
            Return FindingMyBugsSyntax
        End Function

        'find issues with any thing related to the drop downs
        Public Shared Function FindingMyBugsDropDowns() As Int32
            Dim IndexDropDown As Int32
            Dim Temp1, Temp2 As Int32
            Dim Temp3 As String
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3393, 10, "FindMyBugsDropDowns")
#End If
            If MyOptionTest(31) = False Then Return 0
            If Not MyDebug(7) Then Return 0
            If mydebug(9) Then follow(2574, 7, "FMB: Drop Downs")
            'need to make sure that they are the same as the dropdown text
            'This is breaking my own rules of not changing anything in the finding my bugs() not changing anything
            If IsTheDropDownText_TheSameAs_TheSelectedText(False, MyUniverse.ProgramOptions.SelectedColor, SymbolWindow.ToolStripDropDownButtonColor) = False Then MSG_ABug(1997, "Finding My Bugs: Color", " Not selected correctly.", "")
            If IsTheDropDownText_TheSameAs_TheSelectedText(False, MyUniverse.ProgramOptions.SelectedDataType, SymbolWindow.ToolStripDropDownDataType) = False Then
                MSG_ABug(1998, "Finding My Bugs: DataType not selected correctly.", MyUniverse.ProgramOptions.SelectedDataType, SymbolWindow.ToolStripDropDownDataType.ToString)
            End If
            If IsTheDropDownText_TheSameAs_TheSelectedText(False, MyUniverse.ProgramOptions.SelectedInputOutput, SymbolWindow.ToolStripDropDownInputOutput) = False Then MSG_ABug(1999, "Finding My Bugs: input/output Not selected correctly.", MyUniverse.ProgramOptions.SelectedInputOutput, SymbolWindow.ToolStripDropDownInputOutput.Text)

            If IsTheDropDownText_TheSameAs_TheSelectedText(False, MyUniverse.ProgramOptions.SelectedRotation, SymbolWindow.ToolStripDropDownRotation) = False Then MSG_ABug(2000, "Finding My Bugs: Rotation Not selected correctly.", "", "")

            If IsTheDropDownText_TheSameAs_TheSelectedText(False, FlowChartWindow.ToolStripDropDownSelectSymbol.Text, SymbolWindow.ToolStripDropDownSelectSymbol) = False Then MSG_ABug(2001, "Finding My Bugs: FlowChart Window selected Symbol  does not match Symbol Window selected Symbol ", HighLight(FlowChartWindow.ToolStripDropDownSelectSymbol.Text), HighLight(SymbolWindow.ToolStripDropDownSelectSymbol.Text))

            If IsTheDropDownText_TheSameAs_TheSelectedText(False, MyUniverse.ProgramOptions.SelectedSymbolName, SymbolWindow.ToolStripDropDownSelectSymbol) = False Then MSG_ABug(2002, "Finding My Bugs: Symbol ", " Not selected correctly.", " on the Symbol Window")

            If IsTheDropDownText_TheSameAs_TheSelectedText(False, MyUniverse.ProgramOptions.SelectedSymbolName, FlowChartWindow.ToolStripDropDownSelectSymbol) = False Then MSG_ABug(2003, "Finding My Bugs: Symbol ", " Not selected correctly.", " on the FlowChart Window")

            If IsTheDropDownText_TheSameAs_TheSelectedText(False, MyUniverse.ProgramOptions.SelectedPathStart, SymbolWindow.ToolStripDropDownPathStart) = False Then MSG_ABug(2004, "Finding My Bugs: path start", " Not selected correctly.", "")

            If IsTheDropDownText_TheSameAs_TheSelectedText(False, MyUniverse.ProgramOptions.SelectedPathEnd, SymbolWindow.ToolStripDropDownPathEnd) = False Then MSG_ABug(2005, "Finding My Bugs: path end ", " Not selected correctly.", "")

            If IsTheDropDownText_TheSameAs_TheSelectedText(False, MyUniverse.ProgramOptions.SelectedPathLineStyle, SymbolWindow.ToolStripDropDownPathLineStyle) = False Then MSG_ABug(2006, "Finding My Bugs: path line style ", " Not selected correctly.", "")

            If IsTheDropDownText_TheSameAs_TheSelectedText(False, MyUniverse.ProgramOptions.SelectedNumberOfBytes, SymbolWindow.ToolStripDropDownNumberOfBytes) = False Then MSG_ABug(2007, "Finding My Bugs: number of bytes", " Not selected correctly.", "")

            'they are not
            ' Assume that the two drop down list are sorted      !!!!!!!!!!!!!

            FindingMyBugsDropDowns = 0
#If MINEDEBUG Then
            FindingMyBugsChangeOfWindows()
#End If
            If SymbolWindow.Visible = True Then
                For IndexDropDown = 1 To SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count - 1
                    If SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text = SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown - 1).Text Then
                        FindingMyBugsDropDowns += MSG_ABug(2008, "Finding My Bugs: Duplicate Symbol name in the startWindow", SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text, "")
                    End If
                Next
                'todo all of these drop downs needs to have checks one them 
                If SymbolWindow.ToolStripButtonAddLine.Enabled = False Then
                    MSG_MyTrace3(2009, "'todo ")
                Else
                    MSG_MyTrace3(2010, "'to be done")
                End If
                ' If SymbolWindow.ToolStripButtonAddPoint.Enabled = False Then
                ' MSG_MyTrace3(2011, "'todo ")
                ' Else
                ' MSG_MyTrace3(2012, "'to be done")
                ' End If
                ' If SymbolWindow.ToolStripButtonDelete.Enabled = False Then
                ' MSG_MyTrace3(2013, "'todo ")
                ' Else
                ' MSG_MyTrace3(2014, "'to be done")
                ' End If
                ' If SymbolWindow.ToolStripButtonFlowChartForm_FromSymbolWindow.Enabled = False Then
                ' MSG_MyTrace3(2015, "'todo ")
                ' Else
                ' MSG_MyTrace3(2016, "'to be done")
                ' End If
                ' If SymbolWindow.ToolStripButtonMove.Enabled = False Then
                ' MSG_MyTrace3(2017, "'todo ")
                ' Else
                ' MSG_MyTrace3(2018, "'to be done")
                ' End If
                ' If SymbolWindow.ToolStripButtonNewSymbol.Enabled = False Then
                ' MSG_MyTrace3(2019, "'todo ")
                ' Else
                ' MSG_MyTrace3(2020, "'to be done")
                ' End If
                ' If SymbolWindow.ToolStripButtonOptionForm_FromSymbolWindow.Enabled = False Then
                ' MSG_MyTrace3(2021, "'todo ")
                ' Else
                ' MSG_MyTrace3(2022, "'to be done")
                ' End If
                ' If SymbolWindow.ToolStripButtonUpdateSymbol.Enabled = False Then
                ' MSG_MyTrace3(2023, "'todo ")
                ' Else
                ' MSG_MyTrace3(2024, "'to be done")
                ' End If
                ' If SymbolWindow.ToolStripDropDownButtonColor.Enabled = False Then
                ' MSG_MyTrace3(2025, "'todo ")
                ' Else
                ' MSG_MyTrace3(2026, "'to be done")
                ' End If
                If SymbolWindow.ToolStripDropDownDataType.Enabled = False Then
                    MSG_MyTrace3(2027, "'todo ")
                Else
                    MSG_MyTrace3(2028, "'to be done")
                End If
                ' If SymbolWindow.ToolStripDropDownInputOutput.Enabled = False Then
                ' MSG_MyTrace3(2029, "'todo ")
                ' Else
                ' MSG_MyTrace3(2030, "'to be done")
                ' End If
                ' If SymbolWindow.ToolStripDropDownLineWidth.Enabled = False Then
                ' MSG_MyTrace3(2031, "'todo ")
                ' Else
                ' MSG_MyTrace3(2032, "'to be done")
                ' End If
                ' If SymbolWindow.ToolStripDropDownNumberOfBytes.Enabled = False Then
                ' MSG_MyTrace3(2033, "'todo ")
                ' Else
                ' MSG_MyTrace3(2034, "'to be done")
                ' End If
                ' If SymbolWindow.ToolStripDropDownPathEnd.Enabled = False Then
                ' MSG_MyTrace3(2035, "'todo ")
                ' Else
                ' MSG_MyTrace3(2036, "'to be done")
                ' End If
                ' If SymbolWindow.ToolStripDropDownPathStart.Enabled = False Then
                ' MSG_MyTrace3(2037, "'todo ")
                ' Else
                ' MSG_MyTrace3(2038, "'to be done")
                ' End If
                ' If SymbolWindow.ToolStripDropDownPathLineStyle.Enabled = False Then
                ' MSG_MyTrace3(2039, "'todo ")
                ' Else
                ' MSG_MyTrace3(2040, "'to be done")
                ' End If
                ' If SymbolWindow.ToolStripDropDownRotation.Enabled = False Then
                ' MSG_MyTrace3(2041, "'todo ")
                ' Else
                ' MSG_MyTrace3(2042, "'to be done")
                ' End If
                ' If SymbolWindow.ToolStripDropDownSelectSymbol.Enabled = False Then
                ' MSG_MyTrace3(2043, "'todo ")
                ' Else
                ' MSG_MyTrace3(2044, "'to be done")
                ' End If
                '

                'TODO make sure that the two list match
                Temp1 = FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count
                Temp2 = SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count
                If MyDebug(9) Then follow(2338, 10, Temp1.ToString & " <-----> " & Temp2.ToString)
                If Temp1 <> Temp2 Then
                    If LCase(Trim(SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text)) <>
LCase(Trim(FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text)) Then
                        FindingMyBugsDropDowns += MSG_ABug(2045, "Finding My Bugs: FlowChartWindow  and Symbol Window does not have the same Symbol list." & HighLight(IndexDropDown.ToString), HighLight(LCase(Trim(SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text))) & Len(LCase(Trim(SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text))).ToString, HighLight(LCase(Trim(FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text))) & Len(LCase(Trim(FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text))))
                    End If
                End If

            End If

#If MINEDEBUG Then
            FindingMyBugsChangeOfWindows()
#End If
            If FlowChartWindow.Visible = True Then
                For IndexDropDown = 1 To FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Count - 1
                    Temp3 = FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text
                    '                    if mydebug(4) then  follow(2339, 10, "Looking at Symbols to select @ " & IndexDropDown.ToString & " = " & FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text & " , " & Pop(Temp3, MyUniverse.SysGen.Constants.ConstantDelimiters))
                    If FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text = FlowChartWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown - 1).Text Then
                        FindingMyBugsDropDowns += MSG_ABug(2046, "Finding My Bugs: Duplicate Symbol name in the FlowChart Window", SymbolWindow.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text, "")
                    End If
                Next
            End If

            'todo make sure that all of the defined Symbols are in the drop down list Symbols

            'TODO make sure that the two list match

        End Function


        Public Shared Function FindingMyBugsNamed() As Int32
            Dim IndexNamed, Jndex As Int32
            Dim flag As Int32
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3394, 10, "FindMyBugsNamed")
#End If
            If mydebug(9) Then follow(2575, 9, "FMB: Named")
            FindingMyBugsNamed = 0
            If MyOptionTest(31) = False Then Exit Function
            '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            For IndexNamed = 1 To MyUniverse.MyStaticData.Named_TableCount
                Jndex = IndexNamed - 1
                If Jndex > 0 Then
                    If Named_TableSymbolName(Jndex) = Named_TableSymbolName(IndexNamed) Then ' See if two Symbols are defined
                        FindingMyBugsNamed += MSG_ABug(2048, "Finding My Bugs: Two Symbols with the name name", MyShowNamedRecords(True, Jndex), MyShowNamedRecords(True, Jndex))
                    End If
                End If

                FindingMyBugsPoints(Named_TableSymbolName(Named_FileSymbolName_ISAM(IndexNamed)))
                ' Check for two names in the named file
                If PrintAbleNull(Named_TableSymbolName(Named_FileSymbolName_ISAM(IndexNamed))) <> "_" Then
                    If PrintAbleNull(Named_TableSymbolName(Named_FileSymbolName_ISAM(IndexNamed + 1))) <> "_" Then
                        If Named_TableSymbolName(Named_FileSymbolName_ISAM(IndexNamed)) >= Named_TableSymbolName(Named_FileSymbolName_ISAM(IndexNamed + 1)) Then
                            FindingMyBugsNamed += MSG_ABug(2049, "Finding My Bugs: The Named Table is out of order at " & IndexNamed & " and " & IndexNamed + 1, Named_TableSymbolName(Named_FileSymbolName_ISAM(IndexNamed)), Named_TableSymbolName(Named_FileSymbolName_ISAM(IndexNamed + 1)))
                        End If
                    End If
                End If

                'Check for two syntax's being the same 
                If Len(Named_TableSyntax(IndexNamed)) > 1 Then
                    For Jndex = IndexNamed + 1 To MyUniverse.MyStaticData.Named_TableCount ' From the one in the list to the end
                        If Named_TableSymbolName(IndexNamed) = Named_TableSymbolName(Jndex) Then ' See if two Symbols are defined
                            FindingMyBugsNamed += MSG_ABug(2050, "Finding My Bugs: Two Symbols with the name name", MyShowNamedRecords(True, IndexNamed), MyShowNamedRecords(True, Jndex))
                        End If
                        If Named_TableSyntax(IndexNamed) = Named_TableSyntax(Jndex) Then ' See if two syntax's match (exactly)
                            FindingMyBugsNamed += MSG_ABug(2051, "Finding My Bugs: Two Symbols with the same syntax ", MyShowNamedRecords(True, IndexNamed), MyShowNamedRecords(True, Jndex))
                            MyDoEvents(216)
                        End If
                    Next Jndex
                End If

                ' Check for being two ISAM's being the same 
                If Named_FileSymbolName_ISAM(IndexNamed + 1) <> 0 And Named_FileSymbolName_ISAM(IndexNamed + 1) = Named_FileSymbolName_ISAM(IndexNamed) Then
                    FindingMyBugsNamed += MSG_ABug(2052, "Finding My Bugs: ISAM has two index to the same name", MyShowNamedRecords(True, IndexNamed), MyShowNamedRecords(True, IndexNamed + 1))
                End If

                flag = 0
                For Jndex = 1 To MyUniverse.MyStaticData.Named_TableCount
                    If Jndex <> IndexNamed Then
                        If Named_FileSymbolName_ISAM(IndexNamed) = Named_FileSymbolName_ISAM(Jndex) Then
                            FindingMyBugsNamed += MSG_ABug(2053, "Finding My Bugs: Named ISAM has  " & flag.ToString & " duplicated index's at: ", MyShowNamedRecords(True, IndexNamed), MyShowNamedRecords(True, Jndex))
                            flag += 1
                        End If
                    End If
                Next Jndex

                ' Tell how many are duplicated ' Extra
                If flag > 0 Then
                    FindingMyBugsNamed += MSG_ABug(2054, "Finding My Bugs: Number of times the index's are duplicated", flag.ToString, "")
                End If
            Next IndexNamed

        End Function

        Public Shared Function FindingMyBugsKeyWord(What As String, MyArray() As String) As Int32
            Dim IndexKeyWord As Int32 'Index, 
            Dim Status As String
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3396, 10, "FindMyBugsKeyWord " & What)
#End If
            If mydebug(9) Then follow(2576, 9, "FMB:  Key Words")
            FindingMyBugsKeyWord = 0
            If MyOptionTest(31) = False Then Exit Function
            '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            ' Check keyWord, Operator and Function
            For IndexKeyWord = LBound(MyArray) + 1 To UBound(MyArray) - 1
                If MyArray(IndexKeyWord - 1) = MyArray(IndexKeyWord) Then
                    FindingMyBugsKeyWord += MSG_ABug(2056, "Finding My Bugs: Program Duplication of key word", IndexKeyWord.ToString, HighLight(MyArray(IndexKeyWord - 1)) & HighLight(MyArray(IndexKeyWord)))
                End If
                If MyArray(IndexKeyWord - 1) > MyArray(IndexKeyWord) And Len(Trim(MyArray(IndexKeyWord))) > 0 Then
                    FindingMyBugsKeyWord += MSG_ABug(2057, "Finding My Bugs: Program out of order of key word", IndexKeyWord.ToString, HighLight(MyArray(IndexKeyWord - 1)) & HighLight(MyArray(IndexKeyWord)))
                End If
                '   Else
                '      FindingMyBugsKeyWord += MSG_ABug(2058, "Finding My Bugs: Void keyword " & IndexKeyWord.ToString, HighLight(IsThisAWhat(MyArray(IndexKeyWord - 1))) & HighLight(IsThisAWhat(MyArray(IndexKeyWord))) & HighLight(IsThisAWhat(MyArray(IndexKeyWord + 1))), What)
                '     End If
                Status = IsThisAWhat(MyArray(IndexKeyWord))
                If Status <> What Then
                    ' removed not needed ?Status = IsThisAWhat(MyArray(IndexKeyWord)) 'todo debug only
                    FindingMyBugsKeyWord += MSG_ABug(2059, "Finding My Bugs: Program keyword error >" & MyArray(IndexKeyWord) & "< is not found as an keyword type " & HighLight(What), MyArray(IndexKeyWord), "but thinks is a  " & IsThisAWhat(MyArray(IndexKeyWord)))
                ElseIf Len(Status) <> 0 Then
                Else
                    FindingMyBugsKeyWord += MSG_ABug(2060, "Finding My Bugs: " & HighLight(Status), HighLight(IsThisAWhat(MyArray(IndexKeyWord))), What & " : " & HighLight(MyArray(IndexKeyWord)))
                End If
            Next
        End Function



        Public Shared Function FindingMyBugsGrammar(What As String, MyArray() As String) As Int32
            Dim IndexGrammar As Int32 'Index, 
            Dim Status, X As String
            Dim Grammar As String
            Dim GrammarKeyWord As String
            Dim Z As String = ""
            Dim Temp1 As Int32
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3397, 10, "FindMyBugsGrammar " & What)
#End If
            DisplayStatus(FlowChartWindow.LabelProgramStatus, "FMB Grammar")
            DoThisEvent(3)
            'todo need to add to not check if nothing has changed
            If MyDebug(5) Then follow(2577, 5, "FMB: Grammar " & What)
            'todo need to add a section to check for valid hex formats
            FindingMyBugsGrammar = 0
            If MyOptionTest(31) = False Then Exit Function
            For IndexGrammar = LBound(MyArray) + 1 To UBound(MyArray) - 1
                If MyDebug(8) Then FMB1(8059)
                'first make sure that no BNF keyword is a keyword of the language
                Grammar = MyArray(IndexGrammar)
                Temp1 = InStr(Grammar, "::=")
                Z = ""
                If Temp1 > 0 Then
                    GrammarKeyWord = MyTrim(MyLeft(Grammar, Temp1 - 1))
                Else
                    GrammarKeyWord = Grammar
                End If
                If MyDebug(8) Then FMB(1147, GrammarKeyWord)
                If IsThisA_KeyWord(GrammarKeyWord) = True Then
                    Z &= GrammarKeyWord
                    MSG_ABug(2300, GrammarKeyWord, "You can not have your computer language keyword be defined as a Grammar keyword.", MyArray(IndexGrammar))
                End If
                If PrintAbleNull(MyArray(IndexGrammar)) <> "_" Then
                    If MyGrammarName(MyArray(IndexGrammar - 1)) = MyGrammarName(MyArray(IndexGrammar)) Then
                        FindingMyBugsGrammar += MSG_ABug(2119, "Finding My Bugs: Program Duplication of Grammar definition is not allowed ", IndexGrammar.ToString, vbCrLf & HighLight(MyArray(IndexGrammar - 1)))
                    End If
                    If MyArray(IndexGrammar - 1) > MyArray(IndexGrammar) Then
                        FindingMyBugsGrammar += MSG_ABug(2120, "Finding My Bugs: Program out of order of key word", IndexGrammar.ToString, HighLight(MyArray(IndexGrammar - 1)) & HighLight(MyArray(IndexGrammar)))
                    End If
                Else
                    FindingMyBugsGrammar += MSG_ABug(2058, "Finding My Bugs: Void Grammar definition " & IndexGrammar.ToString, HighLight(IsThisAWhat(MyArray(IndexGrammar))), What)
                    Exit Function
                End If
                Status = MyArray(IndexGrammar)
                ' removed not used ?   Grammar = MyArray(IndexGrammar)
                While Len(Status) > 0
                    'todo need to only return a block if it the first item
                    If MyDebug(10) = True Then DisplayMyStatus(3, Status)
                    X = Trim(Block(Status)) ' take care of blocks first
                    If MyDebug(8) Then FMB(1148, X)
                    If X = "" Then
                        X = Trim(Pop(Status, MyUniverse.SysGen.Constants.ConstantDelimiters))
                    Else
                        Status = MyReplace(Status, X, "")
                    End If
                    Status = Trim(Status)
                    If MyLeft(Status, 1) = " " Then If MyDebug(9) Then follow(2394, 10, "a SPACE")
                    If X = "" Or X = vbCrLf Or X = vbLf Or X = vbCr Then
                        Z &= " CR LF "
                    ElseIf X = "::=" Then     'syntax BNF uses ::= or :
                        Z &= FD & X
                    ElseIf X = "'" Then
                        Z &= FD & X
                    ElseIf X = "|" Then     ' BNF or
                        Z &= FD & X
                    ElseIf X = ";" Then     ' BNF end of line
                        Z &= FD & X
                        Status = "" 'ignore the rest of the line
                    ElseIf X = ")" Then     ' start group
                        Z &= FD & X
                    ElseIf X = ")?" Then     ' start group
                        Z &= FD & X
                    ElseIf X = ")*" Then     ' start group
                        Z &= FD & X
                    ElseIf X = ")+" Then     ' start group
                        Z &= FD & X
                    ElseIf X = ")-" Then     ' start group
                        Z &= FD & X
                    ElseIf X = "(" Then     ' end group
                        Z &= FD & X

                    ElseIf IsThISAMarker(X) <> "" Then
                        Z &= FD & AddRM(X)
                    ElseIf IsThisABlock(X) = True Then
                        '                        Z &= FD & AddRM("Block." & NoBlock(WhatIsThisBlock(X))) 'todo this should call to get just the cGrammar of this block(
                        'todo need to make sure this block is valid
                        GrammarKeyWord = Trim(WhatIsThisBlock(X))
                        If IsThisA_KeyWord(GrammarKeyWord) = True Then
                            Z &= FD & GrammarKeyWord
                            'Status = Trim(Mid(Status, Len(X) + 1))
                            'Status = MyReplace(Status, GrammarKeyWord, "")
                        ElseIf IsThisA_Operator(GrammarKeyWord) = True Then
                            Z &= FD & GrammarKeyWord
                            'Status = Trim(Mid(Status, Len(X) + 1))
                        ElseIf GrammarKeyWord = "" Then
                        Else
                            If Len(GrammarKeyWord) = 1 And Len(X) = 3 Then ' this is a character only so ignore
                                Z &= FD & Mid(GrammarKeyWord, 2, 1)
                                'If MyLeft(Status, 3) = X Then Status = Trim(Mid(Status, 4))
                            ElseIf Hex2Bin(GrammarKeyWord) > -1 Then 'this is a single hex 8 or 16 bit character
                                Z &= FD & GrammarKeyWord
                            ElseIf TestUnicodeRange(GrammarKeyWord, "A") = True Then
                                Z &= FD & AddRM("Grammar.Unicode." & GrammarKeyWord)
                                Status = Trim(Mid(Status, Len(X) + 1))
                            ElseIf FindInSortedLanguageList("Grammar", GrammarKeyWord, Language_Grammar) > 0 Then 'this is already a keyword.
                                Z &= FD & AddRM("Grammar.keyword." & GrammarKeyWord)
                            Else
                                Z &= FD & AddRM("Grammar." & GrammarKeyWord)
                                ShowSorts("Grammar", ReSortLanguagekeyWord("Grammar", MyArray, IndexGrammar))
                                If MyDebug(5) = True Then If mydebug(9) Then follow(2098, 5, "Keyword " & GrammarKeyWord & " added from /Grammar= " & X)
                            End If
                        End If
                    ElseIf BlockBreak(MyArray(IndexGrammar), "<>") <> "" Then
                        Z &= FD & AddRM(BlockBreak(MyArray(IndexGrammar), "<>"))
                        If MyDebug(9) Then follow(2302, 10, "Block " & BlockBreak(MyArray(IndexGrammar), "<>"))
                    ElseIf IsThisA_KeyWord(NoBlock(X)) Then
                        Z &= FD & AddRM(X)
                        If MyDebug(9) Then follow(2302, 10, "Is keyword=" & FindMyKeyword(NoBlock(X)).ToString & FD & NoBlock(X))
                    ElseIf IsThisA_Operator(NoBlock(X)) Then
                        Z &= FD & AddRM(X)
                        If MyDebug(9) Then follow(2302, 10, "Is operator=" & FindMyKeyword(NoBlock(X)).ToString & FD & NoBlock(X))
                    ElseIf IsThisA_Function(NoBlock(X)) Then
                        Z &= FD & AddRM(X)
                        If MyDebug(9) Then follow(2302, 10, "Is function=" & FindMyKeyword(NoBlock(X)).ToString & FD & NoBlock(X))
                    ElseIf FindMyGrammarName(X) <> "" Then
                        Z &= FD & AddRM(X)
                        If MyDebug(9) Then follow(2302, 10, "The name of this Grammar has is =  " & X)
                    Else
                        If InStr(MyRight(X, 1), "?*+-") > 0 Then
                            If FindMyGrammarName(Mid(X, 1, Len(X) - 1)) = "" Then
                                Z &= FD & AddRM(FindMyGrammarName(Mid(X, 1, Len(X) - 1)))
                                If MyDebug(9) Then follow(2303, X & vbTab & MyArray(IndexGrammar))
                            End If
                        ElseIf X = "''" Then
                            Z &= FD & AddRM("''")
                        Else
                            If MyDebug(8) Then follow(2395, "Stop test to see if it defined as something " & vbCrLf & X & vbCrLf & FindMyGrammarName(Mid(X, 1, Len(X) - 1)))
                            Z &= FD & " ???? " & AddRM(X) & " ???? "
                        End If
                    End If
                End While
            Next
        End Function




        Public Shared Function FindingMyBugsPath(IndexFlowChart As Int32) As Int32
            Dim LocalIndex, Jdex, KDex As Int32
            Dim IndexDataType, IndexNet As Int32 'IndexNamed, IndexSymbol, 
            Dim Temp As String
            If DontFindMyBugs() = True Then Return 0
#If MINEDEBUG Then
  if mydebug(9) then follow(3398, 10, "FindMyBugsPath")
#End If
            If Not MyDebug(6) Then Return 0
            If mydebug(9) Then follow(2578, 6, "FMB: Flow Chart Paths " & MyShowFlowChartRecord(False, IndexFlowChart))
            FindingMyBugsPath = 0
            If MyOptionTest(31) = False Then Exit Function

            If FlowChart_TableCode(IndexFlowChart) <> "/path" Then
                FindingMyBugsPath += MSG_ABug(2062, "Finding My Bugs: This is not a /path", MyShowFlowChartRecord(True, IndexFlowChart), "")
                Exit Function
                'Return FindIndex1(FlowChart_ISAM_Name) 'program error (most likely)
            End If
            'Check if Symbol exist
            'todo index flow chart is not yet define     IndexSymbol = Named_TableSymbolIndexes(IndexNamed) ' Error should be caught in FindingMyBugsNamed()
            IndexDataType = FindDataTypeIndex(FlowChart_File_DataType(IndexFlowChart))
            If InvalidIndex(IndexDataType, DataType_FileName) = True Then
                FindingMyBugsPath += MSG_ABug(2063, "Finding My Bugs: Not a valid DataType", MyShowFlowChartRecord(True, IndexFlowChart), "")
            End If

            'Not testing this for now.
            'todo this if this is valid pathlinks or compiled macro code 
            'FlowChart_FilePathLinks_And_CompiledMacroCodeText(IndexFlowChart )


            KDex = FindLowerXY(FlowChart_ISAM_X1(IndexFlowChart), FlowChart_ISAM_X1, FlowChart_FileX1)
            KDex = FindLowerXY(FlowChart_ISAM_Y1(IndexFlowChart), FlowChart_ISAM_Y1, FlowChart_FileY1)
            KDex = FindLowerXY(FlowChart_ISAM_X2(IndexFlowChart), FlowChart_ISAM_X2, FlowChart_File_X2_Rotation)
            KDex = FindLowerXY(FlowChart_ISAM_Y2(IndexFlowChart), FlowChart_ISAM_Y2, FlowChart_File_Y2_Option)

            '?LocalIndex = FlowChart_ISAM_Name(IndexFlowChart )

            'todo check if valid DataType
            IndexNet = FindIndex_In_TableNetLinks(IndexFlowChart)

            If IndexNet <> 0 Then
                If FlowChart_TableCode(IndexFlowChart) = "/path" Then
                    If Net_FileNames(IndexNet) <> FlowChart_FilePathSymbolName(IndexFlowChart) Then
                        MSG_ABug(2064, "Finding My Bugs: The path name is not in the link list " & IndexFlowChart & ":" & IndexNet, MyShowFlowChartRecord(True, IndexFlowChart), MyShowNetLnks(IndexNet))
                    End If
                End If
                Temp = NoFD(Net_TableLinks(IndexNet))
                LocalIndex = PopNonZeroValue(Temp)
                If LocalIndex <> 0 Then
                    While Len(Temp) > 0
                        Temp = NoFD(Temp)
                        Jdex = PopValue(Temp)
                        If Jdex <> 0 Then
                            If LocalIndex <> Jdex Then
                                If FindingMyBugsCheckNet_TableLinks(LocalIndex, Jdex) = True Then
                                Else
                                    MSG_ABug(2067, "Finding My Bugs: Paths are not connected ", MyShowFlowChartRecord(True, LocalIndex), MyShowFlowChartRecord(True, Jdex) & vbCrLf & Net_FileNames(IndexNet) & vbTab & FlowChart_FilePathSymbolName(IndexFlowChart))
                                    'todo should try to auto route them together.
                                    Return 1
                                End If
                            End If
                        Else
                            MSG_ABug(2068, "Finding My Bugs: Invalid index number " & SHL(Net_TableLinks(IndexNet)), LocalIndex.ToString, Jdex.ToString)
                        End If
                    End While
                Else
                    MSG_ABug(2069, "Finding My Bugs: Invalid index1 ", LocalIndex.ToString, "")
                End If
            Else
            End If
            'todo check if DataType of path matches DataType of Symbol and other paths it connects to
            'todo check if path ontop of another path.

        End Function


        'Is there a path from A to B?
        Public Shared Function FindingMyBugsCheckNet_TableLinks(IndexFlowChart1 As Int32, IndexFlowChart2 As Int32) As Boolean
            Dim IndexNetLinks1, IndexNetLinks2 As Int32
            Dim xy1, xy2 As MyLineStructure
            If DontFindMyBugs() = True Then Return False
#If MINEDEBUG Then
  if mydebug(9) then follow(3399, 10, "FindMyBugsCheckNet_TableLinks")
#End If
            'First make sure they are both paths being passed.
            If FlowChart_TableCode(IndexFlowChart1) = "/error" Then Return False
            If FlowChart_TableCode(IndexFlowChart2) = "/error" Then Return False
            If mydebug(9) Then follow(2579, 10, "FMB: Check Nets ")

            If FlowChart_TableCode(IndexFlowChart1) = "/unknown" Then Return False
            If FlowChart_TableCode(IndexFlowChart2) = "/unknonw" Then Return False


            IndexNetLinks1 = FindIndex_In_TableNetLinks(IndexFlowChart1)
            IndexNetLinks2 = FindIndex_In_TableNetLinks(IndexFlowChart2)
            'Find the distance between them.
            xy1 = FlowChart2Line(IndexFlowChart1)
            xy2 = FlowChart2Line(IndexFlowChart2)
            If ROUTERPointsMatch(ROUTERCheckLinesEndAtEachOther(xy1, xy2), MyUniverse.MyStaticData.ZeroZero) = True Then
                Return False
            Else
                Return True
            End If
        End Function


        Public Shared Function ROUTERCheckLinesEndAtEachOther(XY1 As MyLineStructure, XY2 As MyLineStructure) As MyPointStructure
#If MINEDEBUG Then
  if mydebug(9) then follow(3400, 10, "ROUTERCheckLinesEndAtEachOther")
#End If
            If mydebug(9) Then follow(2580, 5, "ROUTER check line ends at each other " & MyShow2Lines(XY1, XY2))
            If XY1.a.x = XY2.a.x Then If XY1.a.y = XY2.a.y Then Return MyPoint1XY(XY1.a.x, XY1.a.y)
            If XY1.a.x = XY2.b.x Then If XY1.a.y = XY2.b.y Then Return MyPoint1XY(XY1.a.x, XY1.a.y)
            If XY1.b.x = XY2.a.x Then If XY1.b.y = XY2.a.y Then Return MyPoint1XY(XY1.b.x, XY1.b.y)
            If XY1.b.x = XY2.b.x Then If XY1.b.y = XY2.b.y Then Return MyPoint1XY(XY1.b.x, XY1.b.y)
            Return MyUniverse.MyStaticData.ZeroZero
        End Function


        'search backwards until you are below ?
        Public Shared Function FindLowerXY(LocalIndex As Int32, MyISAM() As Int32, MyArray() As Int32) As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3401, 10, "FindLowerXY")
#End If
            If mydebug(9) Then follow(2581, 7, "Find LowerXY " & LocalIndex.ToString & ", " & MyArray(LocalIndex).ToString)
            If LocalIndex >= 1 Then
                FindLowerXY = MyISAM(LocalIndex - 1) ' We are searching for one lower then the current selected index
            Else
                FindLowerXY = UBound(MyISAM)
            End If

            Do
                While InvalidIndex(FindLowerXY, FlowChart_FilePathSymbolName) = False And
    FlowChart_TableCode(FindLowerXY) <> "/path"
                    'make sure that the next on is not this one.
                    If LocalIndex <> MyISAM(FindLowerXY - 1) Then
                        FindLowerXY = MyISAM(FindLowerXY - 1) ' back up to the path before this on.
                    Else
                        Return FindIndex1(MyISAM)
                    End If
                End While
                If FindLowerXY < 1 Then
                    Return FindIndex1(MyISAM)
                End If
                FindLowerXY = MyCompared2(MyArray, MyISAM, FindLowerXY, LocalIndex)
                Select Case MyCompared2(MyArray, MyISAM, FindLowerXY, LocalIndex)
                    Case -10, -9, -8, -7, -6 'hack this is never turned
                        MSG_ABug(2074, "Finding My Bugs: " & MyCompared2(MyArray, MyISAM, FindLowerXY, LocalIndex), MyShowFlowChartRecord(True, FindLowerXY), MyShowFlowChartRecord(True, LocalIndex))
                    Case -5 ' usually an invalid index, but could many things.(Or invalid pointer)
                        If FindLowerXY < 1 Then Return FindIndex1(MyISAM)
                        Return FindLowerXY
                    Case -4 'hack this is never turned
                        MSG_ABug(2075, "Finding My Bugs: " & MyCompared2(MyArray, MyISAM, FindLowerXY, LocalIndex), MyShowFlowChartRecord(True, FindLowerXY), MyShowFlowChartRecord(True, LocalIndex))
                        MyCompared2(MyArray, MyISAM, FindLowerXY, LocalIndex)
                    Case -3 'A is higher than B  and C = nothing
                        MSG_ABug(2076, "Finding My Bugs: " & MyCompared2(MyArray, MyISAM, FindLowerXY, LocalIndex), MyShowFlowChartRecord(True, FindLowerXY), MyShowFlowChartRecord(True, LocalIndex))
                        MyCompared2(MyArray, MyISAM, FindLowerXY, LocalIndex)
                    Case -2
                        MSG_ABug(2077, "Finding My Bugs: ", MyCompared2(MyArray, MyISAM, FindLowerXY, LocalIndex) & MyShowFlowChartRecord(True, FindLowerXY), MyShowFlowChartRecord(True, LocalIndex))
                        MyCompared2(MyArray, MyISAM, FindLowerXY, LocalIndex)
                    Case -1 'FindLowerXY.x1 is less than index.x1
                        Return FindLowerXY
                    Case 0
                        'the two are equal
                        If InvalidIndex(FindLowerXY, FlowChart_FilePathSymbolName) = True Then 'Is FindLowerXY valid
                            Return FindIndex1(MyISAM) 'hack (who knows where the lowest /path is?
                        Else
                            If InvalidIndex(MyISAM(FindLowerXY - 1), FlowChart_FilePathSymbolName) = True Then
                                Return FindLowerXY
                            Else
                                FindLowerXY = MyISAM(FindLowerXY - 1)
                            End If
                        End If
                    Case 1
                        If InvalidIndex(FindLowerXY, FlowChart_FilePathSymbolName) Then Return FindIndex1(MyISAM) 'fail safe hack
                        If InvalidIndex(MyISAM(FindLowerXY), FlowChart_FilePathSymbolName) = True Then Return FindLowerXY 'If we can go no farther back then this is it.
                        'So lets try farther back down the list
                        If InvalidIndex(MyISAM(FindLowerXY - 1), FlowChart_FilePathSymbolName) = True Then Return FindLowerXY
                        FindLowerXY = MyISAM(FindLowerXY - 1) ' Greater so back up more (OK, This should never happend because the index for the flow chart should have been pointing to something that is at east equal
                    Case 2
                        MSG_ABug(2078, "Finding My Bugs: ", MyShowFlowChartRecord(True, FindLowerXY), MyShowFlowChartRecord(True, LocalIndex))
                        MyCompared2(MyArray, MyISAM, FindLowerXY, LocalIndex)
                    Case 3 'hack this is never turned
                        MSG_ABug(2079, "Finding My Bugs: ", MyShowFlowChartRecord(True, FindLowerXY), MyShowFlowChartRecord(True, LocalIndex))
                        MyCompared2(MyArray, MyISAM, FindLowerXY, LocalIndex)
                    Case 4 'hack this is never turned
                        MSG_ABug(2080, "Finding My Bugs: ", MyShowFlowChartRecord(True, FindLowerXY), MyShowFlowChartRecord(True, LocalIndex))
                        MyCompared2(MyArray, MyISAM, FindLowerXY, LocalIndex)
                    Case 5 'hack this is never turned
                        MSG_ABug(2081, "Finding My Bugs: ", MyShowFlowChartRecord(True, FindLowerXY), MyShowFlowChartRecord(True, LocalIndex))
                        MyCompared2(MyArray, MyISAM, FindLowerXY, LocalIndex)
                    Case 6, 7, 8, 9, 10 'hack this is never turned
                        MSG_ABug(2082, "Finding My Bugs: ", MyShowFlowChartRecord(True, FindLowerXY), MyShowFlowChartRecord(True, LocalIndex))
                End Select
            Loop While 1 = 1 'forever loop
        End Function

        Public Shared Sub MyAddErrorMessages()
            Dim TS, TE As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3402, 10, "MyAddErrorMessage")
#End If
            If MyDebug(6) Then follow(2582, 8, "Add ErrorMessages")
            TS = MyUniverse.SysGen.Constants.RMStart
            TE = MyUniverse.SysGen.Constants.RMEnd

            OptionsWindow.ComboBoxDebug.Items.Clear()
            ' This routine just loads the error Test for the messages, 
            '{On or off to display msgbox()}
            '{The number of the message must be between 1,000-9,998}
            '{an option of 
            '   "wrong"
            '   "information"
            '   "warning"
            '   "error"
            '   "display"
            '}
            'Then a string of the error message where " & ts & "string1" & te & " ...will be replaced with what the routine passes.
            ' also a few other special's such as " & ts & "routine" & te & " and " & ts & "tracer" & te & "
            MyErrorMessages("on", 1000, "Error", TS & "string1" & TE & vbCrLf & TS & "string2" & TE & vbCrLf & TS & "string3" & TE & vbCrLf & TS & "string4" & TE & vbCrLf & TS & "string5" & TE & vbCrLf & TS & "string6" & TE & vbCrLf & TS & "string7" & TE & vbCrLf & TS & "string8" & TE & vbCrLf & TS & "string9" & TE)
            MyErrorMessages("on", 1001, "Error", "Opening file requires write Or read." & vbCrLf & "Programing error Not reading Or writing file " & vbCrLf & "File name >" & TS & "string2" & TE & "<  " & vbCrLf & "trying to >" & TS & "string1" & TE & "< which Is Not read Or write")
            MyErrorMessages("on", 1003, "display", "Step " & TS & "string9" & TE & ": At Indexs " & TS & "string1" & TE & " and " & TS & "string2" & TE & " shows a code " & TS & "string3" & TE & ".The ISAMs out of order >" & TS & "string4" & TE & "<  high >" & TS & "string5" & TE & "<")
            MyErrorMessages("on", 1004, "Warning", "Checked if the two strings in the list are in ISAM order low >" & TS & "string2" & TE & "<  high >" & TS & "string1" & TE & "<")
            MyErrorMessages("on", 1005, "Error", "Sorting did Not work! And the array Is wrong!")
            MyErrorMessages("on", 1006, "Error", "Sorting did Not work! And the array Is wrong!")
            MyErrorMessages("on", 1007, "Error", "Array length Is " & TS & "string1" & TE & " " & vbCrLf & "ISAM array length Is " & TS & "string2" & TE & vbCrLf & " The array And the ISAM array are deferent sizes!")
            MyErrorMessages("on", 1008, "Display", "Checked if the two strings in the list:" & vbCrLf & " are in ISAM order >" & TS & "string2" & TE & "<< >" & TS & "string1" & TE & "<")
            MyErrorMessages("on", 1009, "Information", "Compile Finished to file>" & TS & "string1" & TE & "< ")
            MyErrorMessages("on", 1010, "Information", "Syntax made for Symbol " & TS & "string3" & TE & vbCrLf & "syntax = " & TS & "string2" & TE & " " & vbCrLf & " code = " & TS & "string1" & TE & vbCrLf & " path = " & TS & "string4" & TE & vbCrLf & " Symbol Index " & TS & "string5" & TE & " " & vbCrLf & " Named index " & TS & "string6" & TE)
            MyErrorMessages("on", 1011, "Error", "The ISAM is zero, and there is data in the number array Index=" & TS & "string1" & TE & " ISAM(index) =" & TS & "string2" & TE & " Array(index) = " & TS & "string3" & TE)
            MyErrorMessages("on", 1012, "Error", "The found (+0) " & TS & "string1" & TE & " with the ISAM Indexes " & TS & "string2" & TE & " should match" & vbCrLf & "The two strings are:" & vbCrLf & ">" & TS & "string3" & TE & "<" & vbCrLf & ">" & TS & "string4" & TE & "<")
            MyErrorMessages("on", 1013, "Error", "A value Is added to the list with a null before And after " & vbCrLf & "(-1)" & TS & "string1" & TE & " >" & TS & "string2" & TE & "<" & vbCrLf & "(+0)" & TS & "string3" & TE & " >" & TS & "string4" & TE & "<" & vbCrLf & "(+1)" & TS & "string5" & TE & " >" & TS & "string6" & TE & "<" & vbCrLf & "." & vbCrLf & "Checking in routine " & TS & "string8" & TE & " called from " & TS & "routine" & TE & " tracer " & TS & "tracer" & TE)
            MyErrorMessages("on", 1014, "information", "Trying to find >" & TS & "string1" & TE & "<  At index " & TS & "string2" & TE)
            MyErrorMessages("on", 1015, "Status", "Checking paths at " & TS & "string1" & TE & " >" & TS & "string6" & TE & "< (" & TS & "string2" & TE & FD & TS & "string3" & TE & ")_(" & TS & "string4" & TE & FD & TS & "string5" & TE & ")")
            MyErrorMessages("on", 1016, "Information", "Resorting with  Bubble Sorting " & vbCrLf & " at " & TS & "string1" & TE & " (+0) " & TS & "string2" & TE & " swapped higher >" & TS & "string3" & TE & "< " & vbCrLf & " at " & TS & "string4" & TE & " with (+0) " & TS & "string5" & TE & " " & vbCrLf & "lower >" & TS & "string6" & TE & "<")
            MyErrorMessages("on", 1017, "Warning", TS & "string1" & TS & "string2" & TE & " " & TS & "string3" & TS & "string4" & TE & " " & TS & "string5")
            MyErrorMessages("on", 1018, "Error", "We are adding ISAM to a record that has a deferent ISAM causing an Error " & TS & "string1" & TE)
            MyErrorMessages("on", 1019, "Error", "The array Is wrong!  " & vbCrLf & "So we are bubble sorting the array instead of quick sorting it.")
            MyErrorMessages("on", 1020, "Warning", "Swapping >" & TS & "string3" & TE & "< with >" & TS & "string2" & TE & "< " & vbCrLf & "at (+0)s " & TS & "string5" & TE & ", " & TS & "string4" & TE & " " & vbCrLf & "ISAMs " & TS & "string7" & TE & ", " & TS & "string6" & TE & " ")
            MyErrorMessages("on", 1021, "Error", "Symbol Name Not Found " & TS & "string1" & TE)
            MyErrorMessages("on", 1022, "Error", "pathLinks Array boundaries has been exceeded  low=" & TS & "string1" & TE & " < at=" & TS & "string2" & TE & " < top=" & TS & "string3" & TE & " in list of numbers  ?=" & TS & "string4" & TE & "")
            MyErrorMessages("on", 1023, "Warning", "two FlowChart items are on top of each other" & TS & "string1" & TE & TS & "string2" & TE)
            MyErrorMessages("on", 1024, "Warning", "Can Not add to Enum list in " & vbCrLf & "List Name >" & TS & "string1" & TE & "< " & vbCrLf & "Number = " & TS & "string2" & TE & " " & vbCrLf & "ItemNumber offset " & TS & "string3" & TE)
            MyErrorMessages("on", 1027, "Information", "At Index's = " & TS & "string1" & TE & " & " & TS & "string2" & TE & vbCrLf & "Swapping ISAM's " & TS & "string3" & TE & " & " & TS & "string4" & TE & vbCrLf & "With Strings >" & TS & "string5" & TE & "< & >" & TS & "string6" & TE & "<" & vbCrLf & "Same values being swapped")
            MyErrorMessages("on", 1028, "Information", "Get (+0) " & TS & "string2" & TE & vbCrLf & "Macro Code Text = >" & TS & "string1" & TE & "<")
            MyErrorMessages("on", 1029, "Information", "Testing distances between points " & vbCrLf & "(" & TS & "string1" & TE & ", " & TS & "string2" & TE & ")" & vbCrLf & "(" & TS & "string3" & TE & ", " & TS & "string4" & TE & ")" & vbCrLf & "(" & TS & "string5" & TE & ", " & TS & "string6" & TE & ")" & vbCrLf & "Index=" & TS & "string7" & TE & vbCrLf & "distance 1 =" & TS & "string8" & TE & vbCrLf & "distance 2 =" & TS & "string9" & TE)
            MyErrorMessages("on", 1030, "Display", "NOT Compiling code " & TS & "string1" & TE & " : " & TS & "string2" & TE & " : " & TS & "string3" & TE)
            MyErrorMessages("on", 1031, "Display", "NOT Compiling code " & TS & "string1" & TE & " : " & TS & "string2" & TE & " : " & TS & "string3" & TE)
            MyErrorMessages("on", 1032, "Display", "Starting to re-paint at " & TS & "string1" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & "ending at " & TS & "string2" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & "Number to draw " & TS & "string3" & TE)
            MyErrorMessages("on", 1035, "Error", "Because there is no / " & vbCrLf & "Testing for change of link " & TS & "string1" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & ">" & TS & "string2" & TE & "<  " & vbCrLf & ">" & TS & "string3" & TE & "< ")
            MyErrorMessages("on", 1036, "Error", "Because there is no / " & vbCrLf & "Testing for change of link " & TS & "string1" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & ">" & TS & "string2" & TE & "<  " & vbCrLf & ">" & TS & "string3" & TE & "< ")
            MyErrorMessages("on", 1037, "Information", " Making up Named " & TS & "string1" & TE & " Symbol at " & TS & "string3" & TE & " code " & TS & "string2" & TE & " with first path " & TS & "string9" & TE)
            MyErrorMessages("on", 1038, "Information", "Finding Point at Symbol table code >" & TS & "string1" & TE & "< " & vbCrLf & "Index " & TS & "string2" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & "searching for closest points to (" & TS & "string3" & TE & FD & TS & "string4" & TE & ").")
            MyErrorMessages("on", 1039, "Information", "Binary find point at Symbol table code >" & TS & "string1" & TE & "< " & vbCrLf & " XY (" & TS & "string3" & TE & FD & TS & "string4" & TE & ")   " & vbCrLf & "(+0)=" & TS & "string5" & TE & " " & vbCrLf & "CurrentIndexOffset " & TS & "string6" & TE)
            MyErrorMessages("on", 1048, "Error", "Color Not Defined >" & TS & "string1" & TE & "< with DataType >" & TS & "string2" & TE & "< at index " & TS & "string3" & TE & " at line number " & TS & "string4" & TE & " changed to " & TS & "string5" & TE)
            MyErrorMessages("on", 1053, "Warning", "Swapping >" & TS & "string1" & TE & "< " & vbCrLf & "with >" & TS & "string2" & TE & "< " & vbCrLf & "at (-1) " & TS & "string3" & TE & ", " & TS & "string4" & TE & " " & vbCrLf & "ISAM " & TS & "string5" & TE & ", " & TS & "string6" & TE & vbCrLf & "Number of swaps made = " & TS & "string9" & TE)
            MyErrorMessages("on", 1054, "Error", "Added at (2) before (1) in table ?? added " & TS & "string2" & TE)
            MyErrorMessages("on", 1059, "Information", "Inserting = >" & TS & "string9" & TE & "<  into Symbols Table " & vbCrLf & "Macro Code Text = = >" & TS & "string1" & TE & "< " & vbCrLf & "named = >" & TS & "string2" & TE & "< " & vbCrLf & "Point Name =>" & TS & "string3" & TE & "< " & vbCrLf & "X1=" & TS & "string4" & TE & ", " & vbCrLf & "Y1=" & TS & "string5" & TE & ", " & vbCrLf & "X2=" & TS & "string6" & TE & ", " & vbCrLf & "Y2=" & TS & "string7" & TE)
            'MyErrorMessages("on", 1060, "Error", " not able to return from list >" & TS & "string1" & TE & "<" & vbCrLf & "inside the " & TS & "string2" & TE & " list")
            MyErrorMessages("on", 1061, "Information", "swap  >" & TS & "string1" & TE & "< with >" & TS & "string2" & TE & "<")
            MyErrorMessages("on", 1089, "Information", "Find the closest (" & TS & "string1" & TE & ", " & TS & "string2" & TE & ") to start at (" & TS & "string1" & TE & ", " & TS & "string2" & TE & ")")
            MyErrorMessages("on", 1090, "Information", "Find the one and only START Symbol")
            MyErrorMessages("on", 1092, "Information", "get the " & TS & "string3" & TE & " point at (" & TS & "string1" & TE & ", " & TS & "string2" & TE & ")")
            MyErrorMessages("on", 1093, "Information", "get the " & TS & "string3" & TE & " point from a Symbol point at (" & TS & "string1" & TE & ", " & TS & "string2" & TE & ") ")
            MyErrorMessages("on", 1094, "Information", "get a Symbol at (" & TS & "string1" & TE & ", " & TS & "string2" & TE & ") with a direction of " & TS & "string3" & TE)
            MyErrorMessages("on", 1095, "Information", " testing if this point is outside the Window area (" & TS & "string1" & TE & ", " & TS & "string2" & TE & ")_(" & TS & "string3" & TE & ", " & TS & "string4" & TE & ")")
            MyErrorMessages("on", 1096, "warning", "Drawing nothing is ignored at (+0) " & TS & "string1" & TE)
            MyErrorMessages("on", 1098, "Information", " Snap point (" & TS & "string1" & TE & ", " & TS & "string2" & TE & ") to be on a " & TS & "string3" & TE & " grid")
            MyErrorMessages("on", 1117, "Error", "I do not have anything in the case statement for a code type >" & TS & "string1" & TE & "< " & vbCrLf & "looking for /Path, /Use, /Constant, /error")
            MyErrorMessages("on", 1120, "Error", "Not matched to color name or datatype names =>" & TS & "string1" & TE & "<")
            MyErrorMessages("on", 1123, "Error", "The index " & TS & "string1" & TE & " has index outside the range " & TS & "string2" & TE & " and " & TS & "string3" & TE & " in the ISAM Table." & vbCrLf & TS & "string2" & TE & " < " & TS & "string1" & TE & " < " & TS & "string3" & TE)
            MyErrorMessages("on", 1129, "Error", "Invalid Index for ISAM Indexes   1 <= " & TS & "string1" & TE & " <= " & TS & "string2" & TE)
            MyErrorMessages("on", 1132, "Information", "at " & TS & "string1" & TE & " checking name >" & TS & "string2" & TE & "< " & "against " & TS & "string3" & TE & " name >" & TS & "string4" & TE & "<")
            MyErrorMessages("on", 1136, "Display", " Exporting Colors to file >" & TS & "string1" & TE & "<")
            MyErrorMessages("on", 1149, "Display", "De-Compiling Source From file >" & TS & "string1" & TE & "<")
            MyErrorMessages("on", 1158, "Error", "Invalid (+0) into Record List, (+0) less than One > " & TS & "string1" & TE & ".")
            MyErrorMessages("on", 1159, "Error", "Expecting a /Use record And got a " & TS & "string1" & TE & " Instead.")
            MyErrorMessages("on", 1163, "Error", "Invalid Rotation =" & TS & "string1" & TE & " named = >" & TS & "string2" & TE & "<.")
            MyErrorMessages("on", 1164, "Error", "There Is no name For this use record " & TS & "string1" & TE & ".Record " & TS & "string2" & TE & " Has no name.")
            MyErrorMessages("on", 1167, "Error", "This should never happen  " & TS & "string1" & TE & " <> 0 And (1)" & TS & "string1" & TE & " = (2)" & TS & "string3" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace)
            MyErrorMessages("on", 1168, "Error", "The (+0) should never be zero " & TS & "string1" & TE)
            MyErrorMessages("on", 1169, "Error", "This should never happen (1)" & TS & "string1" & TE & " <> 0 And (1)" & TS & "string2" & TE & " = (2)" & TS & "string3" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace)
            MyErrorMessages("on", 1170, "Wrong", "The index " & TS & "string1" & TE & " Of a number array should not be zero " & TS & "string2" & TE & vbCrLf & ">" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1183, "Display", "Swapping >" & TS & "string1" & TE & "< " & vbCrLf & "with >" & TS & "string2" & TE & "< " & vbCrLf & "at (+0)s " & TS & "string3" & TE & ", " & TS & "string4" & TE & " " & vbCrLf & "ISAMs " & TS & "string5" & TE & ", " & TS & "string6" & TE & " " & vbCrLf & "Counter " & TS & "string9" & TE)
            MyErrorMessages("on", 1189, "Information", "The List has nothing at (+0) " & TS & "string1" & TE & " ISAM set to " & TS & "string2" & TE & vbCrLf & "FromRoutine=" & TS & "string2" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & "Tracer=" & TS & "string2" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace)
            MyErrorMessages("on", 1211, "ERROR", vbCrLf & "Line Number " & TS & "string1" & TE & vbCrLf & "Key word   = >" & TS & "string2" & TE & "< " & vbCrLf & "input line =>" & TS & "string3" & TE & "< " & vbCrLf & "Unknown Information at line >" & TS & "string4" & TE & "<" & vbCrLf & "Line of unknown >" & TS & "string5" & TE & "<")
            MyErrorMessages("on", 1212, "Error", TS & "string1" & TE & " Do you want to add this color?" & vbCrLf & "Unknown Color :" & TS & "string2" & TE & " : " & TS & "string3" & TE)
            MyErrorMessages("on", 1214, "Error", "Unable to run because there Is no Symbol with the name START Or MAIN.You need a Symbol named 'start' or a Symbol named 'main' in this program")
            MyErrorMessages("on", 1215, "Error", "Found a match when binary search failed to find it between >" & TS & "string1" & TE & "< AND >" & TS & "string2" & TE & "<")
            MyErrorMessages("on", 1246, "Information", TS & "string1" & TE) 'displays FlowChart record
            MyErrorMessages("on", 1247, "Information", "status for index " & TS & "string1" & TE & " Index >" & TS & "string2" & TE & "< links >" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1248, "Information", "Finding all paths connected together index  = " & TS & "string1" & TE & " links >" & TS & "string2" & TE & "<")
            MyErrorMessages("on", 1249, "Information", "Finding all paths connected " & TS & "string1" & TE & " links >" & TS & "string2" & TE & "<" & TS & "string3" & TE)
            MyErrorMessages("on", 1250, "Error", "The FlowChart index is greater than the maxiumn number of the records.The FlowChart index of " & TS & "string1" & TE & ".Is greater than the maximum number in the FlowChart array " & TS & "string2" & TE)
            MyErrorMessages("on", 1251, "Error", "String exceeded " & ConstantCharterLength & " characters " & TS & "string1" & TE)
            MyErrorMessages("on", 1252, "Warning", "Duplications in the list" & vbCrLf & "(-1)=" & TS & "string1" & TE & " ISAM points to =" & TS & "string2" & TE & " Array()= >" & TS & "string3" & TE & "<" & vbCrLf & "(+0)=" & TS & "string4" & TE & " ISAM points to =" & TS & "string5" & TE & " Array()= >" & TS & "string6" & TE & "<" & vbCrLf & "(+1)=" & TS & "string7" & TE & " ISAM points to =" & TS & "string8" & TE & " Array()= >" & TS & "string9" & TE & "<")
            MyErrorMessages("on", 1253, "Error", " at index " & TS & "string1" & TE & " Step" & TS & "string9" & TE & ": The ISAM Table is outside the {Min 1< " & TS & "string2" & TE & " <" & TS & "string3" & TE & " Max}  Value >" & TS & "string4" & TE & "<")
            MyErrorMessages("on", 1254, "Error", "Indexes out of bounds.An index Indexes is out of bounds index -1 = " & TS & "string1" & TE & " :  at ISAM(-1) " & TS & "string2" & TE & " and (+0)" & TS & "string3" & TE & " at ISAM(+0) " & TS & "string4" & TE)
            MyErrorMessages("on", 1256, "Error", "Invalid (+0) into Record List.(+0) " & TS & "string1" & TE & " greater than maxinum Of array size " & TS & "string2" & TE & ".")
            MyErrorMessages("on", 1257, "Display", TS & "string1" & TE & " Swapping >" & TS & "string2" & TE & "< with >" & TS & "string3" & TE & "< at (+0)s " & TS & "string4" & TE & ", " & TS & "string5" & TE & " ISAMs " & TS & "string6" & TE & ", " & TS & "string7" & TE)
            MyErrorMessages("on", 1258, "Display", TS & "string1" & TE & " Swapping >" & TS & "string2" & TE & "< with >" & TS & "string3" & TE & "< at (+0)s " & TS & "string4" & TE & ", " & TS & "string5" & TE & " ISAMs " & TS & "string6" & TE & ", " & TS & "string7" & TE & " at " & TS & "string1" & TE)
            MyErrorMessages("on", 1260, "ERROR", "Routine not written yet ! (Just returns True inside box )  (" & TS & "string1" & TE & ", " & TS & "string2" & TE & ")_(" & TS & "string3" & TE & ", " & TS & "string4" & TE & ")")
            MyErrorMessages("on", 1264, "Display", "no match found and nothing else >" & TS & "string1" & TE & "<, It was added, Function = " & TS & "string2" & TE)
            MyErrorMessages("on", 1265, "Warning", TS & "string1" & TE & "() Swapping >" & TS & "string3" & TE & "< with >" & TS & "string2" & TE & "< at (+0)s " & TS & "string5" & TE & ", " & TS & "string4" & TE & " ISAMs " & TS & "string7" & TE & ", " & TS & "string6" & TE & " at " & TS & "string1" & TE)
            MyErrorMessages("on", 1266, "Display", TS & "string1" & TE & "() Swapping >" & TS & "string2" & TE & "< with >" & TS & "string3" & TE & "< at (+0)s " & TS & "string4" & TE & ", " & TS & "string5" & TE & " ISAMs " & TS & "string6" & TE & ", " & TS & "string7" & TE & " at " & TS & "string1" & TE)
            MyErrorMessages("on", 1268, "Error", "Unable to add the Symbol name to the Symbol name list >" & TS & "string1" & TE & "<")
            MyErrorMessages("on", 1269, "Error", "Passed color name to get >" & TS & "string1" & TE & "< DataType color >" & TS & "string2" & TE & "< color using >" & TS & "string2" & TE & "<")
            MyErrorMessages("on", 1270, "Error", "Found a match when none found in binary search  >" & TS & "string1" & TE & "< looking for >" & TS & "string2" & TE & "<")
            MyErrorMessages("on", 1273, "Information", "Invalid Rotation Number " & TS & "string1" & TE & " Name >" & TS & "string2" & TE & "<")
            MyErrorMessages("on", 1275, "Information", "Sitting on top of each other at (" & TS & "string1" & TE & ", " & TS & "string2" & TE & ")")
            MyErrorMessages("on", 1276, "Error", "YouHaveAnErrorMessage() " & TS & "string1" & TE & " >" & TS & "string1" & TE & "<")
            MyErrorMessages("on", 1280, "Error", "Duplication in the list" & vbCrLf & "(-1)=" & TS & "string1" & TE & " ISAM points to =" & TS & "string2" & TE & " Array()= >" & TS & "string3" & TE & "< " & vbCrLf & "(+0)=" & TS & "string4" & TE & " ISAM points to =" & TS & "string5" & TE & " Array()= >" & TS & "string6" & TE & "< " & vbCrLf & "(+1)=" & TS & "string7" & TE & " ISAM points to =" & TS & "string8" & TE & " Array()= >" & TS & "string9" & TE & "< ")
            MyErrorMessages("on", 1283, "Error", "Unknown command mode >" & TS & "string1" & TE & "<")
            MyErrorMessages("on", 1284, "Warning", TS & "string1" & TE & "() Swapping >" & TS & "string2" & TE & "< with >" & TS & "string3" & TE & "< at (+0)s " & TS & "string4" & TE & ", " & TS & "string5" & TE & " ISAMs " & TS & "string6" & TE & ", " & TS & "string7" & TE & " at " & TS & "string1" & TE)
            MyErrorMessages("on", 1285, "Information", "Distance = " & TS & "string1" & TE & " x1=" & TS & "string2" & TE & " y1=" & TS & "string3" & TE & " x2=" & TS & "string4" & TE & " y2=" & TS & "string5" & TE & " Distance1=" & TS & "string6" & TE & " Distance2=" & TS & "string7" & TE & " Distance3=" & TS & "string8" & TE & " Distance4=" & TS & "string9" & TE)
            MyErrorMessages("on", 1291, "Information", "Didn't Find DataType >" & TS & "string1" & TE & "<")
            MyErrorMessages("on", 1293, "Information", ">" & TS & "string1" & TE & "<.")
            MyErrorMessages("on", 1294, "Information", ">" & TS & "string1" & TE & "< (" & TS & "string2" & TE & ", " & TS & "string3" & TE & ").")
            MyErrorMessages("on", 1295, "Information", "(" & TS & "string1" & TE & ", " & TS & "string2" & TE & ")")
            MyErrorMessages("on", 1298, "Information", "at (+0) " & TS & "string1" & TE)
            MyErrorMessages("on", 1299, "Display", "Number of Symbol Names = " & TS & "string1" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace)
            MyErrorMessages("on", 1321, "Information", "XY (" & TS & "string1" & TE & ", " & TS & "string2" & TE & ")")
            MyErrorMessages("on", 1322, "Display", "Displaying Symbol @ Symbols= >" & TS & "string1" & TE & "<  >" & TS & "string2" & TE & "<  >" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1324, "Information", "Drawing Point at (+0) " & TS & "string1" & TE & " named >" & TS & "string2" & TE & "< Symbol named >" & TS & "string3" & TE & "< Point Name = " & TS & "string4" & TE & ".")
            MyErrorMessages("on", 1326, "Warning", " number of flag " & TS & "string1" & TE & vbCrLf & "Swapping >" & TS & "string3" & TE & "< with >" & TS & "string2" & TE & "< " & vbCrLf & "at Index's " & TS & "string5" & TE & ", " & TS & "string4" & TE & " " & vbCrLf & "ISAMs " & TS & "string7" & TE & ", " & TS & "string6" & TE & " ")
            MyErrorMessages("on", 1327, "Display", TS & "string1" & TE & "() Swapping >" & TS & "string2" & TE & "< with >" & TS & "string3" & TE & "< at (+0)s " & TS & "string4" & TE & ", " & TS & "string5" & TE & " ISAMs " & TS & "string6" & TE & ", " & TS & "string7" & TE & " at " & TS & "string1" & TE)
            MyErrorMessages("on", 1332, "Error", "return of adding this Symbol failed and returned an error code " & TS & "string1" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & " Symbol name : >" & TS & "string1" & TE & "<")
            MyErrorMessages("on", 1333, "Information", "Ready")
            MyErrorMessages("on", 1337, "Information", "Checking (+0) find " & vbCrLf & TS & "string2" & TE & " = Searching for " & vbCrLf & vbCrLf & "Before: " & TS & "string3" & TE & vbCrLf & "At    :" & TS & "string4" & TE & vbCrLf & "After :" & TS & "string5" & TE & vbCrLf & TS & "string6" & TE & vbCrLf & TS & "string7" & TE & vbCrLf & "Tracer = " & TS & "string1" & TE)
            MyErrorMessages("on", 1340, "Information", "Checking (+0) find " & vbCrLf & "Searching for  = >" & TS & "string2" & TE & "<" & vbCrLf & "Before:>" & TS & "string3" & TE & "<" & vbCrLf & "At    :>" & TS & "string4" & TE & "<" & vbCrLf & "After :>" & TS & "string5" & TE & "<" & vbCrLf & vbCrLf & "FlowChart Index:" & TS & "string6" & TE & vbCrLf & "Named Index" & TS & "string7" & TE & vbCrLf & "Tracer = " & TS & "string1" & TE)
            MyErrorMessages("on", 1341, "Information", "Checking (+0) find " & vbCrLf & "From FlowChart Searching for >" & TS & "string2" & TE & "<" & vbCrLf & vbCrLf & "Named Before: " & TS & "string3" & TE & vbCrLf & "Named At    :" & TS & "string4" & TE & vbCrLf & "Named After :" & TS & "string5" & TE & vbCrLf & "FlowChart Index=" & TS & "string6" & TE & vbCrLf & "Named Index =" & TS & "string7" & TE & vbCrLf & vbCrLf & "Tracer = " & TS & "string1" & TE)
            MyErrorMessages("on", 1343, "Information", "Checking (+0) find " & vbCrLf & "Searching for = >" & TS & "string2" & TE & "<" & vbCrLf & vbCrLf & "Before: " & TS & "string3" & TE & vbCrLf & "At    :" & TS & "string4" & TE & vbCrLf & "After :" & TS & "string5" & TE & vbCrLf & "FlowChart Index=" & TS & "string6" & TE & vbCrLf & "Named Index=" & TS & "string7" & TE & vbCrLf & "Tracer = " & TS & "string1" & TE)
            MyErrorMessages("on", 1366, "Information", "Checking Index find " & vbCrLf & "Searching for =" & TS & "string2" & TE & vbCrLf & vbCrLf & "Before: " & TS & "string3" & TE & vbCrLf & "At    :" & TS & "string4" & TE & vbCrLf & "After :" & TS & "string5" & TE & vbCrLf & TS & "string6" & TE & vbCrLf & TS & "string7" & TE & vbCrLf & "Tracer = " & TS & "string1" & TE)
            MyErrorMessages("on", 1367, "Information", "Checking Index find " & vbCrLf & "Searching for =" & TS & "string2" & TE & vbCrLf & "Before: " & TS & "string3" & TE & vbCrLf & "At    :" & TS & "string4" & TE & vbCrLf & "After :" & TS & "string5" & TE & vbCrLf & TS & "string6" & TE & vbCrLf & TS & "string7" & TE & vbCrLf & "Tracer = " & TS & "string1" & TE)
            MyErrorMessages("on", 1373, "Information", "Array ISAM is not in the correct order" & vbCrLf & "Searching for  >" & TS & "string1" & TE & "< " & vbCrLf & vbCrLf & "(+0) -1 = >" & TS & "string2" & TE & "< " & vbCrLf & "(+0)    = >" & TS & "string3" & TE & "< " & vbCrLf & "(+0) +1 = >" & TS & "string4" & TE & "< ")
            MyErrorMessages("on", 1375, "Information", "Unknow Code " & vbCrLf & "> " & TS & "string1" & TE & "<" & vbCrLf & "Macro Code Text =>" & TS & "string2" & TE & "<" & vbCrLf & "(" & TS & "string3" & TE & ")_(" & TS & "string4" & TE & ")" & vbCrLf & "Links = " & TS & "string5" & TE & vbCrLf & "Named = " & TS & "string6" & TE & vbCrLf & "Other = " & TS & "string7" & TE & vbCrLf & "(+0) = " & TS & "string8" & TE)
            MyErrorMessages("on", 1380, "Warning", "The ISAM() points To an invalid index " & vbCrLf & "ISAM=" & TS & "string2" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & "(+0)=" & TS & "string3" & TE & vbCrLf & "Checking in routine " & TS & "string8" & TE & " called from " & TS & "routine" & TE & " tracer " & TS & "tracer" & TE)
            MyErrorMessages("on", 1385, "Error", "The array at index " & TS & "string1" & TE & " is empty  ISAM(+0) =" & TS & "string2" & TE & " >" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1387, "Error", "The ISAM() points To an invalid index In the array" & vbCrLf & "ISAM=" & TS & "string2" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & "(+0)=" & TS & "string3" & TE & vbCrLf & "Checking in routine " & TS & "string8" & TE & " called from " & TS & "routine" & TE & " tracer " & TS & "tracer" & TE)
            MyErrorMessages("on", 1388, "Warning", "The ISAM() points To an invalid index" & vbCrLf & "ISAM=" & TS & "string2" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & "(+0)=" & TS & "string3" & TE & vbCrLf & "routine=" & TS & "string2" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & "FromRoutine=" & TS & "string2" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & "Tracer=" & TS & "string2" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace)
            MyErrorMessages("on", 1389, "Warning", "The ISAM() points To an invalid index In the array" & vbCrLf & "ISAM=" & TS & "string2" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & "(+0)=" & TS & "string3" & TE & vbCrLf & "routine=" & TS & "string2" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & "FromRoutine=" & TS & "string2" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & "Tracer=" & TS & "string2" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace)
            MyErrorMessages("on", 1390, "Warning", "Index is below One " & vbCrLf & "Checking in routine " & TS & "string8" & TE & " called from " & TS & "routine" & TE & " tracer " & TS & "tracer" & TE)
            MyErrorMessages("on", 1391, "Error", "Index is greater than the max size of ARRAY()" & vbCrLf & "Checking in routine " & TS & "string8" & TE & " called from " & TS & "routine" & TE & " tracer " & TS & "tracer" & TE)
            MyErrorMessages("on", 1392, "Error", "Index is greater than the max size of ISAM()" & vbCrLf & "Checking in routine " & TS & "string8" & TE & " called from " & TS & "routine" & TE & " tracer " & TS & "tracer" & TE)
            '?
            MyErrorMessages("on", 1393, "Error", "Index is greater than the max size of ARRAY()" & vbCrLf & "Checking in routine " & TS & "string8" & TE & " called from " & TS & "routine" & TE & " tracer " & TS & "tracer" & TE)
            MyErrorMessages("on", 1394, "Error", "Index is greater than the max size of ISAM()" & vbCrLf & "Checking in routine " & TS & "string8" & TE & " called from " & TS & "routine" & TE & " tracer " & TS & "tracer" & TE)
            MyErrorMessages("on", 1395, "Error", "The ISAM is out of order before index (Text1 & Text2)" & vbCrLf & "Text1 = " & TS & "string1" & TE & vbCrLf & "1st to 2nd = " & TS & "string4" & TE & vbCrLf & "Text2 = " & TS & "string2" & TE & vbCrLf & "Compare test used to determine this message = " & TS & "string6" & TE & vbCrLf & "called from " & TS & "string9" & TE)
            MyErrorMessages("on", 1396, "Error", "The ISAM is out of order after index (Text2 & Text 3)" & vbCrLf & "Text2 = " & TS & "string2" & TE & vbCrLf & "2nd to 3rd = " & TS & "string5" & TE & vbCrLf & "text3 = " & TS & "string3" & TE & vbCrLf & "Compare test used to determine this message = " & TS & "string6" & TE & vbCrLf & "called from " & TS & "string9" & TE)
            MyErrorMessages("on", 1399, "Error", "Invalid Index of >" & TS & "string1" & TE & "< called from " & TS & "string9" & TE)
            MyErrorMessages("on", 1400, "Information", "Invalid (+0) of >" & TS & "string1" & TE & "< called from " & TS & "string9" & TE)
            MyErrorMessages("on", 1401, "Information", "Invalid (+0) of >" & TS & "string1" & TE & "< called from " & TS & "string9" & TE)
            MyErrorMessages("on", 1402, "Error", "Line " & TS & "string3" & TE & ", Lost the >" & TS & "string1" & TE & "< " & vbCrLf & " >" & TS & "string2" & TE & "< " & vbCrLf & "for Symbol name >" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1403, "Error", "Line " & TS & "string3" & TE & ", Lost the >" & TS & "string1" & TE & "< " & vbCrLf & " >" & TS & "string2" & TE & "< " & vbCrLf & "for Symbol name >" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1404, "Error", "Line " & TS & "string3" & TE & ", Lost the >" & TS & "string1" & TE & "< " & vbCrLf & " >" & TS & "string2" & TE & "< " & vbCrLf & "for Symbol name >" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1405, "Error", "Line " & TS & "string3" & TE & ", Lost the >" & TS & "string1" & TE & "< " & vbCrLf & " >" & TS & "string2" & TE & "< " & vbCrLf & "for Symbol name >" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1406, "Error", "Line " & TS & "string3" & TE & ", Lost the >" & TS & "string1" & TE & "< " & vbCrLf & " >" & TS & "string2" & TE & "< " & vbCrLf & "for Symbol name >" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1407, "Error", "Line " & TS & "string3" & TE & ", Lost the >" & TS & "string1" & TE & "< " & vbCrLf & " >" & TS & "string2" & TE & "< " & vbCrLf & "for Symbol name >" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1408, "Error", "Line " & TS & "string3" & TE & ", Lost the >" & TS & "string1" & TE & "< " & vbCrLf & " >" & TS & "string2" & TE & "< " & vbCrLf & "for Symbol name >" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1409, "Error", "Line " & TS & "string3" & TE & ", Lost the >" & TS & "string1" & TE & "< " & vbCrLf & " >" & TS & "string2" & TE & "< " & vbCrLf & "for Symbol name >" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1410, "Error", "Line " & TS & "string3" & TE & ", Lost the >" & TS & "string1" & TE & "< " & vbCrLf & " >" & TS & "string2" & TE & "< " & vbCrLf & "for Symbol name >" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1411, "Error", "Not Able to return a valid index for " & TS & "string1" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & " for keyword >" & TS & "string3" & TE & "<" & vbCrLf & " Inputline = >" & TS & "string4" & TE & "<" & vbCrLf & "Input Line Number = " & TS & "string5" & TE)
            MyErrorMessages("on", 1413, "Error", "At step " & TS & "string2" & TE & ".Adding blank information to the list >" & TS & "string1" & TE & "<   >" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1414, "Error", " at " & TS & "string2" & TE & ".blank information changed to ? in the list from line " & TS & "string5" & TE & MyUniverse.ProgramOptions.FCCL_WhiteSpace & vbCrLf & ">" & TS & "string3" & TE & "<" & vbCrLf & " the format should be :" & TS & "string4" & TE & vbCrLf & " inputLine is : " & TS & "string3" & TE)
            MyErrorMessages("on", 1433, "Information", TS & "string1" & TE & TS & "string2" & TE & TS & "string3" & TE & TS & "string4" & TE & TS & "string5" & TE & TS & "string6" & TE)
        End Sub


        Public Shared Function MyCompareSyntax_S(String1 As String, String2 As String) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3403, 10, "MyCompareSyntax")
#End If
            If mydebug(9) Then follow(2583, 5, "Syntax2Syntax ")
            If LCase(String1) = LCase(String2) Then Return "equal"
            Return "notequal"
        End Function



        Public Shared Sub WhatKey(e As KeyPressEventArgs)
            Dim MyText As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3404, 10, "WhatKey")
#End If
            If mydebug(9) Then follow(2584, 5, "WhatKeyPressed ")
            MyText = FlowChartWindow.ToolStripTextBoxMyInputText.Text & e.KeyChar.ToString
            'characters I might have to take care of
            'vbHiragana, vbKatakana, vbLinguisticCasing, vbNarrowvbNewLine, vbSimplifiedChinese, vbTraditionalChinese, vbWide
            Select Case e.KeyChar.ToString
                Case "(", ")", "{", "}", "[", "]"
                    ShowSyntax(MyText)
                    Return
                Case "=", "+", "-", "/", "*", "'"
                    ShowSyntax(MyText)
                    Return
                Case "!", "@", "#", "$", "%", "^", "&", "_", "~"
                    ShowSyntax(MyText)
                    Return
                Case "|", "\", ",", ".", "?"
                    ShowSyntax(MyText)
                    Return
                Case MyUniverse.ProgramOptions.FCCL_WhiteSpace
                    ShowSyntax(MyText)
                    Return
                Case "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" 'digits
                    ShowSyntax(MyText)
                    Return

    ' = 96-105
                Case Keys.NumPad0.ToString, Keys.NumPad1.ToString, Keys.NumPad2.ToString, Keys.NumPad3.ToString, Keys.NumPad4.ToString, Keys.NumPad5.ToString, Keys.NumPad6.ToString, Keys.NumPad7.ToString, Keys.NumPad8.ToString, Keys.NumPad9.ToString
                    ShowSyntax(MyText)
                    Return
                Case "a", "b", "c", "d", "e", "f", "g", "g", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"
                    ShowSyntax(MyText)
                    Return
    'It returns caps when in quotes.'capital letters never show up i guess cause the select statment test against lower case?
                Case "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"
                    Return
                Case vbCr, vbCrLf, vbLf, vbTab, vbFormFeed, Chr(34)
                    Return
                Case vbBack, ChrW(1).ToString 'DELETE CHARACTER
                    Return
                Case Keys.Add.ToString '   =  107
                    Return
    'Case Keys.D0.ToString '   =  48
    'Case Keys.D1.ToString '   =  49
    'Case Keys.D2.ToString '   =  50
    'Case Keys.D3.ToString '   =  51
    'Case Keys.D4.ToString '   =  52
    'Case Keys.D5.ToString '   =  53
    'Case Keys.D6.ToString '   =  54
    'Case Keys.D7.ToString '   =  55
    'Case Keys.D8.ToString '   =  56
    'Case Keys.D9.ToString '   =  57
                Case Keys.MButton.ToString '   =  4
                Case Keys.XButton1.ToString '   =  5
                Case Keys.XButton2.ToString '   =  6
                Case Keys.Back.ToString '   =  8
                Case Keys.Tab.ToString '   =  9
                Case Keys.LineFeed.ToString '   =  10
                Case Keys.Clear.ToString '   =  12
                Case Keys.[Return].ToString '   =  13
                Case Keys.Enter.ToString '   =  13
                Case Keys.ShiftKey.ToString '   =  16
                Case Keys.ControlKey.ToString '   =  17
                Case Keys.Menu.ToString '   =  18
                Case Keys.Pause.ToString '   =  19
                Case Keys.Capital.ToString '   =  20
                Case Keys.CapsLock.ToString '   =  20
                Case Keys.KanaMode.ToString '   =  21
                Case Keys.HanguelMode.ToString '   =  22  
                Case Keys.JunjaMode.ToString '   =  23
                Case Keys.FinalMode.ToString '   =  24
                Case Keys.HanjaMode.ToString '   =  25
                Case Keys.KanjiMode.ToString '   =  25
                Case Keys.Escape.ToString '   =  27
                Case Keys.IMEConvert.ToString '   =  28
                Case Keys.IMENonconvert.ToString '   =  29
                Case Keys.IMEAccept.ToString '   =  30
                Case Keys.IMEModeChange.ToString '   =  31
                Case Keys.Prior.ToString '   =  33
                Case Keys.PageUp.ToString '   =  33
                Case Keys.[Next].ToString '   =  34
                Case Keys.PageDown.ToString '   =  34
                Case Keys.[End].ToString '   =  35
                Case Keys.Home.ToString '   =  36
                Case Keys.Left.ToString '   =  37
                Case Keys.Up.ToString '   =  38
                Case Keys.Right.ToString '   =  39
                Case Keys.Down.ToString '   =  40
                Case Keys.[Select].ToString '   =  41
                Case Keys.Print.ToString '   =  42
                Case Keys.Execute.ToString '   =  43
                Case Keys.Snapshot.ToString '   =  44
                Case Keys.PrintScreen.ToString '   =  44
                Case Keys.Insert.ToString '   =  45
                Case Keys.Delete.ToString '   =  46
                Case Keys.Help.ToString '   =  47
                Case Keys.LWin.ToString '   =  91' Left Windows Key
                Case Keys.RWin.ToString '   =  92'Right Windows key (Which doesn't exist)
                Case Keys.Apps.ToString '   =  93'This is the right mouse help button   ?
                Case Keys.Sleep.ToString '   =  95
                Case Keys.Multiply.ToString '   =  106
                Case Keys.Separator.ToString '   =  108
                Case Keys.Subtract.ToString '   =  109
                Case Keys.[Decimal].ToString '   =  110
                Case Keys.Divide.ToString '   =  111
                Case Keys.F1.ToString '   =  112
                Case Keys.F2.ToString '   =  113
                Case Keys.F3.ToString '   =  114
                Case Keys.F4.ToString '   =  115
                Case Keys.F5.ToString '   =  116
                Case Keys.F6.ToString '   =  117
                Case Keys.F7.ToString '   =  118
                Case Keys.F8.ToString '   =  119
                Case Keys.F9.ToString '   =  120
                Case Keys.F10.ToString '   =  121
                Case Keys.F11.ToString '   =  122
                Case Keys.F12.ToString '   =  123
                Case Keys.F13.ToString '   =  124
                Case Keys.F14.ToString '   =  125
                Case Keys.F15.ToString '   =  126
                Case Keys.F16.ToString '   =  127
                Case Keys.F17.ToString '   =  128
                Case Keys.F18.ToString '   =  129
                Case Keys.F19.ToString '   =  130
                Case Keys.F20.ToString '   =  131
                Case Keys.F21.ToString '   =  132
                Case Keys.F22.ToString '   =  133
                Case Keys.F23.ToString '   =  134
                Case Keys.F24.ToString '   =  135
                Case Keys.NumLock.ToString '   =  144
                Case Keys.Scroll.ToString '   =  145
                Case Keys.LShiftKey.ToString '   =  160
                Case Keys.RShiftKey.ToString '   =  161
                Case Keys.LControlKey.ToString '   =  162
                Case Keys.RControlKey.ToString '   =  163
                Case Keys.LMenu.ToString '   =  164
                Case Keys.RMenu.ToString '   =  165
                Case Keys.BrowserBack.ToString '   =  166
                Case Keys.BrowserForward.ToString '   =  167
                Case Keys.BrowserRefresh.ToString '   =  168
                Case Keys.BrowserStop.ToString '   =  169
                Case Keys.BrowserSearch.ToString '   =  170
                Case Keys.BrowserFavorites.ToString '   =  171
                Case Keys.BrowserHome.ToString '   =  172
                Case Keys.VolumeMute.ToString '   =  173
                Case Keys.VolumeDown.ToString '   =  174
                Case Keys.VolumeUp.ToString '   =  175
                Case Keys.MediaNextTrack.ToString '   =  176
                Case Keys.MediaPreviousTrack.ToString '   =  177
                Case Keys.MediaStop.ToString '   =  178
                Case Keys.MediaPlayPause.ToString '   =  179
                Case Keys.LaunchMail.ToString '   =  180
                Case Keys.SelectMedia.ToString '   =  181
                Case Keys.LaunchApplication1.ToString '   =  182
                Case Keys.LaunchApplication2.ToString '   =  183
                Case Keys.OemSemicolon.ToString '   =  186
                Case Keys.Oem1.ToString '   =  186
                Case Keys.Oemplus.ToString '   =  187
                Case Keys.Oemcomma.ToString '   =  188
                Case Keys.OemMinus.ToString '   =  189
                Case Keys.OemPeriod.ToString '   =  190
                Case Keys.OemQuestion.ToString '   =  191
                Case Keys.Oem2.ToString '   =  191
                Case Keys.Oemtilde.ToString '   =  192
                Case Keys.Oem3.ToString '   =  192
                Case Keys.OemOpenBrackets.ToString '   =  219
                Case Keys.Oem4.ToString '   =  219
                Case Keys.OemPipe.ToString '   =  220
                Case Keys.Oem5.ToString '   =  220
                Case Keys.OemCloseBrackets.ToString '   =  221
                Case Keys.Oem6.ToString '   =  221
                Case Keys.OemQuotes.ToString '   =  222
                Case Keys.Oem7.ToString '   =  222
                Case Keys.Oem8.ToString '   =  223
                Case Keys.OemBackslash.ToString '   =  226
                Case Keys.Oem102.ToString '   =  226
                Case Keys.ProcessKey.ToString '   =  229
                Case Keys.Packet.ToString '   =  231
                Case Keys.Attn.ToString '   =  246
                Case Keys.Crsel.ToString '   =  247
                Case Keys.Exsel.ToString '   =  248
                Case Keys.EraseEof.ToString '   =  249
                Case Keys.Play.ToString '   =  250
                Case Keys.Zoom.ToString '   =  251
                Case Keys.NoName.ToString '   =  252
                Case Keys.Pa1.ToString '   =  253
                Case Keys.OemClear.ToString '   =  254
                Case Keys.KeyCode.ToString '   =  65535
                Case Keys.Shift.ToString '   =  65536
                Case Keys.Control.ToString '   =  131072
                Case Keys.Alt.ToString '   =  262144
                Case Else
                    MSG_ABug(2085, "unknown key pressed" & HighLight(e.GetType.FullName) & HighLight(e.GetType.Attributes.ToString), e.KeyChar, HighLight(e.KeyChar.ToString))
            End Select
            MSG_AInfo(2086, "A key pressed, but not used " & HighLight(e.GetType.FullName) & HighLight(e.GetType.Attributes.ToString), e.KeyChar, HighLight(e.KeyChar.ToString))
        End Sub



        Public Shared Sub ShowSyntax(Temp As String) ' Extra
#If MINEDEBUG Then
  if mydebug(9) then follow(3405, 10, "ShowSyntax")
#End If
            If mydebug(9) Then follow(2585, 5, "ShowSyntax ")
            Temp = FlowChartWindow.ToolStripTextBoxMyInputText.Text 'Save the Code 
            MyUniverse.MyStaticData.Path_Names = MyParse(MyUniverse.MyStaticData.My_Syntax_Line_Parsed, Temp)
            MyUniverse.MyStaticData.Path_NamesCounted = CountPathNames(MyUniverse.MyStaticData.Path_Names)
            DisplayStatus(FlowChartWindow.LabelProgramStatus, MakeStatementSyntax(MyUniverse.MyStaticData.My_Syntax_Line_Parsed))
            MyDoEvents(217)
        End Sub

        Public Shared Function MyShell(Temp As String) As Int32
            Dim DevicePathFileName As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3406, 10, "MyShell")
#End If
            If mydebug(9) Then follow(2586, 5, "MyShell " & Temp)
            MyShell = 0
            MyDoEvents(218)
            DevicePathFileName = Temp
            If Dir(DevicePathFileName) <> "" Then
                Return Shell(DevicePathFileName, AppWinStyle.MaximizedFocus,)
            End If

            MyBeep()
            Select Case MsgBox("Unable to find : " & Temp & vbCrLf & "Search for it?", MsgBoxStyle.YesNo Or MsgBoxStyle.Information, "Unable to start the preprocessor for this language, Select another language")
                Case MsgBoxResult.Abort, MsgBoxResult.Cancel, MsgBoxResult.Ignore, MsgBoxResult.No, MsgBoxResult.Retry
                Case MsgBoxResult.Yes, MsgBoxResult.Ok
                    'search for temp
                    DevicePathFileName = FindFileName(Temp)
                    If DevicePathFileName <> "" Then
                        If Dir(DevicePathFileName) <> "" Then
                            Return Shell(DevicePathFileName, AppWinStyle.MinimizedNoFocus, True, 1000)
                        End If
                    End If
                    MyBeep()
                    MsgBox("Search Failed to find program " & DevicePathFileName)
            End Select
            'need to go find this 

            DevicePathFileName = "\" & Mid(Temp, 2, Len(Temp)) & Temp & "\" & Temp
            If Dir(DevicePathFileName) <> "" Then Return Shell(DevicePathFileName, AppWinStyle.MinimizedNoFocus, True, 1000)
            DevicePathFileName = FileIO.FileSystem.CurrentDirectory & "\" & Temp
            If Dir(DevicePathFileName) <> "" Then Return Shell(DevicePathFileName, AppWinStyle.MinimizedNoFocus, True, 1000)

        End Function

        Public Shared Function FileIgnoreList(PathName As String) As Boolean
#If MINEDEBUG Then
  if mydebug(9) then follow(3407, 10, "FileIgnoreList")
#End If
            If mydebug(9) Then follow(2587, 5, "File Ignore List " & PathName)
            If InStr(PathName, "$") <> 0 Then Return True
            If PathName = "\Recovery\" Then Return True
            If PathName = "\Support\" Then Return True
            If PathName = "\System Volume Information\" Then Return True
            Return False
        End Function


        Public Shared Function FindFileName(PathFileExt As String) As String
            Dim DevicePathFile As String
            Dim MyCurrentPath(1), MyPath, MyFileName, MyExtension As String
            Dim WhereIsFile As String
            Dim MyCurrent As Int32
#If MINEDEBUG Then
  if mydebug(9) then follow(3408, 10, "FindFileName")
#End If
            If mydebug(9) Then follow(2588, 5, "FindFileName " & PathFileExt)
            MyDoEvents(219)
            DevicePathFile = PathFileExt
            DisplayMyStatus(3, "Searching " & PathFileExt & "...")
            If DevicePathFile = "" Then Return ""
            If MyLeft(DevicePathFile, 2) = "\\" Then
                DevicePathFile = Mid(DevicePathFile, 2, Len(DevicePathFile))
            End If

            If Dir(DevicePathFile) <> "" Then 'Found it
                Return Dir(DevicePathFile)
            End If

            MyPath = Path.GetDirectoryName(DevicePathFile)
            If MyRight(MyPath, 1) <> "\" Then MyPath &= "\"
            MyFileName = Path.GetFileNameWithoutExtension(DevicePathFile)
            If MyFileName = "" Then Return ""
            MyExtension = Path.GetExtension(DevicePathFile)



            MyCurrent = 1
            MyCurrentPath(MyCurrent) = Dir(MyPath & "*", FileAttribute.Directory)
            If MyCurrentPath(MyCurrent) <> "" Then
                If MyRight(MyCurrentPath(MyCurrent), 1) <> "\" Then MyCurrentPath(MyCurrent) = MyCurrentPath(MyCurrent) & "\"
                While MyCurrentPath(MyCurrent) <> "" And MyCurrentPath(MyCurrent) <> MyPath
                    If FileIgnoreList(MyCurrentPath(MyCurrent)) = True Then
                        MyCurrentPath(MyCurrent) = ""
                    Else
                        MyCurrent += 1
                    End If
                    ReDim Preserve MyCurrentPath(MyCurrent)
                    MyCurrentPath(MyCurrent) = MyPath & Dir() ' Get the next directory
                    If MyCurrentPath(MyCurrent) <> "" Then
                        If MyRight(MyCurrentPath(MyCurrent), 1) <> "\" Then MyCurrentPath(MyCurrent) = MyCurrentPath(MyCurrent) & "\"
                    End If
                End While
            End If

            For MyCurrent = UBound(MyCurrentPath) To LBound(MyCurrentPath) Step -1
                If MyCurrentPath(MyCurrent) <> "" And MyCurrentPath(MyCurrent) <> MyPath Then
                    WhereIsFile = MyCurrentPath(MyCurrent) & MyFileName & MyExtension
                    WhereIsFile = FindFileName(WhereIsFile)  'search all of the sub directories
                    If WhereIsFile <> "" Then Return WhereIsFile
                End If
            Next

            Return "" ' Not found anywhere (OK, anywhere I looked)
        End Function





        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This starts the other program to init(When language is selected), preprocess(The entire file into the clipboard?), Post Process(From the clipboard? to file(s?))
        'breaking them up into files, will require a drilldown to be put back in.
        Public Shared Function FCCL_Init() As String
            Dim Temp As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3409, 10, "FCCL_Init")
#End If
            If MyOptionTest(18) = True Then
                Return ""
            End If
            If MyDebug(9) Then follow(2589, 3, "FCCL_Init ")
            FlowChartWindow.Show()
            SymbolWindow.Show()
            FileInputOutputWindow.Show()
            OptionsWindow.Show()

            'TODO stop the old one if any 
            'todo set the fc processID to -1 in init() to flag that nothing is started
            'todo if fc processID is running then clipboard /FCFinish
            'todo then wait for it to finish
            'todo then start up the new process
            'fight now it just starts a new one
            'start the new language processor
            MyDoEvents(220)
            PutClipBoard("/FCInit")
            Temp = FileIO.FileSystem.CurrentDirectory & "\" & MyUniverse.ProgramOptions.FCCL_LanguageClassName & ".exe"
            MyUniverse.MySystem.FCProcessID = MyShell(Temp) 'Nowait, 1000 wait if true
            If MyUniverse.MySystem.FCProcessID < 0 Then
                Temp = "\Program Files\FC" & MyUniverse.ProgramOptions.FCCL_LanguageClassName & ".exe"
                MyUniverse.MySystem.FCProcessID = MyShell(Temp) 'Nowait, 1000 wait if true
                If MyUniverse.MySystem.FCProcessID < 0 Then
                    Temp = "\Program Files (x86)\FC" & MyUniverse.ProgramOptions.FCCL_LanguageClassName & ".exe"
                    MyUniverse.MySystem.FCProcessID = MyShell(Temp) 'Nowait, 1000 wait if true
                End If
            End If

            If MyUniverse.MySystem.FCProcessID < 0 Then
                MsgBox("Unable to start " & Temp, MsgBoxStyle.Critical, "Start the program " & Temp & "from the windows start menu." & vbCrLf & "Or move it where it will be looking for it.")
                Return ""
                Exit Function
            End If
            Return ""
        End Function


        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'This returns each line of code to decompile, converting into a generaic Syntax (keyWord, Operator, ...)
        'None of this is checked yet
        Public Shared Function FCCL_PreProcessor(KeyLine As String) As String
#If MINEDEBUG Then
  if mydebug(9) then follow(3410, 10, "FCCL_PreProcessor")
#End If
            If MyDebug(6) Then follow(2590, 6, "FCCL_Preprocessor " & KeyLine)
            If MyOptionTest(18) = True Then
                If Len(MyTrim(KeyLine)) > 0 Then
                    'MyUniverse.MySystem.MyNOTaClipBoard = AddCameFromLine(AddGo_ToNextLine(KeyLine))
                    'Return MyUniverse.MySystem.MyNOTaClipBoard
                    'todo this should return the line after another process changes anything that needs to be changed
                    Return KeyLine
                Else
                    Return MyTrim(KeyLine) 'returns nothing and no came from or Go_To 
                End If
            End If
            PutClipBoard("/FCPre" & vbCrLf & KeyLine)
            Return GetClipBoard()
        End Function

        '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        'Public Shared Function FCCL_PostProcessor(KeyLine As String) As String
        '    if MyDebug(10 ) then follow(2591, 5, "?")
        ' If MyOptionTest(18) = True Then
        '         MyUniverse.MySystem.MyNOTaClipBoard = KeyLine
        ' Return MyUniverse.MySystem.MyNOTaClipBoard
        ' End If
        '     PutClipBoard("/FCPost" & vbCrLf & KeyLine)
        '     MyDoEvents(221)
        ' Return GetClipBoard()
        ' End Function 'FCCL_PostProcessor



        'lost
        Public Shared Function GetClipBoard() As String ' Gets import/export file to process
            Dim ErrorCount As Int32
#If MINEDEBUG Then
       If MyDebug(10) Then  if mydebug(9) then follow(3411, 10, "GetClipBoard")
#End If
            If MyDebug(10) Then follow(2592, 10, "Get Clip Board ")
            DoEvents(222001)
            'Wait until there is a /finish on the clipboard
            If MyOptionTest(18) = True Then
                Return MyUniverse.MySystem.MyNOTaClipBoard
            End If

            GetClipBoard = ""
            ErrorCount = 0
            'it fails on everything, so I am delaying it 1/2 second each time.
            System.Threading.Thread.Sleep(500)

            On Error GoTo ClipBoardError

            If Clipboard.GetDataObject.GetDataPresent(DataFormats.Text) Then
                GetClipBoard = My.Computer.Clipboard.GetText()
                While InStr(LCase(GetClipBoard), "/finish") = 0
                    MyDoEvents(223)
                    GetClipBoard = My.Computer.Clipboard.GetText()
                    MyDoEvents(224)
                    'hack fixed at half a second, needs to do this correctly in the future, and all of the error checking to make sure that the other program runs, or else it could hang forever.(Need at least a limit loop)
                    System.Threading.Thread.Sleep(500)
                    MyDoEvents(225)
                    'if not done in 30 seconds then exit with nothing from the clipboard

                    ErrorCount += 1
                    If ErrorCount > 60 Then
                        ' -.MSG_MyTrace1(2095, "No responce from the language preprocessor program." & HighLight(My.Computer.Clipboard.GetText().ToString), 0)
                        'todo make the answer to include retry
                        MyBeep()
                        Select Case MsgBox("No response from the language preprocessor program." & vbCrLf & "Keep trying, or ignore all together?", MsgBoxStyle.RetryCancel Or MsgBoxStyle.Exclamation, HighLight(My.Computer.Clipboard.GetText()))
                            Case vbOK
                                Return My.Computer.Clipboard.GetText() & vbCrLf & "/Error not able to get the clip board " & "/finish"
                            Case vbNo
                                Return My.Computer.Clipboard.GetText() & vbCrLf & "/Error not able to get the clip board " & "/finish"
                            Case vbIgnore
                                OptionsWindow.CheckedListBoxOptionSelection.SetItemCheckState(18, CheckState.Unchecked)
                        End Select
                        Exit Function
                    End If
                End While
                My.Computer.Clipboard.Clear() 'clear it because we have the information
                MyDoEvents(226)
            End If
            Exit Function
ClipBoardError:
            DisplayMyStatus(3, "ClipBoard has error reading it.")
            MyDoEvents(227)
            Return "/error=Error 2" & vbCrLf & "/Finish"
        End Function



        Public Shared Sub FindMyBugsROUTER_OnTop()
            Dim IndexFlowChart As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3412, 10, "FindMyBugsROUTER_OnTop")
#End If
            If mydebug(9) Then follow(2593, 9, "FMB: Router_On Top")
            If MyOptionTest(31) = False Then Return

            For IndexFlowChart = 1 To TopOfFile("FlowChart")
                Select Case LCase(FlowChart_TableCode(IndexFlowChart))
                    Case "/path"
                        FindMyBugsROUTER_FindDupPath(IndexFlowChart)
                    Case My_keyWord(My_KeyConstUse) 'Ignore, because it test paths against Symbols later.
                    Case "/error"
                    Case Else
                        MSG_ABug(2097, "Finding My Bugs: code not taken care of ", MyShowFlowChartRecord(True, IndexFlowChart), "")
                End Select
            Next IndexFlowChart
        End Sub



        Public Shared Sub FindMyBugsROUTER_FindDupPath(IndexFlowChart As Int32)
            Dim LocalIndex, Kdex As Int32
            Dim A As MyLineStructure 'todo is this nessary '''= Nothing
            Dim B As MyLineStructure = Nothing
            Dim C As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3413, 10, "FindMyBugsROUTER_FindDupPath")
#End If
            If MyDebug(9) Then follow(2594, 9, "FMB: Router Find Dup Paths " & MyShowPath(False, IndexFlowChart))
            If MyOptionTest(31) = False Then Return

            Kdex = TopOfFile("FlowChart")
            C = MyUniverse.SysGen.Constants.ConstantSymbolCenter ' 1/2 size of Symbol

            A = FlowChart2Line(IndexFlowChart)

            LocalIndex = ROUTER_Find_Lowest_Index(A.a.x - C - 1, FlowChart_FileX1, FlowChart_ISAM_X1) '-1 to get before the first path/Symbol
            If LocalIndex <> 0 Then
                LocalIndex = MyABS(LocalIndex)
                While FlowChart_TableX1(FlowChart_ISAM_X1(LocalIndex)) < (A.a.x + C) And LocalIndex <= Kdex
                    If FlowChart_ISAM_X1(LocalIndex) <> IndexFlowChart Then
                        Select Case LCase(FlowChart_TableCode(LocalIndex))
                            Case "/error"
                                MSG_AInfo(2099, "Error ", "", MyShowFlowChartRecord(True, LocalIndex))
                            Case "/path"
                                B = FlowChart2Line(LocalIndex)
        'See if it goes all the way through through a Symbol
        '(if it starts or stops then it is ok,
        '(unless it misseed the point on the Symbol that it was suppose to connect to, but that is another issue somewhere else
                            Case My_keyWord(My_KeyConstUse)
                                B.a.x = FlowChart_TableX1(LocalIndex) - MyUniverse.SysGen.Constants.ConstantSymbolCenter
                                B.a.y = FlowChart_TableY1(LocalIndex) - MyUniverse.SysGen.Constants.ConstantSymbolCenter
                                B.b.x = FlowChart_TableX1(LocalIndex) + MyUniverse.SysGen.Constants.ConstantSymbolCenter
                                B.b.y = FlowChart_TableY1(LocalIndex) + MyUniverse.SysGen.Constants.ConstantSymbolCenter
                                If FindingMyBugs_ROUTER_IsLineOnLine(A, B) = True Then
                                    'D = MyShowFlowChartRecord(True, LocalIndex) & vbCrLf & MyShowFlowChartRecord(True, IndexFlowChart)
                                End If
                            Case "", Nothing 'invalid index
                            Case Else
                                MSG_ABug(2100, "Finding My Bugs: Code not taken care of ", MyShowFlowChartRecord(True, LocalIndex), "")
                        End Select
                    End If
                    LocalIndex += 1
                End While
            End If
        End Sub



        'Test to see if these two line/square objects overlap each other
        'todo need to add to make sure they are at least ..... distance apart
        Public Shared Function FindingMyBugs_ROUTER_IsLineOnLine(a As MyLineStructure, b As MyLineStructure) As Boolean
            Dim X As MyLineStructure = Nothing
            Dim Y As MyLineStructure = Nothing
            Dim DebugTemp1, dEBUGtEMP2 As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3414, 10, "FindingMyBugs_Router_IsLineOnLine")
#End If
            If MyOptionTest(31) = False Then Return True
            'order them 
            X.a.x = MyMin(a.a.x, a.b.x)
            X.b.x = MyMax(a.a.x, a.b.x)
            X.a.y = MyMin(a.a.y, a.b.y)
            X.b.y = MyMax(a.a.y, a.b.y)


            Y.a.x = MyMin(b.a.x, b.b.x)
            Y.b.x = MyMax(b.a.x, b.b.x)
            Y.a.y = MyMin(b.a.y, b.b.y)
            Y.b.y = MyMax(b.a.y, b.b.y)
            'does box/path a on box b
            DebugTemp1 = MyShow3Lines(X, Y, X)
            dEBUGtEMP2 = MyShow3Lines(a, b, a)
            'is A all leftof B
            If X.b.x < Y.a.x And X.b.x < Y.a.x Then
                Return False 'A is all left B
            End If
            'Is A all right of B
            If X.a.x > Y.b.x And X.a.x > Y.b.x Then
                Return False 'A is rightr of B
            End If

            'is A all above B
            If X.b.y < Y.b.y And X.b.y < Y.a.y Then
                Return False 'A is all left B
            End If
            'Is A all below B
            If X.a.y > Y.b.y And X.a.y > Y.b.y Then
                Return False 'A is rightr of B
            End If
            If MyDebug(6) Then follow(2595, 6, "FMB: Router Is Line On Line  " & MyShow2Lines(X, Y) & vbTab & vbTab & MyShow2Lines(a, b))
            Return True

        End Function


        Public Shared Function ROUTER_Find_Lowest_Index(XY As Int32, MyArrayLong() As Int32, ISAM() As Int32) As Int32
            Dim LocalIndex As Int32
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3415, 10, "ROUTER_Fine_Lowest_Index")
#End If
            If MyDebug(7) Then follow(2596, 7, "Router find lowest index " & XY.ToString)
            'need to make sure this returns that index, not the x
            LocalIndex = FindIndexInISAMTable("FlowChart", "DoNotAdd", MyArrayLong, ISAM, XY) '
            'gobackwards untill you are before it.
            While LocalIndex > 1
                If XY = MyArrayLong(ISAM(LocalIndex)) Then
                    LocalIndex = ISAM(LocalIndex - 1) 'one before this one.
                Else
                    Exit While
                End If
            End While
            Return LocalIndex
        End Function

        Private Shared Sub PutClipBoard(MyClipBoard As String) ' Puts import/export file to process
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3416, 10, "PutClipBoard")
#End If
            If mydebug(9) Then follow(2597, 5, "Put Clip Board")
            'Dim x As Boolean
            'x = MyOptionTest(18)
            If MyOptionTest(18) = True Then
                MyUniverse.MySystem.MyNOTaClipBoard = MyClipBoard
                Return
            End If
            My.Computer.Clipboard.Clear()
            My.Computer.Clipboard.SetText(MyClipBoard)
        End Sub

        Public Shared Sub SetUpHelpForm(CTL As Form)
            If MyDebug(8) Then follow(2598, 8, "SetupHelpForm " & CTL.Name)
            CTL.HelpButton = True
        End Sub


        Public Shared Function FindLanguageClassName(MyRootDir As String) As String
            Dim A, X As String
            Dim Kounter As Int32
            Dim SubDirectories(0) As String
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3417, 10, "FindLanguageClassName")
#End If
            If InStr(MyRootDir, "\\") <> 0 Then Return Nothing
            If MyDebug(8) Then follow(2602, 8, "Find Language Class Name " & SHL(MyRootDir))
            'first find the directory
            A = MyUniverse.ProgramOptions.FCCL_LanguageClassName
            X = Dir(MyRootDir & "*.", FileAttribute.Directory)
            While X <> "" And InStr(X, FD & A) = 0
                SubDirectories(UBound(SubDirectories)) = X
                If FileNameOnly(X) = MyUniverse.ProgramOptions.FCCL_LanguageClassName Then
                    Return MyRootDir & X
                End If
                ReDim Preserve SubDirectories(UBound(SubDirectories) + 1)
                X = Dir()
            End While
            For Kounter = LBound(SubDirectories) To UBound(SubDirectories)
                X = FindLanguageClassName(MyRootDir & SubDirectories(Kounter) & "\")
                If Len(X) > 0 Then Return X
            Next Kounter
            'second find the file

            Return Nothing

        End Function





        'fill the dialect list box with this class of Symbols.
        Public Shared Sub ListBoxLanguageDialect()
#If MINEDEBUG Then
            if MyDebug(10 ) then follow(3418, 10, "ListBoxLanguageDialect")
#End If
            'if MyDebug(10 ) then follow(2603, 4, "List Box Language Dialect " & OptionsWindow.ListBoxLanguage.SelectedItem.ToString & ", " & OptionsWindow.ListBoxDialect.SelectedItem.ToString)
            MyUniverse.ProgramOptions.FCCL_LanguageClassName = OptionsWindow.ListBoxLanguage.SelectedItem.ToString
            MyUniverse.ProgramOptions.FCCL_DialectName = OptionsWindow.ListBoxDialect.SelectedItem.ToString

            If Len(MyUniverse.ProgramOptions.FCCL_LanguageClassName) = 0 Then Return

            'get the directory that this is at.
            MyUniverse.ProgramOptions.FCCL_Directory = FindLanguageClassName(My.Application.Info.DirectoryPath & "\Languages\")


            'Get the computer language now
            DisplayStatus(OptionsWindow.LabelProgramStatus, MyUniverse.ProgramOptions.FCCL_Directory)
            DoThisEvent(2732)
            FCCL_Init()
            ImportLineOrFile(GetClipBoard())

            'Fails because it is not finding sub directory category of classes of languages.
            Import(MyUniverse.ProgramOptions.FCCL_Directory & "\" & MyUniverse.ProgramOptions.FCCL_DialectName & " definition.Symbol")
            MyButtonsEnableRules()
            'MyDoEvents(228)
            If MyDebug(8) Then FMB1(8062)
            ShowAllForms(HideWindow, HideWindow, HideWindow, ShowWindow)
            DisplayMyStatus(3, "Import a FlowChart, or convert source code into a FlowChart")
            'need to highlight suggustings for the next button (hilight those button(s) and make the rest normal - ButtonRules())
            DoThisEvent(2914)
        End Sub



        'Structure POINTAPI
        ' Dim x As Long
        ' Dim y As Long
        ' End Structure

        ' Structure MSG
        ' Dim hwnd As Long
        ' Dim message As Long
        ' Dim wParam As Long
        ' Dim lParam As Long
        ' Dim time As Long
        ' Dim pt As POINTAPI
        ' Dim lPrivate As Long
        ' End Structure

        ' Public Declare Function PeekMessage Lib "user32" Alias "PeekMessageW" _
        ' (lpMsg As MSG, ByVal hwnd As Long, ByVal wMsgFilterMin As Long,
        ' ByVal wMsgFilterMax As Long, ByVal wRemoveMsg As Long) As Long



    End Class
End Namespace
