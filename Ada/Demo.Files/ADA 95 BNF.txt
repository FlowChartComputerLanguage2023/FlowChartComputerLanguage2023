
abort_statement   ::= "abort" task_name { "," task_name }* ";"
abortable_part   ::= sequence_of_statements
abstract_subprogram_declaration   ::= subprogram_specification "is" "abstract" ";"
accept_alternative   ::= accept_statement [ sequence_of_statements ]
accept_statement   ::= "accept" entry_direct_name [ "(" entry_index ")" ] parameter_profile [ "do" handled_sequence_of_statements "end" [ entry_identifier ] ] ";"
access_definition   ::= "access" subtype_mark
access_to_object_definition   ::= "access" [ general_access_modifier ] subtype_indication
access_to_subprogram_definition   ::= ( "access" [ "protected" ] "procedure" parameter_profile | "access" [ "protected" ] "function" parameter_and_result_profile )
access_type_definition   ::= ( access_to_object_definition | access_to_subprogram_definition )
actual_parameter_part   ::= "(" parameter_association { "," parameter_association }* ")"
aggregate   ::= ( record_aggregate | extension_aggregate | array_aggregate )
allocator   ::= ( "new" subtype_indication | "new" qualified_expression )
ancestor_part   ::= ( expression | subtype_mark )
array_aggregate   ::= ( positional_array_aggregate | named_array_aggregate )
array_component_association   ::= discrete_choice_list "=>" expression
array_type_definition   ::= ( unconstrained_array_definition | constrained_array_definition )
assignment_statement   ::= variable_name ":=" expression ";"
asynchronous_select   ::= "select" triggering_alternative "then" "abort" abortable_part "end" "select" ";"
at_clause   ::= "for" direct_name "use" "at" expression ";"
attribute_definition_clause   ::= ( "for" local_name "'" attribute_designator "use" expression ";" | "for" local_name "'" attribute_designator "use" name ";" )
attribute_designator   ::= ( identifier [ "(" static_expression ")" ] | "Access" | "Delta" | "Digits" )
attribute_reference   ::= prefix "'" attribute_designator
base  ::=  numeral
based_literal  ::=  base [\#] based_numeral ([\.] based_numeral)? [\#] exponent?
based_numeral  ::=  extended_digit (underline? extended_digit)*
basic_declaration   ::= ( type_declaration | subtype_declaration | object_declaration | number_declaration | subprogram_declaration | abstract_subprogram_declaration | package_declaration | renaming_declaration | exception_declaration | generic_declaration | generic_instantiation )
basic_declarative_item   ::= ( basic_declaration | representation_clause | use_clause )
binary_adding_operator   ::= ( "+" | "-" | "&" )
block_statement   ::= [ block_statement_identifier ":" ] [ "declare" declarative_part ] "begin" handled_sequence_of_statements "end" [ block_identifier ] ";"
body   ::= ( proper_body | body_stub )
body_stub   ::= ( subprogram_body_stub | package_body_stub | task_body_stub | protected_body_stub )
case_statement   ::= "case" expression "is" case_statement_alternative { case_statement_alternative }* "end" "case" ";"
case_statement_alternative   ::= "when" discrete_choice_list "=>" sequence_of_statements
character ::=  ( graphic_character | format_effector | other_control_function )
character_literal  ::=  [\'] graphic_character [\']
choice_parameter_specification   ::= defining_identifier
code_statement   ::= qualified_expression ";"
comment  ::=  "--" non_end_of_line_character*
compilation   ::= { compilation_unit }*
compilation_unit   ::= ( context_clause library_item | context_clause subunit )
component_choice_list   ::= ( component_selector_name { "|" component_selector_name }* | "others" )
component_clause   ::= component_local_name "at" position "range" first_bit ".." last_bit ";"
component_declaration   ::= defining_identifier_list ":" component_definition [ ":=" default_expression ] ";"
component_definition   ::= [ "aliased" ] subtype_indication
component_item   ::= ( component_declaration | representation_clause )
component_list   ::= ( component_item { component_item }* | { component_item }* variant_part | "null" ";" )
composite_constraint   ::= ( index_constraint | discriminant_constraint )
compound_statement   ::= ( if_statement | case_statement | loop_statement | block_statement | accept_statement | select_statement )
condition   ::= boolean_expression
conditional_entry_call   ::= "select" entry_call_alternative "else" sequence_of_statements "end" "select" ";"
constrained_array_definition   ::= "array" "(" discrete_subtype_definition { "," discrete_subtype_definition }* ")" "of" component_definition
constraint   ::= ( scalar_constraint | composite_constraint )
context_clause   ::= { context_item }*
context_item   ::= ( with_clause | use_clause )
decimal_fixed_point_definition   ::= "delta" static_expression "digits" static_expression [ real_range_specification ]
decimal_literal  ::=  numeral ([\.] numeral)? exponent?
declarative_item   ::= ( basic_declarative_item | body )
declarative_part   ::= { declarative_item }*
default_expression   ::= expression
default_name   ::= name
defining_character_literal   ::= character_literal
defining_designator   ::= ( defining_program_unit_name | defining_operator_symbol )
defining_identifier   ::= identifier
defining_identifier_list   ::= defining_identifier { "," defining_identifier }*
defining_operator_symbol   ::= operator_symbol
defining_program_unit_name   ::= [ parent_unit_name "." ] defining_identifier
delay_alternative   ::= delay_statement [ sequence_of_statements ]
delay_relative_statement   ::= "delay" delay_expression ";"
delay_statement   ::= ( delay_until_statement | delay_relative_statement )
delay_until_statement   ::= "delay" "until" delay_expression ";"
delta_constraint   ::= "delta" static_expression [ range_constraint ]
derived_type_definition   ::= [ "abstract" ] "new" parent_subtype_indication [ record_extension_part ]
designator   ::= ( [ parent_unit_name "." ] identifier | operator_symbol )
digit  ::=  [0-9]
digits_constraint   ::= "digits" static_expression [ range_constraint ]
direct_name   ::= ( identifier | operator_symbol )
discrete_choice   ::= ( expression | discrete_range | "others" )
discrete_choice_list   ::= discrete_choice { "|" discrete_choice }*
discrete_range   ::= ( discrete_subtype_indication | range_definition )
discrete_subtype_definition   ::= ( discrete_subtype_indication | "range" )
discriminant_association   ::= [ discriminant_selector_name { "|" discriminant_selector_name }* "=>" ] expression
discriminant_constraint   ::= "(" discriminant_association { "," discriminant_association }* ")"
discriminant_part   ::= ( unknown_discriminant_part | known_discriminant_part )
discriminant_specification   ::= ( defining_identifier_list ":" subtype_mark [ ":=" default_expression ] | defining_identifier_list ":" access_definition [ ":=" default_expression ] )
entry_barrier   ::= "when" condition
entry_body   ::= "entry" defining_identifier entry_body_formal_part entry_barrier "is" declarative_part "begin" handled_sequence_of_statements "end" [ entry_identifier ] ";"
entry_body_formal_part   ::= [ "(" entry_index_specification ")" ] parameter_profile
entry_call_alternative   ::= entry_call_statement [ sequence_of_statements ]
entry_call_statement   ::= entry_name [ actual_parameter_part ] ";"
entry_declaration   ::= "entry" defining_identifier [ "(" discrete_subtype_definition ")" ] parameter_profile ";"
entry_index   ::= expression
entry_index_specification   ::= "for" defining_identifier "in" discrete_subtype_definition
enumeration_aggregate   ::= array_aggregate
enumeration_literal_specification   ::= ( defining_identifier | defining_character_literal )
enumeration_representation_clause   ::= "for" first_subtype_local_name "use" enumeration_aggregate ";"
enumeration_type_definition   ::= "(" enumeration_literal_specification { "," enumeration_literal_specification }* ")"
exception_choice   ::= ( exception_name | "others" )
exception_declaration   ::= defining_identifier_list ":" "exception" ";"
exception_handler   ::= "when" [ choice_parameter_specification ":" ] exception_choice { "|" exception_choice }* "=>" sequence_of_statements
exception_renaming_declaration   ::= defining_identifier ":" "exception" "renames" exception_name ";"
exit_statement   ::= "exit" [ loop_name ] [ "when" condition ] ";"
explicit_actual_parameter   ::= ( expression | variable_name )
explicit_dereference   ::= name "." "all"
explicit_generic_actual_parameter   ::= ( expression | variable_name | subprogram_name | entry_name | subtype_mark | package_instance_name )
exponent  ::=  
expression   ::= ( relation { "and" relation }* | relation { "and" "then" relation }* | relation { "or" relation }* | relation { "or" "else" relation }* | relation { "xor" relation }* )
extended_digit  ::=   ( digit | [A-F] )
extension_aggregate   ::= "(" ancestor_part "with" record_component_association_list ")"
factor   ::= ( primary [ "**" primary ] | "abs" primary | "not" primary )
first_bit   ::= static_simple_expression
fixed_point_definition   ::= ( ordinary_fixed_point_definition | decimal_fixed_point_definition )
floating_point_definition   ::= "digits" static_expression [ real_range_specification ]
formal_access_type_definition   ::= access_type_definition
formal_array_type_definition   ::= array_type_definition
formal_decimal_fixed_point_definition   ::= "delta" "<>" "digits" "<>"
formal_derived_type_definition   ::= [ "abstract" ] "new" subtype_mark [ "with" "private" ]
formal_discrete_type_definition   ::= "(" "<>" ")"
formal_floating_point_definition   ::= "digits" "<>"
formal_modular_type_definition   ::= "mod" "<>"
formal_object_declaration   ::= defining_identifier_list ":" mode subtype_mark [ ":=" default_expression ] ";"
formal_ordinary_fixed_point_definition   ::= "delta" "<>"
formal_package_actual_part   ::= ( "(" "<>" ")" | [ generic_actual_part ] )
formal_package_declaration   ::= "with" "package" defining_identifier "is" "new" generic_package_name formal_package_actual_part ";"
formal_part   ::= "(" parameter_specification { ";" parameter_specification }* ")"
formal_private_type_definition   ::= [ [ "abstract" ] "tagged" ] [ "limited" ] "private"
formal_signed_integer_type_definition   ::= "range" "<>"
formal_subprogram_declaration   ::= "with" subprogram_specification [ "is" subprogram_default ] ";"
formal_type_declaration   ::= "type" defining_identifier [ discriminant_part ] "is" formal_type_definition ";"
formal_type_definition   ::= ( formal_private_type_definition | formal_derived_type_definition | formal_discrete_type_definition | formal_signed_integer_type_definition | formal_modular_type_definition | formal_floating_point_definition | formal_ordinary_fixed_point_definition | formal_decimal_fixed_point_definition | formal_array_type_definition | formal_access_type_definition )
format_effector  ::=  ... % Ada RM 95: The control functions of ISO 6429 called character tabulation (HT), line tabulation (VT), carriage return (CR), line feed (LF), and form feed (FF). 
full_type_declaration   ::= ( "type" defining_identifier [ known_discriminant_part ] "is" type_definition ";" | task_type_declaration | protected_type_declaration )
function_call   ::= ( function_name | function_prefix actual_parameter_part )
general_access_modifier   ::= ( "all" | "constant" )
generic_actual_part   ::= "(" generic_association { "," generic_association }* ")"
generic_association   ::= [ generic_formal_parameter_selector_name "=>" ] explicit_generic_actual_parameter
generic_declaration   ::= ( generic_subprogram_declaration | generic_package_declaration )
generic_formal_parameter_declaration   ::= ( formal_object_declaration | formal_type_declaration | formal_subprogram_declaration | formal_package_declaration )
generic_formal_part   ::= "generic" { ( generic_formal_parameter_declaration | use_clause ) }*
generic_instantiation   ::= ( "package" defining_program_unit_name "is" "new" generic_package_name [ generic_actual_part ] ";" | "procedure" defining_program_unit_name "is" "new" generic_procedure_name [ generic_actual_part ] ";" | "function" defining_designator "is" "new" generic_function_name [ generic_actual_part ] ";" )
generic_package_declaration   ::= generic_formal_part package_specification ";"
generic_renaming_declaration   ::= ( "generic" "package" defining_program_unit_name "renames" generic_package_name ";" | "generic" "procedure" defining_program_unit_name "renames" generic_procedure_name ";" | "generic" "function" defining_program_unit_name "renames" generic_function_name ";" )
generic_subprogram_declaration   ::= generic_formal_part subprogram_specification ";"
goto_statement   ::= "goto" label_name ";"
graphic_character ::=  ( identifier_letter | digit | space_character | special_character )
guard   ::= "when" condition "=>"
handled_sequence_of_statements   ::= sequence_of_statements [ "exception" exception_handler { exception_handler }* ]
highest_precedence_operator   ::= ( "**" | "abs" | "not" )
identifier ::= identifier_letter (underline? letter_or_digit)*
identifier_letter  ::=   ( upper_case_identifier_letter | lower_case_identifier_letter )
if_statement   ::= "if" condition "then" sequence_of_statements { "elsif" condition "then" sequence_of_statements }* [ "else" sequence_of_statements ] "end" "if" ";"
implicit_dereference   ::= name
incomplete_type_declaration   ::= "type" defining_identifier [ discriminant_part ] ";"
index_constraint   ::= "(" discrete_range { "," discrete_range }* ")"
index_subtype_definition   ::= subtype_mark "range" "<>"
indexed_component   ::= prefix "(" expression { "," expression }* ")"
integer_type_definition   ::= ( signed_integer_type_definition | modular_type_definition )
iteration_scheme   ::= ( "while" condition | "for" loop_parameter_specification )
known_discriminant_part   ::= "(" discriminant_specification { ";" discriminant_specification }* ")"
label   ::= "<<" label_statement_identifier ">>"
last_bit   ::= static_simple_expression
letter_or_digit  ::=   ( identifier_letter | digit )
library_item   ::= ( [ "private" ] library_unit_declaration | library_unit_body | [ "private" ] library_unit_renaming_declaration )
library_unit_body   ::= ( subprogram_body | package_body )
library_unit_declaration   ::= ( subprogram_declaration | package_declaration | generic_declaration | generic_instantiation )
library_unit_renaming_declaration   ::= ( package_renaming_declaration | generic_renaming_declaration | subprogram_renaming_declaration )
local_name   ::= ( direct_name | direct_name "'" attribute_designator | library_unit_name )
logical_operator   ::= ( "and" | "or" | "xor" )
loop_parameter_specification   ::= defining_identifier "in" [ "reverse" ] discrete_subtype_definition
loop_statement   ::= [ loop_statement_identifier ":" ] [ iteration_scheme ] "loop" sequence_of_statements "end" "loop" [ loop_identifier ] ";"
lower_case_identifier_letter  ::=  ... % Ada RM 95: Any character of Row 00 of ISO 10646 BMP whose name begins Latin Small Letter''. 
mod_clause   ::= "at" "mod" static_expression ";"
mode   ::= ( [ "in" ] | "in" "out" | "out" )
modular_type_definition   ::= "mod" static_expression
multiplying_operator   ::= ( "*" | "/" | "mod" | "rem" )
name   ::= ( direct_name | explicit_dereference | indexed_component | slice | selected_component | attribute_reference | type_conversion | function_call | character_literal )
named_array_aggregate   ::= "(" array_component_association { "," array_component_association }* ")"
non_end_of_line_character  ::=  ... % Not defined in Ada RM 95
non_quotation_mark_graphic_character  ::=  ... % Ada RM 95: a single graphic_character other than a quotation mark
null_statement   ::= "null" ";"
number_declaration   ::= defining_identifier_list ":" "constant" ":=" static_expression ";"
numeral  ::=  digit (underline? digit)*
numeric_literal  ::=   ( decimal_literal | based_literal )
object_declaration   ::= ( defining_identifier_list ":" [ "aliased" ] [ "constant" ] subtype_indication [ ":=" expression ] ";" | defining_identifier_list ":" [ "aliased" ] [ "constant" ] array_type_definition [ ":=" expression ] ";" | single_task_declaration | single_protected_declaration )
object_renaming_declaration   ::= defining_identifier ":" subtype_mark "renames" object_name ";"
operator_symbol   ::= string_literal
ordinary_fixed_point_definition   ::= "delta" static_expression real_range_specification
other_control_function  ::=  ... % Ada RM 95: Any control function, other than a format_effector, that is allowed in a comment; the set of other_control_functions allowed in comments is implementation defined.
package_body   ::= "package" body defining_program_unit_name "is" declarative_part [ "begin" handled_sequence_of_statements ] "end" [ [ parent_unit_name "." ] identifier ] ";"
package_body_stub   ::= "package" body defining_identifier "is" "separate" ";"
package_declaration   ::= package_specification ";"
package_renaming_declaration   ::= "package" defining_program_unit_name renamespackage_name ";"
package_specification   ::= "package" defining_program_unit_name "is" { basic_declarative_item }* [ "private" { basic_declarative_item }* ] "end" [ [ parent_unit_name "." ] identifier ]
parameter_and_result_profile   ::= [ formal_part ] "return" subtype_mark
parameter_association   ::= [ formal_parameter_selector_name "=>" ] explicit_actual_parameter
parameter_profile   ::= [ formal_part ]
parameter_specification   ::= ( defining_identifier_list ":" mode subtype_mark [ ":=" default_expression ] | defining_identifier_list ":" access_definition [ ":=" default_expression ] )
parent_unit_name   ::= name
position   ::= static_expression
positional_array_aggregate   ::= ( "(" expression "," expression { "," expression }* ")" | "(" expression { "," expression }* "," "others" "=>" expression ")" )
pragma   ::= pragma identifier [ "(" pragma_argument_association { "," pragma_argument_association }* ")" ] ";"
pragma_argument_association   ::= ( [ pragma_argument_identifier "=>" ] name | [ pragma_argument_identifier "=>" ] expression )
prefix   ::= ( name | implicit_dereference )
primary   ::= ( numeric_literal | "null" | string_literal | aggregate | name | qualified_expression | allocator | "(" expression ")" )
private_extension_declaration   ::= "type" defining_identifier [ discriminant_part ] "is" [ "abstract" ] "new" ancestor_subtype_indication "with" "private" ";"
private_type_declaration   ::= "type" defining_identifier [ discriminant_part ] "is" [ [ "abstract" ] "tagged" ] [ "limited" ] "private" ";"
procedure_call_statement   ::= ( procedure_name ";" | procedure_prefix actual_parameter_part ";" )
proper_body   ::= ( subprogram_body | package_body | task_body | protected_body )
protected_body   ::= "protected" body defining_identifier "is" { protected_operation_item }* "end" [ protected_identifier ] ";"
protected_body_stub   ::= "protected" body defining_identifier "is" "separate" ";"
protected_definition   ::= { protected_operation_declaration }* [ "private" { protected_element_declaration }* ] "end" [ protected_identifier ]
protected_element_declaration   ::= ( protected_operation_declaration | component_declaration )
protected_operation_declaration   ::= ( subprogram_declaration | entry_declaration | representation_clause )
protected_operation_item   ::= ( subprogram_declaration | subprogram_body | entry_body | representation_clause )
protected_type_declaration   ::= "protected" "type" defining_identifier [ known_discriminant_part ] "is" protected_definition ";"
qualified_expression   ::= ( subtype_mark "'" "(" expression ")" | subtype_mark "'" aggregate )
raise_statement   ::= "raise" [ exception_name ] ";"
range_attribute_designator   ::= "Range" [ "(" static_expression ")" ]
range_attribute_reference   ::= prefix "'" range_attribute_designator
range_constraint   ::= "range" range_definition
range_definition   ::= ( range_attribute_reference | simple_expression ".." simple_expression )
real_range_specification   ::= "range" static_simple_expression ".." static_simple_expression
real_type_definition   ::= ( floating_point_definition | fixed_point_definition )
record_aggregate   ::= "(" record_component_association_list ")"
record_component_association   ::= [ component_choice_list "=>" ] expression
record_component_association_list   ::= ( record_component_association { "," record_component_association }* | "null" "record" )
record_definition   ::= ( "record" component_list "end" "record" | "null" "record" )
record_extension_part   ::= "with" record_definition
record_representation_clause   ::= "for" first_subtype_local_name "use" "record" [ mod_clause ] { component_clause }* "end" "record" ";"
record_type_definition   ::= [ [ "abstract" ] "tagged" ] [ "limited" ] record_definition
relation   ::= ( simple_expression [ relational_operator simple_expression ] | simple_expression [ "not" ] "in" range_definition | simple_expression [ "not" ] "in" subtype_mark )
relational_operator   ::= ( "=" | "/=" | "<" | "<=" | ">" | ">=" )
renaming_declaration   ::= ( object_renaming_declaration | exception_renaming_declaration | package_renaming_declaration | subprogram_renaming_declaration | generic_renaming_declaration )
representation_clause   ::= ( attribute_definition_clause | enumeration_representation_clause | record_representation_clause | at_clause )
requeue_statement   ::= "requeue" entry_name [ "with" "abort" ] ";"
restriction   ::= ( restriction_identifier | restriction_parameter_identifier "=>" expression )
return_statement   ::= "return" [ expression ] ";"
scalar_constraint   ::= ( range_constraint | digits_constraint | delta_constraint )
select_alternative   ::= ( accept_alternative | delay_alternative | terminate_alternative )
select_statement   ::= ( selective_accept | timed_entry_call | conditional_entry_call | asynchronous_select )
selected_component   ::= prefix "." selector_name
selective_accept   ::= "select" [ guard ] select_alternative { "or" [ guard ] select_alternative }* [ "else" sequence_of_statements ] "end" "select" ";"
selector_name   ::= ( identifier | character_literal | operator_symbol )
sequence_of_statements   ::= statement { statement }*
signed_integer_type_definition   ::= "range" static_simple_expression ".." static_simple_expression
simple_expression   ::= [ unary_adding_operator ] term { binary_adding_operator term }*
simple_statement   ::= ( null_statement | assignment_statement | exit_statement | goto_statement | procedure_call_statement | return_statement | entry_call_statement | requeue_statement | delay_statement | abort_statement | raise_statement | code_statement )
single_protected_declaration   ::= "protected" defining_identifier "is" protected_definition ";"
single_task_declaration   ::= "task" defining_identifier [ "is" task_definition ] ";"
slice   ::= prefix "(" discrete_range ")"
space_character  ::=  ... % Ada RM 95: The character of ISO 10646 BMP named Space''.
special_character  ::=  ... % Ada RM 95: Any character of the ISO 10646 BMP that is not reserved for a control function, and is not the space_character, an identifier_letter, or a digit. 
statement   ::= ( { label }* simple_statement | { label }* compound_statement )
statement_identifier   ::= direct_name
string_element  ::=   ( [\"] [\"] | non_quotation_mark_graphic_character )
string_literal  ::=  [\"] string_element* [\"]
subprogram_body   ::= subprogram_specification "is" declarative_part "begin" handled_sequence_of_statements "end" [ designator ] ";"
subprogram_body_stub   ::= subprogram_specification "is" "separate" ";"
subprogram_declaration   ::= subprogram_specification ";"
subprogram_default   ::= ( default_name | "<>" )
subprogram_renaming_declaration   ::= subprogram_specification "renames" callable_entity_name ";"
subprogram_specification   ::= ( "procedure" defining_program_unit_name parameter_profile | "function" defining_designator parameter_and_result_profile )
subtype_declaration   ::= "subtype" defining_identifier "is" subtype_indication ";"
subtype_indication   ::= subtype_mark [ constraint ]
subtype_mark   ::= subtype_name
subunit   ::= "separate" "(" parent_unit_name ")" proper_body
task_body   ::= "task" body defining_identifier "is" declarative_part "begin" handled_sequence_of_statements "end" [ task_identifier ] ";"
task_body_stub   ::= "task" body defining_identifier "is" "separate" ";"
task_definition   ::= { task_item }* [ "private" { task_item }* ] "end" [ task_identifier ]
task_item   ::= ( entry_declaration | representation_clause )
task_type_declaration   ::= "task" "type" defining_identifier [ known_discriminant_part ] [ "is" task_definition ] ";"
term   ::= factor { multiplying_operator factor }*
terminate_alternative   ::= "terminate" ";"
timed_entry_call   ::= "select" entry_call_alternative "or" delay_alternative "end" "select" ";"
triggering_alternative   ::= triggering_statement [ sequence_of_statements ]
triggering_statement   ::= ( entry_call_statement | delay_statement )
type_conversion   ::= ( subtype_mark "(" expression ")" | subtype_mark "(" name ")" )
type_declaration   ::= ( full_type_declaration | incomplete_type_declaration | private_type_declaration | private_extension_declaration )
type_definition   ::= ( enumeration_type_definition | integer_type_definition | real_type_definition | array_type_definition | record_type_definition | access_type_definition | derived_type_definition )
unary_adding_operator   ::= ( "+" | "--" )
unconstrained_array_definition   ::= "array" "(" index_subtype_definition { "," index_subtype_definition }* ")" "of" component_definition
underline  ::=  [\_]
unknown_discriminant_part   ::= "(" "<>" ")"
upper_case_identifier_letter  ::=  ... % 'Ada RM 95: Any character of Row 00 of ISO 10646 BMP whose name begins <Latin Capital Letter>'
use_clause   ::= ( use_package_clause | use_type_clause )
use_package_clause   ::= "use" package_name { "," package_name }* ";"
use_type_clause   ::= "use" "type" subtype_mark { "," subtype_mark }* ";"
variant   ::= "when" discrete_choice_list "=>" component_list
variant_part   ::= "case" discriminant_direct_name "is" variant { variant }* "end" "case" ";"
with_clause   ::= "with" library_unit_name { "," library_unit_name }* ";"
